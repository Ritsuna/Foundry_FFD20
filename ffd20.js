// Namespace FFD20 Configuration Values
/**
 * FFD20 Configuration Values
 *
 * A dictionary of dictionaries providing configuration data like formulae,
 * translation keys, and other configuration values. Translations keys are
 * assumed to get replaced by their proper translation when the system is loaded.
 *
 * The FFD20 object may be adjusted to influence the system's behaviour during runtime.
 *
 * @global
 * @memberof CONFIG
 */
const FFD20 = {
  re: {
    traitSeparator: /\s*[;]\s*/g,
  },

  /**
   * The set of Ability Scores used within the system
   */
  abilities: {
    str: "FFD20.AbilityStr",
    dex: "FFD20.AbilityDex",
    con: "FFD20.AbilityCon",
    int: "FFD20.AbilityInt",
    wis: "FFD20.AbilityWis",
    cha: "FFD20.AbilityCha",
  },

  /**
   * The set of Ability Scores used within the system in short form
   */
  abilitiesShort: {
    str: "FFD20.AbilityShortStr",
    dex: "FFD20.AbilityShortDex",
    con: "FFD20.AbilityShortCon",
    int: "FFD20.AbilityShortInt",
    wis: "FFD20.AbilityShortWis",
    cha: "FFD20.AbilityShortCha",
  },

  /**
   * The point cost to increase an ability score using Point Buy
   */
  abilityCost: {
    7: -4,
    8: -2,
    9: -1,
    10: 0,
    11: 1,
    12: 2,
    13: 3,
    14: 5,
    15: 7,
    16: 10,
    17: 13,
    18: 17,
  },

  /**
   * The set of Saving Throws
   */
  savingThrows: {
    fort: "FFD20.SavingThrowFort",
    ref: "FFD20.SavingThrowRef",
    will: "FFD20.SavingThrowWill",
  },

  /**
   * The types of classes
   */
  classTypes: {
    base: "FFD20.ClassTypeBase",
    prestige: "FFD20.ClassTypePrestige",
    npc: "FFD20.ClassTypeNPC",
    racial: "FFD20.ClassTypeRacial",
    mythic: "FFD20.ClassTypeMythic",
  },

  /**
   * Valid options for a class's BAB progression
   */
  classBAB: {
    low: "FFD20.Low",
    med: "FFD20.Medium",
    high: "FFD20.High",
  },

  /**
   * Valid options for a class's saving throw bonus progression
   */
  classSavingThrows: {
    low: "FFD20.Poor",
    high: "FFD20.Good",
  },

  /**
   * The formulae for BAB progressions
   */
  classBABFormulas: {
    low: "floor(@level * 0.5)",
    med: "floor(@level * 0.75)",
    high: "@level",
  },

  /**
   * The formulae for saving throw progressions by class type
   */
  classSavingThrowFormulas: {
    base: {
      low: "floor(@level / 3)",
      high: "2 + floor(@level / 2)",
    },
    prestige: {
      low: "floor((1 + @level) / 3)",
      high: "floor((1 + @level) / 2)",
    },
    npc: {
      low: "floor(@level / 3)",
      high: "2 + floor(@level / 2)",
    },
    racial: {
      low: "floor(@level / 3)",
      high: "2 + floor(@level / 2)",
    },
    mythic: {
      low: "0",
      high: "0",
    },
  },

  /**
   * The choices available for favored class bonuses
   */
  favouredClassBonuses: {
    hp: "FFD20.FavouredClassHP",
    skill: "FFD20.FavouredClassSkill",
    alt: "FFD20.FavouredClassAlt",
  },

  /**
   * Icons used for favored class bonus choices
   */
  favouredClassBonusIcons: {
    hp: "fa-heartbeat",
    skill: "fa-wrench",
    alt: "fa-tag",
  },

  /**
   * The set of Armor Classes
   */
  ac: {
    normal: "FFD20.ACNormal",
    touch: "FFD20.ACTouch",
    flatFooted: "FFD20.ACFlatFooted",
  },

  /**
   * The set of Armor Class modifier types
   */
  acValueLabels: {
    normal: "FFD20.ACTypeNormal",
    touch: "FFD20.ACTypeTouch",
    flatFooted: "FFD20.ACTypeFlatFooted",
  },

  /* -------------------------------------------- */

  /**
   * Character alignment options
   */
  alignments: {
    lg: "FFD20.AlignmentLG",
    ng: "FFD20.AlignmentNG",
    cg: "FFD20.AlignmentCG",
    ln: "FFD20.AlignmentLN",
    tn: "FFD20.AlignmentTN",
    cn: "FFD20.AlignmentCN",
    le: "FFD20.AlignmentLE",
    ne: "FFD20.AlignmentNE",
    ce: "FFD20.AlignmentCE",
  },

  /**
   * Character alignment options in their short form
   */
  alignmentsShort: {
    lg: "FFD20.AlignmentShortLG",
    ng: "FFD20.AlignmentShortNG",
    cg: "FFD20.AlignmentShortCG",
    ln: "FFD20.AlignmentShortLN",
    tn: "FFD20.AlignmentShortTN",
    cn: "FFD20.AlignmentShortCN",
    le: "FFD20.AlignmentShortLE",
    ne: "FFD20.AlignmentShortNE",
    ce: "FFD20.AlignmentShortCE",
  },

  /* -------------------------------------------- */

  /**
   * The set of Armor Proficiencies which a character may have
   */
  armorProf: {
    lgt: "FFD20.ArmorProfLight",
    med: "FFD20.ArmorProfMedium",
    hvy: "FFD20.ArmorProfHeavy",
    shl: "FFD20.ArmorProfShield",
    twr: "FFD20.ArmorProfTowerShield",
  },

  /**
   * The set of broad Weapon Proficiencies a character may have
   */
  weaponProf: {
    sim: "FFD20.WeaponProfSimple",
    mar: "FFD20.WeaponProfMartial",
    exo: "FFD20.WeaponProfExotic",
    che: "FFD20.WeaponProfChef",
    pow: "FFD20.WeaponProfPower",
  },

  /* -------------------------------------------- */

  /**
   * This describes the ways that an ability can be activated.
   */
  abilityActivationTypes: {
    passive: "FFD20.ActivationTypePassive",
    free: "FFD20.ActivationTypeFree",
    nonaction: "FFD20.ActivationTypeNonaction",
    swift: "FFD20.ActivationTypeSwift",
    immediate: "FFD20.ActivationTypeImmediate",
    move: "FFD20.ActivationTypeMove",
    standard: "FFD20.ActivationTypeStandard",
    full: "FFD20.ActivationTypeFullround",
    attack: "FFD20.ActivationTypeAttack",
    aoo: "FFD20.ActivationTypeAoO",
    round: "FFD20.ActivationTypeRound",
    minute: "FFD20.ActivationTypeMinute",
    hour: "FFD20.ActivationTypeHour",
    special: "FFD20.ActivationTypeSpecial",
  },

  /**
   * This describes plurals for activation types.
   */
  abilityActivationTypesPlurals: {
    free: "FFD20.ActivationTypeFreePlural",
    swift: "FFD20.ActivationTypeSwiftPlural",
    immediate: "FFD20.ActivationTypeImmediatePlural",
    move: "FFD20.ActivationTypeMovePlural",
    standard: "FFD20.ActivationTypeStandardPlural",
    full: "FFD20.ActivationTypeFullroundPlural",
    attack: "FFD20.ActivationTypeAttackPlural",
    round: "FFD20.ActivationTypeRoundPlural",
    minute: "FFD20.ActivationTypeMinutePlural",
    hour: "FFD20.ActivationTypeHourPlural",
  },

  /**
   * This describes the ways that an ability can be activated when using
   * Unchained rules.
   */
  abilityActivationTypes_unchained: {
    passive: "FFD20.ActivationTypePassive",
    free: "FFD20.ActivationTypeFree",
    nonaction: "FFD20.ActivationTypeNonaction",
    reaction: "FFD20.ActivationTypeReaction",
    action: "FFD20.ActivationTypeAction",
    attack: "FFD20.ActivationTypeAttack",
    aoo: "FFD20.ActivationTypeAoO",
    minute: "FFD20.ActivationTypeMinute",
    hour: "FFD20.ActivationTypeHour",
    special: "FFD20.ActivationTypeSpecial",
  },

  /**
   * This describes plurals for the ways that an ability can be activated when
   * using Unchained rules.
   */
  abilityActivationTypesPlurals_unchained: {
    passive: "FFD20.ActivationTypePassive",
    free: "FFD20.ActivationTypeFreePlural",
    reaction: "FFD20.ActivationTypeReactionPlural",
    action: "FFD20.ActivationTypeActionPlural",
    minute: "FFD20.ActivationTypeMinutePlural",
    hour: "FFD20.ActivationTypeHourPlural",
    special: "FFD20.ActivationTypeSpecial",
  },

  /**
   * The possible conditions when using Wound Threshold rules
   */
  woundThresholdConditions: {
    0: "FFD20.WoundLevelHealthy",
    1: "FFD20.WoundLevelGrazed",
    2: "FFD20.WoundLevelWounded",
    3: "FFD20.WoundLevelCritical",
  },

  divineFocus: {
    0: "",
    1: "FFD20.SpellComponentDivineFocusAlone",
    2: "FFD20.SpellComponentDivineFocusMaterial",
    3: "FFD20.SpellComponentDivineFocusFocus",
  },

  /**
   * The measure template types available e.g. for spells
   */
  measureTemplateTypes: {
    cone: "FFD20.MeasureTemplateCone",
    circle: "FFD20.MeasureTemplateCircle",
    ray: "FFD20.MeasureTemplateRay",
    rect: "FFD20.MeasureTemplateRectangle",
  },

  /* -------------------------------------------- */

  /**
   * The possible creature sizes
   */
  actorSizes: {
    fine: "FFD20.ActorSizeFine",
    dim: "FFD20.ActorSizeDiminutive",
    tiny: "FFD20.ActorSizeTiny",
    sm: "FFD20.ActorSizeSmall",
    med: "FFD20.ActorSizeMedium",
    lg: "FFD20.ActorSizeLarge",
    huge: "FFD20.ActorSizeHuge",
    grg: "FFD20.ActorSizeGargantuan",
    col: "FFD20.ActorSizeColossal",
  },

  /**
   * The possible creature sizes in their one-letter form
   */
  sizeChart: {
    fine: "F",
    dim: "D",
    tiny: "T",
    sm: "S",
    med: "M",
    lg: "L",
    huge: "H",
    grg: "G",
    col: "C",
  },

  /**
   * The size values for Tokens according to the creature's size
   */
  tokenSizes: {
    fine: { w: 1, h: 1, scale: 0.45 },
    dim: { w: 1, h: 1, scale: 0.6 },
    tiny: { w: 1, h: 1, scale: 0.75 },
    sm: { w: 1, h: 1, scale: 0.9 },
    med: { w: 1, h: 1, scale: 1 },
    lg: { w: 2, h: 2, scale: 1 },
    huge: { w: 3, h: 3, scale: 1 },
    grg: { w: 4, h: 4, scale: 1 },
    col: { w: 6, h: 6, scale: 1 },
  },

  /**
   * The size modifier applied to creatures not of medium size
   */
  sizeMods: {
    fine: 8,
    dim: 4,
    tiny: 2,
    sm: 1,
    med: 0,
    lg: -1,
    huge: -2,
    grg: -4,
    col: -8,
  },

  /**
   * The size modifier applied to creatures not of medium size
   */
  sizeSpecialMods: {
    fine: -8,
    dim: -4,
    tiny: -2,
    sm: -1,
    med: 0,
    lg: 1,
    huge: 2,
    grg: 4,
    col: 8,
  },

  /**
   * The size modifier applied to fly checks of creatures not of medium size
   */
  sizeFlyMods: {
    fine: 8,
    dim: 6,
    tiny: 4,
    sm: 2,
    med: 0,
    lg: -2,
    huge: -4,
    grg: -6,
    col: -8,
  },

  /**
   * The size modifier applied to stealth checks of creatures not of medium size
   */
  sizeStealthMods: {
    fine: 16,
    dim: 12,
    tiny: 8,
    sm: 4,
    med: 0,
    lg: -4,
    huge: -8,
    grg: -12,
    col: -16,
  },

  /**
   * The possible options for a creature's maneuverability
   */
  flyManeuverabilities: {
    clumsy: "FFD20.FlyManeuverabilityClumsy",
    poor: "FFD20.FlyManeuverabilityPoor",
    average: "FFD20.FlyManeuverabilityAverage",
    good: "FFD20.FlyManeuverabilityGood",
    perfect: "FFD20.FlyManeuverabilityPerfect",
  },

  /**
   * The bonus values for a creature's maneuverability
   */
  flyManeuverabilityValues: {
    clumsy: -8,
    poor: -4,
    average: 0,
    good: 4,
    perfect: 8,
  },

  /**
   * The resulting speed values when a base speed is reduced
   */
  speedReduction: {
    5: 5,
    15: 10,
    20: 15,
    30: 20,
    35: 25,
    45: 30,
    50: 35,
    60: 40,
    65: 45,
    75: 50,
    80: 55,
    90: 60,
    95: 65,
    105: 70,
    110: 75,
    120: 80,
  },

  /* -------------------------------------------- */

  /**
   * An array of maximum carry capacities, where the index is the ability/strength score.
   */
  encumbranceLoads: [
    0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100, 115, 130, 150, 175, 200, 230, 260, 300, 350, 400, 460, 520, 600, 700,
    800, 920, 1040, 1200, 1400, 1600, 1840, 2080, 2400, 2800, 3200, 3680, 4160, 4800, 5600, 6400, 7360, 8320, 9600,
    11200, 12800, 14720, 16640, 19200, 22400, 25600,
  ],

  /**
   * Encumbrance multipliers applied due to a creature's size for bi- and
   * quadrupedal creatures.
   */
  encumbranceMultipliers: {
    normal: {
      fine: 0.125,
      dim: 0.25,
      tiny: 0.5,
      sm: 0.75,
      med: 1,
      lg: 2,
      huge: 4,
      grg: 8,
      col: 16,
    },
    quadruped: {
      fine: 0.25,
      dim: 0.5,
      tiny: 0.75,
      sm: 1,
      med: 1.5,
      lg: 3,
      huge: 6,
      grg: 12,
      col: 24,
    },
  },

  /* -------------------------------------------- */

  /**
   * The types for Items
   */
  itemTypes: {
    equipment: "FFD20.ItemTypeEquipment",
    weapon: "FFD20.ItemTypeWeapon",
    loot: "FFD20.ItemTypeLoot",
    consumable: "FFD20.ItemTypeConsumable",
    class: "FFD20.ItemTypeClass",
    buff: "FFD20.ItemTypeBuff",
    spell: "FFD20.ItemTypeSpell",
    feat: "FFD20.ItemTypeFeat",
    attack: "FFD20.ItemTypeAttack",
  },

  /**
   * Classification types for item action types
   */
  itemActionTypes: {
    mwak: "FFD20.ActionMWAK",
    rwak: "FFD20.ActionRWAK",
    msak: "FFD20.ActionMSAK",
    rsak: "FFD20.ActionRSAK",
    mcman: "FFD20.ActionMCMan",
    rcman: "FFD20.ActionRCMan",
    spellsave: "FFD20.ActionSpellSave",
    save: "FFD20.ActionSave",
    heal: "FFD20.ActionHeal",
    other: "FFD20.ActionOther",
  },

  /* -------------------------------------------- */

  itemCapacityTypes: {
    items: "FFD20.ItemContainerCapacityItems",
    weight: "FFD20.ItemContainerCapacityWeight",
  },

  /* -------------------------------------------- */

  /**
   * Enumerate the lengths of time over which an item can have limited use ability
   */
  limitedUsePeriods: {
    single: "FFD20.LimitedUseSingle",
    unlimited: "FFD20.Unlimited",
    day: "FFD20.LimitedUseDay",
    week: "FFD20.LimitedUseWeek",
    charges: "FFD20.LimitedUseCharges",
  },

  /* -------------------------------------------- */

  /**
   * The various equipment types and their subtypes
   */
  equipmentTypes: {
    armor: {
      _label: "FFD20.EquipTypeArmor",
      lightArmor: "FFD20.EquipTypeLight",
      mediumArmor: "FFD20.EquipTypeMedium",
      heavyArmor: "FFD20.EquipTypeHeavy",
    },
    shield: {
      _label: "FFD20.EquipTypeShield",
      lightShield: "FFD20.EquipTypeLightShield",
      heavyShield: "FFD20.EquipTypeHeavyShield",
      towerShield: "FFD20.EquipTypeTowerShield",
      other: "FFD20.EquipTypeOtherShield",
    },
    misc: {
      _label: "FFD20.Misc",
      wondrous: "FFD20.EquipTypeWondrousItem",
      clothing: "FFD20.EquipTypeClothing",
      other: "FFD20.Other",
    },
    materia: {
      _label: "FFD20.Materia",
      ability: "FFD20.MateriaTypeAbility",
      independent: "FFD20.MateriaTypeIndependent",
      spell: "FFD20.MateriaTypeSpell",
      summon: "FFD20.MateriaTypeSummon",
      support: "FFD20.MateriaTypeSupport",
    },
  },

  /**
   * The slots equipment can occupy, sorted by category
   */
  equipmentSlots: {
    armor: {
      armor: "FFD20.EquipSlotArmor",
    },
    shield: {
      shield: "FFD20.EquipSlotShield",
    },
    misc: {
      slotless: "FFD20.EquipSlotSlotless",
      head: "FFD20.EquipSlotHead",
      headband: "FFD20.EquipSlotHeadband",
      eyes: "FFD20.EquipSlotEyes",
      shoulders: "FFD20.EquipSlotShoulders",
      neck: "FFD20.EquipSlotNeck",
      chest: "FFD20.EquipSlotChest",
      body: "FFD20.EquipSlotBody",
      belt: "FFD20.EquipSlotBelt",
      wrists: "FFD20.EquipSlotWrists",
      hands: "FFD20.EquipSlotHands",
      ring: "FFD20.EquipSlotRing",
      feet: "FFD20.EquipSlotFeet",
    },
    materia: {
      any: "FFD20.MateriaSlotAny",
      weapon: "FFD20.MateriaSlotWeapon",
      shield: "FFD20.MateriaSlotShield",
      armor: "FFD20.MateriaSlotArmor",
      weaponarmor: "FFD20.MateriaSlotWeaponArmor",
      armorShield: "FFD20.MateriaSlotArmorShield",
      other: "FFD20.MateriaSlotOther",
    },
  },

  /**
   * The subtypes for loot items
   */
  lootTypes: {
    gear: "FFD20.LootTypeGear",
    ammo: "FFD20.LootTypeAmmo",
    tradeGoods: "FFD20.LootTypeTradeGoods",
    misc: "FFD20.Misc",
  },

  /* -------------------------------------------- */

  /**
   * Enumerate the valid consumable types which are recognized by the system
   */
  consumableTypes: {
    potion: "FFD20.ConsumableTypePotion",
    oil: "FFD20.ConsumableTypeOil",
    poison: "FFD20.ConsumableTypePoison",
    drug: "FFD20.ConsumableTypeDrug",
    alchContact: "FFD20.ConsumableTypeAlchContact",
    alchIngested: "FFD20.ConsumableTypeAlchIngested",
    alchInhaled: "FFD20.ConsumableTypeAlchInhaled",
    scroll: "FFD20.ConsumableTypeScroll",
    wand: "FFD20.ConsumableTypeWand",
    staff: "FFD20.ConsumableTypeStaff",
    misc: "FFD20.Misc",
  },

  attackTypes: {
    weapon: "FFD20.AttackTypeWeapon",
    natural: "FFD20.AttackTypeNatural",
    ability: "FFD20.AttackTypeAbility",
    racialAbility: "FFD20.AttackTypeRacial",
    item: "FFD20.Item",
    misc: "FFD20.Misc",
  },

  featTypes: {
    feat: "FFD20.FeatTypeFeat",
    classFeat: "FFD20.FeatTypeClassFeat",
    trait: "FFD20.FeatTypeTraits",
    racial: "FFD20.FeatTypeRacial",
    misc: "FFD20.Misc",
    template: "FFD20.FeatTypeTemplate",
  },

  featTypesPlurals: {
    feat: "FFD20.FeatPlural",
    classFeat: "FFD20.ClassFeaturePlural",
    trait: "FFD20.TraitPlural",
    racial: "FFD20.RacialTraitPlural",
    template: "FFD20.TemplatePlural",
  },

  /**
   * Ability types, each with their short and their long form
   */
  abilityTypes: {
    ex: {
      short: "FFD20.AbilityTypeShortExtraordinary",
      long: "FFD20.AbilityTypeExtraordinary",
    },
    su: {
      short: "FFD20.AbilityTypeShortSupernatural",
      long: "FFD20.AbilityTypeSupernatural",
    },
    sp: {
      short: "FFD20.AbilityTypeShortSpell-Like",
      long: "FFD20.AbilityTypeSpell-Like",
    },
  },

  /* -------------------------------------------- */

  /**
   * The valid currency denominations supported by the game system
   */
  currencies: {
    pgil: "FFD20.CurrencyPGil",
    gil: "FFD20.CurrencyGil",
    sgil: "FFD20.CurrencySGil",
    cgil: "FFD20.CurrencyCGil",
  },

  acTypes: {
    armor: "Armor",
    shield: "Shield",
    natural: "Natural Armor",
  },

  /**
   * The types of bonus modifiers
   */
  bonusModifiers: {
    untyped: "FFD20.BonusModifierUntyped",
    untypedPerm: "FFD20.BonusModifierUntypedPerm",
    base: "FFD20.BonusModifierBase",
    enh: "FFD20.BonusModifierEnhancement",
    dodge: "FFD20.BonusModifierDodge",
    inherent: "FFD20.BonusModifierInherent",
    deflection: "FFD20.BonusModifierDeflection",
    morale: "FFD20.BonusModifierMorale",
    luck: "FFD20.BonusModifierLuck",
    sacred: "FFD20.BonusModifierSacred",
    insight: "FFD20.BonusModifierInsight",
    resist: "FFD20.BonusModifierResistance",
    profane: "FFD20.BonusModifierProfane",
    trait: "FFD20.BonusModifierTrait",
    racial: "FFD20.BonusModifierRacial",
    size: "FFD20.BonusModifierSize",
    competence: "FFD20.BonusModifierCompetence",
    circumstance: "FFD20.BonusModifierCircumstance",
    alchemical: "FFD20.BonusModifierAlchemical",
    penalty: "FFD20.BonusModifierPenalty",
  },

  /**
   * An array of stacking bonus modifiers by their keys for {@link bonusModifiers}
   */
  stackingBonusModifiers: ["untyped", "untypedPerm", "dodge", "racial", "penalty"],

  /* -------------------------------------------- */

  /**
   * The damage types
   */
  damageTypes: {
    bludgeoning: "FFD20.DamageTypeBludgeoning",
    piercing: "FFD20.DamageTypePiercing",
    slashing: "FFD20.DamageTypeSlashing",
    fire: "FFD20.DamageTypeFire",
    ice: "FFD20.DamageTypeIce",
    wind: "FFD20.DamageTypeWind",
    earth: "FFD20.DamageTypeEarth",
    lightning: "FFD20.DamageTypeLightning",
    water: "FFD20.DamageTypeWater",
    light: "FFD20.DamageTypeLight",
    dark: "FFD20.DamageTypeDark",
    nonelemental: "FFD20.DamageTypeNonElemental",
  },

  /* -------------------------------------------- */

  /**
   * Valid options for the range of abilities and spells
   */
  distanceUnits: {
    none: "FFD20.None",
    personal: "FFD20.DistPersonal",
    touch: "FFD20.DistTouch",
    melee: "FFD20.DistMelee",
    reach: "FFD20.DistReach",
    close: "FFD20.DistClose",
    medium: "FFD20.DistMedium",
    long: "FFD20.DistLong",
    ft: "FFD20.DistFt",
    mi: "FFD20.DistMi",
    spec: "FFD20.Special",
    seeText: "FFD20.SeeText",
    unlimited: "FFD20.Unlimited",
  },

  measureUnits: {
    ft: "FFD20.DistFt",
    mi: "FFD20.DistMi",
    m: "FFD20.DistM",
    km: "FFD20.DistKM",
  },

  measureUnitsShort: {
    ft: "FFD20.DistFtShort",
    mi: "FFD20.DistMiShort",
    m: "FFD20.DistMShort",
    km: "FFD20.DistKMShort",
  },

  actorStatures: {
    tall: "FFD20.StatureTall",
    long: "FFD20.StatureLong",
  },

  /* -------------------------------------------- */

  /**
   * This Object defines the types of single or area targets which can be applied in the game system.
   */
  targetTypes: {
    none: "FFD20.None",
    self: "FFD20.TargetSelf",
    creature: "FFD20.TargetCreature",
    ally: "FFD20.TargetAlly",
    enemy: "FFD20.TargetEnemy",
    object: "FFD20.TargetObject",
    space: "FFD20.TargetSpace",
    radius: "FFD20.TargetRadius",
    sphere: "FFD20.TargetSphere",
    cylinder: "FFD20.TargetCylinder",
    cone: "FFD20.TargetCone",
    square: "FFD20.TargetSquare",
    cube: "FFD20.TargetCube",
    line: "FFD20.TargetLine",
    wall: "FFD20.TargetWall",
  },

  /* -------------------------------------------- */

  /**
   * This Object defines the various lengths of time which can occur in FFD20
   */
  timePeriods: {
    inst: "FFD20.TimeInst",
    turn: "FFD20.TimeTurn",
    round: "FFD20.TimeRound",
    minute: "FFD20.TimeMinute",
    hour: "FFD20.TimeHour",
    day: "FFD20.TimeDay",
    month: "FFD20.TimeMonth",
    year: "FFD20.TimeYear",
    perm: "FFD20.TimePerm",
    seeText: "FFD20.SeeText",
    spec: "FFD20.Special",
  },

  timePeriodsShort: {
    turn: "FFD20.TimeTurnShort",
    round: "FFD20.TimeRoundShort",
    minute: "FFD20.TimeMinuteShort",
  },

  /* -------------------------------------------- */

  /**
   * This Object determines spells gained and cast per level
   */
  casterProgression: {
    castsPerDay: {
      prepared: {
        low: [
          [Number.POSITIVE_INFINITY],
          [Number.POSITIVE_INFINITY],
          [Number.POSITIVE_INFINITY],
          [Number.POSITIVE_INFINITY, 0],
          [Number.POSITIVE_INFINITY, 1],
          [Number.POSITIVE_INFINITY, 1],
          [Number.POSITIVE_INFINITY, 1, 0],
          [Number.POSITIVE_INFINITY, 1, 1],
          [Number.POSITIVE_INFINITY, 2, 1],
          [Number.POSITIVE_INFINITY, 2, 1, 0],
          [Number.POSITIVE_INFINITY, 2, 1, 1],
          [Number.POSITIVE_INFINITY, 2, 2, 1],
          [Number.POSITIVE_INFINITY, 3, 2, 1, 0],
          [Number.POSITIVE_INFINITY, 3, 2, 1, 1],
          [Number.POSITIVE_INFINITY, 3, 2, 2, 1],
          [Number.POSITIVE_INFINITY, 3, 3, 2, 1],
          [Number.POSITIVE_INFINITY, 4, 3, 2, 1],
          [Number.POSITIVE_INFINITY, 4, 3, 2, 2],
          [Number.POSITIVE_INFINITY, 4, 3, 3, 2],
          [Number.POSITIVE_INFINITY, 4, 4, 3, 3],
        ],
        med: [
          [Number.POSITIVE_INFINITY, 1],
          [Number.POSITIVE_INFINITY, 2],
          [Number.POSITIVE_INFINITY, 3],
          [Number.POSITIVE_INFINITY, 3, 1],
          [Number.POSITIVE_INFINITY, 4, 2],
          [Number.POSITIVE_INFINITY, 4, 3],
          [Number.POSITIVE_INFINITY, 4, 3, 1],
          [Number.POSITIVE_INFINITY, 4, 4, 2],
          [Number.POSITIVE_INFINITY, 5, 4, 3],
          [Number.POSITIVE_INFINITY, 5, 4, 3, 1],
          [Number.POSITIVE_INFINITY, 5, 4, 4, 2],
          [Number.POSITIVE_INFINITY, 5, 5, 4, 3],
          [Number.POSITIVE_INFINITY, 5, 5, 4, 3, 1],
          [Number.POSITIVE_INFINITY, 5, 5, 4, 4, 2],
          [Number.POSITIVE_INFINITY, 5, 5, 5, 4, 3],
          [Number.POSITIVE_INFINITY, 5, 5, 5, 4, 3, 1],
          [Number.POSITIVE_INFINITY, 5, 5, 5, 4, 4, 2],
          [Number.POSITIVE_INFINITY, 5, 5, 5, 5, 4, 3],
          [Number.POSITIVE_INFINITY, 5, 5, 5, 5, 5, 4],
          [Number.POSITIVE_INFINITY, 5, 5, 5, 5, 5, 5],
        ],
        high: [
          [Number.POSITIVE_INFINITY, 1],
          [Number.POSITIVE_INFINITY, 2],
          [Number.POSITIVE_INFINITY, 2, 1],
          [Number.POSITIVE_INFINITY, 3, 2],
          [Number.POSITIVE_INFINITY, 3, 2, 1],
          [Number.POSITIVE_INFINITY, 3, 3, 2],
          [Number.POSITIVE_INFINITY, 4, 3, 2, 1],
          [Number.POSITIVE_INFINITY, 4, 3, 3, 2],
          [Number.POSITIVE_INFINITY, 4, 4, 3, 2, 1],
          [Number.POSITIVE_INFINITY, 4, 4, 3, 3, 2],
          [Number.POSITIVE_INFINITY, 4, 4, 4, 3, 2, 1],
          [Number.POSITIVE_INFINITY, 4, 4, 4, 3, 3, 2],
          [Number.POSITIVE_INFINITY, 4, 4, 4, 4, 3, 2, 1],
          [Number.POSITIVE_INFINITY, 4, 4, 4, 4, 3, 3, 2],
          [Number.POSITIVE_INFINITY, 4, 4, 4, 4, 4, 3, 2, 1],
          [Number.POSITIVE_INFINITY, 4, 4, 4, 4, 4, 3, 3, 2],
          [Number.POSITIVE_INFINITY, 4, 4, 4, 4, 4, 4, 3, 2, 1],
          [Number.POSITIVE_INFINITY, 4, 4, 4, 4, 4, 4, 3, 3, 2],
          [Number.POSITIVE_INFINITY, 4, 4, 4, 4, 4, 4, 4, 3, 3],
          [Number.POSITIVE_INFINITY, 4, 4, 4, 4, 4, 4, 4, 4, 4],
        ],
      },
      spontaneous: {
        low: [
          [Number.POSITIVE_INFINITY],
          [Number.POSITIVE_INFINITY],
          [Number.POSITIVE_INFINITY],
          [Number.POSITIVE_INFINITY, 1],
          [Number.POSITIVE_INFINITY, 1],
          [Number.POSITIVE_INFINITY, 1],
          [Number.POSITIVE_INFINITY, 1, 1],
          [Number.POSITIVE_INFINITY, 1, 1],
          [Number.POSITIVE_INFINITY, 2, 1],
          [Number.POSITIVE_INFINITY, 2, 1, 1],
          [Number.POSITIVE_INFINITY, 2, 1, 1],
          [Number.POSITIVE_INFINITY, 2, 2, 1],
          [Number.POSITIVE_INFINITY, 3, 2, 1, 1],
          [Number.POSITIVE_INFINITY, 3, 2, 1, 1],
          [Number.POSITIVE_INFINITY, 3, 2, 2, 1],
          [Number.POSITIVE_INFINITY, 3, 3, 2, 1],
          [Number.POSITIVE_INFINITY, 4, 3, 2, 1],
          [Number.POSITIVE_INFINITY, 4, 3, 2, 2],
          [Number.POSITIVE_INFINITY, 4, 3, 3, 2],
          [Number.POSITIVE_INFINITY, 4, 4, 3, 2],
        ],
        med: [
          [Number.POSITIVE_INFINITY, 1],
          [Number.POSITIVE_INFINITY, 2],
          [Number.POSITIVE_INFINITY, 3],
          [Number.POSITIVE_INFINITY, 3, 1],
          [Number.POSITIVE_INFINITY, 4, 2],
          [Number.POSITIVE_INFINITY, 4, 3],
          [Number.POSITIVE_INFINITY, 4, 3, 1],
          [Number.POSITIVE_INFINITY, 4, 4, 2],
          [Number.POSITIVE_INFINITY, 5, 4, 3],
          [Number.POSITIVE_INFINITY, 5, 4, 3, 1],
          [Number.POSITIVE_INFINITY, 5, 4, 4, 2],
          [Number.POSITIVE_INFINITY, 5, 5, 4, 3],
          [Number.POSITIVE_INFINITY, 5, 5, 4, 3, 1],
          [Number.POSITIVE_INFINITY, 5, 5, 4, 4, 2],
          [Number.POSITIVE_INFINITY, 5, 5, 5, 4, 3],
          [Number.POSITIVE_INFINITY, 5, 5, 5, 4, 3, 1],
          [Number.POSITIVE_INFINITY, 5, 5, 5, 4, 4, 2],
          [Number.POSITIVE_INFINITY, 5, 5, 5, 5, 4, 3],
          [Number.POSITIVE_INFINITY, 5, 5, 5, 5, 5, 4],
          [Number.POSITIVE_INFINITY, 5, 5, 5, 5, 5, 5],
        ],
        high: [
          [Number.POSITIVE_INFINITY, 3],
          [Number.POSITIVE_INFINITY, 4],
          [Number.POSITIVE_INFINITY, 5],
          [Number.POSITIVE_INFINITY, 6, 3],
          [Number.POSITIVE_INFINITY, 6, 4],
          [Number.POSITIVE_INFINITY, 6, 5, 3],
          [Number.POSITIVE_INFINITY, 6, 6, 4],
          [Number.POSITIVE_INFINITY, 6, 6, 5, 3],
          [Number.POSITIVE_INFINITY, 6, 6, 6, 4],
          [Number.POSITIVE_INFINITY, 6, 6, 6, 5, 3],
          [Number.POSITIVE_INFINITY, 6, 6, 6, 6, 4],
          [Number.POSITIVE_INFINITY, 6, 6, 6, 6, 5, 3],
          [Number.POSITIVE_INFINITY, 6, 6, 6, 6, 6, 4],
          [Number.POSITIVE_INFINITY, 6, 6, 6, 6, 6, 5, 3],
          [Number.POSITIVE_INFINITY, 6, 6, 6, 6, 6, 6, 4],
          [Number.POSITIVE_INFINITY, 6, 6, 6, 6, 6, 6, 5, 3],
          [Number.POSITIVE_INFINITY, 6, 6, 6, 6, 6, 6, 6, 4],
          [Number.POSITIVE_INFINITY, 6, 6, 6, 6, 6, 6, 6, 5, 3],
          [Number.POSITIVE_INFINITY, 6, 6, 6, 6, 6, 6, 6, 6, 4],
          [Number.POSITIVE_INFINITY, 6, 6, 6, 6, 6, 6, 6, 6, 6],
        ],
      },
      hybrid: {
        high: [
          [Number.POSITIVE_INFINITY, 2],
          [Number.POSITIVE_INFINITY, 3],
          [Number.POSITIVE_INFINITY, 4],
          [Number.POSITIVE_INFINITY, 4, 2],
          [Number.POSITIVE_INFINITY, 4, 3],
          [Number.POSITIVE_INFINITY, 4, 4, 2],
          [Number.POSITIVE_INFINITY, 4, 4, 3],
          [Number.POSITIVE_INFINITY, 4, 4, 4, 2],
          [Number.POSITIVE_INFINITY, 4, 4, 4, 3],
          [Number.POSITIVE_INFINITY, 4, 4, 4, 4, 2],
          [Number.POSITIVE_INFINITY, 4, 4, 4, 4, 3],
          [Number.POSITIVE_INFINITY, 4, 4, 4, 4, 4, 2],
          [Number.POSITIVE_INFINITY, 4, 4, 4, 4, 4, 3],
          [Number.POSITIVE_INFINITY, 4, 4, 4, 4, 4, 4, 2],
          [Number.POSITIVE_INFINITY, 4, 4, 4, 4, 4, 4, 3],
          [Number.POSITIVE_INFINITY, 4, 4, 4, 4, 4, 4, 4, 2],
          [Number.POSITIVE_INFINITY, 4, 4, 4, 4, 4, 4, 4, 3],
          [Number.POSITIVE_INFINITY, 4, 4, 4, 4, 4, 4, 4, 4, 2],
          [Number.POSITIVE_INFINITY, 4, 4, 4, 4, 4, 4, 4, 4, 3],
          [Number.POSITIVE_INFINITY, 4, 4, 4, 4, 4, 4, 4, 4, 4],
        ],
      },
      prestige: {
        low: [
          [Number.POSITIVE_INFINITY, 1],
          [Number.POSITIVE_INFINITY, 2],
          [Number.POSITIVE_INFINITY, 3],
          [Number.POSITIVE_INFINITY, 3, 1],
          [Number.POSITIVE_INFINITY, 4, 2],
          [Number.POSITIVE_INFINITY, 4, 3],
          [Number.POSITIVE_INFINITY, 4, 3, 1],
          [Number.POSITIVE_INFINITY, 4, 4, 2],
          [Number.POSITIVE_INFINITY, 5, 4, 3],
          [Number.POSITIVE_INFINITY, 5, 4, 3, 1],
          [Number.POSITIVE_INFINITY, 5, 4, 3, 1],
          [Number.POSITIVE_INFINITY, 5, 4, 3, 1],
          [Number.POSITIVE_INFINITY, 5, 4, 3, 1],
          [Number.POSITIVE_INFINITY, 5, 4, 3, 1],
          [Number.POSITIVE_INFINITY, 5, 4, 3, 1],
          [Number.POSITIVE_INFINITY, 5, 4, 3, 1],
          [Number.POSITIVE_INFINITY, 5, 4, 3, 1],
          [Number.POSITIVE_INFINITY, 5, 4, 3, 1],
          [Number.POSITIVE_INFINITY, 5, 4, 3, 1],
          [Number.POSITIVE_INFINITY, 5, 4, 3, 1],
        ],
      },
    },
    spellsPreparedPerDay: {
      prepared: {
        low: [
          [null],
          [null],
          [null],
          [null, 0],
          [null, 1],
          [null, 1],
          [null, 1, 0],
          [null, 1, 1],
          [null, 2, 1],
          [null, 2, 1, 0],
          [null, 2, 1, 1],
          [null, 2, 2, 1],
          [null, 3, 2, 1, 0],
          [null, 3, 2, 1, 1],
          [null, 3, 2, 2, 1],
          [null, 3, 3, 2, 1],
          [null, 4, 3, 2, 1],
          [null, 4, 3, 2, 2],
          [null, 4, 3, 3, 2],
          [null, 4, 4, 3, 3],
        ],
        med: [
          [3, 1],
          [4, 2],
          [4, 3],
          [4, 3, 1],
          [4, 4, 2],
          [5, 4, 3],
          [5, 4, 3, 1],
          [5, 4, 4, 2],
          [5, 5, 4, 3],
          [5, 5, 4, 3, 1],
          [5, 5, 4, 4, 2],
          [5, 5, 5, 4, 3],
          [5, 5, 5, 4, 3, 1],
          [5, 5, 5, 4, 4, 2],
          [5, 5, 5, 5, 4, 3],
          [5, 5, 5, 5, 4, 3, 1],
          [5, 5, 5, 5, 4, 4, 2],
          [5, 5, 5, 5, 5, 4, 3],
          [5, 5, 5, 5, 5, 5, 4],
          [5, 5, 5, 5, 5, 5, 5],
        ],
        high: [
          [3, 1],
          [4, 2],
          [4, 2, 1],
          [4, 3, 2],
          [4, 3, 2, 1],
          [4, 3, 3, 2],
          [4, 4, 3, 2, 1],
          [4, 4, 3, 3, 2],
          [4, 4, 4, 3, 2, 1],
          [4, 4, 4, 3, 3, 2],
          [4, 4, 4, 4, 3, 2, 1],
          [4, 4, 4, 4, 3, 3, 2],
          [4, 4, 4, 4, 4, 3, 2, 1],
          [4, 4, 4, 4, 4, 3, 3, 2],
          [4, 4, 4, 4, 4, 4, 3, 2, 1],
          [4, 4, 4, 4, 4, 4, 3, 3, 2],
          [4, 4, 4, 4, 4, 4, 4, 3, 2, 1],
          [4, 4, 4, 4, 4, 4, 4, 3, 3, 2],
          [4, 4, 4, 4, 4, 4, 4, 4, 3, 3],
          [4, 4, 4, 4, 4, 4, 4, 4, 4, 4],
        ],
      },
      spontaneous: {
        low: [
          [2],
          [3],
          [4],
          [4, 2],
          [5, 3],
          [5, 4],
          [6, 4, 2],
          [6, 4, 3],
          [6, 5, 4],
          [6, 5, 4, 2],
          [6, 5, 4, 3],
          [6, 6, 5, 4],
          [6, 6, 5, 4, 2],
          [6, 6, 5, 4, 3],
          [6, 6, 6, 5, 4],
          [6, 6, 6, 5, 4],
          [6, 6, 6, 5, 4],
          [6, 6, 6, 6, 5],
          [6, 6, 6, 6, 5],
          [6, 6, 6, 6, 5],
        ],
        med: [
          [4, 2],
          [5, 3],
          [6, 4],
          [6, 4, 2],
          [6, 4, 3],
          [6, 4, 4],
          [6, 5, 4, 2],
          [6, 5, 4, 3],
          [6, 5, 4, 4],
          [6, 5, 5, 4, 2],
          [6, 6, 5, 4, 3],
          [6, 6, 5, 4, 4],
          [6, 6, 5, 5, 4, 2],
          [6, 6, 6, 5, 4, 3],
          [6, 6, 6, 5, 4, 4],
          [6, 6, 6, 5, 5, 4, 2],
          [6, 6, 6, 6, 5, 4, 3],
          [6, 6, 6, 6, 5, 4, 4],
          [6, 6, 6, 6, 5, 5, 4],
          [6, 6, 6, 6, 6, 5, 5],
        ],
        high: [
          [4, 2],
          [5, 2],
          [5, 3],
          [6, 3, 1],
          [6, 4, 2],
          [7, 4, 2, 1],
          [7, 5, 3, 2],
          [8, 5, 3, 2, 1],
          [8, 5, 4, 3, 2],
          [9, 5, 4, 3, 2, 1],
          [9, 5, 5, 4, 3, 2],
          [9, 5, 5, 4, 3, 2, 1],
          [9, 5, 5, 4, 4, 3, 2],
          [9, 5, 5, 4, 4, 3, 2, 1],
          [9, 5, 5, 4, 4, 4, 3, 2],
          [9, 5, 5, 4, 4, 4, 3, 2, 1],
          [9, 5, 5, 4, 4, 4, 3, 3, 2],
          [9, 5, 5, 4, 4, 4, 3, 3, 2, 1],
          [9, 5, 5, 4, 4, 4, 3, 3, 3, 2],
          [9, 5, 5, 4, 4, 4, 3, 3, 3, 3],
        ],
      },
      hybrid: {
        high: [
          [4, 2],
          [5, 2],
          [5, 3],
          [6, 3, 1],
          [6, 4, 2],
          [7, 4, 2, 1],
          [7, 5, 3, 2],
          [8, 5, 3, 2, 1],
          [8, 5, 4, 3, 2],
          [9, 5, 4, 3, 2, 1],
          [9, 5, 5, 4, 3, 2],
          [9, 5, 5, 4, 3, 2, 1],
          [9, 5, 5, 4, 4, 3, 2],
          [9, 5, 5, 4, 4, 3, 2, 1],
          [9, 5, 5, 4, 4, 4, 3, 2],
          [9, 5, 5, 4, 4, 4, 3, 2, 1],
          [9, 5, 5, 4, 4, 4, 3, 3, 2],
          [9, 5, 5, 4, 4, 4, 3, 3, 2, 1],
          [9, 5, 5, 4, 4, 4, 3, 3, 3, 2],
          [9, 5, 5, 4, 4, 4, 3, 3, 3, 3],
        ],
      },
      prestige: {
        low: [
          [null, 2],
          [null, 3],
          [null, 4],
          [null, 4, 2],
          [null, 4, 3],
          [null, 4, 4],
          [null, 5, 4, 2],
          [null, 5, 4, 3],
          [null, 5, 4, 4],
          [null, 5, 5, 4, 2],
          [null, 5, 5, 4, 2],
          [null, 5, 5, 4, 2],
          [null, 5, 5, 4, 2],
          [null, 5, 5, 4, 2],
          [null, 5, 5, 4, 2],
          [null, 5, 5, 4, 2],
          [null, 5, 5, 4, 2],
          [null, 5, 5, 4, 2],
          [null, 5, 5, 4, 2],
          [null, 5, 5, 4, 2],
        ],
      },
    },
  },

  /* -------------------------------------------- */

  // Healing Types
  /**
   * Types of healing
   */
  healingTypes: {
    healing: "FFD20.Healing",
    temphp: "FFD20.HealingTemp",
  },

  /* -------------------------------------------- */

  /**
   * Character senses options
   * SenseBS = blindsight
   *  = blindsense
   * SenseDV = darkvision
   * SenseLL = lowlightvision
   *  = scent
   *  = allaroundvision
   *  = greensight
   *  = lifesense
   *  = mistsight
   *  = seeindarkness
   *  = thoughtsense
   * SenseTS = tremorsense
   * SenseTR = truesight
   *
   * @type {object}
   *
   */

  senses: {
    bs: "FFD20.SenseBS",
    dv: "FFD20.SenseDV",
    ts: "FFD20.SenseTS",
    tr: "FFD20.SenseTR",
    ll: "FFD20.SenseLL",
  },

  /* -------------------------------------------- */

  /**
   * The set of skill which can be trained in FFD20
   */
  skills: {
    /* Acrobatics */ acr: "FFD20.SkillAcr",
    /* Appraise */ apr: "FFD20.SkillApr",
    /* Bluff */ blf: "FFD20.SkillBlf",
    /* Climb */ clm: "FFD20.SkillClm",
    /* craft skills */ crf: "FFD20.SkillCrf",
    /* Diplomacy */ dip: "FFD20.SkillDip",
    /* Disable Device */ dev: "FFD20.SkillDev",
    /* Disguise */ dis: "FFD20.SkillDis",
    /* Drive */ dri: "FFD20.SkillDri",
    /* Escape Artist */ esc: "FFD20.SkillEsc",
    /* Fly */ fly: "FFD20.SkillFly",
    /* Handle Animal */ han: "FFD20.SkillHan",
    /* Heal */ hea: "FFD20.SkillHea",
    /* Intimidate */ int: "FFD20.SkillInt",
    /* Knowledge (arcana) */ kar: "FFD20.SkillKAr",
    /* Knowledge (dungeoneering) */ kdu: "FFD20.SkillKDu",
    /* Knowledge (engineering) */ ken: "FFD20.SkillKEn",
    /* Knowledge (geography) */ kge: "FFD20.SkillKGe",
    /* Knowledge (history) */ khi: "FFD20.SkillKHi",
    /* Knowledge (local) */ klo: "FFD20.SkillKLo",
    /* Knowledge (nature) */ kna: "FFD20.SkillKNa",
    /* Knowledge (nobility) */ kno: "FFD20.SkillKNo",
    /* Knowledge (planes) */ kpl: "FFD20.SkillKPl",
    /* Knowledge (religion) */ kre: "FFD20.SkillKRe",
    /* Knowledge (technology) */ kte: "FFD20.SkillKTe",
    /* Linguistics */ lin: "FFD20.SkillLin",
    /* Navigate */ nav: "FFD20.SkillNav",
    /* Perception */ per: "FFD20.SkillPer",
    /* Perform */ prf: "FFD20.SkillPrf",
    /* Pilot */ pil: "FFD20.SkillPil",
    /* Profession */ pro: "FFD20.SkillPro",
    /* Repair */ rep: "FFD20.SkillRep",
    /* Ride */ rid: "FFD20.SkillRid",
    /* Sense Motive */ sen: "FFD20.SkillSen",
    /* Sleight of Hand */ slt: "FFD20.SkillSlt",
    /* Spellcraft */ spl: "FFD20.SkillSpl",
    /* Stealth */ ste: "FFD20.SkillSte",
    /* Survival */ sur: "FFD20.SkillSur",
    /* Swim */ swm: "FFD20.SkillSwm",
    /* Use Magic Device */ umd: "FFD20.SkillUMD",
  },

  /**
   * Compendium journal entries containing details about {@link skills}
   */
  skillCompendiumEntries: {
    acr: "ffd20.skills.HPsdXjjRtKNGFGRc", // Acrobatics
    apr: "ffd20.skills.W5GT9F3euC4aG9zP", // Appraise
    blf: "ffd20.skills.pAB2PYkZO3lsmeaC", // Bluff
    clm: "ffd20.skills.xvua9V5Zggkc77Gt", // Climb
    crf: "ffd20.skills.L6LEhHRrn53cMuhE", // craft skills
    dip: "ffd20.skills.OtfbHJhIQsNzmiTN", // Diplomacy
    dev: "ffd20.skills.CCy1fajKKU3K02iQ", // Disable Device
    dis: "ffd20.skills.lP3L1RXi9q4ha9Gu", // Disguise
    dri: "ffd20.skills.EiaJIZVdGDvLxVll", // Drive
    esc: "ffd20.skills.AOQsMtvLY4V3wFEL", // Escape Artist
    fly: "ffd20.skills.rR877UB1xVd3Z7z1", // Fly
    han: "ffd20.skills.fXauAodbOBHBi7Mj", // Handle Animal
    hea: "ffd20.skills.RtBGttkocvTbySjd", // Heal
    int: "ffd20.skills.ImjhcPmm02QSCbPg", // Intimidate
    kar: "ffd20.skills.ki0QvL0K7u4YuK0O", // Knowledge (arcana)
    kdu: "ffd20.skills.ki0QvL0K7u4YuK0O", // Knowledge (dungeoneering)
    ken: "ffd20.skills.ki0QvL0K7u4YuK0O", // Knowledge (engineering)
    kge: "ffd20.skills.ki0QvL0K7u4YuK0O", // Knowledge (geography)
    khi: "ffd20.skills.ki0QvL0K7u4YuK0O", // Knowledge (history)
    klo: "ffd20.skills.ki0QvL0K7u4YuK0O", // Knowledge (local)
    kna: "ffd20.skills.ki0QvL0K7u4YuK0O", // Knowledge (nature)
    kno: "ffd20.skills.ki0QvL0K7u4YuK0O", // Knowledge (nobility)
    kpl: "ffd20.skills.ki0QvL0K7u4YuK0O", // Knowledge (planes)
    kre: "ffd20.skills.ki0QvL0K7u4YuK0O", // Knowledge (religion)
    kte: "ffd20.skills.ki0QvL0K7u4YuK0O", // Knowledge (technology)
    lin: "ffd20.skills.QXIYXqy6ivNHrDrW", // Linguistics
    nav: "ffd20.skills.qtwTUimJjHnSjLkp", // Navigate
    per: "ffd20.skills.YYmmxDgp0g3ltSUG", // Perception
    prf: "ffd20.skills.HhV5UmaRLTjtB3Xh", // Perform
    pil: "ffd20.skills.rVqzliJeSlYj7ewt", // Pilot
    pro: "ffd20.skills.O7Utk8xKbHYDP7Ot", // Profession
    rep: "ffd20.skills.DWB0xZqtaxOwfd2S", // Repair
    rid: "ffd20.skills.mKO8Q4uMiqpMySOZ", // Ride
    sen: "ffd20.skills.R8HGxGCKayOl15AO", // Sense Motive
    slt: "ffd20.skills.zK0CbvpYLZhTN5Wn", // Sleight of Hand
    spl: "ffd20.skills.uLZI2uWz0uB8UgBc", // Spellcraft
    ste: "ffd20.skills.T6nefKotIb5vKE9h", // Stealth
    sur: "ffd20.skills.TXrxgrB2sQjppZFY", // Survival
    swm: "ffd20.skills.weCPHUuXi9sF5r4E", // Swim
    umd: "ffd20.skills.WR5lekzyLT6T2CFH", // Use Magic Device
  },

  /**
   * An array of {@link skills} that can have arbitrary subskills
   */
  arbitrarySkills: ["crf", "prf", "pro"],

  /**
   * An array of {@link skills} that are considered background skills.
   */
  backgroundSkills: ["apr", "crf", "han", "ken", "kge", "khi", "kno", "lin", "prf", "pro", "slt"],

  /* -------------------------------------------- */

  /**
   * Valid options for how a spell is prepared
   */
  spellPreparationModes: {
    atwill: "FFD20.SpellPrepAtWill",
    prepared: "FFD20.SpellPrepPrepared",
    spontaneous: "FFD20.SpellPrepSpontaneous",
  },

  classCasterType: {
    astrologian: "high",
    blackmage: "high",
    bluemage: "high",
    geomancer: "high",
    illusionist: "high",
    necromancer: "high",
    summoner: "high",
    timemage: "high",
    whitemage: "high",
    bard: "med",
    cleric: "med",
    redmage: "med",
    scholar: "med",
    darkpaladin: "low",
    holyknight: "low",
  },

  magicAuraByLevel: {
    spell: [
      { power: "faint", level: 1 },
      { power: "moderate", level: 4 },
      { power: "strong", level: 7 },
      { power: "overwhelming", level: 10 },
    ],
    item: [
      { power: "faint", level: 1 },
      { power: "moderate", level: 6 },
      { power: "strong", level: 12 },
      { power: "overwhelming", level: 21 },
    ],
  },

  auraStrengths: {
    1: "FFD20.AuraStrength_Faint",
    2: "FFD20.AuraStrength_Moderate",
    3: "FFD20.AuraStrength_Strong",
    4: "FFD20.AuraStrength_Overwhelming",
  },

  /* -------------------------------------------- */

  /* -------------------------------------------- */

  // Weapon Types
  weaponTypes: {
    simple: {
      _label: "FFD20.WeaponTypeSimple",
      light: "FFD20.WeaponPropLight",
      "1h": "FFD20.WeaponPropOneHanded",
      "2h": "FFD20.WeaponPropTwoHanded",
      ranged: "FFD20.WeaponSubtypeRanged",
    },
    martial: {
      _label: "FFD20.WeaponTypeMartial",
      light: "FFD20.WeaponPropLight",
      "1h": "FFD20.WeaponPropOneHanded",
      "2h": "FFD20.WeaponPropTwoHanded",
      ranged: "FFD20.WeaponSubtypeRanged",
    },
    exotic: {
      _label: "FFD20.WeaponTypeExotic",
      light: "FFD20.WeaponPropLight",
      "1h": "FFD20.WeaponPropOneHanded",
      "2h": "FFD20.WeaponPropTwoHanded",
      ranged: "FFD20.WeaponSubtypeRanged",
    },
    chef: {
      _label: "FFD20.WeaponTypeChef",
      light: "FFD20.WeaponPropLight",
      "1h": "FFD20.WeaponPropOneHanded",
      "2h": "FFD20.WeaponPropTwoHanded",
      ranged: "FFD20.WeaponSubtypeRanged",
    },
    power: {
      _label: "FFD20.WeaponTypePower",
      light: "FFD20.WeaponPropLight",
      "1h": "FFD20.WeaponPropOneHanded",
      "2h": "FFD20.WeaponPropTwoHanded",
      ranged: "FFD20.WeaponSubtypeRanged",
    },
    misc: {
      _label: "FFD20.Misc",
      splash: "FFD20.WeaponTypeSplash",
      other: "FFD20.Other",
    },
  },

  // Weapon hold types
  weaponHoldTypes: {
    normal: "FFD20.WeaponHoldTypeNormal",
    "2h": "FFD20.WeaponHoldTypeTwoHanded",
    oh: "FFD20.WeaponHoldTypeOffhand",
  },

  /* -------------------------------------------- */

  /**
   * Define the set of weapon property flags which can exist on a weapon
   */
  weaponProperties: {
    blc: "FFD20.WeaponPropBlocking",
    brc: "FFD20.WeaponPropBrace",
    dea: "FFD20.WeaponPropDeadly",
    dst: "FFD20.WeaponPropDistracting",
    dbl: "FFD20.WeaponPropDouble",
    dis: "FFD20.WeaponPropDisarm",
    fin: "FFD20.WeaponPropFinesse",
    frg: "FFD20.WeaponPropFragile",
    grp: "FFD20.WeaponPropGrapple",
    imp: "FFD20.WeaponPropImprovised",
    mnk: "FFD20.WeaponPropMonk",
    nnl: "FFD20.WeaponPropNonLethal",
    prf: "FFD20.WeaponPropPerformance",
    rch: "FFD20.WeaponPropReach",
    snd: "FFD20.WeaponPropSunder",
    thr: "FFD20.WeaponPropThrown",
    trp: "FFD20.WeaponPropTrip",
  },

  /**
   * The components required for casting a spell
   */
  spellComponents: {
    V: "FFD20.SpellComponentVerbal",
    S: "FFD20.SpellComponentSomatic",
    M: "FFD20.SpellComponentMaterial",
    F: "FFD20.SpellComponentFocus",
    DF: "FFD20.SpellComponentDivineFocus",
  },

  /**
   * Spell schools
   */
  spellSchools: {
    crn: "FFD20.SpellSchoolChronomancy",
    drk: "FFD20.SpellSchoolDark",
    div: "FFD20.SpellSchoolDivination",
    ele: "FFD20.SpellSchoolElemental",
    enc: "FFD20.SpellSchoolEnhancing",
    enf: "FFD20.SpellSchoolEnfeebling",
    heal: "FFD20.SpellSchoolHealing",
    ill: "FFD20.SpellSchoolIllusion",
    lit: "FFD20.SpellSchoolLight",
    multi: "FFD20.multiSchool",
    misc: "FFD20.SpellSchoolMisc",
    nec: "FFD20.SpellSchoolNecromancy",
    nel: "FFD20.SpellSchoolNonElemental",
    sum: "FFD20.SpellSchoolSummoning",
    uni: "FFD20.SpellSchoolUniversal",
  },

  /**
   * Spell multi schools
   */
  multiSchools: {
    blank: "",
    sumhealenc: "FFD20.SpellSchoolSummoningHealingEnhancing",
    sumheal: "FFD20.SpellSchoolSummoningHealing",
    sumenfdrk: "FFD20.SpellSchoolSummoningEnfeeblingDark",
    sumenflit: "FFD20.SpellSchoolSummoningEnfeeblingLight",
    sumenfele: "FFD20.SpellSchoolSummoningEnfeeblingElemental",
    sumenf: "FFD20.SpellSchoolSummoningEnfeebling",
    sumenc: "FFD20.SpellSchoolSummoningEnhancing",
    sumdrk: "FFD20.SpellSchoolSummoningDark",
    sumlit: "FFD20.SpellSchoolSummoningLight",
    sumele: "FFD20.SpellSchoolSummoningElemental",
    sumnel: "FFD20.SpellSchoolSummoningNonElemental",
    crnheal: "FFD20.SpellSchoolChronomancyHealing",
    crnnec: "FFD20.SpellSchoolChronomancyNecromancy",
    crnenf: "FFD20.SpellSchoolChronomancyEnfeebling",
    crnenc: "FFD20.SpellSchoolChronomancyEnhancing",
    healenf: "FFD20.SpellSchoolHealingEnfeebling",
    healenc: "FFD20.SpellSchoolHealingEnhancing",
    illenf: "FFD20.SpellSchoolIllusionEnfeebling",
    illenc: "FFD20.SpellSchoolIllusionEnhancing",
    necenc: "FFD20.SpellSchoolNecromancyEnhancing",
    necenf: "FFD20.SpellSchoolNecromancyEnfeebling",
    necele: "FFD20.SpellSchoolNecromancyElemental",
    necnel: "FFD20.SpellSchoolNecromancyNonElemental",
    enfenc: "FFD20.SpellSchoolEnfeeblingEnhancing",
    enfdrkele: "FFD20.SpellSchoolEnfeeblingDarkElemental",
    enfdrknel: "FFD20.SpellSchoolEnfeeblingDarkNonElemental",
    enfdrk: "FFD20.SpellSchoolEnfeeblingDark",
    enflit: "FFD20.SpellSchoolEnfeeblingLight",
    enfele: "FFD20.SpellSchoolEnfeeblingElemental",
    enfnel: "FFD20.SpellSchoolEnfeeblingNonElemental",
    encdrk: "FFD20.SpellSchoolEnhancingDark",
    enclit: "FFD20.SpellSchoolEnhancingLight",
    encele: "FFD20.SpellSchoolEnhancingElemental",
    encnel: "FFD20.SpellSchoolEnhancingNonElemental",
    drkele: "FFD20.SpellSchoolDarkElemental",
    drknel: "FFD20.SpellSchoolDarkNonElemental",
    litele: "FFD20.SpellSchoolLightElemental",
    litnel: "FFD20.SpellSchoolLightNonElemental",
  },

  /**
   * Spell levels
   */
  spellLevels: {
    0: "FFD20.SpellLevel0",
    1: "FFD20.SpellLevel1",
    2: "FFD20.SpellLevel2",
    3: "FFD20.SpellLevel3",
    4: "FFD20.SpellLevel4",
    5: "FFD20.SpellLevel5",
    6: "FFD20.SpellLevel6",
    7: "FFD20.SpellLevel7",
    8: "FFD20.SpellLevel8",
    9: "FFD20.SpellLevel9",
  },

  /* -------------------------------------------- */

  /**
   * Weapon proficiency levels
   * Each level provides a proficiency multiplier
   */
  proficiencyLevels: {
    "-4": "Not Proficient",
    0: "Proficient",
  },

  /* -------------------------------------------- */

  conditionTypes: {
    antagonized: "FFD20.CondTypeAntagonized",
    berserk: "FFD20.CondTypeBerserk",
    bleed: "FFD20.CondTypeBleed",
    blinded: "FFD20.CondTypeBlinded",
    burning: "FFD20.CondTypeBurning",
    charmed: "FFD20.CondTypeCharmed",
    confused: "FFD20.CondTypeConfused",
    cowering: "FFD20.CondTypeCowering",
    cursed: "FFD20.CondTypeCursed",
    dazed: "FFD20.CondTypeDazed",
    dazzled: "FFD20.CondTypeDazzled",
    deafened: "FFD20.CondTypeDeafened",
    deprotect: "FFD20.CondTypeDeprotect",
    deshell: "FFD20.CondTypeDeshell",
    dimmed: "FFD20.CondTypeDimmed",
    disabled: "FFD20.CondTypeDisabled",
    diseased: "FFD20.CondTypeDiseased",
    doom: "FFD20.CondTypeDoom",
    drenched: "FFD20.CondTypeDrenched",
    energyDrained: "FFD20.CondTypeEnergyDrained",
    entangled: "FFD20.CondTypeEntangled",
    exhausted: "FFD20.CondTypeExhausted",
    fascinated: "FFD20.CondTypeFascinated",
    fatigued: "FFD20.CondTypeFatigued",
    frightened: "FFD20.CondTypeFrightened",
    frog: "FFD20.CondTypeFrog",
    frozen: "FFD20.CondTypeFrozen",
    immobilized: "FFD20.CondTypeImmobilized",
    imperil: "FFD20.CondTypeImperil",
    mini: "FFD20.CondTypeMini",
    nauseated: "FFD20.CondTypeNauseated",
    panicked: "FFD20.CondTypePanicked",
    paralyzed: "FFD20.CondTypeParalyzed",
    petrified: "FFD20.CondTypePetrified",
    poisoned: "FFD20.CondTypePoisoned",
    prone: "FFD20.CondTypeProne",
    sapped: "FFD20.CondTypeSapped",
    shaken: "FFD20.CondTypeShaken",
    sickened: "FFD20.CondTypeSickened",
    silenced: "FFD20.CondTypeSilenced",
    sleep: "FFD20.CondTypeSleep",
    slow: "FFD20.CondTypeSlow",
    squalled: "FFD20.CondTypeSqualled",
    staggered: "FFD20.CondTypeStaggered",
    static: "FFD20.CondTypeStatic",
    stop: "FFD20.CondTypeStop",
    stunned: "FFD20.CondTypeStunned",
    weighted: "FFD20.CondTypeWeighted",
    unlucky: "FFD20.CondTypeUnlucky",
    zombie: "FFD20.CondTypeZombie",
  },

  conditions: {
    antagonized: "FFD20.CondAntagonized",
    berserk: "FFD20.CondBerserk",
    bleed: "FFD20.CondBleed",
    ffd20_blind: "FFD20.CondBlinded",
    burning: "FFD20.CondBurning",
    charmed: "FFD20.CondCharmed",
    confused: "FFD20.CondConfused",
    cowering: "FFD20.CondCowering",
    cursed: "FFD20.CondCursed",
    dazed: "FFD20.CondDazed",
    dazzled: "FFD20.CondDazzled",
    ffd20_deaf: "FFD20.CondDeafened",
    deprotect: "FFD20.CondDeprotect",
    deshell: "FFD20.CondDeshell",
    dimmed: "FFD20.CondDimmed",
    disabled: "FFD20.CondDisabled",
    diseased: "FFD20.CondDiseased",
    doom: "FFD20.CondDoom",
    drenched: "FFD20.CondDrenched",
    energyDrained: "FFD20.CondEnergyDrained",
    entangled: "FFD20.CondEntangled",
    exhausted: "FFD20.CondExhausted",
    fascinated: "FFD20.CondFascinated",
    fatigued: "FFD20.CondFatigued",
    frightened: "FFD20.CondFrightened",
    frog: "FFD20.CondFrog",
    frozen: "FFD20.CondFrozen",
    grappled: "FFD20.CondGrappled",
    helpless: "FFD20.CondHelpless",
    immobilized: "FFD20.CondImmobilized",
    imperil: "FFD20.CondImperil",
    incorporeal: "FFD20.CondIncorporeal",
    mini: "FFD20.CondMini",
    nauseated: "FFD20.CondNauseated",
    panicked: "FFD20.CondPanicked",
    paralyzed: "FFD20.CondParalyzed",
    petrified: "FFD20.CondPetrified",
    pinned: "FFD20.CondPinned",
    poisoned: "FFD20.CondPoisoned",
    ffd20_prone: "FFD20.CondProne",
    sapped: "FFD20.CondSapped",
    shaken: "FFD20.CondShaken",
    sickened: "FFD20.CondSickened",
    silenced: "FFD20.CondSilenced",
    ffd20_sleep: "FFD20.CondSleep",
    slow: "FFD20.CondSlow",
    squalled: "FFD20.CondSqualled",
    staggered: "FFD20.CondStaggered",
    static: "FFD20.CondStatic",
    stop: "FFD20.CondStop",
    stunned: "FFD20.CondStunned",
    unlucky: "FFD20.CondUnlucky",
    weighted: "FFD20.CondWeighted",
    zombie: "FFD20.CondZombie",
  },

  conditionTextures: {
    antagonized: "systems/ffd20/icons/conditions/antagonized.png",
    berserk: "systems/ffd20/icons/conditions/berserk.png",
    bleed: "systems/ffd20/icons/conditions/bleed.png",
    ffd20_blind: "systems/ffd20/icons/conditions/blind.png",
    burning: "systems/ffd20/icons/conditions/burning.png",
    charmed: "systems/ffd20/icons/conditions/charmed.png",
    confused: "systems/ffd20/icons/conditions/confused.png",
    cowering: "systems/ffd20/icons/conditions/cowering.png",
    cursed: "systems/ffd20/icons/conditions/cursed.png",
    dazed: "systems/ffd20/icons/conditions/dazed.png",
    dazzled: "systems/ffd20/icons/conditions/dazzled.png",
    ffd20_deaf: "systems/ffd20/icons/conditions/deaf.png",
    deprotect: "systems/ffd20/icons/conditions/deprotect.png",
    deshell: "systems/ffd20/icons/conditions/deshell.png",
    dimmed: "systems/ffd20/icons/conditions/dimmed.png",
    disabled: "systems/ffd20/icons/conditions/disabled.png",
    diseased: "systems/ffd20/icons/conditions/diseased.png",
    doom: "systems/ffd20/icons/conditions/doom.png",
    drenched: "systems/ffd20/icons/conditions/drenched.png",
    energyDrained: "systems/ffd20/icons/conditions/energydrained.png",
    entangled: "systems/ffd20/icons/conditions/entangled.png",
    exhausted: "systems/ffd20/icons/conditions/exhausted.png",
    fascinated: "systems/ffd20/icons/conditions/fascinated.png",
    fatigued: "systems/ffd20/icons/conditions/fatigued.png",
    frightened: "systems/ffd20/icons/conditions/frightened.png",
    frog: "systems/ffd20/icons/conditions/frog.png",
    frozen: "systems/ffd20/icons/conditions/frozen.png",
    grappled: "systems/ffd20/icons/conditions/grappled.png",
    helpless: "systems/ffd20/icons/conditions/helpless.png",
    immobilized: "systems/ffd20/icons/conditions/immobilized.png",
    imperil: "systems/ffd20/icons/conditions/imperil.png",
    incorporeal: "systems/ffd20/icons/conditions/incorporeal.png",
    invisible: "systems/ffd20/icons/conditions/invisible.png",
    mini: "systems/ffd20/icons/conditions/mini.png",
    nauseated: "systems/ffd20/icons/conditions/nauseated.png",
    panicked: "systems/ffd20/icons/conditions/fear.png",
    paralyzed: "systems/ffd20/icons/conditions/paralyzed.png",
    petrified: "systems/ffd20/icons/conditions/petrified.png",
    pinned: "systems/ffd20/icons/conditions/pinned.png",
    poisoned: "systems/ffd20/icons/conditions/poisoned.png",
    ffd20_prone: "systems/ffd20/icons/conditions/prone.png",
    sapped: "systems/ffd20/icons/conditions/sapped.png",
    shaken: "systems/ffd20/icons/conditions/shaken.png",
    sickened: "systems/ffd20/icons/conditions/sickened.png",
    silenced: "systems/ffd20/icons/conditions/silenced.png",
    ffd20_sleep: "systems/ffd20/icons/conditions/sleep.png",
    slow: "systems/ffd20/icons/conditions/slow.png",
    squalled: "systems/ffd20/icons/conditions/squalled.png",
    staggered: "systems/ffd20/icons/conditions/staggered.png",
    static: "systems/ffd20/icons/conditions/static.png",
    stop: "systems/ffd20/icons/conditions/stop.png",
    stunned: "systems/ffd20/icons/conditions/stunned.png",
    unlucky: "systems/ffd20/icons/conditions/unlucky.png",
    weighted: "systems/ffd20/icons/conditions/weighted.png",
    zombie: "systems/ffd20/icons/conditions/zombie.png",
  },

  buffTypes: {
    temp: "FFD20.Temporary",
    perm: "FFD20.Permanent",
    item: "FFD20.Item",
    misc: "FFD20.Misc",
  },

  /**
   * Dictionaries of conditional modifier targets, each with a label and sub-categories
   */
  conditionalTargets: {
    attack: {
      _label: "FFD20.AttackRollPlural",
      allAttack: "FFD20.All",
      hasteAttack: "FFD20.Haste",
      rapidShotAttack: "FFD20.RapidShot",
    },
    damage: {
      _label: "FFD20.Damage",
      allDamage: "FFD20.All",
      hasteDamage: "FFD20.Haste",
      rapidShotDamage: "FFD20.RapidShot",
    },
    size: {
      _label: "FFD20.Size",
    },
    effect: {
      _label: "FFD20.Effects",
    },
    misc: {
      _label: "FFD20.MiscShort",
    },
  },

  /**
   * Dictionaries of change/buff targets, each with a label and sub-categories
   */
  buffTargets: {
    ac: { label: "FFD20.BuffTarACGeneric", category: "defense" },
    aac: { label: "FFD20.BuffTarACArmor", category: "defense" },
    sac: { label: "FFD20.BuffTarACShield", category: "defense" },
    nac: { label: "FFD20.BuffTarACNatural", category: "defense" },
    tac: { label: "FFD20.BuffTarACTouch", category: "defense" },
    ffac: { label: "FFD20.BuffTarACFlatFooted", category: "defense" },
    cmd: { label: "FFD20.CMD", category: "defense" },
    ffcmd: { label: "FFD20.CMDFlatFooted", category: "defense" },
    spellResist: { label: "FFD20.SpellResistance", category: "defense" },
    attack: { label: "FFD20.BuffTarAllAttackRolls", category: "attack" },
    mattack: { label: "FFD20.BuffTarMeleeAttack", category: "attack" },
    rattack: { label: "FFD20.BuffTarRangedAttack", category: "attack" },
    "~attackCore": { label: "", category: "attack" },
    cmb: { label: "FFD20.CMB", category: "attack" },
    bab: { label: "FFD20.BAB", category: "attack" },
    critConfirm: { label: "FFD20.CriticalConfirmation", category: "attack" },
    damage: { label: "FFD20.BuffTarAllDamageRolls", category: "damage" },
    wdamage: { label: "FFD20.WeaponDamage", category: "damage" },
    sdamage: { label: "FFD20.SpellDamage", category: "damage" },
    str: { label: "FFD20.AbilityStr", category: "ability" },
    dex: { label: "FFD20.AbilityDex", category: "ability" },
    con: { label: "FFD20.AbilityCon", category: "ability" },
    int: { label: "FFD20.AbilityInt", category: "ability" },
    wis: { label: "FFD20.AbilityWis", category: "ability" },
    cha: { label: "FFD20.AbilityCha", category: "ability" },
    strMod: { label: "FFD20.AbilityStrMod", category: "ability" },
    dexMod: { label: "FFD20.AbilityDexMod", category: "ability" },
    conMod: { label: "FFD20.AbilityConMod", category: "ability" },
    intMod: { label: "FFD20.AbilityIntMod", category: "ability" },
    wisMod: { label: "FFD20.AbilityWisMod", category: "ability" },
    chaMod: { label: "FFD20.AbilityChaMod", category: "ability" },
    allSavingThrows: { label: "FFD20.BuffTarAllSavingThrows", category: "savingThrows" },
    fort: { label: "FFD20.SavingThrowFort", category: "savingThrows" },
    ref: { label: "FFD20.SavingThrowRef", category: "savingThrows" },
    will: { label: "FFD20.SavingThrowWill", category: "savingThrows" },
    skills: { label: "FFD20.BuffTarAllSkills", category: "skills" },
    strSkills: { label: "FFD20.BuffTarStrSkills", category: "skills" },
    dexSkills: { label: "FFD20.BuffTarDexSkills", category: "skills" },
    conSkills: { label: "FFD20.BuffTarConSkills", category: "skills" },
    intSkills: { label: "FFD20.BuffTarIntSkills", category: "skills" },
    wisSkills: { label: "FFD20.BuffTarWisSkills", category: "skills" },
    chaSkills: { label: "FFD20.BuffTarChaSkills", category: "skills" },
    bonusSkillRanks: { label: "FFD20.BuffTarBonusSkillRanks", category: "skills" },
    allChecks: { label: "FFD20.BuffTarAllAbilityChecks", category: "abilityChecks" },
    strChecks: { label: "FFD20.BuffTarStrChecks", category: "abilityChecks" },
    dexChecks: { label: "FFD20.BuffTarDexChecks", category: "abilityChecks" },
    conChecks: { label: "FFD20.BuffTarConChecks", category: "abilityChecks" },
    intChecks: { label: "FFD20.BuffTarIntChecks", category: "abilityChecks" },
    wisChecks: { label: "FFD20.BuffTarWisChecks", category: "abilityChecks" },
    chaChecks: { label: "FFD20.BuffTarChaChecks", category: "abilityChecks" },
    allSpeeds: { label: "FFD20.BuffTarAllSpeeds", category: "speed" },
    landSpeed: { label: "FFD20.SpeedLand", category: "speed" },
    climbSpeed: { label: "FFD20.SpeedClimb", category: "speed" },
    swimSpeed: { label: "FFD20.SpeedSwim", category: "speed" },
    burrowSpeed: { label: "FFD20.SpeedBurrow", category: "speed" },
    flySpeed: { label: "FFD20.SpeedFly", category: "speed" },
    mhp: { label: "FFD20.HitPoints", category: "health" },
    wounds: { label: "FFD20.Wounds", category: "health" },
    vigor: { label: "FFD20.Vigor", category: "health" },
    init: { label: "FFD20.Initiative", category: "misc" },
    acpA: { label: "FFD20.ACPArmor", category: "misc" },
    acpS: { label: "FFD20.ACPShield", category: "misc" },
    mDexA: { label: "FFD20.MaxDexArmor", category: "misc" },
    mDexS: { label: "FFD20.MaxDexShield", category: "misc" },
    bonusFeats: { label: "FFD20.BuffTarBonusFeats", category: "misc" },
    carryStr: { label: "FFD20.CarryStrength", category: "misc" },
    carryMult: { label: "FFD20.CarryMultiplier", category: "misc" },
  },

  buffTargetCategories: {
    defense: { label: "FFD20.Defense" },
    savingThrows: { label: "FFD20.SavingThrowPlural" },
    attack: { label: "FFD20.Attack" },
    damage: { label: "FFD20.Damage" },
    ability: { label: "FFD20.AbilityScore" },
    abilityChecks: { label: "FFD20.BuffTarAbilityChecks" },
    skills: { label: "FFD20.Skills" },
    skill: { label: "FFD20.BuffTarSpecificSkill" },
    speed: { label: "FFD20.Speed" },
    health: { label: "FFD20.Health" },
    misc: { label: "FFD20.Misc" },
  },

  /**
   * Dictionaries of context note targets, each with a label and sub-categories
   */
  contextNoteTargets: {
    attack: { label: "FFD20.AttackRollPlural", category: "attacks" },
    effect: { label: "FFD20.Effects", category: "attacks" },
    melee: { label: "FFD20.Melee", category: "attacks" },
    meleeWeapon: { label: "FFD20.MeleeWeapon", category: "attacks" },
    meleeSpell: { label: "FFD20.MeleeSpell", category: "attacks" },
    ranged: { label: "FFD20.Ranged", category: "attacks" },
    rangedWeapon: { label: "FFD20.RangedWeapon", category: "attacks" },
    rangedSpell: { label: "FFD20.RangedSpell", category: "attacks" },
    cmb: { label: "FFD20.CMB", category: "attacks" },
    allSavingThrows: { label: "FFD20.BuffTarAllSavingThrows", category: "savingThrows" },
    fort: { label: "FFD20.SavingThrowFort", category: "savingThrows" },
    ref: { label: "FFD20.SavingThrowRef", category: "savingThrows" },
    will: { label: "FFD20.SavingThrowWill", category: "savingThrows" },
    skills: { label: "FFD20.BuffTarAllSkills", category: "skills" },
    strSkills: { label: "FFD20.BuffTarStrSkills", category: "skills" },
    dexSkills: { label: "FFD20.BuffTarDexSkills", category: "skills" },
    conSkills: { label: "FFD20.BuffTarConSkills", category: "skills" },
    intSkills: { label: "FFD20.BuffTarIntSkills", category: "skills" },
    wisSkills: { label: "FFD20.BuffTarWisSkills", category: "skills" },
    chaSkills: { label: "FFD20.BuffTarChaSkills", category: "skills" },
    allChecks: { label: "FFD20.BuffTarAllAbilityChecks", category: "abilityChecks" },
    strChecks: { label: "FFD20.BuffTarStrChecks", category: "abilityChecks" },
    dexChecks: { label: "FFD20.BuffTarDexChecks", category: "abilityChecks" },
    conChecks: { label: "FFD20.BuffTarConChecks", category: "abilityChecks" },
    intChecks: { label: "FFD20.BuffTarIntChecks", category: "abilityChecks" },
    wisChecks: { label: "FFD20.BuffTarWisChecks", category: "abilityChecks" },
    chaChecks: { label: "FFD20.BuffTarChaChecks", category: "abilityChecks" },
    spellEffect: { label: "FFD20.SpellBuffEffect", category: "spell" },
    concentration: { label: "FFD20.Concentration", category: "spell" },
    cl: { label: "FFD20.CasterLevel", category: "spell" },
    ac: { label: "FFD20.ACNormal", category: "defense" },
    cmd: { label: "FFD20.CMD", category: "defense" },
    sr: { label: "FFD20.SpellResistance", category: "defense" },
    init: { label: "FFD20.Initiative", category: "misc" },
  },

  contextNoteCategories: {
    attacks: { label: "FFD20.Attacks" },
    savingThrows: { label: "FFD20.SavingThrowPlural" },
    skills: { label: "FFD20.Skills" },
    skill: { label: "FFD20.BuffTarSpecificSkill" },
    abilityChecks: { label: "FFD20.BuffTarAbilityChecks" },
    spell: { label: "FFD20.BuffTarSpells" },
    defense: { label: "FFD20.Defense" },
    misc: { label: "FFD20.Misc" },
  },

  /**
   * A list of FFD20's languages
   */
  languages: {
    common: "FFD20.LanguageCommon",
    dwarven: "FFD20.LanguageDwarven",
    elvaan: "FFD20.LanguageElvaan",
    galkan: "FFD20.LanguageGalkan",
    lalafellan: "FFD20.LanguageLalafellan",
    mithran: "FFD20.LanguageMithran",
    moogle: "FFD20.LanguageMoogle",
    aegyllan: "FFD20.LanguageAegyllan",
    albhedian: "FFD20.LanguageAlbhedian",
    banganese: "FFD20.LanguageBanganese",
    burmecian: "FFD20.LanguageBurmecian",
    draconic: "FFD20.LanguageDraconic",
    garif: "FFD20.LanguageGarif",
    guado: "FFD20.LanguageGuado",
    hypello: "FFD20.LanguageHypello",
    lupin: "FFD20.LanguageLupin",
    mandragoran: "FFD20.LanguageMandragoran",
    numish: "FFD20.LanguageNumish",
    qiqirn: "FFD20.LanguageQiqirn",
    queran: "FFD20.LanguageQueran",
    roegadyn: "FFD20.LanguageRoegadyn",
    ronsaur: "FFD20.LanguageRonsaur",
    seeq: "FFD20.LanguageSeeq",
    tonberry: "FFD20.LanguageTonberry",
    vieran: "FFD20.LanguageVieran",
    celestial: "FFD20.LanguageCelestial",
    infernal: "FFD20.LanguageInfernal",
    abyssal: "FFD20.LanguageAbyssal",
    aquan: "FFD20.LanguageAquan",
    auran: "FFD20.LanguageAuran",
    auroran: "FFD20.LanguageAuroran",
    enochian: "FFD20.LanguageEnochian",
    ignan: "FFD20.LanguageIgnan",
    terran: "FFD20.LanguageTerran",
    thorian: "FFD20.LanguageThorian",
    umbran: "FFD20.LanguageUmbran",
    amaljaa: "FFD20.LanguageAmaljaa",
    antican: "FFD20.LanguageAntican",
    goblin: "FFD20.LanguageGoblin",
    kojin: "FFD20.LanguageKojin",
    orcish: "FFD20.LanguageOrcish",
    quadav: "FFD20.LanguageQuadav",
    sahagin: "FFD20.LanguageSahagin",
    sylvan: "FFD20.LanguageSylvan",
    undercommon: "FFD20.LanguageUndercommon",
    vanu: "FFD20.LanguageVanu",
    yagudo: "FFD20.LanguageYagudo",
  },

  /**
   * Creature types
   */
  creatureTypes: {
    aberration: "FFD20.CreatureTypeAberration",
    animal: "FFD20.CreatureTypeAnimal",
    construct: "FFD20.CreatureTypeConstruct",
    dragon: "FFD20.CreatureTypeDragon",
    fey: "FFD20.CreatureTypeFey",
    humanoid: "FFD20.CreatureTypeHumanoid",
    magicalBeast: "FFD20.CreatureTypeMagicalBeast",
    monstrousHumanoid: "FFD20.CreatureTypeMonstrousHumanoid",
    ooze: "FFD20.CreatureTypeOoze",
    outsider: "FFD20.CreatureTypeOutsider",
    plant: "FFD20.CreatureTypePlant",
    undead: "FFD20.CreatureTypeUndead",
    vermin: "FFD20.CreatureTypeVermin",
  },

  /**
   * An array containing the damage dice progression for size adjustments
   */
  sizeDie: [
    "1",
    "1d2",
    "1d3",
    "1d4",
    "1d6",
    "1d8",
    "1d10",
    "2d6",
    "2d8",
    "3d6",
    "3d8",
    "4d6",
    "4d8",
    "6d6",
    "6d8",
    "8d6",
    "8d8",
    "12d6",
    "12d8",
    "16d6",
    "16d8",
  ],

  /**
   * Arrays of Character Level XP Requirements by XP track
   */
  CHARACTER_EXP_LEVELS: {
    slow: [
      0, 3000, 7500, 14000, 23000, 35000, 53000, 77000, 115000, 160000, 235000, 330000, 475000, 665000, 955000, 1350000,
      1900000, 2700000, 3850000, 5350000, 8350000, 14350000, 26350000, 50350000, 98350000, 194350000, 386350000,
      770350000, 1538350000, 3074350000,
    ],
    medium: [
      0, 2000, 5000, 9000, 15000, 23000, 35000, 51000, 75000, 105000, 155000, 220000, 315000, 445000, 635000, 890000,
      1300000, 1800000, 2550000, 3600000, 5700000, 9900000, 18300000, 35100000, 68700000, 135900000, 270300000,
      539100000, 1076700000, 2151900000,
    ],
    fast: [
      0, 1300, 3300, 6000, 10000, 15000, 23000, 34000, 50000, 71000, 105000, 145000, 210000, 295000, 425000, 600000,
      850000, 1200000, 1700000, 2400000, 3800000, 6600000, 12200000, 23400000, 45800000, 90600000, 180200000, 359400000,
      717800000, 1434600000,
    ],
  },

  /**
   * An array of Challenge Rating XP Levels
   */
  CR_EXP_LEVELS: [
    200, 400, 600, 800, 1200, 1600, 2400, 3200, 4800, 6400, 9600, 12800, 19200, 25600, 38400, 51200, 76800, 102400,
    153600, 204800, 307200, 409600, 614400, 819200, 1228800, 1638400, 2457600, 3276800, 4915200, 6553600, 9830400,
  ],

  temporaryRollDataFields: {
    actor: [
      "d20",
      "attackBonus",
      "damageBonus",
      "pointBlankBonus",
      "rapidShotPenalty",
      "powerAttackBonus",
      "powerAttackPenalty",
      "conditionals",
      "concentrationBonus",
      "formulaBonus",
      "dcBonus",
      "chargeCostBonus",
      "chargeCost",
      "sizeBonus",
      "bonus",
      "critMult",
      "ablMult",
      "ablDamage",
      "cl",
      "sl",
      "classLevel",
      "ablMod",
      "item",
      "level",
      "mod",
    ],
  },

  keepItemLinksOnCopy: ["classAssociations"],
  classSubTypes: {
    none: "FFD20.None",
    core: "FFD20.ClassSubTypeCore",
    coreArc: "FFD20.ClassSubTypeCoreArc",
    base: "FFD20.ClassSubTypeBase",
    baseArc: "FFD20.ClassSubTypeBaseArc",
    hybrid: "FFD20.ClassSubTypeHybrid",
    hybridArc: "FFD20.ClassSubTypeHybridArc",
  },

  countforexp: {
    exp: "FFD20.ClassExp",
    noExp: "FFD20.ClassNoExp",
  },

  classCastingStats: {
    noncaster: "FFD20.NonCaster",
    int: "FFD20.AbilityShortInt",
    wis: "FFD20.AbilityShortWis",
    cha: "FFD20.AbilityShortCha",
    intAndWis: "FFD20.AbilityShortIntAndWis",
  },

  classBaseMPTypes: {
    noncaster: "FFD20.NonCaster",
    halfCaster: "FFD20.HalfCaster",
    dimPacman: "FFD20.DimPacman",
    pacman: "FFD20.Pacman",
    dimFullCaster: "FFD20.DimFullCaster",
    fullCaster: "FFD20.FullCaster",
    advFullCaster: "FFD20.AdvFullCaster",
  },

  // Current Max Spell Level based on lvl
  ClassSpellLvlProgression: {
    noncaster: "0",
    halfCaster: "min(floor(max(@level - 3 ,0) / 3),4)",
    dimPacman: "min(floor((@level + 2) / 3),6)",
    pacman: "min(floor((@level + 2) / 3),6)",
    dimFullCaster: "min(floor((@level + 1) / 2),9)",
    fullCaster: "min(floor((@level + 1) / 2),9)",
    advFullCaster: "min(floor((@level + 1) / 2),9)",
  },

  // Character MP from levels TODO add other mp bases
  // level        1 2 3 4 5  6  7  8  9 10 11 12 13 14 15 16 17  18  19  20
  classMPlevels: {
    noncaster: [0],
    halfCaster: [0, 0, 0, 1, 2, 3, 4, 5, 6, 7, 8, 10, 12, 14, 16, 19, 22, 25, 29, 33],
    dimPacman: [1, 2, 3, 4, 5, 6, 8, 10, 12, 15, 18, 21, 25, 29, 33, 38, 43, 48, 53, 58],
    pacman: [2, 3, 4, 5, 6, 8, 10, 13, 16, 20, 24, 29, 34, 39, 45, 51, 57, 64, 71, 79],
    dimFullCaster: [2, 3, 4, 5, 6, 8, 11, 15, 20, 24, 29, 35, 42, 49, 56, 65, 74, 83, 92, 101],
    fullCaster: [3, 4, 5, 6, 8, 11, 15, 20, 26, 32, 39, 47, 56, 65, 75, 86, 98, 110, 122, 135],
    advFullCaster: [4, 6, 8, 9, 14, 17, 25, 30, 41, 47, 60, 68, 84, 93, 111, 124, 143, 155, 167, 180],
  },

  // Character MP from stat
  // stat mod 0 1 2 3  4  5  6  7  8  9 10 11 12  13  14  15  16  17
  classMPStatsBonus: {
    1: [0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5],
    2: [0, 1, 3, 3, 3, 4, 6, 6, 6, 7, 9, 9, 9, 10, 12, 12, 12, 13],
    3: [0, 1, 3, 6, 6, 7, 9, 12, 12, 13, 15, 18, 18, 19, 21, 24, 24, 25],
    4: [0, 1, 3, 6, 10, 11, 13, 16, 20, 21, 23, 26, 30, 31, 33, 36, 40, 41],
    5: [0, 1, 3, 6, 10, 16, 18, 21, 25, 31, 33, 36, 40, 46, 48, 51, 55, 61],
    6: [0, 1, 3, 6, 10, 16, 24, 27, 31, 37, 45, 48, 52, 58, 66, 69, 73, 79],
    7: [0, 1, 3, 6, 10, 16, 24, 34, 38, 44, 52, 62, 66, 72, 80, 90, 94, 100],
    8: [0, 1, 3, 6, 10, 16, 24, 34, 46, 52, 60, 70, 82, 88, 96, 106, 118, 124],
    9: [0, 1, 3, 6, 10, 16, 24, 34, 46, 61, 69, 79, 91, 106, 114, 124, 136, 151],
  },

  // to calculate auto mp
  classBaseMPauto: {
    no: "FFD20.No",
    yes: "FFD20.Yes",
    half: "FFD20.Half",
  },

  materiaRarity: {
    common: "FFD20.MateriaRarityCommon",
    uncommon: "FFD20.MateriaRarityUncommon",
    rare: "FFD20.MateriaRarityRare",
    legendary: "FFD20.MateriaRarityLegendary",
  },
  materiaRarityMath: {
    common: 1,
    uncommon: 2,
    rare: 3,
    legendary: 4,
  },
  materiaSlot: {
    unslotted: "FFD20.MateriaSlotUnslotted",
    weapon: "FFD20.MateriaSlotWeapon",
    shield: "FFD20.MateriaSlotShield",
    armor: "FFD20.MateriaSlotArmor",
    other: "FFD20.MateriaSlotOther",
  },
  materiaAdvancement: {
    common: [0, 0, 5000, 10000, 20000],
    uncommon: [0, 5000, 10000, 20000, 40000],
    rare: [0, 7500, 15000, 30000, 60000],
    legendary: [0, 10000, 20000, 40000, 80000],
  },
};

class HealthConfig extends FormApplication {
  constructor(object, options) {
    super(object || HealthConfig.defaultSettings, options);
  }

  /** Collect data for the template. @override */
  async getData() {
    let settings = await game.settings.get("ffd20", "healthConfig");
    settings = mergeObject(HealthConfig.defaultSettings, settings);
    return settings;
  }

  /** @override */
  static get defaultOptions() {
    return mergeObject(super.defaultOptions, {
      title: game.i18n.localize("SETTINGS.ffd20HealthConfigName"),
      id: "health-config",
      template: "systems/ffd20/templates/settings/health.hbs",
      width: 480,
      height: "auto",
      tabs: [
        {
          navSelector: ".tabs",
          contentSelector: ".tabbed",
          initial: "base",
        },
      ],
    });
  }

  static get defaultSettings() {
    return {
      hitdice: {
        PC: { auto: false, rate: 0.5, maximized: 1 },
        NPC: { auto: false, rate: 0.5, maximized: 0 },
        Racial: { auto: false, rate: 0.5, maximized: 0 },
      },
      hitdieOptions: ["Compute", "Rate", "Maximized"],
      rounding: "up",
      continuity: "discrete",
      variants: {
        pc: { useWoundsAndVigor: false, useWoundThresholds: 0, allowWoundThresholdOverride: false },
        npc: { useWoundsAndVigor: false, useWoundThresholds: 0, allowWoundThresholdOverride: true },
      },
    };
  }

  /**
   * Activate the default set of listeners for the Entity sheet These listeners handle basic stuff like form submission or updating images.
   *
   * @override
   */
  activateListeners(html) {
    super.activateListeners(html);
    html.find('button[name="reset"]').click(this._onReset.bind(this));
    html.find('button[name="submit"]').click(this._onSubmit.bind(this));
  }

  /**
   * Handle button click to reset default settings
   *
   * @param event {Event}   The initial button click event
   * @private
   */
  async _onReset(event) {
    event.preventDefault();
    await game.settings.set("ffd20", "healthConfig", HealthConfig.defaultSettings);
    ui.notifications.info(`Reset Pathfinder health configuration.`);
    return this.render();
  }

  _onSubmit(event) {
    super._onSubmit(event);
  }

  /**
   * This method is called upon form submission after form data is validated.
   *
   * @override
   */
  async _updateObject(event, formData) {
    const settings = expandObject(formData);
    // Some mild sanitation for the numeric values.
    for (const hd of Object.values(settings.hitdice)) {
      hd.rate = Math.max(0, Math.min(hd.rate, 100));
      hd.maximized = Math.max(0, Math.min(Math.floor(hd.maximized), 100));
    }

    settings.variants.npc.allowWoundThresholdOverride = true; // HACK: This setting vanishes otherwise

    await game.settings.set("ffd20", "healthConfig", settings);
    ui.notifications.info("Updated Pathfinder health configuration.");
  }
}

class ExperienceConfig extends FormApplication {
  constructor(object, options) {
    super(object || ExperienceConfig.defaultSettings, options);

    this._init = false;
  }

  /** Collect data for the template. @override */
  async getData() {
    const data = {};

    if (!this._init) {
      const settings = await game.settings.get("ffd20", "experienceConfig");
      this._settings = mergeObject(this.constructor.defaultSettings, settings);
      this._init = true;
    }
    data.settings = this._settings;

    // Custom experience track booleans
    data.hasCustomFormula = data.settings.track === "customFormula";

    return data;
  }

  /** @override */
  static get defaultOptions() {
    return mergeObject(super.defaultOptions, {
      title: game.i18n.localize("FFD20.ExperienceConfigName"),
      id: "experience-config",
      template: "systems/ffd20/templates/settings/experience.hbs",
      width: 560,
      height: "auto",
    });
  }

  static get defaultSettings() {
    return {
      track: "medium",
      disableExperienceTracking: false,
      openXpDistributor: true,
      custom: {
        formula: "",
      },
    };
  }

  /**
   * Activate the default set of listeners for the Entity sheet These listeners handle basic stuff like form submission or updating images.
   *
   * @override
   */
  activateListeners(html) {
    super.activateListeners(html);
    html.find('button[type="submit"]').click(this._onButtonSubmit.bind(this));
  }

  _onButtonSubmit(event) {
    this._onSubmit(event);
  }

  _onChangeInput(event) {
    super._onChangeInput(event);

    this._updateApplicationSettings();
  }

  _updateApplicationSettings() {
    // Update settings and re-render
    this._settings = mergeObject(this._settings, expandObject(this._getSubmitData()));
    this.render();
  }

  /**
   * This method is called upon form submission after form data is validated.
   *
   * @override
   */
  async _updateObject(event, formData) {
    const settings = expandObject(formData);
    // Some mild sanitation for the numeric values.
    await game.settings.set("ffd20", "experienceConfig", settings);
    ui.notifications.info("Updated Pathfinder experience configuration.");
  }
}

class AccessibilityConfig extends FormApplication {
  constructor(object, options) {
    super(object || AccessibilityConfig.defaultSettings, options);

    this._init = false;
  }

  /** Collect data for the template. @override */
  async getData() {
    const data = {};

    if (!this._init) {
      const settings = await game.settings.get("ffd20", "accessibilityConfig");
      this._settings = mergeObject(this.constructor.defaultSettings, settings);
      this._init = true;
    }
    data.settings = this._settings;

    return data;
  }

  /** @override */
  static get defaultOptions() {
    return mergeObject(super.defaultOptions, {
      title: game.i18n.localize("FFD20.AccessibilityConfigName"),
      id: "accessibility-config",
      template: "systems/ffd20/templates/settings/accessibility.hbs",
      width: 560,
      height: "auto",
    });
  }

  static get defaultSettings() {
    return {
      fontSize: 0,
    };
  }

  /**
   * Activate the default set of listeners for the Entity sheet These listeners handle basic stuff like form submission or updating images.
   *
   * @override
   */
  activateListeners(html) {
    super.activateListeners(html);
    html.find('button[type="submit"]').click(this._onButtonSubmit.bind(this));
  }

  _onButtonSubmit(event) {
    this._onSubmit(event);
  }

  /**
   * This method is called upon form submission after form data is validated.
   *
   * @override
   */
  async _updateObject(event, formData) {
    const settings = expandObject(formData);
    // Some mild sanitation for the numeric values.
    await game.settings.set("ffd20", "accessibilityConfig", settings);
    ui.notifications.info("Updated Pathfinder accessibility configuration.");
  }
}

class TooltipWorldConfig extends FormApplication {
  constructor(object, options) {
    super(object || TooltipWorldConfig.defaultSettings, options);

    this._cachedData = null;
  }

  getData() {
    const result = {};

    // Get settings
    let settings = game.settings.get("ffd20", "tooltipWorldConfig");
    settings = mergeObject(this.constructor.defaultSettings, settings);
    result.data = settings;

    return result;
  }

  static get defaultOptions() {
    return mergeObject(super.defaultOptions, {
      title: game.i18n.localize("FFD20.TooltipWorldConfigName"),
      id: "tooltip-world-config",
      template: "systems/ffd20/templates/settings/tooltip_world.hbs",
      width: 720,
      height: "auto",
    });
  }

  static get defaultSettings() {
    return {
      disable: false,
      portrait: {
        hide: false,
      },
      hideHeld: true,
      hideArmor: true,
      hideBuffs: true,
      hideConditions: false,
      hideClothing: true,
      hideActorName: true,
      hideActorNameReplacement: "???",
    };
  }

  activateListeners(html) {
    html.find('button[name="submit"]').click(this._onSubmit.bind(this));
    html.find('button[name="reset"]').click(this._onReset.bind(this));
  }

  async _onReset(event) {
    event.preventDefault();
    await game.settings.set("ffd20", "tooltipWorldConfig", this.constructor.defaultSettings);
    ui.notifications.info(game.i18n.localize("FFD20.TooltipConfigResetInfo"));
    return this.render();
  }

  async _updateObject(event, formData) {
    const settings = expandObject(formData);

    await game.settings.set("ffd20", "tooltipWorldConfig", settings);
    ui.notifications.info(game.i18n.localize("FFD20.TooltipConfigUpdateInfo"));
  }
}

class TooltipConfig extends FormApplication {
  constructor(object, options) {
    super(object || TooltipConfig.defaultSettings, options);

    this._cachedData = null;
  }

  getData() {
    if (this._cachedData) return this._cachedData;

    const canvasRect = canvas.app.view.getBoundingClientRect();
    const result = {
      screen: {
        width: canvasRect.width,
        height: canvasRect.height,
        halfWidth: Math.floor(canvasRect.width / 2),
        halfHeight: Math.floor(canvasRect.height / 2),
      },
      isGM: game.user.isGM,
    };

    // Prepare preview data
    {
      const p = {
        width: 320,
        height: 320,
        tooltip: {
          width: 80,
          height: 48,
        },
      };

      const r1 = result.screen.width / result.screen.height;
      const r2 = result.screen.height / result.screen.width;

      if (r1 > r2) {
        p.height = Math.ceil(p.height * r2);
      } else if (r2 > r1) {
        p.width = Math.ceil(p.width * r1);
      }

      result.preview = p;
    }

    // Get settings
    let settings = game.settings.get("ffd20", "tooltipConfig");
    settings = mergeObject(this.constructor.defaultSettings, settings);
    result.data = settings;

    // Get hide key
    result.hideKey = game.i18n.localize("FFD20.Key_Control");

    this._cachedData = result;
    return result;
  }

  static get defaultOptions() {
    return mergeObject(super.defaultOptions, {
      title: game.i18n.localize("FFD20.TooltipConfigName"),
      id: "tooltip-config",
      template: "systems/ffd20/templates/settings/tooltip.hbs",
      width: 720,
      height: "auto",
    });
  }

  static get defaultSettings() {
    return {
      disable: false,
      anchor: {
        x: 1,
        y: 1,
      },
      offset: {
        x: 0,
        y: 0,
      },
      onMouse: false,
      portrait: {
        hide: false,
        maxSize: {
          width: 280,
          height: 280,
        },
      },
      hideWithoutKey: false,
    };
  }

  activateListeners(html) {
    html.find(".immediate-change").change(this._handleImmediateChange.bind(this));

    html.find("button.world-settings").click(this._openWorldSettings.bind(this));

    html.find('button[name="submit"]').click(this._onSubmit.bind(this));
    html.find('button[name="reset"]').click(this._onReset.bind(this));
  }

  _handleImmediateChange(event) {
    const el = event.currentTarget;
    const key = el.name;
    if (!key) return;

    let value;
    if (el.tagName.toUpperCase() === "INPUT") {
      value = el.value;
      if (el.type === "checkbox") value = el.checked === true ? true : false;
    } else {
      value = el.innerHTML;
    }
    if (el.dataset?.dtype === "Boolean") value = Boolean(value);
    else if (el.dataset?.dtype === "Number") value = parseFloat(value);

    setProperty(this._cachedData, `data.${key}`, value);
    this.render();
  }

  _openWorldSettings(event) {
    if (!game.user.can("SETTINGS_MODIFY")) {
      ui.notifications.error("FFD20.ErrorGenericPermission");
      return;
    }

    new TooltipWorldConfig().render(true);
  }

  async _onReset(event) {
    event.preventDefault();
    await game.settings.set("ffd20", "tooltipConfig", this.constructor.defaultSettings);
    this._cachedData = null;
    ui.notifications.info(game.i18n.localize("FFD20.TooltipConfigResetInfo"));
    return this.render();
  }

  async _updateObject(event, formData) {
    const settings = expandObject(formData);

    await game.settings.set("ffd20", "tooltipConfig", settings);
    ui.notifications.info(game.i18n.localize("FFD20.TooltipConfigUpdateInfo"));
  }
}

const registerSystemSettings = function () {
  /**
   * Track the system version upon which point a migration was last applied
   */
  game.settings.register("ffd20", "systemMigrationVersion", {
    name: "System Migration Version",
    scope: "world",
    config: false,
    type: String,
    default: "0.0.0",
  });
  /**
   * Track when the last changelog was shown
   */
  game.settings.register("ffd20", "changelogVersion", {
    name: "Changelog Version",
    scope: "client",
    config: false,
    type: String,
    default: "0.2.0",
  });
  game.settings.register("ffd20", "dontShowChangelog", {
    name: "Don't Automatically Show Changelog",
    scope: "client",
    config: false,
    type: Boolean,
    default: false,
  });

  // Health configuration
  game.settings.registerMenu("ffd20", "healthConfig", {
    name: "SETTINGS.ffd20HealthConfigName",
    label: "SETTINGS.ffd20HealthConfigLabel",
    hint: "SETTINGS.ffd20HealthConfigHint",
    icon: "fas fa-heartbeat",
    type: HealthConfig,
    restricted: true,
  });
  game.settings.register("ffd20", "healthConfig", {
    name: "SETTINGS.ffd20HealthConfigName",
    scope: "world",
    default: HealthConfig.defaultSettings,
    type: Object,
    config: false,
    onChange: () => {
      game.actors.contents.forEach((o) => {
        o.prepareData();
        if (o.sheet != null && o.sheet._state > 0) o.sheet.render();
      });
      Object.values(game.actors.tokens).forEach((o) => {
        o.prepareData();
        if (o.sheet != null && o.sheet._state > 0) o.sheet.render();
      });
    },
  });

  // Experience configuration
  game.settings.registerMenu("ffd20", "experienceConfig", {
    name: "FFD20.ExperienceConfigName",
    label: "FFD20.ExperienceConfigLabel",
    hint: "FFD20.ExperienceConfigHint",
    icon: "fas fa-book",
    type: ExperienceConfig,
    restricted: true,
  });
  game.settings.register("ffd20", "experienceConfig", {
    name: "FFD20.ExperienceConfigName",
    scope: "world",
    default: ExperienceConfig.defaultSettings,
    type: Object,
    config: false,
    onChange: () => {
      game.actors.contents.forEach((o) => {
        o.prepareData();
        if (o.sheet != null && o.sheet._state > 0) o.sheet.render();
      });
      Object.values(game.actors.tokens).forEach((o) => {
        o.prepareData();
        if (o.sheet != null && o.sheet._state > 0) o.sheet.render();
      });
    },
  });

  // Accessibility configuration
  game.settings.registerMenu("ffd20", "accessibilityConfig", {
    name: "FFD20.AccessibilityConfigName",
    label: "FFD20.AccessibilityConfigLabel",
    hint: "FFD20.AccessibilityConfigHint",
    restricted: false,
    icon: "fas fa-wheelchair",
    type: AccessibilityConfig,
  });
  game.settings.register("ffd20", "accessibilityConfig", {
    name: "FFD20.AccessibilityConfigName",
    scope: "client",
    default: AccessibilityConfig.defaultSettings,
    type: Object,
    config: false,
    onChange: () => {
      window.location.reload();
    },
  });

  // Tooltip configuration
  game.settings.registerMenu("ffd20", "tooltipConfig", {
    name: "FFD20.TooltipConfigName",
    label: "FFD20.TooltipConfigLabel",
    hint: "FFD20.TooltipConfigHint",
    restricted: false,
    icon: "fas fa-window-maximize",
    type: TooltipConfig,
  });
  game.settings.register("ffd20", "tooltipConfig", {
    name: "FFD20.TooltipConfigName",
    scope: "client",
    default: TooltipConfig.defaultSettings,
    type: Object,
    config: false,
    onChange: () => {
      game.ffd20.tooltip?.setPosition();
    },
  });

  // Tooltip World configuration
  /* game.settings.registerMenu("ffd20", "tooltipWorldConfig", {
    name: "FFD20.TooltipWorldConfigName",
    label: "FFD20.TooltipWorldConfigLabel",
    hint: "FFD20.TooltipWorldConfigHint",
    restricted: true,
    icon: "fas fa-window-maximize",
    type: TooltipWorldConfig,
  }); */
  game.settings.register("ffd20", "tooltipWorldConfig", {
    name: "FFD20.TooltipWorldConfigName",
    scope: "world",
    default: TooltipWorldConfig.defaultSettings,
    type: Object,
    config: false,
    onChange: () => {
      game.ffd20.tooltip?.setPosition();
    },
  });

  /**
   * Register diagonal movement rule setting
   */
  game.settings.register("ffd20", "diagonalMovement", {
    name: "SETTINGS.ffd20DiagN",
    hint: "SETTINGS.ffd20DiagL",
    scope: "world",
    config: true,
    default: "5105",
    type: String,
    choices: {
      555: "SETTINGS.ffd20DiagPHB",
      5105: "SETTINGS.ffd20DiagDMG",
    },
    onChange: (rule) => (canvas.grid.diagonalRule = rule),
  });

  /**
   * Experience rate
   *
   * @deprecated
   */
  game.settings.register("ffd20", "experienceRate", {
    name: "SETTINGS.ffd20ExpRateN",
    hint: "SETTINGS.ffd20ExpRateL",
    scope: "world",
    config: false,
    default: "",
    type: String,
    onChange: () => {
      [...game.actors.contents, ...Object.values(game.actors.tokens)]
        .filter((o) => {
          return o.data.type === "character";
        })
        .forEach((o) => {
          o.prepareData();
          if (o.sheet != null && o.sheet._state > 0) o.sheet.render();
        });
    },
  });

  const reRenderSheets = () => {
    [...game.actors.contents, ...Object.values(game.actors.tokens)]
      .filter((o) => {
        return o.data.type === "character";
      })
      .forEach((o) => {
        o.prepareData();
        if (o.sheet != null && o.sheet._state > 0) o.sheet.render();
      });
  };

  /**
   * System of Units
   */
  game.settings.register("ffd20", "units", {
    name: "SETTINGS.ffd20UnitsN",
    hint: "SETTINGS.ffd20UnitsL",
    scope: "world",
    config: true,
    default: "imperial",
    type: String,
    choices: {
      imperial: game.i18n.localize("SETTINGS.ffd20ImperialUnits"),
      metric: game.i18n.localize("SETTINGS.ffd20MetricUnits"),
    },
    onChange: reRenderSheets,
  });

  game.settings.register("ffd20", "distanceUnits", {
    name: "SETTINGS.ffd20DistanceUnitsN",
    hint: "SETTINGS.ffd20DistanceUnitsL",
    scope: "world",
    config: true,
    default: "default",
    type: String,
    choices: {
      default: game.i18n.localize("FFD20.Default"),
      imperial: game.i18n.localize("SETTINGS.ffd20ImperialDistanceUnits"),
      metric: game.i18n.localize("SETTINGS.ffd20MetricDistanceUnits"),
    },
    onChange: reRenderSheets,
  });

  game.settings.register("ffd20", "weightUnits", {
    name: "SETTINGS.ffd20WeightUnitsN",
    hint: "SETTINGS.ffd20WeightUnitsL",
    scope: "world",
    config: true,
    default: "default",
    type: String,
    choices: {
      default: game.i18n.localize("FFD20.Default"),
      imperial: game.i18n.localize("SETTINGS.ffd20ImperialWeightUnits"),
      metric: game.i18n.localize("SETTINGS.ffd20MetricWeightUnits"),
    },
    onChange: reRenderSheets,
  });

  /**
   * Option to allow the background skills optional ruleset.
   */
  game.settings.register("ffd20", "allowBackgroundSkills", {
    name: "SETTINGS.ffd20BackgroundSkillsN",
    hint: "SETTINGS.ffd20BackgroundSkillsH",
    scope: "world",
    config: true,
    default: false,
    type: Boolean,
    onChange: () => {
      game.actors.contents.forEach((o) => {
        if (o.sheet && o.sheet.rendered) o.sheet.render(true);
      });
      Object.values(game.actors.tokens).forEach((o) => {
        if (o.sheet && o.sheet.rendered) o.sheet.render(true);
      });
    },
  });

  /**
   * Option to use the Fractional Base Bonuses optional ruleset.
   */
  game.settings.register("ffd20", "useFractionalBaseBonuses", {
    name: "SETTINGS.ffd20FractionalBaseBonusesN",
    hint: "SETTINGS.ffd20FractionalBaseBonusesH",
    scope: "world",
    config: true,
    default: false,
    type: Boolean,
    onChange: () => {
      window.location.reload();
    },
  });

  /**
   * Option to automatically collapse Item Card descriptions
   */
  game.settings.register("ffd20", "autoCollapseItemCards", {
    name: "SETTINGS.ffd20AutoCollapseCardN",
    hint: "SETTINGS.ffd20AutoCollapseCardL",
    scope: "client",
    config: true,
    default: false,
    type: Boolean,
    onChange: () => {
      ui.chat.render();
    },
  });

  /**
   * Option to hide chat buttons
   */
  game.settings.register("ffd20", "hideChatButtons", {
    name: "SETTINGS.ffd20HideChatButtonsN",
    hint: "SETTINGS.ffd20HideChatButtonsH",
    scope: "client",
    config: true,
    default: false,
    type: Boolean,
    onChange: () => {
      ui.chat.render();
    },
  });

  /**
   * Option to change measure style
   */
  game.settings.register("ffd20", "measureStyle", {
    name: "SETTINGS.ffd20MeasureStyleN",
    hint: "SETTINGS.ffd20MeasureStyleL",
    scope: "world",
    config: true,
    default: true,
    type: Boolean,
  });

  /**
   * Low-light Vision Mode
   */
  game.settings.register("ffd20", "lowLightVisionMode", {
    name: "SETTINGS.ffd20LowLightVisionModeN",
    hint: "SETTINGS.ffd20LowLightVisionModeH",
    scope: "world",
    config: true,
    default: false,
    type: Boolean,
    onChange: () => {
      // Refresh canvas sight
      canvas.lighting.initializeSources();
      canvas.perception.initialize();
    },
  });

  game.settings.register("ffd20", "sharedVisionMode", {
    name: "SETTINGS.ffd20SharedVisionModeN",
    hint: "SETTINGS.ffd20SharedVisionModeH",
    scope: "world",
    config: true,
    default: "0",
    type: String,
    choices: {
      0: "SETTINGS.ffd20SharedVisionWithoutSelection",
      1: "SETTINGS.ffd20SharedVisionWithSelection",
    },
    onChange: () => {
      game.socket.emit("system.ffd20", { eventType: "redrawCanvas" });
    },
  });

  /**
   * Set coin weight
   */
  game.settings.register("ffd20", "coinWeight", {
    name: "SETTINGS.ffd20CoinWeightN",
    hint: "SETTINGS.ffd20CoinWeightH",
    scope: "world",
    config: true,
    default: 50,
    type: Number,
    onChange: () => {
      game.actors.contents.forEach((o) => {
        o.prepareData();
      });
      Object.values(game.actors.tokens).forEach((o) => {
        o.prepareData();
      });
    },
  });

  /**
   * Hide token conditions
   */
  game.settings.register("ffd20", "hideTokenConditions", {
    name: "SETTINGS.ffd20HideTokenConditionsN",
    hint: "SETTINGS.ffd20HideTokenConditionsH",
    scope: "world",
    config: true,
    default: false,
    type: Boolean,
    onChange: () => {
      let promises = [];
      const actors = [
        ...Array.from(game.actors.contents.filter((o) => getProperty(o.data, "token.actorLink"))),
        ...Object.values(game.actors.tokens),
      ];
      for (let actor of actors) {
        promises.push(actor.toggleConditionStatusIcons());
      }
      return Promise.all(promises);
    },
  });

  /**
   * Display default token conditions alongside system ones
   */
  game.settings.register("ffd20", "coreEffects", {
    name: "SETTINGS.ffd20CoreEffectsN",
    hint: "SETTINGS.ffd20CoreEffectsH",
    scope: "world",
    config: true,
    default: false,
    type: Boolean,
    onChange: () => {
      window.location.reload();
    },
  });

  /**
   * Skip action dialog prompts
   */
  game.settings.register("ffd20", "skipActionDialogs", {
    name: "SETTINGS.ffd20SkipActionDialogsN",
    hint: "SETTINGS.ffd20SkipActionDialogsH",
    scope: "client",
    config: true,
    default: false,
    type: Boolean,
  });

  /*
   * When skipping an action dialog prompt still place the template if one is configured
   */
  game.settings.register("ffd20", "placeMeasureTemplateOnQuickRolls", {
    name: "SETTINGS.placeMeasureTemplateOnQuickRollsN",
    hint: "SETTINGS.placeMeasureTemplateOnQuickRollsH",
    scope: "client",
    config: true,
    default: true,
    type: Boolean,
  });

  /**
   * Attack chat card template
   */
  game.settings.register("ffd20", "attackChatCardTemplate", {
    name: "SETTINGS.ffd20AttackChatCardTemplateN",
    hint: "SETTINGS.ffd20AttackChatCardTemplateH",
    scope: "world",
    config: true,
    default: "systems/ffd20/templates/chat/attack-roll.hbs",
    type: String,
    choices: {
      "systems/ffd20/templates/chat/attack-roll.hbs": "FFD20.Primary",
      "systems/ffd20/templates/chat/attack-roll2.hbs": "FFD20.Alternate",
    },
  });

  /**
   * Unchained action economy
   */
  game.settings.register("ffd20", "unchainedActionEconomy", {
    name: "SETTINGS.ffd20UnchainedActionEconomyN",
    hint: "SETTINGS.ffd20UnchainedActionEconomyH",
    scope: "world",
    config: true,
    default: false,
    type: Boolean,
    onChange: () => {
      let promises = [];
      const actors = [
        ...Array.from(game.actors.contents.filter((o) => getProperty(o.data, "token.actorLink"))),
        ...Object.values(game.actors.tokens),
      ];
      for (let actor of actors) {
        promises.push(actor.toggleConditionStatusIcons());
      }
      return Promise.all(promises);
    },
  });

  /**
   * Invert filter Shift-clicking
   */
  game.settings.register("ffd20", "invertSectionFilterShiftBehaviour", {
    name: "SETTINGS.ffd20InvertSectionFilterBehaviourN",
    hint: "SETTINGS.ffd20InvertSectionFilterBehaviourH",
    scope: "client",
    config: true,
    default: false,
    type: Boolean,
  });

  /**
   * Hide reach measurements
   */
  game.settings.register("ffd20", "hideReachMeasurements", {
    name: "SETTINGS.ffd20HideReachMeasurementsN",
    hint: "SETTINGS.ffd20HideReachMeasurementsH",
    scope: "client",
    config: true,
    default: false,
    type: Boolean,
  });

  /**
   * Display BAB iteratives instead of simply total
   */
  game.settings.register("ffd20", "displayIteratives", {
    name: "SETTINGS.ffd20DisplayIterativesN",
    hint: "SETTINGS.ffd20DisplayIterativesH",
    scope: "client",
    config: true,
    default: false,
    type: Boolean,
  });

  /**
   * Alternative reach corner rule
   */
  game.settings.register("ffd20", "alternativeReachCornerRule", {
    name: "SETTINGS.ffd20AlternativeReachCornerRuleN",
    hint: "SETTINGS.ffd20AlternativeReachCornerRuleH",
    scope: "world",
    config: true,
    default: false,
    type: Boolean,
  });
};

const registerClientSettings = function () {
  /**
   * Compendium filters
   */
  game.settings.register("ffd20", "compendiumFilters", {
    name: "Compendium Filters",
    hint: "Stores compendium filters",
    scope: "client",
    config: false,
    default: {},
    type: Object,
  });

  /**
   * Compendium items
   */
  game.settings.register("ffd20", "compendiumItems", {
    name: "Compendium Items",
    hint: "Cache compendium entries",
    scope: "client",
    config: false,
    default: {},
    type: Object,
  });

  /**
   * Compendium save versions
   */
  game.settings.register("ffd20", "compendiumSaveVersions", {
    name: "Compendium Save Versions",
    hint: "Versions of compendium caches",
    scope: "client",
    config: false,
    default: {
      spells: "0.1.25",
      items: "0.1.25",
      bestiary: "0.1.25",
      feats: "0.1.25",
      classes: "0.1.25",
      races: "0.1.25",
    },
    type: Object,
  });

  /*
   * Compendium difference data
   */
  game.settings.register("ffd20", "compendiumForceRefresh", {
    name: "Compendium Force Refresh Data",
    hint: "Data needed to determine whether to force refresh compendiums",
    scope: "client",
    config: false,
    default: {
      diff: {
        items: [],
        spells: [],
        classes: [],
        races: [],
        feats: [],
        bestiary: [],
      },
    },
    type: Object,
  });
};

const migrateSystemSettings = async function () {
  if (!game.user.isGM) return;

  // Migrate attack template
  {
    const template = game.settings.get("ffd20", "attackChatCardTemplate");
    if (template.endsWith(".html")) {
      const newTemplate = template.slice(0, template.length - "html".length) + "hbs";
      await game.settings.set("ffd20", "attackChatCardTemplate", newTemplate);
    }
  }
};

const getSkipActionPrompt = function () {
  return (
    (game.settings.get("ffd20", "skipActionDialogs") && !game.keyboard.isDown("Shift")) ||
    (!game.settings.get("ffd20", "skipActionDialogs") && game.keyboard.isDown("Shift"))
  );
};

/**
 * Define a set of template paths to pre-load
 * Pre-loaded templates are compiled and cached for fast access when rendering
 *
 * @returns {Promise}
 */
const preloadHandlebarsTemplates = async function () {
  // Define template paths to load
  const templatePaths = [
    // Actor Sheet Partials
    "systems/ffd20/templates/actors/parts/actor-summary.hbs",
    "systems/ffd20/templates/actors/parts/actor-traits.hbs",
    "systems/ffd20/templates/actors/parts/actor-inventory.hbs",
    "systems/ffd20/templates/actors/parts/actor-features.hbs",
    "systems/ffd20/templates/actors/parts/actor-spellbook-front.hbs",
    "systems/ffd20/templates/actors/parts/actor-spellbook.hbs",
    "systems/ffd20/templates/actors/parts/actor-skills-front.hbs",
    "systems/ffd20/templates/actors/parts/actor-skills.hbs",
    "systems/ffd20/templates/actors/parts/actor-combat.hbs",
    "systems/ffd20/templates/actors/parts/actor-defenses_tables.hbs",
    "systems/ffd20/templates/actors/parts/actor-buffs.hbs",
    "systems/ffd20/templates/actors/parts/actor-attributes.hbs",
    "systems/ffd20/templates/actors/parts/actor-settings.hbs",
    "systems/ffd20/templates/actors/parts/actor-cmb.hbs",

    "systems/ffd20/templates/internal/item-search.hbs",

    // Item Sheet Partials
    "systems/ffd20/templates/items/parts/item-action.hbs",
    "systems/ffd20/templates/items/parts/item-activation.hbs",
    "systems/ffd20/templates/items/parts/item-description.hbs",
    "systems/ffd20/templates/items/parts/item-changes.hbs",
    "systems/ffd20/templates/items/parts/item-template.hbs",
    "systems/ffd20/templates/items/parts/item-links.hbs",
    "systems/ffd20/templates/items/parts/item-aura.hbs",
    "systems/ffd20/templates/items/parts/item-conditionals.hbs",
    "systems/ffd20/templates/items/parts/item-contents.hbs",
    "systems/ffd20/templates/items/parts/item-tag.hbs",
    "systems/ffd20/templates/items/parts/item-name.hbs",
    "systems/ffd20/templates/items/parts/item-advanced.hbs",
    "systems/ffd20/templates/items/parts/item-size.hbs",

    // Apps
    "systems/ffd20/templates/apps/attack-roll-dialog.hbs",
    "systems/ffd20/templates/apps/vision-permission.hbs",
    "systems/ffd20/templates/apps/help-browser.hbs",

    // Chat
    "systems/ffd20/templates/chat/roll-ext.hbs",
    "systems/ffd20/templates/chat/defenses.hbs",

    // Internal Rendering Partials
    "systems/ffd20/templates/internal/spell-description.hbs",
    "systems/ffd20/templates/internal/consumable-description.hbs",
    "systems/ffd20/templates/internal/damage-tooltip.hbs",
    "systems/ffd20/templates/internal/token-config_vision.hbs",
    "systems/ffd20/templates/internal/compendium-browser_entry.hbs",

    // Tooltip
    "systems/ffd20/templates/hud/tooltip.hbs",
    "systems/ffd20/templates/hud/tooltip_actor.hbs",
  ];

  // Load the template parts
  return loadTemplates(templatePaths);
};

class ListTabs {
  constructor({ navSelector, contentSelector, initial, callback } = {}) {
    this.active = initial;
    this.callback = callback;
    this._navSelector = navSelector;
    this._nav = null;
    this._list = null;
    this._contentSelector = contentSelector;
    this._content = null;
  }

  bind(html) {
    // Identify navigation element
    this._nav = html.querySelector(this._navSelector);
    if (!this._nav) return;
    this._list = this._nav.querySelector("select.tabs");
    if (!this._list) return;

    // Set first active tab
    if (!this._list.querySelector("option.active") && !this.active) {
      const option = this._list.options[0];
      option.classList.toggle("active", true);
      this.active = option.dataset.tab;
    }

    // Identify content container
    if (!this._contentSelector) this._content = null;
    else if (html.matches(this._contentSelector)) this._content = html;
    else this._content = html.querySelector(this._contentSelector);

    // Initialize the active tab
    this.activate(this.active);

    // Register event
    this._list.addEventListener("change", this._onClickNav.bind(this));
  }

  activate(tabName, { triggerCallback = false } = {}) {
    // console.trace(tabName);

    // Validate the requested tab name
    const items = this._nav.querySelectorAll("select.tabs option");
    if (!items.length) return;
    const valid = Array.from(items).some((i) => i.dataset.tab === tabName);
    if (!valid) tabName = items[0].dataset.tab;

    // Change active tab
    for (let a of items) {
      if (a.dataset.tab === tabName) {
        this._list.value = a.value;
      }
    }

    // Change active content
    if (this._content) {
      const tabs = this._content.querySelectorAll(".tab");
      for (let t of tabs) {
        t.classList.toggle("active", t.dataset.tab === tabName);
      }
    }

    // Store the active tab
    this.active = tabName;

    // Optionally trigger the callback function
    if (triggerCallback) this.callback(null, this, tabName);
  }

  _onClickNav(event) {
    event.preventDefault();

    const a = event.currentTarget;
    const option = a.options[a.selectedIndex];
    const tabName = option.dataset.tab;
    if (tabName !== this.active) this.activate(tabName, { triggerCallback: true });
  }
}

class SemanticVersion {
  static re = /^(0|[1-9]\d*)\.(0|[1-9]\d*)\.(0|[1-9]\d*)(?:-((?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+([0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$/

  constructor() {
    this.major = 0;
    this.minor = 0;
    this.patch = 0;
    this.preRelease = "";
    this.buildMetaData = "";
  }

  static fromString(str) {
    if (str.match(this.re)) {
      let result = new this();
      result.major = parseInt(RegExp.$1);
      result.minor = parseInt(RegExp.$2);
      result.patch = parseInt(RegExp.$3);
      result.preRelease = RegExp.$4 || "";
      result.buildMetaData = RegExp.$5 || "";
      return result;
    }
    return null;
  }

  toString() {
    return `${this.major}.${this.minor}.${this.patch}`;
  }

  isHigherThan(otherVersion) {
    if (this.major > otherVersion.major) return true;
    if (this.major === otherVersion.major && this.minor > otherVersion.minor) return true;
    if (this.major === otherVersion.major
      && this.minor === otherVersion.minor
      && this.patch > otherVersion.patch) return true;
    return false;
  }

  isLowerThan(otherVersion) {
    if (this.major < otherVersion.major) return true;
    if (this.major === otherVersion.major && this.minor < otherVersion.minor) return true;
    if (this.major === otherVersion.major
      && this.minor === otherVersion.minor
      && this.patch < otherVersion.patch) return true;
    return false;
  }
}

class ChatMessageFFD20 extends ChatMessage {
  get isRoll() {
    return this.data.type === CONST.CHAT_MESSAGE_TYPES.ROLL || this.getFlag("ffd20", "noRollRender");
  }

  /**
   * Return linked item or falsey
   *
   * @type {ItemFFD20}
   */
  get itemSource() {
    let itemId = this.data.flags?.ffd20?.metadata?.item;
    let actor = this.constructor.getSpeakerActor(this.data.speaker);
    if (!itemId || !actor) return false;
    return actor.items.get(itemId);
  }
}

// Returns a promise to the created chatMessage or false if no command was executed
const customRolls = function (message, speaker, rollData) {
  if (message.match(/^\/(\w+)(?: +([^#]+))(?:#(.+))?/)) {
    const type = RegExp.$1?.toUpperCase();
    const value = RegExp.$2;
    const flavor = RegExp.$3;
    const cMsg = CONFIG.ChatMessage.documentClass;

    speaker = speaker ?? cMsg.getSpeaker();
    const actor = cMsg.getSpeakerActor(speaker);
    const scene = speaker.scene ? game.scenes.get(speaker.scene) : canvas.scene;
    const tokenDocument = scene.tokens.get(speaker.token);
    const tokenUuid = tokenDocument?.uuid;

    switch (type) {
      case "D":
      case "DAMAGE":
      case "H":
      case "HEAL":
        rollData = rollData ?? actor?.getRollData() ?? {};
        var roll = RollFFD20.safeRoll(value, rollData);
        var total = roll.total;

        return (async () => {
          const content = await renderTemplate("systems/ffd20/templates/chat/simple-damage.hbs", {
            tokenId: tokenUuid,
            isHealing: type === "HEAL" || type === "H",
            roll: {
              value: total,
              halfValue: Math.floor(total / 2),
              formula: value,
              json: escape(JSON.stringify(roll.toJSON())),
            },
          });
          const chatOptions = {
            type: CONST.CHAT_MESSAGE_TYPES.ROLL,
            roll: roll,
            flavor,
            speaker: speaker,
            rollMode: game.settings.get("core", "rollMode"),
            content: content,
          };
          cMsg.create(chatOptions);
        })();
    }
  }
  return false;
};

const formulaHasDice = function (formula) {
  return formula.match(/[0-9)][dD]/) || formula.match(/[dD][0-9(]/);
};

class DiceFFD20 {
  /**
   * A standardized helper function for managing game system rolls.
   *
   * Holding SHIFT, ALT, or CTRL when the attack is rolled will "fast-forward".
   * This chooses the default options of a normal attack with no bonus, Advantage, or Disadvantage respectively
   *
   * @param {Event} event           The triggering event which initiated the roll
   * @param {Array} parts           The dice roll component parts, excluding the initial d20
   * @param {string} dice           The initial d20
   * @param {Actor} actor           The Actor making the d20 roll
   * @param {object} data           Actor or item data against which to parse the roll
   * @param {string} template       The HTML template used to render the roll dialog
   * @param {string} title          The dice roll UI window title
   * @param {object} speaker        The ChatMessage speaker to pass when creating the chat
   * @param {Function} flavor       A callable function for determining the chat message flavor given parts and data
   * @param {boolean} takeTwenty    Allow rolling with take twenty (and therefore also with take ten)
   * @param {boolean} situational   Allow for an arbitrary situational bonus field
   * @param {boolean} fastForward   Allow fast-forward advantage selection
   * @param {number} critical       The value of d20 result which represents a critical success
   * @param {number} fumble         The value of d20 result which represents a critical failure
   * @param {Function} onClose      Callback for actions to take when the dialog form is closed
   * @param {Object} dialogOptions  Modal dialog options
   * @param {Array} extraRolls      An array containing bonuses/penalties for extra rolls
   * @param {boolean} autoRender    Whether to automatically render the chat messages
   */
  static async d20Roll({
    event,
    parts,
    dice = "1d20",
    data,
    subject,
    template,
    title,
    speaker,
    flavor,
    takeTwenty = true,
    situational = true,
    fastForward = true,
    critical = 20,
    fumble = 1,
    onClose,
    dialogOptions = {},
    extraRolls = [],
    chatTemplate,
    chatTemplateData,
    staticRoll = null,
    chatMessage = true,
    noSound = false,
    compendiumEntry = null,
  }) {
    // Handle input arguments
    flavor = flavor || title;
    let rollMode = game.settings.get("core", "rollMode");
    let rolled = false;

    // Inner roll function
    let _roll = async (parts, setRoll, form) => {
      const originalFlavor = flavor;
      rollMode = form ? form.find('[name="rollMode"]').val() : rollMode;
      for (let a = 0; a < 1 + extraRolls.length; a++) {
        flavor = originalFlavor;
        let curParts = duplicate(parts);
        // Don't include situational bonus unless it is defined
        data.bonus = form ? form.find('[name="bonus"]').val() : 0;
        if (!data.bonus && curParts.indexOf("@bonus") !== -1) curParts.pop();

        // Extra roll specifics
        if (a >= 1) {
          let extraRoll = extraRolls[a - 1];
          curParts.push(extraRoll.bonus);
          flavor += ` <div class="extra-roll-label">${extraRoll.label}</div>`;
        }

        // Do set roll
        if (setRoll != null && setRoll >= 0) {
          curParts[0] = `${setRoll}`;
          flavor += ` (Take ${setRoll})`;
        }

        // Execute the roll
        let roll = await Roll.create(curParts.join(" + "), data).evaluate({ async: true });

        // Convert the roll to a chat message
        if (chatTemplate) {
          // Create roll template data
          const d20 = roll.terms[0];
          const rollData = mergeObject(
            {
              user: game.user.id,
              formula: roll.formula,
              tooltip: await roll.getTooltip(),
              total: roll.total,
              isCrit: d20.total >= critical,
              isFumble: d20.total <= fumble,
              flavor: flavor,
              compendiumEntry: compendiumEntry,
            },
            chatTemplateData || {}
          );

          // Create chat data
          let chatData = {
            user: game.user.id,
            type: CONST.CHAT_MESSAGE_TYPES.ROLL,
            sound: noSound ? null : a === 0 ? CONFIG.sounds.dice : null,
            speaker: speaker,
            content: await renderTemplate(chatTemplate, rollData),
            rollMode: rollMode,
            roll: roll.toJSON(),
            "flags.ffd20.noRollRender": true,
          };
          if (subject) setProperty(chatData, "flags.ffd20.subject", subject);

          // Send message
          rolled = true;

          if (chatMessage) return await ChatMessageFFD20.create(chatData);
        } else {
          rolled = true;
          if (chatMessage) {
            let msgData = {
              speaker: speaker,
              flavor: flavor,
              rollMode: rollMode,
              sound: a === 0 ? CONFIG.sounds.dice : null,
            };
            if (subject) setProperty(msgData, "flags.ffd20.subject", subject);

            await roll.toMessage(msgData);
          }
        }
        return roll;
      }
    };

    // Modify the roll and handle fast-forwarding
    parts = [dice].concat(parts);
    if (fastForward === true) return _roll(parts, staticRoll);
    else parts = parts.concat(["@bonus"]);

    // Render modal dialog
    template = template || "systems/ffd20/templates/chat/roll-dialog.hbs";
    let dialogData = {
      formula: parts.join(" + "),
      data: data,
      rollMode: rollMode,
      rollModes: CONFIG.Dice.rollModes,
    };
    const html = await renderTemplate(template, dialogData);

    let roll;
    return new Promise((resolve) => {
      if (!(dialogOptions.classes instanceof Array)) dialogOptions.classes = [];
      dialogOptions.classes.push("dialog", "ffd20", "die-roll");

      new Dialog(
        {
          title: title,
          content: html,
          buttons: {
            normal: {
              label: game.i18n.localize("FFD20.Normal"),
              callback: (html) => resolve((roll = _roll(parts, staticRoll != null ? staticRoll : -1, html))),
            },
            takeTen: {
              label: game.i18n.localize("FFD20.Take10"),
              condition: takeTwenty,
              callback: (html) => resolve((roll = _roll(parts, 10, html))),
            },
            takeTwenty: {
              label: game.i18n.localize("FFD20.Take20"),
              condition: takeTwenty,
              callback: (html) => resolve((roll = _roll(parts, 20, html))),
            },
          },
          default: "normal",
          close: (html) => {
            if (onClose) onClose(html, parts, data);
            resolve(rolled ? roll : false);
          },
        },
        dialogOptions
      ).render(true);
    });
  }

  /* -------------------------------------------- */

  /**
   * A standardized helper function for managing damage rolls.
   *
   * Holding SHIFT, ALT, or CTRL when the attack is rolled will "fast-forward".
   * This chooses the default options of a normal attack with no bonus, Critical, or no bonus respectively
   *
   * @param {Event} event           The triggering event which initiated the roll
   * @param {Array} parts           The dice roll component parts, excluding the initial d20
   * @param {Actor} actor           The Actor making the damage roll
   * @param {object} data           Actor or item data against which to parse the roll
   * @param {string} template       The HTML template used to render the roll dialog
   * @param {string} title          The dice roll UI window title
   * @param {object} speaker        The ChatMessage speaker to pass when creating the chat
   * @param {Function} flavor       A callable function for determining the chat message flavor given parts and data
   * @param {boolean} critical      Allow critical hits to be chosen
   * @param {Function} onClose      Callback for actions to take when the dialog form is closed
   * @param {object} dialogOptions  Modal dialog options
   */
  static async damageRoll({
    event = {},
    parts,
    actor,
    data,
    template,
    title,
    speaker,
    flavor,
    critical = true,
    onClose,
    dialogOptions = {},
    chatTemplate,
    chatTemplateData,
    chatMessage = true,
    noSound = false,
  }) {
    flavor = flavor || title;
    let rollMode = game.settings.get("core", "rollMode");
    let rolled = false;

    // Inner roll function
    const _roll = async (crit, form) => {
      // Don't include situational bonus unless it is defined
      data.bonus = form ? form.find('[name="bonus"]').val() : 0;

      // Detemrine critical multiplier
      data["critMult"] = crit ? data.item.ability.critMult : 1;
      // Determine damage ability
      data["ablMult"] = 0;
      if (data.item.ability.damageMult != null) {
        data["ablMult"] = data.item.ability.damageMult;
      }

      let roll = Roll.create(parts.join("+"), data);
      if (crit === true) {
        let mult = data.item.ability.critMult || 2;

        // Update first damage part
        roll.alter(0, mult);
        flavor = `${flavor} (Critical)`;
      }

      await roll.evaluate({ async: true });

      // Convert the roll to a chat message
      if (chatTemplate) {
        // Create roll template data
        const rollData = mergeObject(
          {
            user: game.user._id,
            formula: roll.formula,
            tooltip: await roll.getTooltip(),
            total: roll.total,
          },
          chatTemplateData || {}
        );

        // Create chat data
        let chatData = {
          user: game.user._id,
          type: CONST.CHAT_MESSAGE_TYPES.ROLL,
          sound: noSound ? null : CONFIG.sounds.dice,
          speaker: speaker,
          flavor: flavor,
          rollMode: rollMode,
          roll: roll,
          content: await renderTemplate(chatTemplate, rollData),
          useCustomContent: true,
        };
        setProperty(chatData, "flags.ffd20.subject.core", "damage");

        // Handle different roll modes
        switch (chatData.rollMode) {
          case "gmroll":
            chatData["whisper"] = game.users.contents.filter((u) => u.isGM).map((u) => u._id);
            break;
          case "selfroll":
            chatData["whisper"] = [game.user._id];
            break;
          case "blindroll":
            chatData["whisper"] = game.users.contents.filter((u) => u.isGM).map((u) => u._id);
            chatData["blind"] = true;
        }

        // Send message
        rolled = true;
        if (chatMessage) ChatMessageFFD20.create(chatData);
      } else {
        rolled = true;
        if (chatMessage) {
          roll.toMessage({
            speaker: speaker,
            flavor: flavor,
            rollMode: rollMode,
          });
        }
      }

      // Return the Roll object
      return roll;
    };

    // Modify the roll and handle fast-forwarding
    if (!event.shiftKey) return _roll(event.ctrlKey);
    else parts = parts.concat(["@bonus"]);

    // Construct dialog data
    template = template || "systems/ffd20/templates/chat/roll-dialog.hbs";
    let dialogData = {
      formula: parts.join(" + "),
      data: data,
      rollMode: rollMode,
      rollModes: CONFIG.Dice.rollModes,
    };
    const html = await renderTemplate(template, dialogData);

    // Render modal dialog
    let roll;
    return new Promise((resolve) => {
      if (!(dialogOptions.classes instanceof Array)) dialogOptions.classes = [];
      dialogOptions.classes.push("dialog", "ffd20", "damage-roll");

      new Dialog(
        {
          title: title,
          content: html,
          buttons: {
            normal: {
              label: critical ? "Normal" : "Roll",
              callback: (html) => (roll = _roll(false, html)),
            },
            critical: {
              condition: critical,
              label: "Critical Hit",
              callback: (html) => (roll = _roll(true, html)),
            },
          },
          default: "normal",
          close: (html) => {
            if (onClose) onClose(html, parts, data);
            resolve(rolled ? roll : false);
          },
        },
        dialogOptions
      ).render(true);
    });
  }

  static messageRoll({ data, msgStr }) {
    let re = /\[\[(.+)\]\]/g;
    return msgStr.replace(re, (_, p1) => {
      const roll = RollFFD20.safeRoll(p1, data);
      return roll.total.toString();
    });
  }
}

function getAugmentedNamespace(n) {
	if (n.__esModule) return n;
	var a = Object.defineProperty({}, '__esModule', {value: true});
	Object.keys(n).forEach(function (k) {
		var d = Object.getOwnPropertyDescriptor(n, k);
		Object.defineProperty(a, k, d.get ? d : {
			enumerable: true,
			get: function () {
				return n[k];
			}
		});
	});
	return a;
}

function createCommonjsModule(fn) {
  var module = { exports: {} };
	return fn(module, module.exports), module.exports;
}

var colorName = {
	"aliceblue": [240, 248, 255],
	"antiquewhite": [250, 235, 215],
	"aqua": [0, 255, 255],
	"aquamarine": [127, 255, 212],
	"azure": [240, 255, 255],
	"beige": [245, 245, 220],
	"bisque": [255, 228, 196],
	"black": [0, 0, 0],
	"blanchedalmond": [255, 235, 205],
	"blue": [0, 0, 255],
	"blueviolet": [138, 43, 226],
	"brown": [165, 42, 42],
	"burlywood": [222, 184, 135],
	"cadetblue": [95, 158, 160],
	"chartreuse": [127, 255, 0],
	"chocolate": [210, 105, 30],
	"coral": [255, 127, 80],
	"cornflowerblue": [100, 149, 237],
	"cornsilk": [255, 248, 220],
	"crimson": [220, 20, 60],
	"cyan": [0, 255, 255],
	"darkblue": [0, 0, 139],
	"darkcyan": [0, 139, 139],
	"darkgoldenrod": [184, 134, 11],
	"darkgray": [169, 169, 169],
	"darkgreen": [0, 100, 0],
	"darkgrey": [169, 169, 169],
	"darkkhaki": [189, 183, 107],
	"darkmagenta": [139, 0, 139],
	"darkolivegreen": [85, 107, 47],
	"darkorange": [255, 140, 0],
	"darkorchid": [153, 50, 204],
	"darkred": [139, 0, 0],
	"darksalmon": [233, 150, 122],
	"darkseagreen": [143, 188, 143],
	"darkslateblue": [72, 61, 139],
	"darkslategray": [47, 79, 79],
	"darkslategrey": [47, 79, 79],
	"darkturquoise": [0, 206, 209],
	"darkviolet": [148, 0, 211],
	"deeppink": [255, 20, 147],
	"deepskyblue": [0, 191, 255],
	"dimgray": [105, 105, 105],
	"dimgrey": [105, 105, 105],
	"dodgerblue": [30, 144, 255],
	"firebrick": [178, 34, 34],
	"floralwhite": [255, 250, 240],
	"forestgreen": [34, 139, 34],
	"fuchsia": [255, 0, 255],
	"gainsboro": [220, 220, 220],
	"ghostwhite": [248, 248, 255],
	"gold": [255, 215, 0],
	"goldenrod": [218, 165, 32],
	"gray": [128, 128, 128],
	"green": [0, 128, 0],
	"greenyellow": [173, 255, 47],
	"grey": [128, 128, 128],
	"honeydew": [240, 255, 240],
	"hotpink": [255, 105, 180],
	"indianred": [205, 92, 92],
	"indigo": [75, 0, 130],
	"ivory": [255, 255, 240],
	"khaki": [240, 230, 140],
	"lavender": [230, 230, 250],
	"lavenderblush": [255, 240, 245],
	"lawngreen": [124, 252, 0],
	"lemonchiffon": [255, 250, 205],
	"lightblue": [173, 216, 230],
	"lightcoral": [240, 128, 128],
	"lightcyan": [224, 255, 255],
	"lightgoldenrodyellow": [250, 250, 210],
	"lightgray": [211, 211, 211],
	"lightgreen": [144, 238, 144],
	"lightgrey": [211, 211, 211],
	"lightpink": [255, 182, 193],
	"lightsalmon": [255, 160, 122],
	"lightseagreen": [32, 178, 170],
	"lightskyblue": [135, 206, 250],
	"lightslategray": [119, 136, 153],
	"lightslategrey": [119, 136, 153],
	"lightsteelblue": [176, 196, 222],
	"lightyellow": [255, 255, 224],
	"lime": [0, 255, 0],
	"limegreen": [50, 205, 50],
	"linen": [250, 240, 230],
	"magenta": [255, 0, 255],
	"maroon": [128, 0, 0],
	"mediumaquamarine": [102, 205, 170],
	"mediumblue": [0, 0, 205],
	"mediumorchid": [186, 85, 211],
	"mediumpurple": [147, 112, 219],
	"mediumseagreen": [60, 179, 113],
	"mediumslateblue": [123, 104, 238],
	"mediumspringgreen": [0, 250, 154],
	"mediumturquoise": [72, 209, 204],
	"mediumvioletred": [199, 21, 133],
	"midnightblue": [25, 25, 112],
	"mintcream": [245, 255, 250],
	"mistyrose": [255, 228, 225],
	"moccasin": [255, 228, 181],
	"navajowhite": [255, 222, 173],
	"navy": [0, 0, 128],
	"oldlace": [253, 245, 230],
	"olive": [128, 128, 0],
	"olivedrab": [107, 142, 35],
	"orange": [255, 165, 0],
	"orangered": [255, 69, 0],
	"orchid": [218, 112, 214],
	"palegoldenrod": [238, 232, 170],
	"palegreen": [152, 251, 152],
	"paleturquoise": [175, 238, 238],
	"palevioletred": [219, 112, 147],
	"papayawhip": [255, 239, 213],
	"peachpuff": [255, 218, 185],
	"peru": [205, 133, 63],
	"pink": [255, 192, 203],
	"plum": [221, 160, 221],
	"powderblue": [176, 224, 230],
	"purple": [128, 0, 128],
	"rebeccapurple": [102, 51, 153],
	"red": [255, 0, 0],
	"rosybrown": [188, 143, 143],
	"royalblue": [65, 105, 225],
	"saddlebrown": [139, 69, 19],
	"salmon": [250, 128, 114],
	"sandybrown": [244, 164, 96],
	"seagreen": [46, 139, 87],
	"seashell": [255, 245, 238],
	"sienna": [160, 82, 45],
	"silver": [192, 192, 192],
	"skyblue": [135, 206, 235],
	"slateblue": [106, 90, 205],
	"slategray": [112, 128, 144],
	"slategrey": [112, 128, 144],
	"snow": [255, 250, 250],
	"springgreen": [0, 255, 127],
	"steelblue": [70, 130, 180],
	"tan": [210, 180, 140],
	"teal": [0, 128, 128],
	"thistle": [216, 191, 216],
	"tomato": [255, 99, 71],
	"turquoise": [64, 224, 208],
	"violet": [238, 130, 238],
	"wheat": [245, 222, 179],
	"white": [255, 255, 255],
	"whitesmoke": [245, 245, 245],
	"yellow": [255, 255, 0],
	"yellowgreen": [154, 205, 50]
};

var isArrayish = function isArrayish(obj) {
	if (!obj || typeof obj === 'string') {
		return false;
	}

	return obj instanceof Array || Array.isArray(obj) ||
		(obj.length >= 0 && (obj.splice instanceof Function ||
			(Object.getOwnPropertyDescriptor(obj, (obj.length - 1)) && obj.constructor.name !== 'String')));
};

var simpleSwizzle = createCommonjsModule(function (module) {



var concat = Array.prototype.concat;
var slice = Array.prototype.slice;

var swizzle = module.exports = function swizzle(args) {
	var results = [];

	for (var i = 0, len = args.length; i < len; i++) {
		var arg = args[i];

		if (isArrayish(arg)) {
			// http://jsperf.com/javascript-array-concat-vs-push/98
			results = concat.call(results, slice.call(arg));
		} else {
			results.push(arg);
		}
	}

	return results;
};

swizzle.wrap = function (fn) {
	return function () {
		return fn(swizzle(arguments));
	};
};
});

/* MIT license */

var colorString = createCommonjsModule(function (module) {
var reverseNames = {};

// create a list of reverse color names
for (var name in colorName) {
	if (colorName.hasOwnProperty(name)) {
		reverseNames[colorName[name]] = name;
	}
}

var cs = module.exports = {
	to: {},
	get: {}
};

cs.get = function (string) {
	var prefix = string.substring(0, 3).toLowerCase();
	var val;
	var model;
	switch (prefix) {
		case 'hsl':
			val = cs.get.hsl(string);
			model = 'hsl';
			break;
		case 'hwb':
			val = cs.get.hwb(string);
			model = 'hwb';
			break;
		default:
			val = cs.get.rgb(string);
			model = 'rgb';
			break;
	}

	if (!val) {
		return null;
	}

	return {model: model, value: val};
};

cs.get.rgb = function (string) {
	if (!string) {
		return null;
	}

	var abbr = /^#([a-f0-9]{3,4})$/i;
	var hex = /^#([a-f0-9]{6})([a-f0-9]{2})?$/i;
	var rgba = /^rgba?\(\s*([+-]?\d+)\s*,\s*([+-]?\d+)\s*,\s*([+-]?\d+)\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)$/;
	var per = /^rgba?\(\s*([+-]?[\d\.]+)\%\s*,\s*([+-]?[\d\.]+)\%\s*,\s*([+-]?[\d\.]+)\%\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)$/;
	var keyword = /(\D+)/;

	var rgb = [0, 0, 0, 1];
	var match;
	var i;
	var hexAlpha;

	if (match = string.match(hex)) {
		hexAlpha = match[2];
		match = match[1];

		for (i = 0; i < 3; i++) {
			// https://jsperf.com/slice-vs-substr-vs-substring-methods-long-string/19
			var i2 = i * 2;
			rgb[i] = parseInt(match.slice(i2, i2 + 2), 16);
		}

		if (hexAlpha) {
			rgb[3] = parseInt(hexAlpha, 16) / 255;
		}
	} else if (match = string.match(abbr)) {
		match = match[1];
		hexAlpha = match[3];

		for (i = 0; i < 3; i++) {
			rgb[i] = parseInt(match[i] + match[i], 16);
		}

		if (hexAlpha) {
			rgb[3] = parseInt(hexAlpha + hexAlpha, 16) / 255;
		}
	} else if (match = string.match(rgba)) {
		for (i = 0; i < 3; i++) {
			rgb[i] = parseInt(match[i + 1], 0);
		}

		if (match[4]) {
			rgb[3] = parseFloat(match[4]);
		}
	} else if (match = string.match(per)) {
		for (i = 0; i < 3; i++) {
			rgb[i] = Math.round(parseFloat(match[i + 1]) * 2.55);
		}

		if (match[4]) {
			rgb[3] = parseFloat(match[4]);
		}
	} else if (match = string.match(keyword)) {
		if (match[1] === 'transparent') {
			return [0, 0, 0, 0];
		}

		rgb = colorName[match[1]];

		if (!rgb) {
			return null;
		}

		rgb[3] = 1;

		return rgb;
	} else {
		return null;
	}

	for (i = 0; i < 3; i++) {
		rgb[i] = clamp(rgb[i], 0, 255);
	}
	rgb[3] = clamp(rgb[3], 0, 1);

	return rgb;
};

cs.get.hsl = function (string) {
	if (!string) {
		return null;
	}

	var hsl = /^hsla?\(\s*([+-]?(?:\d{0,3}\.)?\d+)(?:deg)?\s*,\s*([+-]?[\d\.]+)%\s*,\s*([+-]?[\d\.]+)%\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)$/;
	var match = string.match(hsl);

	if (match) {
		var alpha = parseFloat(match[4]);
		var h = (parseFloat(match[1]) + 360) % 360;
		var s = clamp(parseFloat(match[2]), 0, 100);
		var l = clamp(parseFloat(match[3]), 0, 100);
		var a = clamp(isNaN(alpha) ? 1 : alpha, 0, 1);

		return [h, s, l, a];
	}

	return null;
};

cs.get.hwb = function (string) {
	if (!string) {
		return null;
	}

	var hwb = /^hwb\(\s*([+-]?\d{0,3}(?:\.\d+)?)(?:deg)?\s*,\s*([+-]?[\d\.]+)%\s*,\s*([+-]?[\d\.]+)%\s*(?:,\s*([+-]?[\d\.]+)\s*)?\)$/;
	var match = string.match(hwb);

	if (match) {
		var alpha = parseFloat(match[4]);
		var h = ((parseFloat(match[1]) % 360) + 360) % 360;
		var w = clamp(parseFloat(match[2]), 0, 100);
		var b = clamp(parseFloat(match[3]), 0, 100);
		var a = clamp(isNaN(alpha) ? 1 : alpha, 0, 1);
		return [h, w, b, a];
	}

	return null;
};

cs.to.hex = function () {
	var rgba = simpleSwizzle(arguments);

	return (
		'#' +
		hexDouble(rgba[0]) +
		hexDouble(rgba[1]) +
		hexDouble(rgba[2]) +
		(rgba[3] < 1
			? (hexDouble(Math.round(rgba[3] * 255)))
			: '')
	);
};

cs.to.rgb = function () {
	var rgba = simpleSwizzle(arguments);

	return rgba.length < 4 || rgba[3] === 1
		? 'rgb(' + Math.round(rgba[0]) + ', ' + Math.round(rgba[1]) + ', ' + Math.round(rgba[2]) + ')'
		: 'rgba(' + Math.round(rgba[0]) + ', ' + Math.round(rgba[1]) + ', ' + Math.round(rgba[2]) + ', ' + rgba[3] + ')';
};

cs.to.rgb.percent = function () {
	var rgba = simpleSwizzle(arguments);

	var r = Math.round(rgba[0] / 255 * 100);
	var g = Math.round(rgba[1] / 255 * 100);
	var b = Math.round(rgba[2] / 255 * 100);

	return rgba.length < 4 || rgba[3] === 1
		? 'rgb(' + r + '%, ' + g + '%, ' + b + '%)'
		: 'rgba(' + r + '%, ' + g + '%, ' + b + '%, ' + rgba[3] + ')';
};

cs.to.hsl = function () {
	var hsla = simpleSwizzle(arguments);
	return hsla.length < 4 || hsla[3] === 1
		? 'hsl(' + hsla[0] + ', ' + hsla[1] + '%, ' + hsla[2] + '%)'
		: 'hsla(' + hsla[0] + ', ' + hsla[1] + '%, ' + hsla[2] + '%, ' + hsla[3] + ')';
};

// hwb is a bit different than rgb(a) & hsl(a) since there is no alpha specific syntax
// (hwb have alpha optional & 1 is default value)
cs.to.hwb = function () {
	var hwba = simpleSwizzle(arguments);

	var a = '';
	if (hwba.length >= 4 && hwba[3] !== 1) {
		a = ', ' + hwba[3];
	}

	return 'hwb(' + hwba[0] + ', ' + hwba[1] + '%, ' + hwba[2] + '%' + a + ')';
};

cs.to.keyword = function (rgb) {
	return reverseNames[rgb.slice(0, 3)];
};

// helpers
function clamp(num, min, max) {
	return Math.min(Math.max(min, num), max);
}

function hexDouble(num) {
	var str = num.toString(16).toUpperCase();
	return (str.length < 2) ? '0' + str : str;
}
});

/* MIT license */

var conversions = createCommonjsModule(function (module) {
// NOTE: conversions should only return primitive values (i.e. arrays, or
//       values that give correct `typeof` results).
//       do not use box values types (i.e. Number(), String(), etc.)

var reverseKeywords = {};
for (var key in colorName) {
	if (colorName.hasOwnProperty(key)) {
		reverseKeywords[colorName[key]] = key;
	}
}

var convert = module.exports = {
	rgb: {channels: 3, labels: 'rgb'},
	hsl: {channels: 3, labels: 'hsl'},
	hsv: {channels: 3, labels: 'hsv'},
	hwb: {channels: 3, labels: 'hwb'},
	cmyk: {channels: 4, labels: 'cmyk'},
	xyz: {channels: 3, labels: 'xyz'},
	lab: {channels: 3, labels: 'lab'},
	lch: {channels: 3, labels: 'lch'},
	hex: {channels: 1, labels: ['hex']},
	keyword: {channels: 1, labels: ['keyword']},
	ansi16: {channels: 1, labels: ['ansi16']},
	ansi256: {channels: 1, labels: ['ansi256']},
	hcg: {channels: 3, labels: ['h', 'c', 'g']},
	apple: {channels: 3, labels: ['r16', 'g16', 'b16']},
	gray: {channels: 1, labels: ['gray']}
};

// hide .channels and .labels properties
for (var model in convert) {
	if (convert.hasOwnProperty(model)) {
		if (!('channels' in convert[model])) {
			throw new Error('missing channels property: ' + model);
		}

		if (!('labels' in convert[model])) {
			throw new Error('missing channel labels property: ' + model);
		}

		if (convert[model].labels.length !== convert[model].channels) {
			throw new Error('channel and label counts mismatch: ' + model);
		}

		var channels = convert[model].channels;
		var labels = convert[model].labels;
		delete convert[model].channels;
		delete convert[model].labels;
		Object.defineProperty(convert[model], 'channels', {value: channels});
		Object.defineProperty(convert[model], 'labels', {value: labels});
	}
}

convert.rgb.hsl = function (rgb) {
	var r = rgb[0] / 255;
	var g = rgb[1] / 255;
	var b = rgb[2] / 255;
	var min = Math.min(r, g, b);
	var max = Math.max(r, g, b);
	var delta = max - min;
	var h;
	var s;
	var l;

	if (max === min) {
		h = 0;
	} else if (r === max) {
		h = (g - b) / delta;
	} else if (g === max) {
		h = 2 + (b - r) / delta;
	} else if (b === max) {
		h = 4 + (r - g) / delta;
	}

	h = Math.min(h * 60, 360);

	if (h < 0) {
		h += 360;
	}

	l = (min + max) / 2;

	if (max === min) {
		s = 0;
	} else if (l <= 0.5) {
		s = delta / (max + min);
	} else {
		s = delta / (2 - max - min);
	}

	return [h, s * 100, l * 100];
};

convert.rgb.hsv = function (rgb) {
	var rdif;
	var gdif;
	var bdif;
	var h;
	var s;

	var r = rgb[0] / 255;
	var g = rgb[1] / 255;
	var b = rgb[2] / 255;
	var v = Math.max(r, g, b);
	var diff = v - Math.min(r, g, b);
	var diffc = function (c) {
		return (v - c) / 6 / diff + 1 / 2;
	};

	if (diff === 0) {
		h = s = 0;
	} else {
		s = diff / v;
		rdif = diffc(r);
		gdif = diffc(g);
		bdif = diffc(b);

		if (r === v) {
			h = bdif - gdif;
		} else if (g === v) {
			h = (1 / 3) + rdif - bdif;
		} else if (b === v) {
			h = (2 / 3) + gdif - rdif;
		}
		if (h < 0) {
			h += 1;
		} else if (h > 1) {
			h -= 1;
		}
	}

	return [
		h * 360,
		s * 100,
		v * 100
	];
};

convert.rgb.hwb = function (rgb) {
	var r = rgb[0];
	var g = rgb[1];
	var b = rgb[2];
	var h = convert.rgb.hsl(rgb)[0];
	var w = 1 / 255 * Math.min(r, Math.min(g, b));

	b = 1 - 1 / 255 * Math.max(r, Math.max(g, b));

	return [h, w * 100, b * 100];
};

convert.rgb.cmyk = function (rgb) {
	var r = rgb[0] / 255;
	var g = rgb[1] / 255;
	var b = rgb[2] / 255;
	var c;
	var m;
	var y;
	var k;

	k = Math.min(1 - r, 1 - g, 1 - b);
	c = (1 - r - k) / (1 - k) || 0;
	m = (1 - g - k) / (1 - k) || 0;
	y = (1 - b - k) / (1 - k) || 0;

	return [c * 100, m * 100, y * 100, k * 100];
};

/**
 * See https://en.m.wikipedia.org/wiki/Euclidean_distance#Squared_Euclidean_distance
 * */
function comparativeDistance(x, y) {
	return (
		Math.pow(x[0] - y[0], 2) +
		Math.pow(x[1] - y[1], 2) +
		Math.pow(x[2] - y[2], 2)
	);
}

convert.rgb.keyword = function (rgb) {
	var reversed = reverseKeywords[rgb];
	if (reversed) {
		return reversed;
	}

	var currentClosestDistance = Infinity;
	var currentClosestKeyword;

	for (var keyword in colorName) {
		if (colorName.hasOwnProperty(keyword)) {
			var value = colorName[keyword];

			// Compute comparative distance
			var distance = comparativeDistance(rgb, value);

			// Check if its less, if so set as closest
			if (distance < currentClosestDistance) {
				currentClosestDistance = distance;
				currentClosestKeyword = keyword;
			}
		}
	}

	return currentClosestKeyword;
};

convert.keyword.rgb = function (keyword) {
	return colorName[keyword];
};

convert.rgb.xyz = function (rgb) {
	var r = rgb[0] / 255;
	var g = rgb[1] / 255;
	var b = rgb[2] / 255;

	// assume sRGB
	r = r > 0.04045 ? Math.pow(((r + 0.055) / 1.055), 2.4) : (r / 12.92);
	g = g > 0.04045 ? Math.pow(((g + 0.055) / 1.055), 2.4) : (g / 12.92);
	b = b > 0.04045 ? Math.pow(((b + 0.055) / 1.055), 2.4) : (b / 12.92);

	var x = (r * 0.4124) + (g * 0.3576) + (b * 0.1805);
	var y = (r * 0.2126) + (g * 0.7152) + (b * 0.0722);
	var z = (r * 0.0193) + (g * 0.1192) + (b * 0.9505);

	return [x * 100, y * 100, z * 100];
};

convert.rgb.lab = function (rgb) {
	var xyz = convert.rgb.xyz(rgb);
	var x = xyz[0];
	var y = xyz[1];
	var z = xyz[2];
	var l;
	var a;
	var b;

	x /= 95.047;
	y /= 100;
	z /= 108.883;

	x = x > 0.008856 ? Math.pow(x, 1 / 3) : (7.787 * x) + (16 / 116);
	y = y > 0.008856 ? Math.pow(y, 1 / 3) : (7.787 * y) + (16 / 116);
	z = z > 0.008856 ? Math.pow(z, 1 / 3) : (7.787 * z) + (16 / 116);

	l = (116 * y) - 16;
	a = 500 * (x - y);
	b = 200 * (y - z);

	return [l, a, b];
};

convert.hsl.rgb = function (hsl) {
	var h = hsl[0] / 360;
	var s = hsl[1] / 100;
	var l = hsl[2] / 100;
	var t1;
	var t2;
	var t3;
	var rgb;
	var val;

	if (s === 0) {
		val = l * 255;
		return [val, val, val];
	}

	if (l < 0.5) {
		t2 = l * (1 + s);
	} else {
		t2 = l + s - l * s;
	}

	t1 = 2 * l - t2;

	rgb = [0, 0, 0];
	for (var i = 0; i < 3; i++) {
		t3 = h + 1 / 3 * -(i - 1);
		if (t3 < 0) {
			t3++;
		}
		if (t3 > 1) {
			t3--;
		}

		if (6 * t3 < 1) {
			val = t1 + (t2 - t1) * 6 * t3;
		} else if (2 * t3 < 1) {
			val = t2;
		} else if (3 * t3 < 2) {
			val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;
		} else {
			val = t1;
		}

		rgb[i] = val * 255;
	}

	return rgb;
};

convert.hsl.hsv = function (hsl) {
	var h = hsl[0];
	var s = hsl[1] / 100;
	var l = hsl[2] / 100;
	var smin = s;
	var lmin = Math.max(l, 0.01);
	var sv;
	var v;

	l *= 2;
	s *= (l <= 1) ? l : 2 - l;
	smin *= lmin <= 1 ? lmin : 2 - lmin;
	v = (l + s) / 2;
	sv = l === 0 ? (2 * smin) / (lmin + smin) : (2 * s) / (l + s);

	return [h, sv * 100, v * 100];
};

convert.hsv.rgb = function (hsv) {
	var h = hsv[0] / 60;
	var s = hsv[1] / 100;
	var v = hsv[2] / 100;
	var hi = Math.floor(h) % 6;

	var f = h - Math.floor(h);
	var p = 255 * v * (1 - s);
	var q = 255 * v * (1 - (s * f));
	var t = 255 * v * (1 - (s * (1 - f)));
	v *= 255;

	switch (hi) {
		case 0:
			return [v, t, p];
		case 1:
			return [q, v, p];
		case 2:
			return [p, v, t];
		case 3:
			return [p, q, v];
		case 4:
			return [t, p, v];
		case 5:
			return [v, p, q];
	}
};

convert.hsv.hsl = function (hsv) {
	var h = hsv[0];
	var s = hsv[1] / 100;
	var v = hsv[2] / 100;
	var vmin = Math.max(v, 0.01);
	var lmin;
	var sl;
	var l;

	l = (2 - s) * v;
	lmin = (2 - s) * vmin;
	sl = s * vmin;
	sl /= (lmin <= 1) ? lmin : 2 - lmin;
	sl = sl || 0;
	l /= 2;

	return [h, sl * 100, l * 100];
};

// http://dev.w3.org/csswg/css-color/#hwb-to-rgb
convert.hwb.rgb = function (hwb) {
	var h = hwb[0] / 360;
	var wh = hwb[1] / 100;
	var bl = hwb[2] / 100;
	var ratio = wh + bl;
	var i;
	var v;
	var f;
	var n;

	// wh + bl cant be > 1
	if (ratio > 1) {
		wh /= ratio;
		bl /= ratio;
	}

	i = Math.floor(6 * h);
	v = 1 - bl;
	f = 6 * h - i;

	if ((i & 0x01) !== 0) {
		f = 1 - f;
	}

	n = wh + f * (v - wh); // linear interpolation

	var r;
	var g;
	var b;
	switch (i) {
		default:
		case 6:
		case 0: r = v; g = n; b = wh; break;
		case 1: r = n; g = v; b = wh; break;
		case 2: r = wh; g = v; b = n; break;
		case 3: r = wh; g = n; b = v; break;
		case 4: r = n; g = wh; b = v; break;
		case 5: r = v; g = wh; b = n; break;
	}

	return [r * 255, g * 255, b * 255];
};

convert.cmyk.rgb = function (cmyk) {
	var c = cmyk[0] / 100;
	var m = cmyk[1] / 100;
	var y = cmyk[2] / 100;
	var k = cmyk[3] / 100;
	var r;
	var g;
	var b;

	r = 1 - Math.min(1, c * (1 - k) + k);
	g = 1 - Math.min(1, m * (1 - k) + k);
	b = 1 - Math.min(1, y * (1 - k) + k);

	return [r * 255, g * 255, b * 255];
};

convert.xyz.rgb = function (xyz) {
	var x = xyz[0] / 100;
	var y = xyz[1] / 100;
	var z = xyz[2] / 100;
	var r;
	var g;
	var b;

	r = (x * 3.2406) + (y * -1.5372) + (z * -0.4986);
	g = (x * -0.9689) + (y * 1.8758) + (z * 0.0415);
	b = (x * 0.0557) + (y * -0.2040) + (z * 1.0570);

	// assume sRGB
	r = r > 0.0031308
		? ((1.055 * Math.pow(r, 1.0 / 2.4)) - 0.055)
		: r * 12.92;

	g = g > 0.0031308
		? ((1.055 * Math.pow(g, 1.0 / 2.4)) - 0.055)
		: g * 12.92;

	b = b > 0.0031308
		? ((1.055 * Math.pow(b, 1.0 / 2.4)) - 0.055)
		: b * 12.92;

	r = Math.min(Math.max(0, r), 1);
	g = Math.min(Math.max(0, g), 1);
	b = Math.min(Math.max(0, b), 1);

	return [r * 255, g * 255, b * 255];
};

convert.xyz.lab = function (xyz) {
	var x = xyz[0];
	var y = xyz[1];
	var z = xyz[2];
	var l;
	var a;
	var b;

	x /= 95.047;
	y /= 100;
	z /= 108.883;

	x = x > 0.008856 ? Math.pow(x, 1 / 3) : (7.787 * x) + (16 / 116);
	y = y > 0.008856 ? Math.pow(y, 1 / 3) : (7.787 * y) + (16 / 116);
	z = z > 0.008856 ? Math.pow(z, 1 / 3) : (7.787 * z) + (16 / 116);

	l = (116 * y) - 16;
	a = 500 * (x - y);
	b = 200 * (y - z);

	return [l, a, b];
};

convert.lab.xyz = function (lab) {
	var l = lab[0];
	var a = lab[1];
	var b = lab[2];
	var x;
	var y;
	var z;

	y = (l + 16) / 116;
	x = a / 500 + y;
	z = y - b / 200;

	var y2 = Math.pow(y, 3);
	var x2 = Math.pow(x, 3);
	var z2 = Math.pow(z, 3);
	y = y2 > 0.008856 ? y2 : (y - 16 / 116) / 7.787;
	x = x2 > 0.008856 ? x2 : (x - 16 / 116) / 7.787;
	z = z2 > 0.008856 ? z2 : (z - 16 / 116) / 7.787;

	x *= 95.047;
	y *= 100;
	z *= 108.883;

	return [x, y, z];
};

convert.lab.lch = function (lab) {
	var l = lab[0];
	var a = lab[1];
	var b = lab[2];
	var hr;
	var h;
	var c;

	hr = Math.atan2(b, a);
	h = hr * 360 / 2 / Math.PI;

	if (h < 0) {
		h += 360;
	}

	c = Math.sqrt(a * a + b * b);

	return [l, c, h];
};

convert.lch.lab = function (lch) {
	var l = lch[0];
	var c = lch[1];
	var h = lch[2];
	var a;
	var b;
	var hr;

	hr = h / 360 * 2 * Math.PI;
	a = c * Math.cos(hr);
	b = c * Math.sin(hr);

	return [l, a, b];
};

convert.rgb.ansi16 = function (args) {
	var r = args[0];
	var g = args[1];
	var b = args[2];
	var value = 1 in arguments ? arguments[1] : convert.rgb.hsv(args)[2]; // hsv -> ansi16 optimization

	value = Math.round(value / 50);

	if (value === 0) {
		return 30;
	}

	var ansi = 30
		+ ((Math.round(b / 255) << 2)
		| (Math.round(g / 255) << 1)
		| Math.round(r / 255));

	if (value === 2) {
		ansi += 60;
	}

	return ansi;
};

convert.hsv.ansi16 = function (args) {
	// optimization here; we already know the value and don't need to get
	// it converted for us.
	return convert.rgb.ansi16(convert.hsv.rgb(args), args[2]);
};

convert.rgb.ansi256 = function (args) {
	var r = args[0];
	var g = args[1];
	var b = args[2];

	// we use the extended greyscale palette here, with the exception of
	// black and white. normal palette only has 4 greyscale shades.
	if (r === g && g === b) {
		if (r < 8) {
			return 16;
		}

		if (r > 248) {
			return 231;
		}

		return Math.round(((r - 8) / 247) * 24) + 232;
	}

	var ansi = 16
		+ (36 * Math.round(r / 255 * 5))
		+ (6 * Math.round(g / 255 * 5))
		+ Math.round(b / 255 * 5);

	return ansi;
};

convert.ansi16.rgb = function (args) {
	var color = args % 10;

	// handle greyscale
	if (color === 0 || color === 7) {
		if (args > 50) {
			color += 3.5;
		}

		color = color / 10.5 * 255;

		return [color, color, color];
	}

	var mult = (~~(args > 50) + 1) * 0.5;
	var r = ((color & 1) * mult) * 255;
	var g = (((color >> 1) & 1) * mult) * 255;
	var b = (((color >> 2) & 1) * mult) * 255;

	return [r, g, b];
};

convert.ansi256.rgb = function (args) {
	// handle greyscale
	if (args >= 232) {
		var c = (args - 232) * 10 + 8;
		return [c, c, c];
	}

	args -= 16;

	var rem;
	var r = Math.floor(args / 36) / 5 * 255;
	var g = Math.floor((rem = args % 36) / 6) / 5 * 255;
	var b = (rem % 6) / 5 * 255;

	return [r, g, b];
};

convert.rgb.hex = function (args) {
	var integer = ((Math.round(args[0]) & 0xFF) << 16)
		+ ((Math.round(args[1]) & 0xFF) << 8)
		+ (Math.round(args[2]) & 0xFF);

	var string = integer.toString(16).toUpperCase();
	return '000000'.substring(string.length) + string;
};

convert.hex.rgb = function (args) {
	var match = args.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
	if (!match) {
		return [0, 0, 0];
	}

	var colorString = match[0];

	if (match[0].length === 3) {
		colorString = colorString.split('').map(function (char) {
			return char + char;
		}).join('');
	}

	var integer = parseInt(colorString, 16);
	var r = (integer >> 16) & 0xFF;
	var g = (integer >> 8) & 0xFF;
	var b = integer & 0xFF;

	return [r, g, b];
};

convert.rgb.hcg = function (rgb) {
	var r = rgb[0] / 255;
	var g = rgb[1] / 255;
	var b = rgb[2] / 255;
	var max = Math.max(Math.max(r, g), b);
	var min = Math.min(Math.min(r, g), b);
	var chroma = (max - min);
	var grayscale;
	var hue;

	if (chroma < 1) {
		grayscale = min / (1 - chroma);
	} else {
		grayscale = 0;
	}

	if (chroma <= 0) {
		hue = 0;
	} else
	if (max === r) {
		hue = ((g - b) / chroma) % 6;
	} else
	if (max === g) {
		hue = 2 + (b - r) / chroma;
	} else {
		hue = 4 + (r - g) / chroma + 4;
	}

	hue /= 6;
	hue %= 1;

	return [hue * 360, chroma * 100, grayscale * 100];
};

convert.hsl.hcg = function (hsl) {
	var s = hsl[1] / 100;
	var l = hsl[2] / 100;
	var c = 1;
	var f = 0;

	if (l < 0.5) {
		c = 2.0 * s * l;
	} else {
		c = 2.0 * s * (1.0 - l);
	}

	if (c < 1.0) {
		f = (l - 0.5 * c) / (1.0 - c);
	}

	return [hsl[0], c * 100, f * 100];
};

convert.hsv.hcg = function (hsv) {
	var s = hsv[1] / 100;
	var v = hsv[2] / 100;

	var c = s * v;
	var f = 0;

	if (c < 1.0) {
		f = (v - c) / (1 - c);
	}

	return [hsv[0], c * 100, f * 100];
};

convert.hcg.rgb = function (hcg) {
	var h = hcg[0] / 360;
	var c = hcg[1] / 100;
	var g = hcg[2] / 100;

	if (c === 0.0) {
		return [g * 255, g * 255, g * 255];
	}

	var pure = [0, 0, 0];
	var hi = (h % 1) * 6;
	var v = hi % 1;
	var w = 1 - v;
	var mg = 0;

	switch (Math.floor(hi)) {
		case 0:
			pure[0] = 1; pure[1] = v; pure[2] = 0; break;
		case 1:
			pure[0] = w; pure[1] = 1; pure[2] = 0; break;
		case 2:
			pure[0] = 0; pure[1] = 1; pure[2] = v; break;
		case 3:
			pure[0] = 0; pure[1] = w; pure[2] = 1; break;
		case 4:
			pure[0] = v; pure[1] = 0; pure[2] = 1; break;
		default:
			pure[0] = 1; pure[1] = 0; pure[2] = w;
	}

	mg = (1.0 - c) * g;

	return [
		(c * pure[0] + mg) * 255,
		(c * pure[1] + mg) * 255,
		(c * pure[2] + mg) * 255
	];
};

convert.hcg.hsv = function (hcg) {
	var c = hcg[1] / 100;
	var g = hcg[2] / 100;

	var v = c + g * (1.0 - c);
	var f = 0;

	if (v > 0.0) {
		f = c / v;
	}

	return [hcg[0], f * 100, v * 100];
};

convert.hcg.hsl = function (hcg) {
	var c = hcg[1] / 100;
	var g = hcg[2] / 100;

	var l = g * (1.0 - c) + 0.5 * c;
	var s = 0;

	if (l > 0.0 && l < 0.5) {
		s = c / (2 * l);
	} else
	if (l >= 0.5 && l < 1.0) {
		s = c / (2 * (1 - l));
	}

	return [hcg[0], s * 100, l * 100];
};

convert.hcg.hwb = function (hcg) {
	var c = hcg[1] / 100;
	var g = hcg[2] / 100;
	var v = c + g * (1.0 - c);
	return [hcg[0], (v - c) * 100, (1 - v) * 100];
};

convert.hwb.hcg = function (hwb) {
	var w = hwb[1] / 100;
	var b = hwb[2] / 100;
	var v = 1 - b;
	var c = v - w;
	var g = 0;

	if (c < 1) {
		g = (v - c) / (1 - c);
	}

	return [hwb[0], c * 100, g * 100];
};

convert.apple.rgb = function (apple) {
	return [(apple[0] / 65535) * 255, (apple[1] / 65535) * 255, (apple[2] / 65535) * 255];
};

convert.rgb.apple = function (rgb) {
	return [(rgb[0] / 255) * 65535, (rgb[1] / 255) * 65535, (rgb[2] / 255) * 65535];
};

convert.gray.rgb = function (args) {
	return [args[0] / 100 * 255, args[0] / 100 * 255, args[0] / 100 * 255];
};

convert.gray.hsl = convert.gray.hsv = function (args) {
	return [0, 0, args[0]];
};

convert.gray.hwb = function (gray) {
	return [0, 100, gray[0]];
};

convert.gray.cmyk = function (gray) {
	return [0, 0, 0, gray[0]];
};

convert.gray.lab = function (gray) {
	return [gray[0], 0, 0];
};

convert.gray.hex = function (gray) {
	var val = Math.round(gray[0] / 100 * 255) & 0xFF;
	var integer = (val << 16) + (val << 8) + val;

	var string = integer.toString(16).toUpperCase();
	return '000000'.substring(string.length) + string;
};

convert.rgb.gray = function (rgb) {
	var val = (rgb[0] + rgb[1] + rgb[2]) / 3;
	return [val / 255 * 100];
};
});

/*
	this function routes a model to all other models.

	all functions that are routed have a property `.conversion` attached
	to the returned synthetic function. This property is an array
	of strings, each with the steps in between the 'from' and 'to'
	color models (inclusive).

	conversions that are not possible simply are not included.
*/

function buildGraph() {
	var graph = {};
	// https://jsperf.com/object-keys-vs-for-in-with-closure/3
	var models = Object.keys(conversions);

	for (var len = models.length, i = 0; i < len; i++) {
		graph[models[i]] = {
			// http://jsperf.com/1-vs-infinity
			// micro-opt, but this is simple.
			distance: -1,
			parent: null
		};
	}

	return graph;
}

// https://en.wikipedia.org/wiki/Breadth-first_search
function deriveBFS(fromModel) {
	var graph = buildGraph();
	var queue = [fromModel]; // unshift -> queue -> pop

	graph[fromModel].distance = 0;

	while (queue.length) {
		var current = queue.pop();
		var adjacents = Object.keys(conversions[current]);

		for (var len = adjacents.length, i = 0; i < len; i++) {
			var adjacent = adjacents[i];
			var node = graph[adjacent];

			if (node.distance === -1) {
				node.distance = graph[current].distance + 1;
				node.parent = current;
				queue.unshift(adjacent);
			}
		}
	}

	return graph;
}

function link$1(from, to) {
	return function (args) {
		return to(from(args));
	};
}

function wrapConversion(toModel, graph) {
	var path = [graph[toModel].parent, toModel];
	var fn = conversions[graph[toModel].parent][toModel];

	var cur = graph[toModel].parent;
	while (graph[cur].parent) {
		path.unshift(graph[cur].parent);
		fn = link$1(conversions[graph[cur].parent][cur], fn);
		cur = graph[cur].parent;
	}

	fn.conversion = path;
	return fn;
}

var route = function (fromModel) {
	var graph = deriveBFS(fromModel);
	var conversion = {};

	var models = Object.keys(graph);
	for (var len = models.length, i = 0; i < len; i++) {
		var toModel = models[i];
		var node = graph[toModel];

		if (node.parent === null) {
			// no possible conversion, or this node is the source model.
			continue;
		}

		conversion[toModel] = wrapConversion(toModel, graph);
	}

	return conversion;
};

var convert = {};

var models$1 = Object.keys(conversions);

function wrapRaw(fn) {
	var wrappedFn = function (args) {
		if (args === undefined || args === null) {
			return args;
		}

		if (arguments.length > 1) {
			args = Array.prototype.slice.call(arguments);
		}

		return fn(args);
	};

	// preserve .conversion property if there is one
	if ('conversion' in fn) {
		wrappedFn.conversion = fn.conversion;
	}

	return wrappedFn;
}

function wrapRounded(fn) {
	var wrappedFn = function (args) {
		if (args === undefined || args === null) {
			return args;
		}

		if (arguments.length > 1) {
			args = Array.prototype.slice.call(arguments);
		}

		var result = fn(args);

		// we're assuming the result is an array here.
		// see notice in conversions.js; don't use box types
		// in conversion functions.
		if (typeof result === 'object') {
			for (var len = result.length, i = 0; i < len; i++) {
				result[i] = Math.round(result[i]);
			}
		}

		return result;
	};

	// preserve .conversion property if there is one
	if ('conversion' in fn) {
		wrappedFn.conversion = fn.conversion;
	}

	return wrappedFn;
}

models$1.forEach(function (fromModel) {
	convert[fromModel] = {};

	Object.defineProperty(convert[fromModel], 'channels', {value: conversions[fromModel].channels});
	Object.defineProperty(convert[fromModel], 'labels', {value: conversions[fromModel].labels});

	var routes = route(fromModel);
	var routeModels = Object.keys(routes);

	routeModels.forEach(function (toModel) {
		var fn = routes[toModel];

		convert[fromModel][toModel] = wrapRounded(fn);
		convert[fromModel][toModel].raw = wrapRaw(fn);
	});
});

var colorConvert = convert;

var _slice = [].slice;

var skippedModels = [
	// to be honest, I don't really feel like keyword belongs in color convert, but eh.
	'keyword',

	// gray conflicts with some method names, and has its own method defined.
	'gray',

	// shouldn't really be in color-convert either...
	'hex'
];

var hashedModelKeys = {};
Object.keys(colorConvert).forEach(function (model) {
	hashedModelKeys[_slice.call(colorConvert[model].labels).sort().join('')] = model;
});

var limiters = {};

function Color(obj, model) {
	if (!(this instanceof Color)) {
		return new Color(obj, model);
	}

	if (model && model in skippedModels) {
		model = null;
	}

	if (model && !(model in colorConvert)) {
		throw new Error('Unknown model: ' + model);
	}

	var i;
	var channels;

	if (obj == null) { // eslint-disable-line no-eq-null,eqeqeq
		this.model = 'rgb';
		this.color = [0, 0, 0];
		this.valpha = 1;
	} else if (obj instanceof Color) {
		this.model = obj.model;
		this.color = obj.color.slice();
		this.valpha = obj.valpha;
	} else if (typeof obj === 'string') {
		var result = colorString.get(obj);
		if (result === null) {
			throw new Error('Unable to parse color from string: ' + obj);
		}

		this.model = result.model;
		channels = colorConvert[this.model].channels;
		this.color = result.value.slice(0, channels);
		this.valpha = typeof result.value[channels] === 'number' ? result.value[channels] : 1;
	} else if (obj.length) {
		this.model = model || 'rgb';
		channels = colorConvert[this.model].channels;
		var newArr = _slice.call(obj, 0, channels);
		this.color = zeroArray(newArr, channels);
		this.valpha = typeof obj[channels] === 'number' ? obj[channels] : 1;
	} else if (typeof obj === 'number') {
		// this is always RGB - can be converted later on.
		obj &= 0xFFFFFF;
		this.model = 'rgb';
		this.color = [
			(obj >> 16) & 0xFF,
			(obj >> 8) & 0xFF,
			obj & 0xFF
		];
		this.valpha = 1;
	} else {
		this.valpha = 1;

		var keys = Object.keys(obj);
		if ('alpha' in obj) {
			keys.splice(keys.indexOf('alpha'), 1);
			this.valpha = typeof obj.alpha === 'number' ? obj.alpha : 0;
		}

		var hashedKeys = keys.sort().join('');
		if (!(hashedKeys in hashedModelKeys)) {
			throw new Error('Unable to parse color from object: ' + JSON.stringify(obj));
		}

		this.model = hashedModelKeys[hashedKeys];

		var labels = colorConvert[this.model].labels;
		var color = [];
		for (i = 0; i < labels.length; i++) {
			color.push(obj[labels[i]]);
		}

		this.color = zeroArray(color);
	}

	// perform limitations (clamping, etc.)
	if (limiters[this.model]) {
		channels = colorConvert[this.model].channels;
		for (i = 0; i < channels; i++) {
			var limit = limiters[this.model][i];
			if (limit) {
				this.color[i] = limit(this.color[i]);
			}
		}
	}

	this.valpha = Math.max(0, Math.min(1, this.valpha));

	if (Object.freeze) {
		Object.freeze(this);
	}
}

Color.prototype = {
	toString: function () {
		return this.string();
	},

	toJSON: function () {
		return this[this.model]();
	},

	string: function (places) {
		var self = this.model in colorString.to ? this : this.rgb();
		self = self.round(typeof places === 'number' ? places : 1);
		var args = self.valpha === 1 ? self.color : self.color.concat(this.valpha);
		return colorString.to[self.model](args);
	},

	percentString: function (places) {
		var self = this.rgb().round(typeof places === 'number' ? places : 1);
		var args = self.valpha === 1 ? self.color : self.color.concat(this.valpha);
		return colorString.to.rgb.percent(args);
	},

	array: function () {
		return this.valpha === 1 ? this.color.slice() : this.color.concat(this.valpha);
	},

	object: function () {
		var result = {};
		var channels = colorConvert[this.model].channels;
		var labels = colorConvert[this.model].labels;

		for (var i = 0; i < channels; i++) {
			result[labels[i]] = this.color[i];
		}

		if (this.valpha !== 1) {
			result.alpha = this.valpha;
		}

		return result;
	},

	unitArray: function () {
		var rgb = this.rgb().color;
		rgb[0] /= 255;
		rgb[1] /= 255;
		rgb[2] /= 255;

		if (this.valpha !== 1) {
			rgb.push(this.valpha);
		}

		return rgb;
	},

	unitObject: function () {
		var rgb = this.rgb().object();
		rgb.r /= 255;
		rgb.g /= 255;
		rgb.b /= 255;

		if (this.valpha !== 1) {
			rgb.alpha = this.valpha;
		}

		return rgb;
	},

	round: function (places) {
		places = Math.max(places || 0, 0);
		return new Color(this.color.map(roundToPlace(places)).concat(this.valpha), this.model);
	},

	alpha: function (val) {
		if (arguments.length) {
			return new Color(this.color.concat(Math.max(0, Math.min(1, val))), this.model);
		}

		return this.valpha;
	},

	// rgb
	red: getset('rgb', 0, maxfn(255)),
	green: getset('rgb', 1, maxfn(255)),
	blue: getset('rgb', 2, maxfn(255)),

	hue: getset(['hsl', 'hsv', 'hsl', 'hwb', 'hcg'], 0, function (val) { return ((val % 360) + 360) % 360; }), // eslint-disable-line brace-style

	saturationl: getset('hsl', 1, maxfn(100)),
	lightness: getset('hsl', 2, maxfn(100)),

	saturationv: getset('hsv', 1, maxfn(100)),
	value: getset('hsv', 2, maxfn(100)),

	chroma: getset('hcg', 1, maxfn(100)),
	gray: getset('hcg', 2, maxfn(100)),

	white: getset('hwb', 1, maxfn(100)),
	wblack: getset('hwb', 2, maxfn(100)),

	cyan: getset('cmyk', 0, maxfn(100)),
	magenta: getset('cmyk', 1, maxfn(100)),
	yellow: getset('cmyk', 2, maxfn(100)),
	black: getset('cmyk', 3, maxfn(100)),

	x: getset('xyz', 0, maxfn(100)),
	y: getset('xyz', 1, maxfn(100)),
	z: getset('xyz', 2, maxfn(100)),

	l: getset('lab', 0, maxfn(100)),
	a: getset('lab', 1),
	b: getset('lab', 2),

	keyword: function (val) {
		if (arguments.length) {
			return new Color(val);
		}

		return colorConvert[this.model].keyword(this.color);
	},

	hex: function (val) {
		if (arguments.length) {
			return new Color(val);
		}

		return colorString.to.hex(this.rgb().round().color);
	},

	rgbNumber: function () {
		var rgb = this.rgb().color;
		return ((rgb[0] & 0xFF) << 16) | ((rgb[1] & 0xFF) << 8) | (rgb[2] & 0xFF);
	},

	luminosity: function () {
		// http://www.w3.org/TR/WCAG20/#relativeluminancedef
		var rgb = this.rgb().color;

		var lum = [];
		for (var i = 0; i < rgb.length; i++) {
			var chan = rgb[i] / 255;
			lum[i] = (chan <= 0.03928) ? chan / 12.92 : Math.pow(((chan + 0.055) / 1.055), 2.4);
		}

		return 0.2126 * lum[0] + 0.7152 * lum[1] + 0.0722 * lum[2];
	},

	contrast: function (color2) {
		// http://www.w3.org/TR/WCAG20/#contrast-ratiodef
		var lum1 = this.luminosity();
		var lum2 = color2.luminosity();

		if (lum1 > lum2) {
			return (lum1 + 0.05) / (lum2 + 0.05);
		}

		return (lum2 + 0.05) / (lum1 + 0.05);
	},

	level: function (color2) {
		var contrastRatio = this.contrast(color2);
		if (contrastRatio >= 7.1) {
			return 'AAA';
		}

		return (contrastRatio >= 4.5) ? 'AA' : '';
	},

	isDark: function () {
		// YIQ equation from http://24ways.org/2010/calculating-color-contrast
		var rgb = this.rgb().color;
		var yiq = (rgb[0] * 299 + rgb[1] * 587 + rgb[2] * 114) / 1000;
		return yiq < 128;
	},

	isLight: function () {
		return !this.isDark();
	},

	negate: function () {
		var rgb = this.rgb();
		for (var i = 0; i < 3; i++) {
			rgb.color[i] = 255 - rgb.color[i];
		}
		return rgb;
	},

	lighten: function (ratio) {
		var hsl = this.hsl();
		hsl.color[2] += hsl.color[2] * ratio;
		return hsl;
	},

	darken: function (ratio) {
		var hsl = this.hsl();
		hsl.color[2] -= hsl.color[2] * ratio;
		return hsl;
	},

	saturate: function (ratio) {
		var hsl = this.hsl();
		hsl.color[1] += hsl.color[1] * ratio;
		return hsl;
	},

	desaturate: function (ratio) {
		var hsl = this.hsl();
		hsl.color[1] -= hsl.color[1] * ratio;
		return hsl;
	},

	whiten: function (ratio) {
		var hwb = this.hwb();
		hwb.color[1] += hwb.color[1] * ratio;
		return hwb;
	},

	blacken: function (ratio) {
		var hwb = this.hwb();
		hwb.color[2] += hwb.color[2] * ratio;
		return hwb;
	},

	grayscale: function () {
		// http://en.wikipedia.org/wiki/Grayscale#Converting_color_to_grayscale
		var rgb = this.rgb().color;
		var val = rgb[0] * 0.3 + rgb[1] * 0.59 + rgb[2] * 0.11;
		return Color.rgb(val, val, val);
	},

	fade: function (ratio) {
		return this.alpha(this.valpha - (this.valpha * ratio));
	},

	opaquer: function (ratio) {
		return this.alpha(this.valpha + (this.valpha * ratio));
	},

	rotate: function (degrees) {
		var hsl = this.hsl();
		var hue = hsl.color[0];
		hue = (hue + degrees) % 360;
		hue = hue < 0 ? 360 + hue : hue;
		hsl.color[0] = hue;
		return hsl;
	},

	mix: function (mixinColor, weight) {
		// ported from sass implementation in C
		// https://github.com/sass/libsass/blob/0e6b4a2850092356aa3ece07c6b249f0221caced/functions.cpp#L209
		if (!mixinColor || !mixinColor.rgb) {
			throw new Error('Argument to "mix" was not a Color instance, but rather an instance of ' + typeof mixinColor);
		}
		var color1 = mixinColor.rgb();
		var color2 = this.rgb();
		var p = weight === undefined ? 0.5 : weight;

		var w = 2 * p - 1;
		var a = color1.alpha() - color2.alpha();

		var w1 = (((w * a === -1) ? w : (w + a) / (1 + w * a)) + 1) / 2.0;
		var w2 = 1 - w1;

		return Color.rgb(
				w1 * color1.red() + w2 * color2.red(),
				w1 * color1.green() + w2 * color2.green(),
				w1 * color1.blue() + w2 * color2.blue(),
				color1.alpha() * p + color2.alpha() * (1 - p));
	}
};

// model conversion methods and static constructors
Object.keys(colorConvert).forEach(function (model) {
	if (skippedModels.indexOf(model) !== -1) {
		return;
	}

	var channels = colorConvert[model].channels;

	// conversion methods
	Color.prototype[model] = function () {
		if (this.model === model) {
			return new Color(this);
		}

		if (arguments.length) {
			return new Color(arguments, model);
		}

		var newAlpha = typeof arguments[channels] === 'number' ? channels : this.valpha;
		return new Color(assertArray(colorConvert[this.model][model].raw(this.color)).concat(newAlpha), model);
	};

	// 'static' construction methods
	Color[model] = function (color) {
		if (typeof color === 'number') {
			color = zeroArray(_slice.call(arguments), channels);
		}
		return new Color(color, model);
	};
});

function roundTo(num, places) {
	return Number(num.toFixed(places));
}

function roundToPlace(places) {
	return function (num) {
		return roundTo(num, places);
	};
}

function getset(model, channel, modifier) {
	model = Array.isArray(model) ? model : [model];

	model.forEach(function (m) {
		(limiters[m] || (limiters[m] = []))[channel] = modifier;
	});

	model = model[0];

	return function (val) {
		var result;

		if (arguments.length) {
			if (modifier) {
				val = modifier(val);
			}

			result = this[model]();
			result.color[channel] = val;
			return result;
		}

		result = this[model]().color[channel];
		if (modifier) {
			result = modifier(result);
		}

		return result;
	};
}

function maxfn(max) {
	return function (v) {
		return Math.max(0, Math.min(max, v));
	};
}

function assertArray(val) {
	return Array.isArray(val) ? val : [val];
}

function zeroArray(arr, length) {
	for (var i = 0; i < length; i++) {
		if (typeof arr[i] !== 'number') {
			arr[i] = 0;
		}
	}

	return arr;
}

var color = Color;

/* -------------------------------------------- */

const createCustomChatMessage = async function (
  chatTemplate,
  chatTemplateData = {},
  chatData = {},
  { rolls = [] } = {}
) {
  let rollMode = game.settings.get("core", "rollMode");
  chatData = mergeObject(
    {
      rollMode: rollMode,
      user: game.user.id,
      type: CONST.CHAT_MESSAGE_TYPES.CHAT,
    },
    chatData
  );
  chatData.content = await renderTemplate(chatTemplate, chatTemplateData);
  // Handle different roll modes
  switch (chatData.rollMode) {
    case "gmroll":
      chatData["whisper"] = game.users.contents.filter((u) => u.isGM).map((u) => u.id);
      break;
    case "selfroll":
      chatData["whisper"] = [game.user.id];
      break;
    case "blindroll":
      chatData["whisper"] = game.users.contents.filter((u) => u.isGM).map((u) => u.id);
      chatData["blind"] = true;
      break;
  }

  // Dice So Nice integration
  if (chatData.roll != null && rolls.length === 0) rolls = [chatData.roll];
  if (game.dice3d != null && game.dice3d.isEnabled()) {
    for (let roll of rolls) {
      await game.dice3d.showForRoll(roll, game.user, false, chatData.whisper, chatData.blind);
      chatData.sound = null;
    }
  }

  return ChatMessageFFD20.create(chatData);
};

const hideRollInfo = function (app, html, data) {
  const whisper = app.data.whisper || [];
  const isBlind = whisper.length && app.data.blind;
  const isVisible = whisper.length ? whisper.includes(game.user.id) || (app.isAuthor && !isBlind) : true;
  if (!isVisible) {
    html.find(".dice-formula").text("???");
    html.find(".dice-total").text("?");
    html.find(".dice").text("");
    html.find(".success").removeClass("success");
    html.find(".failure").removeClass("failure");
  }
};

const hideGMSensitiveInfo = function (app, html, data) {
  if (game.user.isGM) return;

  let speaker = app.data.speaker;
  let actor = null;
  if (speaker != null) {
    if (speaker.token) {
      actor = game.actors.tokens[speaker.token];
    }
    if (!actor) {
      actor = game.actors.get(speaker.actor);
    }
  }

  if (!actor || (actor && actor.testUserPermission(game.user, "LIMITED"))) return;

  // Hide info
  html.find(".gm-sensitive").remove();
};

const addChatCardTitleGradient = async function (app, html, data) {
  const card = html.find(".chat-card")[0];
  if (!card) return;
  const actor = await ItemFFD20._getChatCardActor(card);
  if (!actor) return;
  const item = actor.items.get(card.dataset.itemId);
  if (!item) return;
  const title = $(card).find(".card-header");
  if (!title.length) return;

  title.css("background-image", `linear-gradient(to right, ${item.typeColor}, ${item.typeColor2})`);

  const titleText = title.find("h2, h3");
  if (color(item.typeColor).isLight()) titleText.css("color", "black");
  else titleText.css("color", "white");
};

const applyAccessibilitySettings = function (app, html, data, conf) {
  const fontSize = conf.fontSize || 0;

  // Enlarge font sizes
  if (fontSize > 0) {
    // Enlarge table font sizes
    {
      const size = 10 + fontSize * 4;
      html.find("table").css("font-size", `${size}px`);
    }

    // Enlarge attack roll numbers
    {
      const size = 12 + fontSize * 4;
      html.find(".inline-roll, .fake-inline-roll").css("font-size", `${size}px`);
    }

    // Enlarge attack headers
    {
      const size = 1 + fontSize * 0.3;
      html.find(".chat-attack th").css("font-size", `${size}em`);
    }
    // Enlarge attack labels
    {
      const size = 0.7 + fontSize * 0.3;
      html.find(".chat-attack td").css("font-size", `${size}em`);
    }
  }
};

const createInlineRollString = function (roll) {
  return (
    `<a class="inline-roll inline-result" title="${roll.formula}" data-roll="${escape(JSON.stringify(roll))}">` +
    `<i class="fas fa-dice-d20"></i> ${roll.total}` +
    `</a>`
  );
};

/* -------------------------------------------- */

/**
 * Override the default Initiative formula to customize special behaviors of the game system.
 * Apply advantage, proficiency, or bonuses where appropriate
 * Apply the dexterity score as a decimal tiebreaker if requested
 * See Combat._getInitiativeFormula for more detail.
 *
 * @param actor
 */
const _getInitiativeFormula = function (actor) {
  if (CONFIG.Combat.initiative.formula) var parts = CONFIG.Combat.initiative.formula.split(/\s*\+\s*/);
  else parts = ["1d20", "@attributes.init.total", "@attributes.init.total / 100"];
  if (!actor) return parts[0] ?? "0";
  return parts.filter((p) => p !== null).join(" + ");
};

Combat.showInitiativeDialog = function (formula = null) {
  return new Promise((resolve) => {
    let template = "systems/ffd20/templates/chat/roll-dialog.hbs";
    let rollMode = game.settings.get("core", "rollMode");
    let dialogData = {
      formula: formula ? formula : "",
      rollMode: rollMode,
      rollModes: CONFIG.Dice.rollModes,
    };
    // Create buttons object
    let buttons = {
      normal: {
        label: "Roll",
        callback: (html) => {
          rollMode = html.find('[name="rollMode"]').val();
          const bonus = html.find('[name="bonus"]').val();
          resolve({ rollMode: rollMode, bonus: bonus });
        },
      },
    };
    // Show dialog
    renderTemplate(template, dialogData).then((dlg) => {
      new Dialog(
        {
          title: game.i18n.localize("FFD20.InitiativeBonus"),
          content: dlg,
          buttons: buttons,
          default: "normal",
          close: (html) => {
            resolve({ stop: true });
          },
        },
        {
          classes: ["dialog", "ffd20", "roll-initiative"],
        }
      ).render(true);
    });
  });
};

const _rollInitiative = async function (ids, { formula = null, updateTurn = true, messageOptions = {} } = {}) {
  // Structure input data
  ids = typeof ids === "string" ? [ids] : ids;
  const currentId = this.combatant.id;
  if (!formula) formula = _getInitiativeFormula(this.combatant.actor);

  let overrideRollMode = null,
    bonus = "",
    stop = false;
  if (keyboard.isDown("Shift")) {
    const dialogData = await Combat.showInitiativeDialog(formula);
    overrideRollMode = dialogData.rollMode;
    bonus = dialogData.bonus || "";
    stop = dialogData.stop || false;
  }

  if (stop) return this;

  // Iterate over Combatants, performing an initiative roll for each
  const [updates, messages] = await ids.reduce(
    async (results, id, i) => {
      const result = await results;
      let [updates, messages] = result;

      // Get Combatant data
      const c = this.combatants.get(id);
      if (!c) return results;
      const actorData = c.actor ? c.actor.data.data : {};
      formula = formula || this._getInitiativeFormula(c.actor ? c.actor : null);

      actorData.bonus = bonus;
      // Add bonus
      if (bonus.length > 0 && i === 0) {
        formula += " + @bonus";
      }

      // Roll initiative
      const rollMode =
        overrideRollMode != null
          ? overrideRollMode
          : messageOptions.rollMode || c.token.hidden || c.hidden
          ? "gmroll"
          : "roll";
      const roll = RollFFD20.safeRoll(formula, actorData);
      if (roll.err) ui.notifications.warn(roll.err.message);
      updates.push({ _id: id, initiative: roll.total });

      let [notes, notesHTML] = c.actor.getInitiativeContextNotes();

      // Create roll template data
      const rollData = mergeObject(
        {
          user: game.user.id,
          formula: roll.formula,
          tooltip: await roll.getTooltip(),
          total: roll.total,
        },
        notes.length > 0 ? { hasExtraText: true, extraText: notesHTML } : {}
      );

      // Create chat data
      let chatData = mergeObject(
        {
          user: game.user.id,
          type: CONST.CHAT_MESSAGE_TYPES.CHAT,
          rollMode: rollMode,
          sound: CONFIG.sounds.dice,
          speaker: {
            scene: canvas.scene.id,
            actor: c.actor ? c.actor.id : null,
            token: c.token.id,
            alias: c.token.name,
          },
          flavor: game.i18n.localize("FFD20.RollsForInitiative").format(c.token.name),
          roll: roll,
          content: await renderTemplate("systems/ffd20/templates/chat/roll-ext.hbs", rollData),
        },
        messageOptions
      );
      setProperty(chatData, "flags.ffd20.subject.core", "init");

      // Handle different roll modes
      switch (chatData.rollMode) {
        case "gmroll":
          chatData["whisper"] = game.users.contents.filter((u) => u.isGM).map((u) => u.id);
          break;
        case "selfroll":
          chatData["whisper"] = [game.user._id];
          break;
        case "blindroll":
          chatData["whisper"] = game.users.contents.filter((u) => u.isGM).map((u) => u.id);
          chatData["blind"] = true;
      }

      if (i > 0) chatData.sound = null; // Only play 1 sound for the whole set
      messages.push(chatData);

      // Return the Roll and the chat data
      return results;
    },
    [[], []]
  );
  if (!updates.length) return this;

  // Update multiple combatants
  await this.updateEmbeddedDocuments("Combatant", updates);

  // Ensure the turn order remains with the same combatant
  if (updateTurn) await this.update({ turn: this.turns.findIndex((t) => t.id === currentId) });

  // Create multiple chat messages
  await ChatMessage.create(messages);

  // Return the updated Combat
  return this;
};

const duplicateCombatantInitiativeDialog = function (combats, combatantId) {
  const combat = combats.find((c) => c.combatants.filter((o) => o.id === combatantId).length > 0);
  if (!combat) {
    ui.notifications.warn(game.i18n.localize("FFD20.WarningNoCombatantFound"));
    return;
  }
  const combatant = combat.combatants.filter((o) => o.id === combatantId)[0];
  if (!combatant) {
    ui.notifications.warn(game.i18n.localize("FFD20.WarningNoCombatantFound"));
    return;
  }

  new Dialog(
    {
      title: `${game.i18n.localize("FFD20.DuplicateInitiative")}: ${combatant.actor.name}`,
      content: `<div class="flexrow form-group">
      <label>${game.i18n.localize("FFD20.InitiativeOffset")}</label>
      <input type="number" name="initiativeOffset" value="0"/>
    </div>`,
      buttons: {
        confirm: {
          label: game.i18n.localize("FFD20.Confirm"),
          callback: (html) => {
            const offset = parseFloat(html.find('input[name="initiativeOffset"]').val());
            const prevInitiative = combatant.initiative != null ? combatant.initiative : 0;
            const newInitiative = prevInitiative + offset;
            duplicateCombatantInitiative(combat, combatant, newInitiative);
          },
        },
        cancel: {
          label: game.i18n.localize("Cancel"),
        },
      },
      default: "confirm",
    },
    {
      classes: ["dialog", "ffd20", "duplicate-initiative"],
    }
  ).render(true);
};

const duplicateCombatantInitiative = function (combat, combatant, initiative) {
  console.debug("Duplicating combatant:", combatant);
  combat.createEmbeddedDocuments("Combatant", [
    mergeObject(duplicate(combatant.data), { initiative: initiative }, { inplace: false }),
  ]);
};

const addCombatTrackerContextOptions = function (result) {
  result.push({
    name: "FFD20.DuplicateInitiative",
    icon: '<i class="fas fa-dice-d20"></i>',
    callback: (li) => duplicateCombatantInitiativeDialog.call(this, this.combats, li.data("combatant-id")),
  });
};

const LinkFunctions = {
  charges: function (item, links) {
    for (let l of links) {
      const otherItem = this.items.find((o) => o.id === l.id);
      if (!otherItem) continue;

      otherItem.links.charges = item;
      otherItem.prepareLinks();
    }
  },
};

class RollFFD20$1 extends Roll {
  static safeRoll(formula, data = {}, context, options = { suppressError: false }) {
    let roll;
    try {
      roll = this.create(formula, data).evaluate({ async: false });
    } catch (err) {
      roll = this.create("0", data).evaluate({ async: false });
      roll.err = err;
    }
    if (roll.warning) roll.err = Error("This formula had a value replaced with null.");
    if (roll.err) {
      if (context && !options.suppressError) console.error(context, roll.err);
      else if (CONFIG.debug.roll) console.error(roll.err);
    }
    return roll;
  }

  static safeTotal(formula, data) {
    return isNaN(+formula) ? RollFFD20$1.safeRoll(formula, data).total : +formula;
  }

  /**
   * @override
   */
  static simplifyTerms(terms) {
    // Simplify terms by combining with pending strings
    let simplified = terms.reduce((terms, term) => {
      const prior = terms[terms.length - 1];
      const isOperator = term instanceof OperatorTerm;

      // Combine a non-operator term with prior StringTerm
      if (!isOperator && prior instanceof StringTerm) {
        prior.term += term.total;
        foundry.utils.mergeObject(prior.options, term.options);
        return terms;
      }

      // Attach string terms as flavor texts to numeric terms, if appropriate
      const priorNumeric = prior instanceof NumericTerm;
      if (prior && priorNumeric && term instanceof StringTerm && term.term.match(/\[(.+)\]/)) {
        prior.options.flavor = RegExp.$1;
        return terms;
      }

      // Combine StringTerm with a prior non-operator term
      const priorOperator = prior instanceof OperatorTerm;
      if (prior && !priorOperator && term instanceof StringTerm) {
        term.term = String(prior.total) + term.term;
        foundry.utils.mergeObject(term.options, prior.options);
        terms[terms.length - 1] = term;
        return terms;
      }

      // Otherwise continue
      terms.push(term);
      return terms;
    }, []);

    // Convert remaining String terms to a RollTerm which can be evaluated
    simplified = simplified.map((term) => {
      if (!(term instanceof StringTerm)) return term;
      const t = this._classifyStringTerm(term.formula, { intermediate: false });
      t.options = term.options;
      return t;
    });

    // Eliminate leading or trailing arithmetic
    if (simplified[0] instanceof OperatorTerm && simplified[0].operator !== "-") simplified.shift();
    if (simplified[terms.length - 1] instanceof OperatorTerm) simplified.pop();
    return simplified;
  }

  /**
   * @override
   *
   * Split a formula by identifying its outer-most parenthetical and math terms
   * @param {string} _formula      The raw formula to split
   * @returns {string[]}          An array of terms, split on parenthetical terms
   * @private
   */
  static _splitParentheses(_formula) {
    return this._splitGroup(_formula, {
      openRegexp: ParentheticalTerm.OPEN_REGEXP,
      closeRegexp: ParentheticalTerm.CLOSE_REGEXP,
      openSymbol: "(",
      closeSymbol: ")",
      onClose: (group) => {
        const fn = group.open.slice(0, -1);
        const options = { flavor: group.flavor ? group.flavor.slice(1, -1) : undefined };
        const term = group.terms.join("");
        const terms = [];

        if (fn in game.ffd20.rollPreProcess) {
          let fnParams = group.terms
            // .slice(2, -1)
            .reduce((cur, s) => {
              cur.push(...s.split(/\s*,\s*/));
              return cur;
            }, [])
            .map((o) => {
              // Return raw string
              if ((o.startsWith('"') && o.endsWith('"')) || (o.startsWith("'") && o.endsWith("'"))) {
                return o.slice(1, -1);
              }
              // Return raw string without quotes
              if (o.match(/^[a-zA-Z0-9]+$/)) {
                return parseRollStringVariable(o);
              }
              // Return roll result
              return RollFFD20$1.safeRoll(o, this.data).total;
            });

          return game.ffd20.rollPreProcess[fn](...fnParams);
        } else if (fn in Math) {
          const args = this._splitMathArgs(term);
          terms.push(new MathTerm({ fn, terms: args, options }));
        } else {
          if (fn) terms.push(new StringTerm({ term: fn }));
          terms.push(new ParentheticalTerm({ term, options }));
        }
        return terms;
      },
    });
  }

  static cleanFlavor(flavor) {
    return flavor.replace(/\[\];/g, "");
  }

  /**
   * Render the tooltip HTML for a RollFFD20 instance
   *
   * @returns {Promise<string>} The rendered HTML tooltip as a string
   */
  async getTooltip() {
    const parts = this.dice.map((d) => d.getTooltipData());
    const numericParts = this.terms.reduce((cur, t, idx, arr) => {
      const result = t instanceof NumericTerm ? t.getTooltipData() : undefined;

      const prior = arr[idx - 1];
      if (t instanceof NumericTerm && prior && prior instanceof OperatorTerm && prior.operator === "-") {
        result.total = -result.total;
      }

      if (result !== undefined) {
        if (!result.flavor) result.flavor = game.i18n.localize("FFD20.Undefined");
        cur.push(result);
      }
      return cur;
    }, []);
    return renderTemplate("systems/ffd20/templates/dice/tooltip.hbs", { parts, numericParts });
  }
}

const parseRollStringVariable = function (value) {
  if (value === "false") return false;
  if (value === "true") return true;
  if (value === "null") return null;
  if (value === "undefined") return undefined;

  if (value.match(/^(?:[0-9]+)?(?:\.[0-9]+)?$/)) {
    return parseFloat(value);
  }
  return value;
};

class ItemChange {
  static create(data, parent) {
    const result = new this();

    result.data = mergeObject(this.defaultData, data);
    result.parent = parent;
    result.updateTime = new Date();

    return result;
  }

  static get defaultData() {
    return {
      _id: randomID(8),
      formula: "",
      operator: "add",
      subTarget: "",
      modifier: "",
      priority: 0,
      value: 0,
      flavor: undefined,
    };
  }

  get id() {
    return this.data._id;
  }
  get _id() {
    return this.data._id;
  }
  get formula() {
    return this.data.formula;
  }
  get operator() {
    return this.data.operator;
  }
  get subTarget() {
    return this.data.subTarget;
  }
  get modifier() {
    return this.data.modifier;
  }
  get priority() {
    return this.data.priority;
  }
  get value() {
    return this.data.value;
  }
  get flavor() {
    return this.data.flavor ?? this.parent?.name.replace(/\[|\]/g, "") ?? this.modifier;
  }

  get source() {
    return this.data.source;
  }
  getSourceInfoTargets(actor) {
    switch (this.subTarget) {
      case "aac":
      case "sac":
      case "nac":
        return ["data.attributes.ac.normal.total", "data.attributes.ac.flatFooted.total"];
    }

    // Return default targets
    let flats = getChangeFlat.call(actor, this.subTarget, this.modifier);
    if (!(flats instanceof Array)) flats = [flats];
    return flats;
  }

  prepareData() {}

  preUpdate(data) {
    // Make sure sub-target is valid
    {
      if (data["target"]) {
        const subTarget = data["subTarget"] || this.subTarget;
        const changeSubTargets = this.parent.getChangeSubTargets(data["target"]);
        if (changeSubTargets[subTarget] == null) {
          data["subTarget"] = Object.keys(changeSubTargets)[0];
        }
      }
    }

    return data;
  }

  async update(data, options = {}) {
    this.updateTime = new Date();

    if (this.parent != null) {
      data = this.preUpdate(data);

      const rawChange = this.parent.data.data.changes.find((o) => o._id === this._id);
      const idx = this.parent.data.data.changes.indexOf(rawChange);
      if (idx >= 0) {
        data = Object.entries(data).reduce((cur, o) => {
          cur[`data.changes.${idx}.${o[0]}`] = o[1];
          return cur;
        }, {});
        return this.parent.update(data, options);
      }
    }
  }

  applyChange(actor, targets = null, flags = {}) {
    // Prepare change targets
    if (!targets) {
      targets = getChangeFlat.call(actor, this.subTarget, this.modifier);
      if (!(targets instanceof Array)) targets = [targets];
    }
    const sourceInfoTargets = this.getSourceInfoTargets(actor);
    let addedSourceInfo = false;

    const rollData = this.parent ? this.parent.getRollData() : actor.getRollData();

    const overrides = actor.changeOverrides;
    for (let t of targets) {
      if (!overrides || overrides[t]) {
        let operator = this.operator;
        if (operator === "+") operator = "add";
        if (operator === "=") operator = "set";

        let value = 0;
        if (operator === "script") {
          const fn = this.createFunction(this.formula, ["d", "item"]);
          const result = fn(rollData, this.parent);
          value = result.value;
          operator = result.operator;
        } else {
          value = RollFFD20$1.safeRoll(this.formula || "0", rollData, [t, this, rollData], {
            suppressError: this.parent && !this.parent.testUserPermission(game.user, "OWNER"),
          }).total;
        }

        this.data.value = value;

        if (!t) continue;
        const prior = overrides[t][operator][this.modifier];

        switch (operator) {
          case "add":
            {
              const base = getProperty(actor.data, t);
              if (typeof base === "number") {
                if (CONFIG.FFD20.stackingBonusModifiers.indexOf(this.modifier) !== -1) {
                  setProperty(actor.data, t, base + value);
                  overrides[t][operator][this.modifier] = (prior ?? 0) + value;

                  if (this.parent && !addedSourceInfo) {
                    for (let si of sourceInfoTargets) {
                      getSourceInfo(actor.sourceInfo, si).positive.push({
                        value: value,
                        name: this.parent.name,
                        type: this.parent.type,
                      });
                    }
                    addedSourceInfo = true;
                  }
                } else {
                  const diff = !prior ? value : Math.max(0, value - (prior ?? 0));
                  setProperty(actor.data, t, base + diff);
                  overrides[t][operator][this.modifier] = Math.max(prior ?? 0, value);

                  if (this.parent) {
                    for (let si of sourceInfoTargets) {
                      const sInfo = getSourceInfo(actor.sourceInfo, si).positive;

                      let doAdd = true;
                      sInfo.forEach((o) => {
                        if (o.modifier === this.modifier) {
                          if (o.value < value) {
                            sInfo.splice(sInfo.indexOf(o), 1);
                          } else {
                            doAdd = false;
                          }
                        }
                      });

                      if (doAdd) {
                        sInfo.push({
                          value: value,
                          name: this.parent.name,
                          type: this.parent.type,
                          modifier: this.modifier,
                        });
                      }
                    }
                  }
                }
              }
            }
            break;

          case "set":
            setProperty(actor.data, t, value);
            overrides[t][operator][this.modifier] = value;

            if (this.parent && !addedSourceInfo) {
              for (let si of sourceInfoTargets) {
                getSourceInfo(actor.sourceInfo, si).positive.push({
                  value: value,
                  operator: "set",
                  name: this.parent.name,
                  type: this.parent.type,
                });
              }
              addedSourceInfo = true;
            }
            break;
        }

        // Reset ability modifiers
        if (t.match(/^data\.abilities\.(?:[a-zA-Z0-9]+)\.(?:total|penalty|base)$/)) {
          actor.refreshAbilityModifiers();
        }
      }
    }
  }

  createFunction(funcDef, funcArgs = []) {
    try {
      const preDef = `const actor = item.actor; const result = { operator: "add", value: 0, };`;
      const postDef = `return result;`;
      const fullDef = `return function(${funcArgs.join(",")}) {${preDef}${funcDef}${postDef}};`;
      return new Function(fullDef)();
    } catch (e) {
      console.warn("Could not create change function with definition ", funcDef);
      return function () {
        return { operator: "add", value: 0 };
      };
    }
  }
}

/**
 *
 */
function applyChanges() {
  this.changeOverrides = {};
  const c = Array.from(this.changes);

  // Organize changes by priority
  c.sort((a, b) => _sortChanges.call(this, a, b));

  // Parse change flags
  for (let i of this.changeItems) {
    for (const [k, v] of Object.entries(getProperty(i.data, "data.changeFlags"))) {
      if (v === true) {
        this.flags[k] = true;

        if (k === "loseDexToAC") {
          for (const k2 of ["normal", "touch"]) {
            getSourceInfo(this.sourceInfo, `data.attributes.ac.${k2}.total`).negative.push({
              value: game.i18n.localize("FFD20.ChangeFlagLoseDexToAC"),
              name: i.name,
              type: i.type,
            });
          }
          getSourceInfo(this.sourceInfo, "data.attributes.cmd.total").negative.push({
            value: game.i18n.localize("FFD20.ChangeFlagLoseDexToAC"),
            name: i.name,
            type: i.type,
          });
        }
      }
    }
  }
  this.refreshDerivedData();

  // Apply all changes
  for (let change of c) {
    let flats = getChangeFlat.call(this, change.subTarget, change.modifier);
    if (!(flats instanceof Array)) flats = [flats];
    for (const f of flats) {
      if (!this.changeOverrides[f]) this.changeOverrides[f] = createOverride();
    }

    change.applyChange(this, flats, this.flags);

    this.refreshDerivedData();
  }

  resetSkills.call(this);

  this.changeOverrides = expandObject(this.changeOverrides);
}

const createOverride = function () {
  const result = {
    add: {},
    set: {},
  };

  for (let k of Object.keys(CONFIG.FFD20.bonusModifiers)) {
    result.add[k] = null;
    result.set[k] = null;
  }

  return result;
};

const getSortChangePriority = function () {
  const skillTargets = this._skillTargets;
  return {
    types: [
      "acpA",
      "acpS",
      "mDexA",
      "mDexS",
      "str",
      "dex",
      "con",
      "int",
      "wis",
      "cha",
      "strMod",
      "dexMod",
      "conMod",
      "intMod",
      "wisMod",
      "chaMod",
      "skills",
      "carryStr",
      "carryMult",
      "strSkills",
      "dexSkills",
      "conSkills",
      "intSkills",
      "wisSkills",
      "chaSkills",
      ...skillTargets,
      "allChecks",
      "strChecks",
      "dexChecks",
      "conChecks",
      "intChecks",
      "wisChecks",
      "chaChecks",
      "landSpeed",
      "climbSpeed",
      "swimSpeed",
      "burrowSpeed",
      "flySpeed",
      "allSpeeds",
      "ac",
      "aac",
      "sac",
      "nac",
      "tac",
      "ffac",
      "attack",
      "bab",
      "~attackCore",
      "mattack",
      "rattack",
      "damage",
      "wdamage",
      "sdamage",
      "critConfirm",
      "allSavingThrows",
      "fort",
      "ref",
      "will",
      "cmb",
      "cmd",
      "ffcmd",
      "init",
      "mhp",
      "wounds",
      "vigor",
      "mmp",
      "limitbreak",
    ],
    modifiers: [
      "untyped",
      "untypedPerm",
      "base",
      "enh",
      "dodge",
      "inherent",
      "deflection",
      "morale",
      "luck",
      "sacred",
      "insight",
      "resist",
      "profane",
      "trait",
      "racial",
      "size",
      "competence",
      "circumstance",
      "alchemical",
      "penalty",
    ],
  };
};

const _sortChanges = function (a, b) {
  const priority = getSortChangePriority.call(this);
  const typeA = priority.types.indexOf(a.subTarget);
  const typeB = priority.types.indexOf(b.subTarget);
  const modA = priority.modifiers.indexOf(a.modifier);
  const modB = priority.modifiers.indexOf(b.modifier);
  let prioA = typeof a.priority === "string" ? parseInt(a.priority) : a.priority;
  let prioB = typeof b.priority === "string" ? parseInt(b.priority) : b.priority;
  prioA = (prioA || 0) + 1000;
  prioB = (prioB || 0) + 1000;

  return prioB - prioA || typeA - typeB || modA - modB;
};

const getChangeFlat = function (changeTarget, changeType, curData = null) {
  if (changeTarget == null) return null;

  curData = curData ?? this.data.data;
  let result = [];

  switch (changeTarget) {
    case "mhp":
      return "data.attributes.hp.max";
    case "wounds":
      return "data.attributes.wounds.max";
    case "vigor":
      return "data.attributes.vigor.max";
    case "mmp":
      return "data.attributes.mp.max";
    case "limitbreak":
      return "data.attributes.limitbreak.max";
    case "str":
    case "dex":
    case "con":
    case "int":
    case "wis":
    case "cha":
      if (changeType === "penalty") return `data.abilities.${changeTarget}.penalty`;
      if (["base", "untypedPerm"].includes(changeType))
        return [`data.abilities.${changeTarget}.total`, `data.abilities.${changeTarget}.base`];
      return `data.abilities.${changeTarget}.total`;
    case "strMod":
    case "dexMod":
    case "conMod":
    case "intMod":
    case "wisMod":
    case "chaMod":
      return `data.abilities.${changeTarget.slice(0, 3)}.mod`;
    case "carryStr":
      return "data.details.carryCapacity.bonus.total";
    case "carryMult":
      return "data.details.carryCapacity.multiplier.total";
    case "ac":
      switch (changeType) {
        case "dodge":
          return ["data.attributes.ac.normal.total", "data.attributes.ac.touch.total", "data.attributes.cmd.total"];
        case "deflection":
          return [
            "data.attributes.ac.normal.total",
            "data.attributes.ac.touch.total",
            "data.attributes.ac.flatFooted.total",
            "data.attributes.cmd.total",
            "data.attributes.cmd.flatFootedTotal",
          ];
        case "circumstance":
        case "insight":
        case "luck":
        case "morale":
        case "profane":
        case "sacred":
          return [
            "data.attributes.ac.normal.total",
            "data.attributes.ac.touch.total",
            "data.attributes.ac.flatFooted.total",
            "data.attributes.cmd.total",
            "data.attributes.cmd.flatFootedTotal",
          ];
        default:
          return [
            "data.attributes.ac.normal.total",
            "data.attributes.ac.touch.total",
            "data.attributes.ac.flatFooted.total",
          ];
      }
    case "aac":
      return "temp.ac.armor";
    case "sac":
      return "temp.ac.shield";
    case "nac":
      return "temp.ac.natural";
    case "tac":
      return "data.attributes.ac.touch.total";
    case "ffac":
      return "data.attributes.ac.flatFooted.total";
    case "ffcmd":
      return "data.attributes.cmd.flatFootedTotal";
    case "bab":
      return "data.attributes.bab.total";
    case "~attackCore":
      return "data.attributes.attack.shared";
    case "attack":
      return "data.attributes.attack.general";
    case "mattack":
      return "data.attributes.attack.melee";
    case "rattack":
      return "data.attributes.attack.ranged";
    case "critConfirm":
      return "data.attributes.attack.critConfirm";
    case "allSavingThrows":
      return [
        "data.attributes.savingThrows.fort.total",
        "data.attributes.savingThrows.ref.total",
        "data.attributes.savingThrows.will.total",
      ];
    case "fort":
      return "data.attributes.savingThrows.fort.total";
    case "ref":
      return "data.attributes.savingThrows.ref.total";
    case "will":
      return "data.attributes.savingThrows.will.total";
    case "skills":
      for (let [a, skl] of Object.entries(curData.skills)) {
        if (skl == null) continue;
        result.push(`data.skills.${a}.changeBonus`);

        if (skl.subSkills != null) {
          for (let b of Object.keys(skl.subSkills)) {
            result.push(`data.skills.${a}.subSkills.${b}.changeBonus`);
          }
        }
      }
      return result;
    case "strSkills":
      for (let [a, skl] of Object.entries(curData.skills)) {
        if (skl == null) continue;
        if (skl.ability === "str") result.push(`data.skills.${a}.changeBonus`);

        if (skl.subSkills != null) {
          for (let [b, subSkl] of Object.entries(skl.subSkills)) {
            if (subSkl != null && subSkl.ability === "str") result.push(`data.skills.${a}.subSkills.${b}.changeBonus`);
          }
        }
      }
      return result;
    case "dexSkills":
      for (let [a, skl] of Object.entries(curData.skills)) {
        if (skl == null) continue;
        if (skl.ability === "dex") result.push(`data.skills.${a}.changeBonus`);

        if (skl.subSkills != null) {
          for (let [b, subSkl] of Object.entries(skl.subSkills)) {
            if (subSkl != null && subSkl.ability === "dex") result.push(`data.skills.${a}.subSkills.${b}.changeBonus`);
          }
        }
      }
      return result;
    case "conSkills":
      for (let [a, skl] of Object.entries(curData.skills)) {
        if (skl == null) continue;
        if (skl.ability === "con") result.push(`data.skills.${a}.changeBonus`);

        if (skl.subSkills != null) {
          for (let [b, subSkl] of Object.entries(skl.subSkills)) {
            if (subSkl != null && subSkl.ability === "con") result.push(`data.skills.${a}.subSkills.${b}.changeBonus`);
          }
        }
      }
      return result;
    case "intSkills":
      for (let [a, skl] of Object.entries(curData.skills)) {
        if (skl == null) continue;
        if (skl.ability === "int") result.push(`data.skills.${a}.changeBonus`);

        if (skl.subSkills != null) {
          for (let [b, subSkl] of Object.entries(skl.subSkills)) {
            if (subSkl != null && subSkl.ability === "int") result.push(`data.skills.${a}.subSkills.${b}.changeBonus`);
          }
        }
      }
      return result;
    case "wisSkills":
      for (let [a, skl] of Object.entries(curData.skills)) {
        if (skl == null) continue;
        if (skl.ability === "wis") result.push(`data.skills.${a}.changeBonus`);

        if (skl.subSkills != null) {
          for (let [b, subSkl] of Object.entries(skl.subSkills)) {
            if (subSkl != null && subSkl.ability === "wis") result.push(`data.skills.${a}.subSkills.${b}.changeBonus`);
          }
        }
      }
      return result;
    case "chaSkills":
      for (let [a, skl] of Object.entries(curData.skills)) {
        if (skl == null) continue;
        if (skl.ability === "cha") result.push(`data.skills.${a}.changeBonus`);

        if (skl.subSkills != null) {
          for (let [b, subSkl] of Object.entries(skl.subSkills)) {
            if (subSkl != null && subSkl.ability === "cha") result.push(`data.skills.${a}.subSkills.${b}.changeBonus`);
          }
        }
      }
      return result;
    case "allChecks":
      return [
        "data.abilities.str.checkMod",
        "data.abilities.dex.checkMod",
        "data.abilities.con.checkMod",
        "data.abilities.int.checkMod",
        "data.abilities.wis.checkMod",
        "data.abilities.cha.checkMod",
      ];
    case "strChecks":
      return "data.abilities.str.checkMod";
    case "dexChecks":
      return "data.abilities.dex.checkMod";
    case "conChecks":
      return "data.abilities.con.checkMod";
    case "intChecks":
      return "data.abilities.int.checkMod";
    case "wisChecks":
      return "data.abilities.wis.checkMod";
    case "chaChecks":
      return "data.abilities.cha.checkMod";
    case "allSpeeds":
      for (let speedKey of Object.keys(curData.attributes.speed)) {
        if (getProperty(curData, `attributes.speed.${speedKey}.base`))
          result.push(`data.attributes.speed.${speedKey}.total`);
      }
      return result;
    case "landSpeed":
      return "data.attributes.speed.land.total";
    case "climbSpeed":
      return "data.attributes.speed.climb.total";
    case "swimSpeed":
      return "data.attributes.speed.swim.total";
    case "burrowSpeed":
      return "data.attributes.speed.burrow.total";
    case "flySpeed":
      return "data.attributes.speed.fly.total";
    case "cmb":
      return "data.attributes.cmb.total";
    case "cmd":
      if (changeType === "dodge") return "data.attributes.cmd.total";
      return ["data.attributes.cmd.total", "data.attributes.cmd.flatFootedTotal"];
    case "init":
      return "data.attributes.init.total";
    case "acpA":
      return "data.attributes.acp.armorBonus";
    case "acpS":
      return "data.attributes.acp.shieldBonus";
    case "mDexA":
      return "data.attributes.mDex.armorBonus";
    case "mDexS":
      return "data.attributes.mDex.shieldBonus";
    case "spellResist":
      return "data.attributes.sr.total";
  }

  if (changeTarget.match(/^skill\.([a-zA-Z0-9]+)$/)) {
    const sklKey = RegExp.$1;
    if (curData.skills[sklKey] != null) {
      return `data.skills.${sklKey}.changeBonus`;
    }
  } else if (changeTarget.match(/^skill\.([a-zA-Z0-9]+)\.subSkills\.([a-zA-Z0-9]+)$/)) {
    const sklKey = RegExp.$1;
    const subSklKey = RegExp.$2;
    if (curData.skills[sklKey]?.subSkills?.[subSklKey] != null) {
      return `data.skills.${sklKey}.subSkills.${subSklKey}.changeBonus`;
    }
  }

  // Try to determine a change flat from hooks
  {
    let result = { keys: [] };
    Hooks.callAll("ffd20.getChangeFlat", changeTarget, changeType, result);
    if (result.keys && result.keys.length) return result.keys;
  }
  return null;
};

const addDefaultChanges = function (changes) {
  // Call hook
  let tempChanges = [];
  Hooks.callAll("ffd20.addDefaultChanges", this, tempChanges);
  changes.push(...tempChanges.filter((c) => c instanceof ItemChange));

  // Class hit points
  const classes = this.data.items
    .filter((o) => o.type === "class" && !["racial"].includes(getProperty(o.data, "data.classType")))
    .sort((a, b) => {
      return a.sort - b.sort;
    });
  const racialHD = this.data.items
    .filter((o) => o.type === "class" && getProperty(o.data, "data.classType") === "racial")
    .sort((a, b) => {
      return a.sort - b.sort;
    });

  const healthConfig = game.settings.get("ffd20", "healthConfig");
  const cls_options = this.data.type === "character" ? healthConfig.hitdice.PC : healthConfig.hitdice.NPC;
  const race_options = healthConfig.hitdice.Racial;
  const round = { up: Math.ceil, nearest: Math.round, down: Math.floor }[healthConfig.rounding];
  const continuous = { discrete: false, continuous: true }[healthConfig.continuity];

  const push_health = (value, source) => {
    changes.push(
      ItemChange.create({
        formula: value.toString(),
        target: "misc",
        subTarget: "mhp",
        modifier: "untypedPerm",
        source: source.name,
      })
    );
    changes.push(
      ItemChange.create({
        formula: value.toString(),
        target: "misc",
        subTarget: "vigor",
        modifier: "untypedPerm",
        source: source.name,
      })
    );
  };
  const manual_health = (health_source) => {
    let health =
      health_source.data.data.hp + (health_source.data.data.classType === "base") * health_source.data.data.fc.hp.value;

    getSourceInfo(this.sourceInfo, "data.attributes.hp.max").positive.push({
      value: health_source.data.data.hp,
      name: game.i18n.format("FFD20.SourceInfoSkillRank_ClassBase", { className: health_source.name }),
    });
    getSourceInfo(this.sourceInfo, "data.attributes.vigor.max").positive.push({
      value: health_source.data.data.hp,
      name: game.i18n.format("FFD20.SourceInfoSkillRank_ClassBase", { className: health_source.name }),
    });
    if (health_source.data.data.fc.hp.value > 0) {
      getSourceInfo(this.sourceInfo, "data.attributes.hp.max").positive.push({
        value: health_source.data.data.fc.hp.value,
        name: game.i18n.format("FFD20.SourceInfoSkillRank_ClassFC", { className: health_source.name }),
      });
      getSourceInfo(this.sourceInfo, "data.attributes.vigor.max").positive.push({
        value: health_source.data.data.fc.hp.value,
        name: game.i18n.format("FFD20.SourceInfoSkillRank_ClassFC", { className: health_source.name }),
      });
    }

    if (!continuous) health = round(health);
    push_health(health, health_source);
  };
  const auto_health = (health_source, options, maximized = 0) => {
    if (health_source.data.hd === 0) return;

    let die_health = 1 + (health_source.data.data.hd - 1) * options.rate;
    if (!continuous) die_health = round(die_health);

    const maxed_health = Math.min(health_source.data.data.level, maximized) * health_source.data.data.hd;
    const level_health = Math.max(0, health_source.data.data.level - maximized) * die_health;
    const favor_health = (health_source.data.data.classType === "base") * health_source.data.data.fc.hp.value;
    let health = maxed_health + level_health + favor_health;

    getSourceInfo(this.sourceInfo, "data.attributes.hp.max").positive.push({
      value: maxed_health + level_health,
      name: game.i18n.format("FFD20.SourceInfoSkillRank_ClassBase", { className: health_source.name }),
    });
    getSourceInfo(this.sourceInfo, "data.attributes.vigor.max").positive.push({
      value: maxed_health + level_health,
      name: game.i18n.format("FFD20.SourceInfoSkillRank_ClassBase", { className: health_source.name }),
    });
    if (health_source.data.data.fc.hp.value > 0) {
      getSourceInfo(this.sourceInfo, "data.attributes.hp.max").positive.push({
        value: health_source.data.data.fc.hp.value,
        name: game.i18n.format("FFD20.SourceInfoSkillRank_ClassFC", { className: health_source.name }),
      });
      getSourceInfo(this.sourceInfo, "data.attributes.vigor.max").positive.push({
        value: health_source.data.data.fc.hp.value,
        name: game.i18n.format("FFD20.SourceInfoSkillRank_ClassFC", { className: health_source.name }),
      });
    }

    push_health(health, health_source);
  };
  const compute_health = (health_sources, options) => {
    // Compute and push health, tracking the remaining maximized levels.
    if (options.auto) {
      let maximized = options.maximized;
      for (const hd of health_sources) {
        auto_health(hd, options, maximized);
        maximized = Math.max(0, maximized - hd.data.data.level);
      }
    } else health_sources.forEach((race) => manual_health(race));
  };

  compute_health(racialHD, race_options);
  compute_health(classes, cls_options);

  // Class mana points, call class and race info from above

  const push_mana = (value, source) => {
    changes.push(
      ItemChange.create({
        formula: value.toString(),
        target: "misc",
        subTarget: "mmp",
        modifier: "untypedPerm",
        source: source.name,
      })
    );

    getSourceInfo(this.sourceInfo, "data.attributes.mp.max").positive.push({
      value: value,
      name: source.name,
    });
  };

  const manual_mana = (mana_source) => {
    let mana = mana_source.data.data.mp === null ? 0 : mana_source.data.data.mp;
    getSourceInfo(this.sourceInfo, "data.attributes.mp.max").positive.push({
      value: mana_source.data.data.mp,
      name: game.i18n.format("FFD20.SourceInfoSkillRank_ClassBase", { className: mana_source.name }),
    });
    push_mana(mana, mana_source);
  };

  const auto_mana = (mana_source) => {
    if (mana_source.data.data.classBaseMPTypes === "noncaster") return;
    if (mana_source.data.data.level === 0) return;
      // figure out how much mp comes from the class
      let mult = 1;
      if (mana_source.data.data.classBaseMPauto === "half") mult = 0.5;
      const manaChart = CONFIG.FFD20.classMPlevels[mana_source.data.data.classBaseMPTypes];
      const level_mana = Math.floor(manaChart[mana_source.data.data.level - 1] * mult);
      getSourceInfo(this.sourceInfo, "data.attributes.mp.max").positive.push({
        value: level_mana,
        name: game.i18n.format("FFD20.SourceInfoSkillRank_ClassBase", { className: mana_source.name }),
      });
      push_mana(level_mana, mana_source);
    };

    /* Compute and push mana, tracking the remaining maximized levels.
     * for each class, check if it is calulating mp or defaulting to manually entered value
     * step 1 - gather all classes
     * step 2 - check for each if it is auto or manual
     * step 3 - pass to correct function
     * step 4 - if manual just add mp to pool
     * step 5 - for auto follow substeps
     * the following is for each class passed to it
     * step 5a - condence relevant variables
     *   MP type: which mp chart does it look at - mana_source.data.classBaseMPTypes
     *   Max spell lvl: which spell prog does it look at - mana_source.data.classBaseMPTypes
     *   level: level of the class - mana_source.data.level
     *   casting stat: what stat(s) are used for it - mana_source.data.classCastingStat
     * pass result
     * else
     * pass manual mp value
     * total results
     */

    // TODO adjust for class autos
    // check each for false or null, do first manual option, if true move to auto

  const compute_mana = (mana_sources) => {
    mana_sources.forEach((mpsource) => {
    if (mpsource.data.data.classBaseMPauto == "no" || mpsource.data.data.classBaseMPauto == null) {
      manual_mana(mpsource);
    } else {
      auto_mana(mpsource);
      }
    });
  };

  compute_mana(racialHD);
  compute_mana(classes);

  // Add class data to saving throws
  const allClasses = [...classes, ...racialHD];
  for (let a of Object.keys(this.data.data.attributes.savingThrows)) {
    const k = `data.attributes.savingThrows.${a}.total`;
    setProperty(this.data, k, getProperty(this.data, `data.attributes.savingThrows.${a}.base`) || 0);
    // Using Fractional Base Bonuses
    if (game.settings.get("ffd20", "useFractionalBaseBonuses")) {
      let highStart = false;
      const total = Math.floor(
        allClasses.reduce((cur, obj) => {
          const saveScale = getProperty(obj.data, `data.savingThrows.${a}.value`) || "";
          if (saveScale === "high") {
            const acc = highStart ? 0 : 2;
            highStart = true;
            return cur + obj.data.data.level / 2 + acc;
          }
          if (saveScale === "low") return cur + obj.data.data.level / 3;
          return cur;
        }, 0)
      );

      // Add change
      changes.push(
        ItemChange.create({
          formula: total.toString(),
          target: "savingThrows",
          subTarget: a,
          modifier: "untypedPerm",
          flavor: game.i18n.localize("FFD20.Base"),
        })
      );
      getSourceInfo(this.sourceInfo, k).positive.push({
        value: total,
        name: game.i18n.localize("FFD20.Base"),
      });
    } else {
      for (let c of allClasses) {
        const classType = getProperty(c.data.data, "classType") || "base";
        let formula = CONFIG.FFD20.classSavingThrowFormulas[classType][c.data.data.savingThrows[a].value];
        if (formula == null) formula = "0";
        const total = Math.floor(RollFFD20.safeRoll(formula, { level: c.data.data.level }).total);

        // Add change
        changes.push(
          ItemChange.create({
            formula: total.toString(),
            target: "savingThrows",
            subTarget: a,
            modifier: "untypedPerm",
            flavor: getProperty(c, "name"),
          })
        );
        getSourceInfo(this.sourceInfo, k).positive.push({
          value: total,
          name: getProperty(c, "name"),
        });
      }
    }
  }

  // Add Constitution to HP
  let hpAbility = getProperty(this.data, "data.attributes.hpAbility");
  if (hpAbility == null) hpAbility = "con";
  if (hpAbility !== "") {
    changes.push(
      ItemChange.create({
        formula: `@abilities.${hpAbility}.mod * @attributes.hd.total`,
        target: "misc",
        subTarget: "mhp",
        modifier: "base",
      })
    );
    getSourceInfo(this.sourceInfo, "data.attributes.hp.max").positive.push({
      formula: `@abilities.${hpAbility}.mod * @attributes.hd.total`,
      name: CONFIG.FFD20.abilities[hpAbility],
    });

    if (!getProperty(this.data, "data.attributes.wounds.base")) {
      const woundFormula = `(@abilities.${hpAbility}.total * 2) + @abilities.${hpAbility}.drain`;
      changes.push(
        ItemChange.create({
          formula: woundFormula,
          target: "misc",
          subTarget: "wounds",
          modifier: "base",
        })
      );
      getSourceInfo(this.sourceInfo, "data.attributes.wounds.max").positive.push({
        formula: woundFormula,
        name: CONFIG.FFD20.abilities[hpAbility],
      });
    }
  }

  // add bonus mp and does it after all stat mods
  classes.forEach((mp_source) => {
    let mpAbility = mp_source.data.data.classCastingStat;
    if (mpAbility == null) mpAbility = "noncaster";
    if (mpAbility === "noncaster") return;
    if (mp_source.data.data.level === 0) return;
    const spellMath = CONFIG.FFD20.ClassSpellLvlProgression[mp_source.data.data.classBaseMPTypes];
    const currentSpellLvl = Math.floor(RollFFD20.safeRoll(spellMath, { level: mp_source.data.data.level }).total);
    let mpProg = CONFIG.FFD20.classMPStatsBonus[currentSpellLvl];
    if (mpAbility !== "") {
      const arrayStr = JSON.stringify(mpProg);
      if (mpAbility === "intAndWis") {
        changes.push(
          ItemChange.create({
            formula: `${arrayStr}[@abilities.int.mod] + ${arrayStr}[@abilities.wis.mod]`,
            target: "misc",
            subTarget: "mmp",
            modifier: "base",
          })
        );
        getSourceInfo(this.sourceInfo, "data.attributes.mp.max").positive.push({
          formula: `${arrayStr}[@abilities.int.mod] + ${arrayStr}[@abilities.wis.mod]`,
          name: `${mp_source.name} ${CONFIG.FFD20.abilities["int"]} & ${CONFIG.FFD20.abilities["wis"]}`,
        });
      } else {
        changes.push(
          ItemChange.create({
            formula: `${arrayStr}[@abilities.${mpAbility}.mod]`,
            target: "misc",
            subTarget: "mmp",
            modifier: "base",
          })
        );
        getSourceInfo(this.sourceInfo, "data.attributes.mp.max").positive.push({
          formula: `${arrayStr}[@abilities.${mpAbility}.mod]`,
          name: `${mp_source.name} ${CONFIG.FFD20.abilities[mpAbility]}`,
        });
      }
    }
  });

  // Add movement speed(s)
  for (let [k, s] of Object.entries(this.data.data.attributes.speed)) {
    let base = s.base;
    if (!base) base = 0;
    changes.push(
      ItemChange.create({
        formula: base.toString(),
        target: "speed",
        subTarget: `${k}Speed`,
        modifier: "base",
        operator: "set",
        priority: 1000,
      })
    );
    if (base > 0) {
      getSourceInfo(this.sourceInfo, `data.attributes.speed.${k}.total`).positive.push({
        value: base,
        name: game.i18n.localize("FFD20.Base"),
      });
    }
  }

  // Add base attack modifiers shared by all attacks
  {
    // BAB to attack
    changes.push(
      ItemChange.create({
        formula: "@attributes.bab.total",
        target: "attack",
        subTarget: "~attackCore",
        modifier: "untypedPerm",
      })
    );
    getSourceInfo(this.sourceInfo, "data.attributes.attack.shared").positive.push({
      formula: "@attributes.bab.total",
      name: game.i18n.localize("FFD20.BAB"),
    });
    // Energy drain to attack
    changes.push(
      ItemChange.create({
        formula: "-@attributes.energyDrain",
        target: "attack",
        subTarget: "~attackCore",
        modifier: "untypedPerm",
      })
    );
    getSourceInfo(this.sourceInfo, "data.attributes.attack.shared").negative.push({
      formula: "-@attributes.energyDrain",
      name: game.i18n.localize("FFD20.CondTypeEnergyDrain"),
    });
    // ACP to attack
    changes.push(
      ItemChange.create({
        formula: "-@attributes.acp.attackPenalty",
        target: "attack",
        subTarget: "~attackCore",
        modifier: "penalty",
      })
    );
    getSourceInfo(this.sourceInfo, "data.attributes.attack.shared").negative.push({
      formula: "-@attributes.acp.attackPenalty",
      name: game.i18n.localize("FFD20.ArmorCheckPenalty"),
    });
  }

  // Add variables to CMD
  {
    // BAB to CMD
    changes.push(
      ItemChange.create({
        formula: "@attributes.bab.total",
        target: "misc",
        subTarget: "cmd",
        modifier: "untypedPerm",
      })
    );
    for (const k of ["total", "flatFootedTotal"]) {
      getSourceInfo(this.sourceInfo, `data.attributes.cmd.${k}`).positive.push({
        formula: "@attributes.bab.total",
        name: game.i18n.localize("FFD20.BAB"),
      });
    }
    // Strength to CMD
    // const abl = getProperty(this.data, "data.attributes.cmd.ability");
    changes.push(
      ItemChange.create({
        formula: `@abilities.str.mod`,
        target: "misc",
        subTarget: "cmd",
        modifier: "untypedPerm",
      })
    );
    for (const k of ["total", "flatFootedTotal"]) {
      getSourceInfo(this.sourceInfo, `data.attributes.cmd.${k}`).positive.push({
        formula: "@abilities.str.mod",
        name: CONFIG.FFD20.abilities["str"],
      });
    }
    // Energy Drain to CMD
    changes.push(
      ItemChange.create({
        formula: "-@attributes.energyDrain",
        target: "misc",
        subTarget: "cmd",
        modifier: "untypedPerm",
        source: game.i18n.localize("FFD20.CondTypeEnergyDrain"),
      })
    );
    for (const k of ["total", "flatFootedTotal"]) {
      getSourceInfo(this.sourceInfo, `data.attributes.cmd.${k}`).negative.push({
        formula: "-@attributes.energyDrain",
        name: game.i18n.localize("FFD20.CondTypeEnergyDrain"),
      });
    }
  }

  // Add Dexterity Modifier to Initiative
  {
    const abl = getProperty(this.data, "data.attributes.init.ability");
    if (abl) {
      changes.push(
        ItemChange.create({
          formula: `@abilities.${abl}.mod`,
          target: "misc",
          subTarget: "init",
          modifier: "untypedPerm",
          priority: -100,
        })
      );
      getSourceInfo(this.sourceInfo, "data.attributes.init.total").positive.push({
        formula: `@abilities.${abl}.mod`,
        name: CONFIG.FFD20.abilities[abl],
      });
    }

    // Add ACP penalty
    if (["str", "dex"].includes(abl)) {
      changes.push(
        ItemChange.create({
          formula: "-@attributes.acp.attackPenalty",
          target: "misc",
          subTarget: "init",
          modifier: "penalty",
          priority: -100,
        })
      );
      getSourceInfo(this.sourceInfo, "data.attributes.init.total").negative.push({
        formula: "-@attributes.acp.attackPenalty",
        name: game.i18n.localize("FFD20.ArmorCheckPenalty"),
      });
    }
  }

  // Add Ability modifiers and Energy Drain to saving throws
  {
    let abl;
    // Ability Mod to Fortitude
    abl = getProperty(this.data, "data.attributes.savingThrows.fort.ability");
    if (abl) {
      changes.push(
        ItemChange.create({
          formula: `@abilities.${abl}.mod`,
          target: "savingThrows",
          subTarget: "fort",
          modifier: "untypedPerm",
          flavor: CONFIG.FFD20.abilities[abl],
        })
      );
      getSourceInfo(this.sourceInfo, "data.attributes.savingThrows.fort.total").positive.push({
        formula: `@abilities.${abl}.mod`,
        name: CONFIG.FFD20.abilities[abl],
      });
    }
    // Ability Mod to Reflex
    abl = getProperty(this.data, "data.attributes.savingThrows.ref.ability");
    if (abl) {
      changes.push(
        ItemChange.create({
          formula: `@abilities.${abl}.mod`,
          target: "savingThrows",
          subTarget: "ref",
          modifier: "untypedPerm",
          flavor: CONFIG.FFD20.abilities[abl],
        })
      );
      getSourceInfo(this.sourceInfo, "data.attributes.savingThrows.ref.total").positive.push({
        formula: `@abilities.${abl}.mod`,
        name: CONFIG.FFD20.abilities[abl],
      });
    }
    // Ability Mod to Will
    abl = getProperty(this.data, "data.attributes.savingThrows.will.ability");
    if (abl) {
      changes.push(
        ItemChange.create({
          formula: `@abilities.${abl}.mod`,
          target: "savingThrows",
          subTarget: "will",
          modifier: "untypedPerm",
          flavor: CONFIG.FFD20.abilities[abl],
        })
      );
      getSourceInfo(this.sourceInfo, "data.attributes.savingThrows.will.total").positive.push({
        formula: `@abilities.${abl}.mod`,
        name: CONFIG.FFD20.abilities[abl],
      });
    }
    // Energy Drain
    changes.push(
      ItemChange.create({
        formula: "-@attributes.energyDrain",
        target: "savingThrows",
        subTarget: "allSavingThrows",
        modifier: "penalty",
        flavor: game.i18n.localize("FFD20.CondTypeEnergyDrain"),
      })
    );
    for (let k of Object.keys(getProperty(this.data, "data.attributes.savingThrows"))) {
      getSourceInfo(this.sourceInfo, `data.attributes.savingThrows.${k}.total`).positive.push({
        formula: "-@attributes.energyDrain",
        name: game.i18n.localize("FFD20.CondTypeEnergyDrain"),
      });
    }
  }
  // Spell Resistance
  {
    const sr = getProperty(this.data, "data.attributes.sr.formula") || 0;
    changes.push(
      ItemChange.create({
        formula: sr.toString(),
        target: "misc",
        subTarget: "spellResist",
        modifier: "base",
        priority: 1000,
      })
    );
    getSourceInfo(this.sourceInfo, "data.attributes.sr.total").positive.push({
      formula: sr,
      name: game.i18n.localize("FFD20.Base"),
    });
  }
  {
    // Carry capacity strength bonus
    const cStr = getProperty(this.data, "data.details.carryCapacity.bonus.user") || 0;
    changes.push(
      ItemChange.create({
        formula: cStr.toString(),
        target: "misc",
        subTarget: "carryStr",
        modifier: "untyped",
        priority: 1000,
      })
    );
    getSourceInfo(this.sourceInfo, "data.details.carryCapacity.bonus.total").positive.push({
      formula: cStr.toString(),
      name: game.i18n.localize("FFD20.Custom"),
    });
    // Carry capacity multiplier
    const cMultBase = getProperty(this.data, "data.details.carryCapacity.multiplier.base") ?? 1;
    changes.push(
      ItemChange.create({
        formula: cMultBase.toString(),
        target: "misc",
        subTarget: "carryMult",
        modifier: "base",
        priority: 1000,
      })
    );
    getSourceInfo(this.sourceInfo, "data.details.carryCapacity.multiplier.total").positive.push({
      formula: cMultBase.toString(),
      name: game.i18n.localize("FFD20.Base"),
    });
    const cMult = getProperty(this.data, "data.details.carryCapacity.multiplier.user") || 0;
    changes.push(
      ItemChange.create({
        formula: cMult.toString(),
        target: "misc",
        subTarget: "carryMult",
        modifier: "untyped",
        priority: 1000,
      })
    );
    getSourceInfo(this.sourceInfo, "data.details.carryCapacity.multiplier.total").positive.push({
      formula: cMult.toString(),
      name: game.i18n.localize("FFD20.Custom"),
    });
  }
  // Natural armor
  {
    const ac = getProperty(this.data, "data.attributes.naturalAC") || 0;
    changes.push(
      ItemChange.create({
        formula: ac.toString(),
        target: "ac",
        subTarget: "nac",
        modifier: "base",
      })
    );
    for (const k of ["normal", "flatFooted"]) {
      getSourceInfo(this.sourceInfo, `data.attributes.ac.${k}.total`).positive.push({
        formula: ac.toString(),
        name: game.i18n.localize("FFD20.BuffTarACNatural"),
      });
    }
  }
  // Add armor bonuses from equipment
  this.data.items
    .filter((obj) => {
      return obj.type === "equipment" && obj.data.data.equipped;
    })
    .forEach((item) => {
      let armorTarget = "aac";
      if (item.data.data.equipmentType === "shield") armorTarget = "sac";
      // Push base armor
      if (item.data.data.armor.value) {
        let ac = item.data.data.armor.value;
        if (item.data.data.broken) ac = Math.floor(ac / 2);
        ac += item.data.data.armor.enh;
        changes.push(
          ItemChange.create({
            formula: ac.toString(),
            target: "ac",
            subTarget: armorTarget,
            modifier: "base",
          })
        );
        for (let k of ["normal", "flatFooted"]) {
          getSourceInfo(this.sourceInfo, `data.attributes.ac.${k}.total`).positive.push({
            value: ac,
            name: item.name,
            type: item.type,
          });
        }
      }
    });

  // Add fly bonuses or penalties based on maneuverability
  {
    const flyKey = getProperty(this.data, "data.attributes.speed.fly.maneuverability");
    let flyValue = 0;
    if (flyKey != null) flyValue = CONFIG.FFD20.flyManeuverabilityValues[flyKey];
    if (flyValue !== 0) {
      changes.push(
        ItemChange.create({
          formula: flyValue.toString(),
          target: "skill",
          subTarget: "skill.fly",
          modifier: "racial",
        })
      );
      getSourceInfo(this.sourceInfo, "data.skills.fly.changeBonus").positive.push({
        value: flyValue,
        name: game.i18n.localize("FFD20.FlyManeuverability"),
      });
    }
  }
  // Add swim and climb skill bonuses based on having speeds for them
  {
    changes.push(
      ItemChange.create({
        formula: "@attributes.speed.climb.total > 0 ? 8 : 0",
        target: "skill",
        subTarget: "skill.clm",
        modifier: "racial",
        priority: -1,
      })
    );
    getSourceInfo(this.sourceInfo, "data.skills.clm.changeBonus").positive.push({
      formula: "@attributes.speed.climb.total > 0 ? 8 : 0",
      name: game.i18n.localize("FFD20.SpeedClimb"),
    });

    changes.push(
      ItemChange.create({
        formula: "@attributes.speed.swim.total > 0 ? 8 : 0",
        target: "skill",
        subTarget: "skill.swm",
        modifier: "racial",
        priority: -1,
      })
    );
    getSourceInfo(this.sourceInfo, "data.skills.swm.changeBonus").positive.push({
      formula: "@attributes.speed.swim.total > 0 ? 8 : 0",
      name: game.i18n.localize("FFD20.SpeedSwim"),
    });
  }

  // Add energy drain to skills
  {
    changes.push(
      ItemChange.create({
        formula: "-@attributes.energyDrain",
        target: "skills",
        subTarget: "skills",
        modifier: "untypedPerm",
        flavor: game.i18n.localize("FFD20.CondTypeEnergyDrain"),
      })
    );
    const flats = getChangeFlat.call(this, "skills", "untyped");
    for (let f of flats) {
      getSourceInfo(this.sourceInfo, f).positive.push({
        formula: "-@attributes.energyDrain",
        name: game.i18n.localize("FFD20.CondTypeEnergyDrain"),
      });
    }
  }

  // Add size bonuses to various attributes
  const sizeKey = this.data.data.traits.size;
  if (sizeKey !== "med") {
    // AC
    changes.push(
      ItemChange.create({
        formula: CONFIG.FFD20.sizeMods[sizeKey].toString(),
        target: "ac",
        subTarget: "ac",
        modifier: "size",
      })
    );
    for (const k of ["normal", "touch", "flatFooted"]) {
      getSourceInfo(this.sourceInfo, `data.attributes.ac.${k}.total`).positive.push({
        value: CONFIG.FFD20.sizeMods[sizeKey],
        type: "size",
      });
    }
    // Stealth skill
    changes.push(
      ItemChange.create({
        formula: CONFIG.FFD20.sizeStealthMods[sizeKey].toString(),
        target: "skill",
        subTarget: "skill.ste",
        modifier: "size",
      })
    );
    getSourceInfo(this.sourceInfo, "data.skills.ste.changeBonus").positive.push({
      value: CONFIG.FFD20.sizeStealthMods[sizeKey],
      type: "size",
    });
    // Fly skill
    changes.push(
      ItemChange.create({
        formula: CONFIG.FFD20.sizeFlyMods[sizeKey].toString(),
        target: "skill",
        subTarget: "skill.fly",
        modifier: "size",
      })
    );
    getSourceInfo(this.sourceInfo, "data.skills.fly.changeBonus").positive.push({
      value: CONFIG.FFD20.sizeFlyMods[sizeKey],
      type: "size",
    });
    // CMD
    changes.push(
      ItemChange.create({
        formula: CONFIG.FFD20.sizeSpecialMods[sizeKey].toString(),
        target: "misc",
        subTarget: "cmd",
        modifier: "size",
      })
    );
    for (let k of ["total", "flatFootedTotal"]) {
      getSourceInfo(this.sourceInfo, `data.attributes.cmd.${k}`).positive.push({
        value: CONFIG.FFD20.sizeSpecialMods[sizeKey],
        type: "size",
      });
    }
  }

  // Add conditions
  for (let [con, v] of Object.entries(this.data.data.attributes.conditions || {})) {
    if (!v) continue;

    switch (con) {
      case "ffd20_blind":
        changes.push(
          ItemChange.create({
            formula: "-2",
            target: "ac",
            subTarget: "ac",
            modifier: "penalty",
          })
        );
        this.flags["loseDexToAC"] = true;

        for (let k of [
          "data.attributes.ac.normal.total",
          "data.attributes.ac.touch.total",
          "data.attributes.ac.flatFooted.total",
          "data.attributes.cmd.total",
          "data.attributes.cmd.flatFootedTotal",
        ]) {
          getSourceInfo(this.sourceInfo, k).negative.push({
            value: -2,
            name: game.i18n.localize("FFD20.CondBlind"),
          });
        }
        for (let k of [
          "data.attributes.ac.normal.total",
          "data.attributes.ac.touch.total",
          "data.attributes.cmd.total",
          "data.attributes.cmd.flatFootedTotal",
        ]) {
          getSourceInfo(this.sourceInfo, k).negative.push({
            value: game.i18n.localize("FFD20.ChangeFlagLoseDexToAC"),
            name: game.i18n.localize("FFD20.CondBlind"),
          });
        }
        break;
      case "cowering":
        changes.push(
          ItemChange.create({
            formula: "-2",
            target: "ac",
            subTarget: "ac",
            modifier: "penalty",
          })
        );
        for (const k of Object.keys(this.data.data.attributes.ac)) {
          getSourceInfo(this.sourceInfo, `data.attributes.ac.${k}.total`).negative.push({
            value: -2,
            name: game.i18n.localize("FFD20.CondCowering"),
          });
        }
        this.flags["loseDexToAC"] = true;
        getSourceInfo(this.sourceInfo, "data.attributes.ac.normal.total").negative.push({
          name: game.i18n.localize("FFD20.CondCowering"),
          value: game.i18n.localize("FFD20.ChangeFlagLoseDexToAC"),
        });
        getSourceInfo(this.sourceInfo, "data.attributes.ac.touch.total").negative.push({
          name: game.i18n.localize("FFD20.CondCowering"),
          value: game.i18n.localize("FFD20.ChangeFlagLoseDexToAC"),
        });
        getSourceInfo(this.sourceInfo, "data.attributes.cmd.total").negative.push({
          name: game.i18n.localize("FFD20.CondCowering"),
          value: game.i18n.localize("FFD20.ChangeFlagLoseDexToAC"),
        });
        break;
      case "dazzled":
        changes.push(
          ItemChange.create({
            formula: "-1",
            target: "attack",
            subTarget: "attack",
            modifier: "penalty",
          })
        );
        getSourceInfo(this.sourceInfo, "data.attributes.attack.general").negative.push({
          value: -1,
          name: game.i18n.localize("FFD20.CondDazzled"),
        });
        break;
      case "ffd20_deaf":
        changes.push(
          ItemChange.create({
            formula: "-4",
            target: "misc",
            subTarget: "init",
            modifier: "penalty",
          })
        );
        getSourceInfo(this.sourceInfo, "data.attributes.init.total").negative.push({
          value: -4,
          name: game.i18n.localize("FFD20.CondDeaf"),
        });
        break;
      case "entangled":
        changes.push(
          ItemChange.create({
            formula: "-4",
            target: "ability",
            subTarget: "dex",
            modifier: "penalty",
          })
        );
        getSourceInfo(this.sourceInfo, "data.abilities.dex.total").negative.push({
          value: -4,
          name: game.i18n.localize("FFD20.CondEntangled"),
        });

        changes.push(
          ItemChange.create({
            formula: "-2",
            target: "attack",
            subTarget: "attack",
            modifier: "penalty",
          })
        );
        getSourceInfo(this.sourceInfo, "data.attributes.attack.general").negative.push({
          value: -2,
          name: game.i18n.localize("FFD20.CondEntangled"),
        });
        break;
      case "grappled":
        changes.push(
          ItemChange.create({
            formula: "-4",
            target: "ability",
            subTarget: "dex",
            modifier: "penalty",
          })
        );
        getSourceInfo(this.sourceInfo, "data.abilities.dex.total").negative.push({
          value: -4,
          name: game.i18n.localize("FFD20.CondGrappled"),
        });

        changes.push(
          ItemChange.create({
            formula: "-2",
            target: "attack",
            subTarget: "attack",
            modifier: "penalty",
          })
        );
        getSourceInfo(this.sourceInfo, "data.attributes.attack.general").negative.push({
          value: -2,
          name: game.i18n.localize("FFD20.CondGrappled"),
        });

        changes.push(
          ItemChange.create({
            formula: "-2",
            target: "misc",
            subTarget: "cmb",
            modifier: "penalty",
          })
        );
        getSourceInfo(this.sourceInfo, "data.attributes.cmb.total").negative.push({
          value: -2,
          name: game.i18n.localize("FFD20.CondGrappled"),
        });
        break;
      case "helpless":
        changes.push(
          ItemChange.create({
            formula: "0",
            target: "ability",
            subTarget: "dex",
            modifier: "untypedPerm",
            operator: "set",
            priority: -1000,
          })
        );
        getSourceInfo(this.sourceInfo, "data.abilities.dex.total").negative.push({
          name: game.i18n.localize("FFD20.CondHelpless"),
          value: game.i18n.localize("FFD20.ChangeFlagNoDex"),
        });
        break;
      case "ffd20_sleep":
        changes.push(
          ItemChange.create({
            formula: "0",
            target: "ability",
            subTarget: "dex",
            modifier: "untypedPerm",
            operator: "set",
            priority: -1000,
          })
        );
        getSourceInfo(this.sourceInfo, "data.abilities.dex.total").negative.push({
          name: game.i18n.localize("FFD20.CondSleep"),
          value: game.i18n.localize("FFD20.ChangeFlagNoDex"),
        });
        break;
      case "paralyzed":
        changes.push(
          ItemChange.create({
            formula: "0",
            target: "ability",
            subTarget: "dex",
            modifier: "untypedPerm",
            operator: "set",
            priority: -1000,
          })
        );
        changes.push(
          ItemChange.create({
            formula: "0",
            target: "ability",
            subTarget: "str",
            modifier: "untypedPerm",
            operator: "set",
            priority: -1000,
          })
        );
        getSourceInfo(this.sourceInfo, "data.abilities.dex.total").negative.push({
          name: game.i18n.localize("FFD20.CondParalyzed"),
          value: game.i18n.localize("FFD20.ChangeFlagNoDex"),
        });
        getSourceInfo(this.sourceInfo, "data.abilities.str.total").negative.push({
          name: game.i18n.localize("FFD20.CondParalyzed"),
          value: game.i18n.localize("FFD20.ChangeFlagNoStr"),
        });
        break;
      case "ffd20_prone":
        changes.push(
          ItemChange.create({
            formula: "-4",
            target: "attack",
            subTarget: "mattack",
            modifier: "penalty",
          })
        );
        getSourceInfo(this.sourceInfo, "data.attributes.attack.melee").negative.push({
          name: game.i18n.localize("FFD20.CondProne"),
          value: -4,
        });
        break;
      case "pinned":
        changes.push(
          ItemChange.create({
            formula: "min(0, @abilities.dex.mod)",
            target: "ability",
            subTarget: "dexMod",
            modifier: "untyped",
            operator: "set",
            flavor: game.i18n.localize("FFD20.CondPinned"),
            priority: 1001,
          })
        );
        this.flags["loseDexToAC"] = true;
        getSourceInfo(this.sourceInfo, "data.abilities.dex.total").negative.push({
          name: game.i18n.localize("FFD20.CondPinned"),
          value: game.i18n.localize("FFD20.DenyDexBonus"),
        });
        for (const k of [
          "data.attributes.ac.normal.total",
          "data.attributes.ac.touch.total",
          "data.attributes.cmd.total",
        ]) {
          getSourceInfo(this.sourceInfo, k).negative.push({
            name: game.i18n.localize("FFD20.CondPinned"),
            value: game.i18n.localize("FFD20.ChangeFlagLoseDexToAC"),
          });
        }

        changes.push(
          ItemChange.create({
            formula: "-4",
            target: "ac",
            subTarget: "ac",
            modifier: "penalty",
          })
        );
        changes.push(
          ItemChange.create({
            formula: "-4",
            target: "misc",
            subTarget: "cmd",
            modifier: "penalty",
          })
        );
        for (const k of [
          "data.attributes.ac.normal.total",
          "data.attributes.ac.touch.total",
          "data.attributes.ac.flatFooted.total",
          "data.attributes.cmd.total",
          "data.attributes.cmd.flatFootedTotal",
        ]) {
          getSourceInfo(this.sourceInfo, k).negative.push({
            name: game.i18n.localize("FFD20.CondPinned"),
            value: -4,
          });
        }
        break;
      case "shaken":
        changes.push(
          ItemChange.create({
            formula: "-2",
            target: "attack",
            subTarget: "attack",
            modifier: "penalty",
          })
        );
        getSourceInfo(this.sourceInfo, "data.attributes.attack.general").negative.push({
          value: -2,
          name: game.i18n.localize("FFD20.CondShaken"),
        });

        changes.push(
          ItemChange.create({
            formula: "-2",
            target: "savingThrows",
            subTarget: "allSavingThrows",
            modifier: "penalty",
          })
        );
        for (let k of Object.keys(this.data.data.attributes.savingThrows)) {
          getSourceInfo(this.sourceInfo, `data.attributes.savingThrows.${k}.total`).negative.push({
            value: -2,
            name: game.i18n.localize("FFD20.CondShaken"),
          });
        }

        {
          changes.push(
            ItemChange.create({
              formula: "-2",
              target: "skills",
              subTarget: "skills",
              modifier: "penalty",
            })
          );
          const flats = getChangeFlat.call(this, "skills", "penalty");
          for (let f of flats) {
            getSourceInfo(this.sourceInfo, f).negative.push({
              value: -2,
              name: game.i18n.localize("FFD20.CondShaken"),
            });
          }
        }

        {
          changes.push(
            ItemChange.create({
              formula: "-2",
              target: "abilityChecks",
              subTarget: "allChecks",
              modifier: "penalty",
            })
          );
          const flats = getChangeFlat.call(this, "allChecks", "penalty");
          for (let f of flats) {
            getSourceInfo(this.sourceInfo, f).negative.push({
              value: -2,
              name: game.i18n.localize("FFD20.CondShaken"),
            });
          }
        }
        break;
      case "frightened":
        changes.push(
          ItemChange.create({
            formula: "-2",
            target: "attack",
            subTarget: "attack",
            modifier: "penalty",
          })
        );
        getSourceInfo(this.sourceInfo, "data.attributes.attack.general").negative.push({
          value: -2,
          name: game.i18n.localize("FFD20.CondFrightened"),
        });

        changes.push(
          ItemChange.create({
            formula: "-2",
            target: "savingThrows",
            subTarget: "allSavingThrows",
            modifier: "penalty",
          })
        );
        for (let k of Object.keys(this.data.data.attributes.savingThrows)) {
          getSourceInfo(this.sourceInfo, `data.attributes.savingThrows.${k}.total`).negative.push({
            value: -2,
            name: game.i18n.localize("FFD20.CondFrightened"),
          });
        }

        {
          changes.push(
            ItemChange.create({
              formula: "-2",
              target: "skills",
              subTarget: "skills",
              modifier: "penalty",
            })
          );
          const flats = getChangeFlat.call(this, "skills", "penalty");
          for (let f of flats) {
            getSourceInfo(this.sourceInfo, f).negative.push({
              value: -2,
              name: game.i18n.localize("FFD20.CondFrightened"),
            });
          }
        }

        {
          changes.push(
            ItemChange.create({
              formula: "-2",
              target: "abilityChecks",
              subTarget: "allChecks",
              modifier: "penalty",
            })
          );
          const flats = getChangeFlat.call(this, "allChecks", "penalty");
          for (let f of flats) {
            getSourceInfo(this.sourceInfo, f).negative.push({
              value: -2,
              name: game.i18n.localize("FFD20.CondFrightened"),
            });
          }
        }
        break;
      case "panicked":
        changes.push(
          ItemChange.create({
            formula: "-2",
            target: "attack",
            subTarget: "attack",
            modifier: "penalty",
            flavor: game.i18n.localize("FFD20.CondFear"),
          })
        );
        getSourceInfo(this.sourceInfo, "data.attributes.attack.general").negative.push({
          value: -2,
          name: game.i18n.localize("FFD20.CondFear"),
        });

        changes.push(
          ItemChange.create({
            formula: "-2",
            target: "savingThrows",
            subTarget: "allSavingThrows",
            modifier: "penalty",
          })
        );
        for (let k of Object.keys(this.data.data.attributes.savingThrows)) {
          getSourceInfo(this.sourceInfo, `data.attributes.savingThrows.${k}.total`).negative.push({
            value: -2,
            name: game.i18n.localize("FFD20.CondFear"),
          });
        }

        {
          changes.push(
            ItemChange.create({
              formula: "-2",
              target: "skills",
              subTarget: "skills",
              modifier: "penalty",
            })
          );
          const flats = getChangeFlat.call(this, "skills", "penalty");
          for (let f of flats) {
            getSourceInfo(this.sourceInfo, f).negative.push({
              value: -2,
              name: game.i18n.localize("FFD20.CondFear"),
            });
          }
        }

        {
          changes.push(
            ItemChange.create({
              formula: "-2",
              target: "abilityChecks",
              subTarget: "allChecks",
              modifier: "penalty",
            })
          );
          const flats = getChangeFlat.call(this, "allChecks", "penalty");
          for (let f of flats) {
            getSourceInfo(this.sourceInfo, f).negative.push({
              value: -2,
              name: game.i18n.localize("FFD20.CondFear"),
            });
          }
        }
        break;
      case "sickened":
        changes.push(
          ItemChange.create({
            formula: "-2",
            target: "attack",
            subTarget: "attack",
            modifier: "penalty",
            flavor: game.i18n.localize("FFD20.CondSickened"),
          })
        );
        getSourceInfo(this.sourceInfo, "data.attributes.attack.general").negative.push({
          value: -2,
          name: game.i18n.localize("FFD20.CondSickened"),
        });

        changes.push(
          ItemChange.create({
            formula: "-2",
            target: "damage",
            subTarget: "wdamage",
            modifier: "penalty",
          })
        );
        getSourceInfo(this.sourceInfo, "data.attributes.damage.weapon").negative.push({
          value: -2,
          name: game.i18n.localize("FFD20.CondSickened"),
        });

        changes.push(
          ItemChange.create({
            formula: "-2",
            target: "savingThrows",
            subTarget: "allSavingThrows",
            modifier: "penalty",
          })
        );
        for (let k of Object.keys(this.data.data.attributes.savingThrows)) {
          getSourceInfo(this.sourceInfo, `data.attributes.savingThrows.${k}.total`).negative.push({
            value: -2,
            name: game.i18n.localize("FFD20.CondSickened"),
          });
        }

        {
          changes.push(
            ItemChange.create({
              formula: "-2",
              target: "skills",
              subTarget: "skills",
              modifier: "penalty",
            })
          );
          const flats = getChangeFlat.call(this, "skills", "penalty");
          for (let f of flats) {
            getSourceInfo(this.sourceInfo, f).negative.push({
              value: -2,
              name: game.i18n.localize("FFD20.CondSickened"),
            });
          }
        }

        {
          changes.push(
            ItemChange.create({
              formula: "-2",
              target: "abilityChecks",
              subTarget: "allChecks",
              modifier: "penalty",
            })
          );
          const flats = getChangeFlat.call(this, "allChecks", "penalty");
          for (let f of flats) {
            getSourceInfo(this.sourceInfo, f).negative.push({
              value: -2,
              name: game.i18n.localize("FFD20.CondSickened"),
            });
          }
        }
        break;
      case "stunned":
        changes.push(
          ItemChange.create({
            formula: "-2",
            target: "ac",
            subTarget: "ac",
            modifier: "penalty",
          })
        );
        for (const k of Object.keys(this.data.data.attributes.ac)) {
          getSourceInfo(this.sourceInfo, `data.attributes.ac.${k}.total`).negative.push({
            value: -2,
            name: game.i18n.localize("FFD20.CondStunned"),
          });
        }
        this.flags["loseDexToAC"] = true;
        getSourceInfo(this.sourceInfo, "data.attributes.ac.normal.total").negative.push({
          name: game.i18n.localize("FFD20.CondStunned"),
          value: game.i18n.localize("FFD20.ChangeFlagLoseDexToAC"),
        });
        getSourceInfo(this.sourceInfo, "data.attributes.ac.touch.total").negative.push({
          name: game.i18n.localize("FFD20.CondStunned"),
          value: game.i18n.localize("FFD20.ChangeFlagLoseDexToAC"),
        });
        getSourceInfo(this.sourceInfo, "data.attributes.cmd.total").negative.push({
          name: game.i18n.localize("FFD20.CondStunned"),
          value: game.i18n.localize("FFD20.ChangeFlagLoseDexToAC"),
        });
        break;
      case "slow":
          changes.push(
            ItemChange.create({
              formula: "-1",
              target: "attack",
              subTarget: "attack",
              modifier: "penalty",
            })
          );
          getSourceInfo(this.sourceInfo, "data.attributes.attack.general").negative.push({
            value: -1,
            name: game.i18n.localize("FFD20.Condslow"),
          });

          changes.push(
            ItemChange.create({
              formula: "-1",
              target: "savingThrows",
              subTarget: "ref",
              modifier: "penalty",
            })
          );
          for (let k of Object.keys(this.data.data.attributes.savingThrows)) {
            getSourceInfo(this.sourceInfo, `data.attributes.savingThrows.${k}.total`).negative.push({
              value: -1,
              name: game.i18n.localize("FFD20.CondSlow"),
            });
          }
          changes.push(
            ItemChange.create({
              formula: "-1",
              target: "ac",
              subTarget: "ac",
              modifier: "penalty",
            })
          );
          for (const k of Object.keys(this.data.data.attributes.ac)) {
            getSourceInfo(this.sourceInfo, `data.attributes.ac.${k}.total`).negative.push({
              value: -1,
              name: game.i18n.localize("FFD20.CondSlow"),
            });
          }
          break;
      }
  }

  // Handle fatigue and exhaustion so that they don't stack
  if (this.data.data.attributes.conditions.exhausted) {
    changes.push(
      ItemChange.create({
        formula: "-6",
        target: "ability",
        subTarget: "str",
        modifier: "penalty",
      })
    );
    getSourceInfo(this.sourceInfo, "data.abilities.str.total").negative.push({
      value: -6,
      name: game.i18n.localize("FFD20.CondExhausted"),
    });

    changes.push(
      ItemChange.create({
        formula: "-6",
        target: "ability",
        subTarget: "dex",
        modifier: "penalty",
      })
    );
    getSourceInfo(this.sourceInfo, "data.abilities.dex.total").negative.push({
      value: -6,
      name: game.i18n.localize("FFD20.CondExhausted"),
    });
  } else if (this.data.data.attributes.conditions.fatigued) {
    changes.push(
      ItemChange.create({
        formula: "-2",
        target: "ability",
        subTarget: "str",
        modifier: "penalty",
      })
    );
    getSourceInfo(this.sourceInfo, "data.abilities.str.total").negative.push({
      value: -2,
      name: game.i18n.localize("FFD20.CondFatigued"),
    });

    changes.push(
      ItemChange.create({
        formula: "-2",
        target: "ability",
        subTarget: "dex",
        modifier: "penalty",
      })
    );
    getSourceInfo(this.sourceInfo, "data.abilities.dex.total").negative.push({
      value: -2,
      name: game.i18n.localize("FFD20.CondFatigued"),
    });
  }

  // Apply level drain to hit points
  if (!Number.isNaN(this.data.data.attributes.energyDrain) && this.data.data.attributes.energyDrain > 0) {
    changes.push(
      ItemChange.create({
        formula: "-(@attributes.energyDrain * 5)",
        target: "misc",
        subTarget: "mhp",
        modifier: "untyped",
        priority: -750,
      })
    );
    getSourceInfo(this.sourceInfo, "data.attributes.hp.max").negative.push({
      formula: "-(@attributes.energyDrain * 5)",
      name: game.i18n.localize("FFD20.CondTypeEnergyDrain"),
    });

    changes.push(
      ItemChange.create({
        formula: "-(@attributes.energyDrain * 5)",
        target: "misc",
        subTarget: "vigor",
        modifier: "untyped",
        priority: -750,
      })
    );
    getSourceInfo(this.sourceInfo, "data.attributes.vigor.max").negative.push({
      formula: "-(@attributes.energyDrain * 5)",
      name: game.i18n.localize("FFD20.CondTypeEnergyDrain"),
    });
  }
};

const resetSkills = function () {
  const skills = this.data.data.skills;

  for (const [sklKey, skl] of Object.entries(skills)) {
    if (!skl) continue;

    let acpPenalty = skl.acp ? this.data.data.attributes.acp.total : 0;
    let ablMod = this.data.data.abilities[skl.ability].mod || 0;
    let specificSkillBonus = skl.changeBonus || 0;

    // Parse main skills
    let sklValue = skl.rank + (skl.cs && skl.rank > 0 ? 3 : 0) + ablMod + specificSkillBonus - acpPenalty;
    setProperty(this.data, `data.skills.${sklKey}.mod`, sklValue);

    // Parse sub-skills
    for (const [subSklKey, subSkl] of Object.entries(skl.subSkills || {})) {
      if (!subSkl) continue;
      if (!getProperty(this.data, `data.skills.${sklKey}.subSkills.${subSklKey}`)) continue;

      acpPenalty = subSkl.acp ? this.data.data.attributes.acp.total : 0;
      ablMod = this.data.data.abilities[subSkl.ability].mod || 0;
      specificSkillBonus = subSkl.changeBonus || 0;
      sklValue = subSkl.rank + (subSkl.cs && subSkl.rank > 0 ? 3 : 0) + ablMod + specificSkillBonus - acpPenalty;
      setProperty(this.data, `data.skills.${sklKey}.subSkills.${subSklKey}.mod`, sklValue);
    }
  }
};

const getSourceInfo = function (obj, key) {
  if (!obj[key]) {
    obj[key] = { negative: [], positive: [] };
  }
  return obj[key];
};

const setSourceInfoByName = function (obj, key, name, value, positive = true) {
  const target = positive ? "positive" : "negative";
  const sourceInfo = getSourceInfo(obj, key)[target];
  const data = sourceInfo.find((o) => o.name === name);
  if (data) data.value = value;
  else {
    sourceInfo.push({
      name: name,
      value: value,
    });
  }
};

/**
 * @param {ItemChange[]} changes - An array containing all changes to check. Must be called after they received a value (by ItemChange.applyChange)
 * @param options
 * @returns {ItemChange[]} - A list of processed changes, excluding the lower-valued ones inserted (if they don't stack)
 */
const getHighestChanges = function (changes, options = { ignoreTarget: false }) {
  const highestTemplate = {
    value: 0,
    ids: [],
    highestID: null,
  };
  const highest = Object.keys(CONFIG.FFD20.bonusModifiers).reduce((cur, k) => {
    if (options.ignoreTarget) cur[k] = duplicate(highestTemplate);
    else cur[k] = {};
    return cur;
  }, {});

  for (let c of changes) {
    let h;
    if (options.ignoreTarget) h = highest[c.modifier];
    else h = highest[c.modifier][c.subTarget];

    h.ids.push(c._id);
    if (h.value < c.value || !h.highestID) {
      h.value = c.value;
      h.highestID = c._id;
    }
  }

  {
    let mod, h;
    const filterFunc = function (c) {
      if (h.highestID === c._id) return true;
      if (CONFIG.FFD20.stackingBonusModifiers.indexOf(mod) === -1 && h.ids.includes(c._id)) return false;
      return true;
    };

    for (mod of Object.keys(highest)) {
      if (options.ignoreTarget) {
        h = highest[mod];
        changes = changes.filter(filterFunc);
      } else {
        for (let subTarget of Object.keys(highest[mod])) {
          h = highest[mod][subTarget];
          changes = changes.filter(filterFunc);
        }
      }
    }
  }

  return changes;
};

class VisionPermissionSheet extends FormApplication {
  constructor(object, options) {
    super(object, options);

    // Register the sheet as an active Application for the Entity
    this.object.apps[this.appId] = this;
  }

  static get defaultOptions() {
    return mergeObject(super.defaultOptions, {
      classes: ["sheet", "vision-permission"],
      template: "systems/ffd20/templates/apps/vision-permission.hbs",
      width: 300,
      height: "auto",
      closeOnSubmit: true,
      submitOnClose: false,
      submitOnChange: false,
    });
  }

  get title() {
    return this.token && !this.token.data.actorLink
      ? `Vision Permissions: [Token] ${this.object.name}`
      : `Vision Permissions: ${this.object.name}`;
  }
  get isLinkedToken() {
    return this.token ? this.token.data.actorLink : false;
  }

  async _updateObject(event, formData) {
    await this.object.setFlag("ffd20", "visionPermission", formData);
    game.socket.emit("system.ffd20", { eventType: "redrawCanvas" });
  }

  async getData() {
    let data = super.getData();
    data = mergeObject(data, this.object.getFlag("ffd20", "visionPermission"));
    data.users = data.users || {};

    data.defaultLevels = [
      { level: "no", name: game.i18n.localize("FFD20.No") },
      { level: "yes", name: game.i18n.localize("FFD20.Yes") },
    ];
    data.levels = [{ level: "default", name: game.i18n.localize("FFD20.Default") }, ...data.defaultLevels];
    if (data.default == null) data.default = "no";

    data.users = game.users.reduce((cur, o) => {
      if (!o.isGM) {
        cur[o._id] = {
          user: o,
          level: data.users[o._id]?.level || "default",
          hidden: false,
        };
      }

      return cur;
    }, {});

    return data;
  }
}

/**
 * Check if a Token can be a vison source for the current user (due to shared vision).
 *
 * @param {Token} token - The Token
 * @returns {boolean} Whether token is a possible vision source
 */
const hasTokenVision = function (token) {
  if (!token.actor) return false;
  if (token.actor.testUserPermission(game.user, "OWNER")) return true;

  const visionFlag = token.actor.getFlag("ffd20", "visionPermission");
  if (!visionFlag || !visionFlag.users[game.user._id]) return false;
  if (visionFlag.users[game.user._id].level === "yes") return true;
  if (visionFlag.users[game.user._id].level === "default" && visionFlag.default === "yes") return true;

  return false;
};

/**
 * Extend the base Actor class to implement additional game system logic.
 */
class ActorFFD20 extends Actor {
  constructor(...args) {
    super(...args);

    /**
     * A list of all the active items with changes.
     *
     * @property
     * @type {Array}
     */
    if (this.changeItems === undefined) this.changeItems = [];

    /**
     * Stores all ItemChanges from carried items.
     *
     * @property
     * @public
     * @type {object}
     */
    if (this.changes === undefined) this.changes = new Collection();

    /**
     * Stores updates to be applied to the actor near the end of the _onUpdate method.
     *
     * @property
     * @private
     * @type {object.<string, any>}
     */
    if (this._queuedUpdates === undefined) this._queuedUpdates = {};

    /**
     * @property {object} _rollData
     * Cached roll data for this item.
     */
    if (this._rollData === undefined) this._rollData = null;

    /**
     * @property {object.<string>} _runningFunctions
     * Keeps track of currently running async functions that shouldn't run multiple times simultaneously.
     */
    if (this._runningFunctions === undefined) this._runningFunctions = {};

    /**
     * @property {object} _queuedItemUpdates
     * A dictionary of item IDs and the data to update. Will be called once this actor has been updated, and immediately cleared.
     */
    if (this._queuedItemUpdates === undefined) this._queuedItemUpdates = {};

    /**
     * @property {ItemFFD20[]} containerItems
     * All items this actor is holding in containers.
     */
    if (this.containerItems === undefined) this.containerItems = [];

    /**
     * @property {object} _prevAttributes
     * A list of attributes to remember between updates.
     */
    if (this._prevAttributes === undefined) this._prevAttributes = null;
  }

  /* -------------------------------------------- */

  static chatListeners(html) {
    html.on("click", "button[data-action], a[data-action]", this._onChatCardButtonAction.bind(this));
  }

  static async _onChatCardButtonAction(event) {
    event.preventDefault();

    // Extract card data
    const button = event.currentTarget;
    const card = button.closest(".chat-card");
    const action = button.dataset.action;

    // Roll saving throw
    if (action === "defense-save") {
      const actor = await ItemFFD20._getChatCardActor(card);
      const saveId = button.dataset.save;
      if (actor) actor.rollSavingThrow(saveId, { event: event, skipPrompt: getSkipActionPrompt() });
    } else if (action === "save") {
      const actors = ActorFFD20.getSelectedActors();
      const saveId = button.dataset.type;
      let noSound = false;
      for (let a of actors) {
        a[0].rollSavingThrow(saveId, { event: event, noSound: noSound, skipPrompt: getSkipActionPrompt() });
        noSound = true;
      }
    }
    // Show compendium entry
    else if (action === "open-compendium-entry") {
      const entryKey = button.dataset.compendiumEntry;
      const parts = entryKey.split(".");
      const packKey = parts.slice(0, 2).join(".");
      const entryId = parts.slice(-1)[0];
      const pack = game.packs.get(packKey);
      const entry = await pack.getDocument(entryId);
      entry.sheet.render(true);
    }
  }

  static getActiveActor({ actorName = null, actorId = null } = {}) {
    const speaker = ChatMessage.getSpeaker();
    let actor;

    if (actorName || actorId) {
      actor = game.actors.contents.find((o) => {
        if (actorName && o.name !== actorName) return false;
        if (actorId && o.id !== actorId) return false;
        return true;
      });
    }
    if (speaker.token && !actor) actor = canvas.tokens.placeables.find((o) => o.id === speaker.token)?.actor;
    if (!actor) actor = game.actors.get(speaker.actor);

    return actor;
  }

  /**
   * Returns an array of all selected tokens, along with their actors.
   *
   * @returns {Array.<ActorFFD20, Token>[]}
   */
  static getSelectedActors() {
    let result = [];
    for (let t of canvas.tokens.controlled) {
      result.push([t.actor, t]);
    }
    return result;
  }

  /* -------------------------------------------- */

  get spellFailure() {
    return this.items
      .filter((o) => {
        return o.type === "equipment" && o.data.data.equipped === true;
      })
      .reduce((cur, o) => {
        if (typeof o.data.data.spellFailure === "number") return cur + o.data.data.spellFailure;
        return cur;
      }, 0);
  }

  get race() {
    if (this.items == null) return null;
    return this.items.filter((o) => o.type === "race")[0];
  }

  get typeColor() {
    return "#FDE600";
  }

  static _translateSourceInfo(type, subtype, name) {
    let result = "";
    if (type === "size") result = game.i18n.localize("FFD20.SourceInfoSize");
    if (type === "buff") {
      result = game.i18n.localize("FFD20.SourceInfoBuffs");
      if (subtype === "temp") result = game.i18n.localize("FFD20.SourceInfoTemporaryBuffs");
      if (subtype === "perm") result = game.i18n.localize("FFD20.SourceInfoPermanentBuffs");
      if (subtype === "item") result = game.i18n.localize("FFD20.SourceInfoItemBuffs");
      if (subtype === "misc") result = game.i18n.localize("FFD20.SourceInfoMiscBuffs");
    }
    if (type === "equipment") result = game.i18n.localize("FFD20.SourceInfoEquipment");
    if (type === "weapon") result = game.i18n.localize("FFD20.SourceInfoWeapons");
    if (type === "feat") {
      result = game.i18n.localize("FFD20.SourceInfoFeats");
      if (subtype === "classFeat") result = game.i18n.localize("FFD20.SourceInfoClassFeatures");
      if (subtype === "trait") result = game.i18n.localize("FFD20.SourceInfoTraits");
      if (subtype === "racial") result = game.i18n.localize("FFD20.SourceInfoRacialTraits");
      if (subtype === "misc") result = game.i18n.localize("FFD20.SourceInfoMiscFeatures");
      if (subtype === "template") result = game.i18n.localize("FFD20.SourceInfoTemplate");
    }
    if (type === "race") {
      result = game.i18n.localize("FFD20.SourceInfoRace");
    }

    if (!name || name.length === 0) return result;
    if (result === "") return name;
    return `${result} (${name})`;
  }

  static _getChangeItemSubtype(item) {
    if (item.type === "buff") return item.data.buffType;
    if (item.type === "feat") return item.data.featType;
    return "";
  }

  get _skillTargets() {
    let skills = [];
    let subSkills = [];
    for (let [sklKey, skl] of Object.entries(this.data.data.skills)) {
      if (skl == null) continue;
      if (skl.subSkills != null) {
        for (let subSklKey of Object.keys(skl.subSkills)) {
          subSkills.push(`skill.${sklKey}.subSkills.${subSklKey}`);
        }
      } else skills.push(`skill.${sklKey}`);
    }
    return [...skills, ...subSkills];
  }

  /**
   * The VisionPermissionSheet instance for this actor
   *
   * @type {VisionPermissionSheet}
   */
  get visionPermissionSheet() {
    if (!this._visionPermissionSheet) this._visionPermissionSheet = new VisionPermissionSheet(this);
    return this._visionPermissionSheet;
  }

  _dataIsPC(data) {
    if (data.permission != null) {
      const nonGM = game.users.contents.filter((u) => !u.isGM);
      return nonGM.some((u) => {
        if (data.permission["default"] >= CONST.ENTITY_PERMISSIONS["OWNER"]) return true;
        return data.permission[u._id] >= CONST.ENTITY_PERMISSIONS["OWNER"];
      });
    }
    const hasPlayerOwner = this.hasPlayerOwner;
    return hasPlayerOwner;
  }

  _prepareContainerItems(items) {
    let collection = [];

    const getContainerContents = function (item) {
      if (item.type !== "container") return;

      item.items.forEach((i) => {
        collection.push(i);
        getContainerContents(i);
      });
    };

    items.forEach((item) => {
      getContainerContents(item);
    });

    return collection;
  }

  _prepareItemFlags(items) {
    let bFlags = {};
    let dFlags = {};

    for (let i of items) {
      // Process boolean flags
      if (i.isActive) {
        const flags = getProperty(i.data, "data.flags.boolean") || [];
        for (let f of flags) {
          bFlags[f] = bFlags[f] || { sources: [] };
          bFlags[f].sources.push(i);
        }
      }

      // Process dictionary flags
      if (i.data.data.tag) {
        const flags = getProperty(i.data, "data.flags.dictionary") || [];
        for (let f of flags) {
          setProperty(dFlags, `${i.data.data.tag}.${f[0]}`, i.isActive ? f[1] : 0);
        }
      }
    }

    return {
      boolean: bFlags,
      dictionary: dFlags,
    };
  }

  _prepareChanges() {
    this.changeItems = this.items
      .filter((obj) => {
        return (
          (obj.data.data.changes instanceof Array && obj.data.data.changes.length) ||
          (obj.data.data.changeFlags && Object.values(obj.data.data.changeFlags).filter((o) => o === true).length)
        );
      })
      .filter((obj) => obj.isActive);

    let changes = [];
    for (let i of this.changeItems) {
      changes.push(...i.changes);
    }
    addDefaultChanges.call(this, changes);

    const c = new Collection();
    for (let e of changes) {
      c.set(e._id, e);
    }
    this.changes = c;
  }

  applyActiveEffects() {
    super.applyActiveEffects();

    this.containerItems = this._prepareContainerItems(this.items);
    this.itemFlags = this._prepareItemFlags(this.allItems);
    this._prepareChanges();
  }

  prepareData() {
    this.sourceInfo = {};
    this.flags = {};

    // Prepare data
    super.prepareData();

    this._initialized = true;
    this._setSourceDetails(this.sourceInfo);

    this.doQueuedUpdates();
  }

  prepareBaseData() {
    super.prepareBaseData();
    this._resetInherentTotals();
    Hooks.callAll("ffd20.prepareBaseActorData", this);

    // Update total level and mythic tier
    const classes = this.data.items.filter((o) => o.type === "class");
    const level = classes
      .filter((o) => o.data.data.classType !== "mythic" && o.data.data.countforexp === "exp")
      .reduce((cur, o) => cur + o.data.data.level, 0);
    setProperty(this.data, "data.details.level.value", level);

    const mythicTier = classes
      .filter((o) => o.data.data.classType === "mythic")
      .reduce((cur, o) => cur + o.data.data.level, 0);
    setProperty(this.data, "data.details.mythicTier", mythicTier);

    // Populate conditions
    for (const condition of Object.keys(CONFIG.FFD20.conditions)) {
      this.data.data.attributes.conditions[condition] ??= false;
    }

    // The following is not for NPCs
    if (this.data.type === "character" || this.data.type === "npc" ) {
      const maxExp = this.getLevelExp(level);
      setProperty(this.data, "data.details.xp.max", maxExp);
    }

    {
      // Handle armor and weapon proficiencies for PCs
      // NPCs are considered proficient with their armor
      if (this.data.type === "character") {
        // Collect proficiencies from items, add them to actor's proficiency totals
        for (const prof of ["armorProf", "weaponProf", "languages"]) {
          // Custom proficiency baseline from actor
          const customProficiencies =
            this.data.data.traits[prof]?.custom.split(CONFIG.FFD20.re.traitSeparator).filter((item) => item.length > 0) ||
            [];

          // Iterate over all items to create one array of non-custom proficiencies
          const proficiencies = this.data.items.reduce(
            (profs, item) => {
              // Check only items able to grant proficiencies
              if (hasProperty(item.data, `data.${prof}`)) {
                // Get existing sourceInfo for item with this name, create sourceInfo if none is found
                // Remember whether sourceInfo can be modified or has to be pushed at the end
                let sInfo = getSourceInfo(this.sourceInfo, `data.traits.${prof}`).positive.find(
                    (o) => o.name === item.name
                  ),
                  hasInfo = !!sInfo;
                if (!sInfo) sInfo = { name: item.name, value: [] };
                else if (typeof sInfo.value === "string") sInfo.value = sInfo.value.split(", ");

                // Regular proficiencies
                for (const proficiency of item.data.data[prof].value) {
                  // Add localized source info if item's info does not have this proficiency already
                  if (!sInfo.value.includes(proficiency)) sInfo.value.push(CONFIG.FFD20[`${prof}`][proficiency]);
                  // Add raw proficiency key
                  if (!profs.includes(proficiency)) profs.push(proficiency);
                }

                // Collect trimmed but otherwise original proficiency strings, dedupe array for actor's total
                const customProfs =
                  item.data.data[prof].custom
                    ?.split(CONFIG.FFD20.re.traitSeparator)
                    .map((i) => i.trim())
                    .filter((el, i, arr) => el.length > 0 && arr.indexOf(el) === i) || [];
                // Add readable custom profs to sources and overall collection
                sInfo.value.push(...customProfs);
                customProficiencies.push(...customProfs);

                if (sInfo.value.length > 0) {
                  // Dedupe if adding to existing sourceInfo
                  if (hasInfo) sInfo.value = [...new Set(sInfo.value)];
                  // Transform arrays into presentable strings
                  sInfo.value = sInfo.value.join(", ");
                  // If sourceInfo was not a reference to existing info, push it now
                  if (!hasInfo) getSourceInfo(this.sourceInfo, `data.traits.${prof}`).positive.push(sInfo);
                }
              }
              return profs;
            },
            [...this.data.data.traits[prof].value] // Default proficiency baseline from actor
          );

          // Save collected proficiencies in actor's data
          setProperty(this.data, `data.traits.${prof}.total`, [...proficiencies]);
          setProperty(this.data, `data.traits.${prof}.customTotal`, customProficiencies.join(";"));
        }
      }
    }

    // Refresh ability scores
    {
      const abs = Object.keys(this.data.data.abilities);
      for (let ab of abs) {
        const value = getProperty(this.data, `data.abilities.${ab}.value`);
        if (value == null) {
          setProperty(this.data, `data.abilities.${ab}.total`, null);
          setProperty(this.data, `data.abilities.${ab}.base`, null);
          setProperty(this.data, `data.abilities.${ab}.baseMod`, 0);
        } else {
          setProperty(
            this.data,
            `data.abilities.${ab}.total`,
            value - getProperty(this.data, `data.abilities.${ab}.drain`)
          );
          setProperty(
            this.data,
            `data.abilities.${ab}.penalty`,
            (getProperty(this.data, `data.abilities.${ab}.penalty`) || 0) +
              (getProperty(this.data, `data.abilities.${ab}.userPenalty`) || 0)
          );
          setProperty(this.data, `data.abilities.${ab}.base`, getProperty(this.data, `data.abilities.${ab}.total`));
        }
      }
      this.refreshAbilityModifiers();
    }

    // Reset BAB
    {
      const useFractionalBaseBonuses = game.settings.get("ffd20", "useFractionalBaseBonuses") === true;
      const k = "data.attributes.bab.total";
      if (useFractionalBaseBonuses) {
        setProperty(
          this.data,
          k,
          Math.floor(
            classes.reduce((cur, obj) => {
              const babScale = getProperty(obj, "data.data.bab") || "";
              if (babScale === "high") return cur + obj.data.data.level;
              if (babScale === "med") return cur + obj.data.data.level * 0.75;
              if (babScale === "low") return cur + obj.data.data.level * 0.5;
              return cur;
            }, 0)
          )
        );

        const v = getProperty(this.data, k);
        if (v !== 0) {
          getSourceInfo(this.sourceInfo, k).positive.push({
            name: game.i18n.localize("FFD20.Base"),
            value: v,
          });
        }
      } else {
        setProperty(
          this.data,
          k,
          classes.reduce((cur, obj) => {
            const v = RollFFD20$1.safeRoll(CONFIG.FFD20.classBABFormulas[obj.data.data.bab], { level: obj.data.data.level })
              .total;

            if (v !== 0) {
              getSourceInfo(this.sourceInfo, k).positive.push({
                name: getProperty(obj, "name"),
                value: v,
              });
            }

            return cur + v;
          }, 0)
        );
      }
    }

    // Prepare Character data
    if (this.data.type === "character") this._prepareCharacterData(this.data.data);
    else if (this.data.type === "npc") this._prepareNPCData(this.data.data);

    // Reset HD
    setProperty(this.data, "data.attributes.hd.total", getProperty(this.data, "data.details.level.value"));

    // recalulate limitbreaks
    setProperty(
      this.data,
      "data.attributes.limitbreak.max",
      1 + Math.floor(getProperty(this.data, "data.details.level.value") / 4)
    );

    // Apply ACP and Max Dexterity Bonus
    this._applyArmorPenalties();

    // Reset class skills
    for (let [k, s] of Object.entries(getProperty(this.data, "data.skills"))) {
      if (!s) continue;
      const isClassSkill = classes.reduce((cur, o) => {
        if ((getProperty(o.data, "data.classSkills") || {})[k] === true) return true;
        return cur;
      }, false);
      setProperty(this.data, `data.skills.${k}.cs`, isClassSkill);
      for (let k2 of Object.keys(getProperty(s, "subSkills") || {})) {
        setProperty(this.data, `data.skills.${k}.subSkills.${k2}.cs`, isClassSkill);
      }
    }

    this.updateSpellbookInfo();

    // Add base initiative (for NPC Lite sheets)
    {
      setProperty(this.data, "data.attributes.init.total", getProperty(this.data, "data.attributes.init.value"));
    }
  }

  /**
   * Checks if there's any matching proficiency
   *
   * @param {ItemFFD20 } item - The item to check for.
   * @param {string} proficiencyName - The proficiency name to look for. e.g. 'lightShield' or 'mediumArmor'.
   * @returns {boolean} Whether the actor is proficient with that item.
   */
  hasArmorProficiency(item, proficiencyName) {
    // Assume NPCs to be proficient with their armor
    if (this.data.type === "npc") return true;

    // Check for item type
    if (item.type !== "equipment" || !["armor", "shield"].includes(item.data.data.equipmentType)) return true;

    // Custom proficiencies
    const customProficiencies =
      this.data.data.traits.armorProf?.customTotal
        ?.split(CONFIG.FFD20.re.traitSeparator)
        .map((item) => item.trim().toLowerCase())
        .filter((item) => item.length > 0) || [];

    const name = item.name.toLowerCase(),
      tag = item.data.tag;
    return (
      this.data.data.traits.armorProf.total.includes(proficiencyName) ||
      customProficiencies.find((prof) => prof.includes(name) || prof.includes(tag)) != undefined
    );
  }

  updateSpellbookInfo() {
    const rollData = this.getRollData();

    // Set spellbook info
    for (let [spellbookKey, spellbook] of Object.entries(getProperty(this.data, "data.attributes.spells.spellbooks"))) {
      const spellbookAbilityKey = spellbook.ability;
      let spellbookAbilityScore = getProperty(this.data, `data.abilities.${spellbookAbilityKey}.total`) ?? 10;

      // Add spell slots based on ability bonus slot formula
      {
        const formula = getProperty(spellbook, "spellSlotAbilityBonusFormula") || "0";
        spellbookAbilityScore += RollFFD20$1.safeRoll(formula, rollData).total;
      }

      const spellbookAbilityMod = Math.floor((spellbookAbilityScore - 10) / 2);

      // Set CL
      {
        const key = `data.attributes.spells.spellbooks.${spellbookKey}.cl.total`;
        const formula = getProperty(spellbook, "cl.formula") || "0";
        let total = 0;

        // Add NPC base
        if (this.data.type === "npc") {
          const value = getProperty(spellbook, "cl.base") || 0;
          total += value;
          getSourceInfo(this.sourceInfo, key).positive.push({ name: game.i18n.localize("FFD20.Base"), value: value });
        }
        // Add HD
        if (spellbook.class === "_hd") {
          const value = getProperty(this.data, "data.attributes.hd.total");
          total += value;
          getSourceInfo(this.sourceInfo, key).positive.push({ name: game.i18n.localize("FFD20.HitDie"), value: value });
        }
        // Add class levels
        else if (spellbook.class && rollData.classes[spellbook.class]) {
          const value = rollData.classes[spellbook.class].lvl;
          total += value;

          setSourceInfoByName(this.sourceInfo, key, rollData.classes[spellbook.class].name, value);
        }

        // set auto spell level calculation offset
        if (spellbook.autoSpellLevelCalculation) {
          const autoKey = `data.attributes.spells.spellbooks.${spellbookKey}.cl.autoSpellLevelTotal`;
          const autoFormula = getProperty(spellbook, "cl.autoSpellLevelCalculationFormula") || "0";
          const autoBonus = RollFFD20$1.safeTotal(autoFormula, rollData);
          const autoTotal = Math.max(1, Math.min(20, total + autoBonus));
          setProperty(this.data, autoKey, autoTotal);

          total += autoBonus;
          if (autoBonus !== 0) {
            setSourceInfoByName(
              this.sourceInfo,
              key,
              game.i18n.localize("FFD20.AutoSpellClassLevelOffset.Formula"),
              autoBonus
            );
          }
        }

        // Add from bonus formula
        const clBonus = RollFFD20$1.safeRoll(formula, rollData).total;
        total += clBonus;
        if (clBonus > 0) {
          setSourceInfoByName(this.sourceInfo, key, game.i18n.localize("FFD20.CasterLevelBonusFormula"), clBonus);
        } else if (clBonus < 0) {
          setSourceInfoByName(this.sourceInfo, key, game.i18n.localize("FFD20.CasterLevelBonusFormula"), clBonus, false);
        }

        if (getProperty(rollData, "attributes.woundThresholds.penalty") != null) {
          // Subtract Wound Thresholds penalty. Can't reduce below 1.
          if (rollData.attributes.woundThresholds.penalty > 0 && total > 1) {
            total = Math.max(1, total - rollData.attributes.woundThresholds.penalty);
            setSourceInfoByName(
              this.sourceInfo,
              key,
              game.i18n.localize(CONFIG.FFD20.woundThresholdConditions[rollData.attributes.woundThresholds.level]),
              -rollData.attributes.woundThresholds.penalty
            );
          }
        }

        // Subtract energy drain
        if (rollData.attributes.energyDrain) {
          total = Math.max(0, total - rollData.attributes.energyDrain);
          setSourceInfoByName(
            this.sourceInfo,
            key,
            game.i18n.localize("FFD20.CondTypeEnergyDrain"),
            -Math.abs(rollData.attributes.energyDrain),
            false
          );
        }

        setProperty(this.data, key, total);
      }

      const getAbilityBonus = (a) =>
        a !== 0 && typeof spellbookAbilityMod === "number" ? ActorFFD20.getSpellSlotIncrease(spellbookAbilityMod, a) : 0;
      // Spell slots
      {
        const bookPath = `data.attributes.spells.spellbooks.${spellbookKey}`;

        const useAuto = getProperty(this.data, `${bookPath}.autoSpellLevelCalculation`);
        if (useAuto) {
          let spellPrepMode = spellbook.spellPreparationMode;
          if (!spellPrepMode || spellPrepMode === "null") {
            spellPrepMode = "spontaneous";
            setProperty(this.data, `${bookPath}.spellPreparationMode`, spellPrepMode);
          }

          // turn off spell points
          setProperty(this.data, `${bookPath}.spellPoints.useSystem`, false);

          // set base "spontaneous" based on spell prep mode
          if (spellPrepMode === "hybrid" || spellPrepMode === "prestige" || spellPrepMode === "spontaneous") {
            spellbook.spontaneous = true;
            setProperty(this.data, `${bookPath}.spontaneous`, true);
          } else {
            spellbook.spontaneous = false;
            setProperty(this.data, `${bookPath}.spontaneous`, false);
          }

          let casterType = getProperty(this.data, `${bookPath}.casterType`);
          if (!casterType || casterType === "null" || (spellPrepMode === "hybrid" && casterType !== "high")) {
            casterType = "high";
            setProperty(this.data, `${bookPath}.casterType`, casterType);
          }
          if (spellPrepMode === "prestige" && casterType !== "low") {
            casterType = "low";
            setProperty(this.data, `${bookPath}.casterType`, casterType);
          }

          const castsForLevels =
            CONFIG.FFD20.casterProgression[spellbook.spontaneous ? "castsPerDay" : "spellsPreparedPerDay"][spellPrepMode][
              casterType
            ];
          const classLevel = Math.max(Math.min(getProperty(this.data, `${bookPath}.cl.autoSpellLevelTotal`), 20), 1);
          rollData.ablMod = spellbookAbilityMod;

          const allLevelModFormula =
            getProperty(
              this.data,
              `${bookPath}.${spellbook.spontaneous ? "castPerDayAllOffsetFormula" : "preparedAllOffsetFormula"}`
            ) || "0";
          const allLevelMod = RollFFD20$1.safeTotal(allLevelModFormula, rollData);

          for (let a = 0; a < 10; a++) {
            // 0 is special because it doesn't get bonus preps and can cast them indefinitely so can't use the "cast per day" value
            const spellsForLevel =
              a === 0 && spellbook.spontaneous
                ? CONFIG.FFD20.casterProgression.spellsPreparedPerDay[spellPrepMode][casterType][classLevel - 1][a]
                : castsForLevels[classLevel - 1][a];
            setProperty(this.data, `${bookPath}.spells.spell${a}.base`, spellsForLevel);

            const offsetFormula =
              getProperty(
                this.data,
                `${bookPath}.spells.spell${a}.${[
                  spellbook.spontaneous ? "castPerDayOffsetFormula" : "preparedOffsetFormula",
                ]}`
              ) || "0";

            let max =
              typeof spellsForLevel === "number" || (a === 0 && spellbook.hasCantrips)
                ? spellsForLevel + getAbilityBonus(a) + allLevelMod + RollFFD20$1.safeTotal(offsetFormula, rollData)
                : null;

            setProperty(this.data, `${bookPath}.spells.spell${a}.max`, max);
            let oldval = getProperty(this.data, `${bookPath}.spells.spell${a}.value`);
            if (!Number.isFinite(oldval)) setProperty(this.data, `${bookPath}.spells.spell${a}.value`, max);
          }
        } else {
          for (let a = 0; a < 10; a++) {
            let base = parseInt(getProperty(this.data, `${bookPath}.spells.spell${a}.base`));
            if (Number.isNaN(base)) {
              setProperty(this.data, `${bookPath}.spells.spell${a}.base`, null);
              setProperty(this.data, `${bookPath}.spells.spell${a}.max`, 0);
            } else if (getProperty(this.data, `${bookPath}.autoSpellLevels`)) {
              base += getAbilityBonus(a);
              setProperty(this.data, `${bookPath}.spells.spell${a}.max`, base);
            } else {
              setProperty(this.data, `${bookPath}.spells.spell${a}.max`, base);
            }

            let max = getProperty(this.data, `${bookPath}.spells.spell${a}.max`);
            let oldval = getProperty(this.data, `${bookPath}.spells.spell${a}.value`);
            if (!Number.isFinite(oldval)) setProperty(this.data, `${bookPath}.spells.spell${a}.value`, max);
          }
        }
      }

      // Set spontaneous spell slots to something sane
      {
        for (let a = 0; a < 10; a++) {
          const k = `data.attributes.spells.spellbooks.${spellbookKey}.spells.spell${a}.value`;
          const current = getProperty(this.data, k);
          setProperty(this.data, k, current || 0);
        }
      }

      // Update spellbook slots
      {
        const slots = {};
        for (let sbKey of Object.keys(getProperty(this.data, "data.attributes.spells.spellbooks"))) {
          for (let a = 0; a < 10; a++) {
            setProperty(
              slots,
              `${sbKey}.${a}.value`,
              getProperty(this.data, `data.attributes.spells.spellbooks.${sbKey}.spells.spell${a}.max`) || 0
            );
            setProperty(
              slots,
              `${sbKey}.${a}.domainSlots`,
              getProperty(this.data, `data.attributes.spells.spellbooks.${sbKey}.domainSlotValue`) || 0
            );
          }
        }

        const spells = this.items.filter((o) => o.type === "spell" && o.data.data.spellbook === spellbookKey);
        for (let i of spells) {
          const sb = i.spellbook;
          if (!sb || sb.spontaneous) {
            continue;
          }

          const sbKey = i.data.data.spellbook;
          const isDomain = getProperty(i.data, "data.domain") === true;
          const a = i.data.data.level;
          const slotCost = i.data.data.slotCost ?? 1;
          let dSlots = getProperty(slots, `${sbKey}.${a}.domainSlots`); // `
          let uses = getProperty(slots, `${sbKey}.${a}.value`);
          if (Number.isFinite(i.maxCharges)) {
            let subtract = { domain: 0, uses: 0 };
            if (isDomain) {
              subtract.domain = Math.min(i.maxCharges, dSlots);
              subtract.uses = (i.maxCharges - subtract.domain) * slotCost;
            } else {
              subtract.uses = i.maxCharges * slotCost;
            }
            dSlots -= subtract.domain;
            uses -= subtract.uses;
          }
          setProperty(slots, `${sbKey}.${a}.value`, uses);
          setProperty(slots, `${sbKey}.${a}.domainSlots`, dSlots);
          setProperty(this.data, `data.attributes.spells.spellbooks.${sbKey}.spells.spell${a}.value`, uses);
        }

        // Spells available hint text if auto spell levels is enabled
        {
          const bookPath = `data.attributes.spells.spellbooks.${spellbookKey}`;
          const useAuto = getProperty(this.data, `${bookPath}.autoSpellLevelCalculation`);
          if (useAuto) {
            const spellPrepMode = spellbook.spellPreparationMode;
            let casterType = getProperty(this.data, `${bookPath}.casterType`) || "high";
            const classLevel = Math.max(Math.min(getProperty(this.data, `${bookPath}.cl.autoSpellLevelTotal`), 20), 1);

            let spellbookAbilityScore = getProperty(this.data, `data.abilities.${spellbookAbilityKey}.total`);

            const allLevelModFormula = getProperty(this.data, `${bookPath}.preparedAllOffsetFormula`) || "0";
            const allLevelMod = RollFFD20$1.safeTotal(allLevelModFormula, rollData);

            for (let a = 0; a < 10; a++) {
              if (!isNaN(spellbookAbilityScore) && spellbookAbilityScore - 10 < a) {
                const message = game.i18n.localize("FFD20.SpellScoreTooLow");
                setProperty(this.data, `${bookPath}.spells.spell${a}.spellMessage`, message);
                continue;
              }

              let remaining;
              if (spellPrepMode === "prepared") {
                // for prepared casters, just use the 'value' calculated above
                remaining = getProperty(this.data, `${bookPath}.spells.spell${a}.value`);
              } else {
                // spontaneous or hybrid
                // if not prepared then base off of casts per day
                let available =
                  CONFIG.FFD20.casterProgression.spellsPreparedPerDay[spellPrepMode][casterType]?.[classLevel - 1][a];
                available += allLevelMod;

                const formula = getProperty(this.data, `${bookPath}.spells.spell${a}.preparedOffsetFormula`) || "0";
                available += RollFFD20$1.safeTotal(formula, rollData);

                const used = spells.reduce((acc, i) => {
                  const { level, spellbook, preparation } = i.data.data;
                  return level === a && spellbook === spellbookKey && preparation.spontaneousPrepared ? ++acc : acc;
                }, 0);

                remaining = available - used;
              }

              if (!remaining) {
                setProperty(this.data, `${bookPath}.spells.spell${a}.spellMessage`, "");
                continue;
              }

              let remainingMessage = "";
              if (remaining < 0) {
                remainingMessage = game.i18n.format("FFD20.TooManySpells", { quantity: Math.abs(remaining) });
              } else if (remaining > 0) {
                if (spellPrepMode === "spontaneous") {
                  remainingMessage =
                    remaining === 1
                      ? game.i18n.localize("FFD20.LearnMoreSpell")
                      : game.i18n.format("FFD20.LearnMoreSpells", { quantity: remaining });
                } else {
                  // hybrid or prepared
                  remainingMessage =
                    remaining === 1
                      ? game.i18n.localize("FFD20.PrepareMoreSpell")
                      : game.i18n.format("FFD20.PrepareMoreSpells", { quantity: remaining });
                }
              }

              if (remainingMessage) {
                setProperty(this.data, `${bookPath}.spells.spell${a}.spellMessage`, remainingMessage);
              }
            }
          }
        }
      }

      // Spell points
      {
        const formula =
          getProperty(this.data, `data.attributes.spells.spellbooks.${spellbookKey}.spellPoints.maxFormula`) || "0";
        rollData.cl = getProperty(this.data, `data.attributes.spells.spellbooks.${spellbookKey}.cl.total`);
        rollData.ablMod = spellbookAbilityMod;
        const spellClass = getProperty(this.data, `data.attributes.spells.spellbooks.${spellbookKey}.class`) ?? "";
        rollData.classLevel =
          spellClass === "_hd"
            ? rollData.attributes.hd.total
            : spellClass?.length > 0
            ? getProperty(rollData, `classes.${spellClass}.level`) || 0 // `
            : 0;
        const roll = RollFFD20$1.safeRoll(formula, rollData);
        setProperty(this.data, `data.attributes.spells.spellbooks.${spellbookKey}.spellPoints.max`, roll.total);
      }

      // Set spellbook range
      const cl = spellbook.cl.total;
      spellbook.range = {
        close: convertDistance(25 + 5 * Math.floor(cl / 2))[0],
        medium: convertDistance(100 + 10 * cl)[0],
        long: convertDistance(400 + 40 * cl)[0],
      };
    }
  }

  /**
   * Called just before the first change is applied, and after every change is applied.
   * Sets additional variables (such as spellbook range)
   */
  refreshDerivedData() {
    // Reset maximum dexterity bonus
    setProperty(this.data, "data.attributes.maxDexBonus", null);

    {
      // Compute encumbrance
      const encPen = this._computeEncumbrance();

      // Apply armor penalties
      const gearPen = this._applyArmorPenalties();

      // Set armor check penalty
      setProperty(this.data, "data.attributes.acp.encumbrance", encPen.acp);
      setProperty(this.data, "data.attributes.acp.gear", gearPen.acp);
      setProperty(this.data, "data.attributes.acp.total", Math.max(encPen.acp, gearPen.acp));

      // Set maximum dexterity bonus
      if (encPen.maxDexBonus != null || gearPen.maxDexBonus != null) {
        setProperty(
          this.data,
          "data.attributes.maxDexBonus",
          Math.min(encPen.maxDexBonus ?? Number.POSITIVE_INFINITY, gearPen.maxDexBonus ?? Number.POSITIVE_INFINITY)
        );
      }
    }
  }

  /**
   * Augment the basic actor data with additional dynamic data.
   */
  prepareDerivedData() {
    super.prepareDerivedData();

    // Refresh roll data
    // Some changes act wonky without this
    // Example: `@skills.hea.rank >= 10 ? 6 : 3` doesn't work well without this
    this.getRollData({ refresh: true });

    this.items.forEach((item) => {
      item.prepareDerivedItemData();
      this.updateItemResources(item.data);
    });

    applyChanges.call(this);

    // Prepare specific derived data
    this.prepareSpecificDerivedData();

    // Setup links
    this.prepareItemLinks();

    // Update item resources
    this.items.forEach((item) => {
      item.prepareDerivedItemData();
      this.updateItemResources(item.data);

      // Update tokens for resources
      const tokens = this.isToken ? [this.token] : this.getActiveTokens();
      tokens.forEach((t) => {
        try {
          t.drawBars();
        } catch (err) {
          // Drop the harmless error
        }
      });
    });
  }

  prepareSpecificDerivedData() {
    Hooks.callAll("ffd20.prepareDerivedActorData", this);

    // Set base ability modifier
    for (const ab of Object.keys(this.data.data.abilities)) {
      setProperty(
        this.data,
        `data.abilities.${ab}.baseMod`,
        Math.floor((getProperty(this.data, `data.abilities.${ab}.base`) - 10) / 2)
      );
    }

    const actorData = this.data;
    const data = actorData.data;

    // Round health
    const healthConfig = game.settings.get("ffd20", "healthConfig");
    const round = { up: Math.ceil, nearest: Math.round, down: Math.floor }[healthConfig.rounding];
    for (const k of ["data.attributes.hp.max", "data.attributes.vigor.max"]) {
      setProperty(this.data, `${k}`, round(getProperty(this.data, `${k}`)));
    }

    // Refresh HP
    this._applyPreviousAttributes();

    // Update wound threshold
    this.updateWoundThreshold();

    // Apply wound thresholds to skills
    const woundPenalty = this.data.data.attributes.woundThresholds?.penalty ?? 0;
    if (woundPenalty) {
      for (let k of this.allSkills) {
        const prevValue = getProperty(this.data, `data.skills.${k}.mod`);
        setProperty(this.data, `data.skills.${k}.mod`, prevValue - woundPenalty);
      }
    }

    // Reset CR
    if (this.data.type === "npc") {
      setProperty(this.data, "data.details.cr.total", this.getCR(this.data.data));

      // Reset experience value
      try {
        const crTotal = getProperty(this.data, "data.details.cr.total") || 0;
        setProperty(this.data, "data.details.xp.value", this.getCRExp(crTotal));
      } catch (e) {
        setProperty(this.data, "data.details.xp.value", this.getCRExp(1));
      }
    }

    // Shared attack bonuses
    {
      // Size
      const sizeMod = CONFIG.FFD20.sizeMods[this.data.data.traits.size];
      // Total
      const totalAtk =
        (getProperty(this.data, "data.attributes.bab.total") ?? 0) -
        (getProperty(this.data, "data.attributes.acp.attackPenalty") ?? 0) -
        (getProperty(this.data, "data.attributes.energyDrain") ?? 0) +
        sizeMod;
      setProperty(this.data, "data.attributes.attack.shared", totalAtk);
    }

    // Create arbitrary skill slots
    for (let skillId of CONFIG.FFD20.arbitrarySkills) {
      if (data.skills[skillId] == null) continue;
      let skill = data.skills[skillId];
      skill.subSkills = skill.subSkills || {};
      for (let subSkillId of Object.keys(skill.subSkills)) {
        if (skill.subSkills[subSkillId] == null) delete skill.subSkills[subSkillId];
      }
    }

    // Delete removed skills
    for (let skillId of Object.keys(data.skills)) {
      let skl = data.skills[skillId];
      if (skl == null) {
        delete data.skills[skillId];
      }
    }

    // Mark background skills
    for (let skillId of Object.keys(data.skills)) {
      if (CONFIG.FFD20.backgroundSkills.includes(skillId)) {
        let skill = data.skills[skillId];
        skill.background = true;
        for (let subSkillId of Object.keys(skill.subSkills ?? {})) skill.subSkills[subSkillId].background = true;
      }
    }

    // Prepare modifier containers
    data.attributes.mods = data.attributes.mods || {};
    data.attributes.mods.skills = data.attributes.mods.skills || {};

    // Set labels
    this.labels = {};
    this.labels.race =
      this.race == null ? game.i18n.localize("FFD20.Race") : game.i18n.localize("FFD20.RaceTitle").format(this.race.name);
    this.labels.alignment = CONFIG.FFD20.alignments[this.data.data.details.alignment];

    // Set speed labels
    this.labels.speed = {};
    for (const [key, obj] of Object.entries(getProperty(this.data, "data.attributes.speed") || {})) {
      const dist = convertDistance(obj.total);
      this.labels.speed[key] = `${dist[0]} ${CONFIG.FFD20.measureUnitsShort[dist[1]]}`;
    }

    // Combine AC types
    for (const k of ["temp.ac.armor", "temp.ac.shield", "temp.ac.natural"]) {
      const v = getProperty(this.data, k);
      if (v) {
        for (const k2 of ["normal", "flatFooted"]) {
          setProperty(
            this.data,
            `data.attributes.ac.${k2}.total`,
            getProperty(this.data, `data.attributes.ac.${k2}.total`) + v
          );
        }
      }
    }

    // Add Dexterity to AC
    {
      // get configured ability scores
      const acAbl = this.data.data.attributes.ac.normal.ability ?? "dex";
      const acTouchAbl = this.data.data.attributes.ac.touch.ability ?? "dex";
      const cmdDexAbl = this.data.data.attributes.cmd.dexAbility ?? "dex";
      let acAblMod = getProperty(this.data, `data.abilities.${acAbl}.mod`);
      let acTouchAblMod = getProperty(this.data, `data.abilities.${acTouchAbl}.mod`);
      let cmdDexAblMod = getProperty(this.data, `data.abilities.${cmdDexAbl}.mod`);

      if (this.flags["loseDexToAC"]) {
        acAblMod = Math.min(acAblMod, 0);
        acTouchAblMod = Math.min(acTouchAblMod, 0);
      }
      const maxDex = getProperty(this.data, "data.attributes.maxDexBonus") ?? null;
      const ac = {
        normal: maxDex !== null ? Math.min(maxDex, acAblMod) : acAblMod,
        touch: maxDex !== null ? Math.min(maxDex, acTouchAblMod) : acTouchAblMod,
        flatFooted: Math.min(0, acAblMod),
      };
      const acAblKey = {
        normal: acAbl,
        touch: acTouchAbl,
        flatFooted: acAbl,
      };
      const cmd = {
        total: cmdDexAblMod,
        flatFootedTotal: Math.min(0, cmdDexAblMod),
      };
      for (const [k, v] of Object.entries(ac)) {
        setProperty(
          this.data,
          `data.attributes.ac.${k}.total`,
          getProperty(this.data, `data.attributes.ac.${k}.total`) + v
        );
        getSourceInfo(this.sourceInfo, `data.attributes.ac.${k}.total`).positive.push({
          value: v,
          name: CONFIG.FFD20.abilities[acAblKey[k]],
        });
      }
      for (const [k, v] of Object.entries(cmd)) {
        setProperty(this.data, `data.attributes.cmd.${k}`, getProperty(this.data, `data.attributes.cmd.${k}`) + v);
        getSourceInfo(this.sourceInfo, `data.attributes.cmd.${k}`).positive.push({
          value: v,
          name: CONFIG.FFD20.abilities[cmdDexAbl],
        });
      }
    }

    // Reduce final speed under certain circumstances
    {
      const armorItems = this.items.filter((o) => o.data.type === "equipment");
      let reducedSpeed = false;
      let sInfo = { name: "", value: game.i18n.localize("FFD20.ReducedMovementSpeed") };
      if (this.data.data.attributes.encumbrance.level >= 1 && !this.flags["noEncumbrance"]) {
        reducedSpeed = true;
        sInfo.name = game.i18n.localize("FFD20.Encumbrance");
      }
      if (
        armorItems.filter((o) => getProperty(o.data.data, "equipmentSubtype") === "mediumArmor" && o.data.data.equipped)
          .length &&
        !this.flags["mediumArmorFullSpeed"]
      ) {
        reducedSpeed = true;
        sInfo.name = game.i18n.localize("FFD20.EquipTypeMedium");
      }
      if (
        armorItems.filter((o) => getProperty(o.data.data, "equipmentSubtype") === "heavyArmor" && o.data.data.equipped)
          .length &&
        !this.flags["heavyArmorFullSpeed"]
      ) {
        reducedSpeed = true;
        sInfo.name = game.i18n.localize("FFD20.EquipTypeHeavy");
      }
      if (reducedSpeed) {
        for (const speedKey of Object.keys(this.data.data.attributes.speed)) {
          const key = `data.attributes.speed.${speedKey}.total`;
          let value = getProperty(this.data, key);
          setProperty(this.data, key, this.constructor.getReducedMovementSpeed(value));
          if (value > 0) {
            getSourceInfo(this.sourceInfo, key).negative.push(sInfo);
          }
        }
      }
    }

    // Add encumbrance source details
    switch (getProperty(this.data, "data.attributes.encumbrance.level")) {
      case 1:
        getSourceInfo(this.sourceInfo, "data.attributes.acp.total").negative.push({
          name: game.i18n.localize("FFD20.Encumbrance"),
          value: 3,
        });
        getSourceInfo(this.sourceInfo, "data.attributes.maxDexBonus").negative.push({
          name: game.i18n.localize("FFD20.Encumbrance"),
          value: 3,
        });
        break;
      case 2:
        getSourceInfo(this.sourceInfo, "data.attributes.acp.total").negative.push({
          name: game.i18n.localize("FFD20.Encumbrance"),
          value: 6,
        });
        getSourceInfo(this.sourceInfo, "data.attributes.maxDexBonus").negative.push({
          name: game.i18n.localize("FFD20.Encumbrance"),
          value: 1,
        });
        break;
    }

    this.updateSpellbookInfo();

    this.refreshDerivedData();
  }

  /**
   * Computes armor penalties for this actor.
   *
   * @returns {MobilityPenaltyResult} The resulting penalties from armor.
   */
  _applyArmorPenalties() {
    // Item type to proficiency maps
    const proficiencyMaps = {
      armor: {
        lightArmor: "lgt",
        mediumArmor: "med",
        heavyArmor: "hvy",
      },
      shield: {
        other: "shl", // buckler
        lightShield: "shl",
        heavyShield: "shl",
        towerShield: "twr",
      },
    };

    let attackACPPenalty = 0; // ACP to attack penalty from lacking proficiency. Stacks infinitely.
    const acp = { armor: 0, shield: 0 };
    const mdex = { armor: null, shield: null };

    this.data.items
      .filter((obj) => {
        return obj.type === "equipment" && obj.data.data.equipped;
      })
      .forEach((obj) => {
        const eqType = obj.data.data.equipmentType;
        const isShieldOrArmor = ["armor", "shield"].includes(eqType);
        let itemACP = Math.abs(obj.data.data.armor.acp);
        if (obj.data.data.masterwork === true && isShieldOrArmor) itemACP = Math.max(0, itemACP - 1);

        if (isShieldOrArmor)
          itemACP = Math.max(0, itemACP + (getProperty(this.data, `data.attributes.acp.${eqType}Bonus`) ?? 0));

        if (obj.data.data.broken) {
          itemACP *= 2;
        }

        if (itemACP) {
          const sInfo = getSourceInfo(this.sourceInfo, "data.attributes.acp.total").negative.find(
            (o) => o.name === obj.name
          );
          if (sInfo) sInfo.value = itemACP;
          else {
            getSourceInfo(this.sourceInfo, "data.attributes.acp.total").negative.push({
              name: obj.name,
              value: itemACP,
            });
          }
        }

        if (isShieldOrArmor) {
          if (itemACP > acp[eqType]) acp[eqType] = itemACP;
          if (!this.hasArmorProficiency(obj, proficiencyMaps[eqType][obj.data.data.equipmentSubtype]))
            attackACPPenalty += itemACP;
        }

        if (obj.data.data.armor.dex !== null && isShieldOrArmor) {
          const mDex = Number.parseInt(obj.data.data.armor.dex);
          if (Number.isInteger(mDex)) {
            const itemMDex = mDex + (getProperty(this.data, `data.attributes.mDex.${eqType}Bonus`) ?? 0);
            mdex[eqType] = Math.min(itemMDex, mdex[eqType] ?? Number.POSITIVE_INFINITY);

            const sInfo = getSourceInfo(this.sourceInfo, "data.attributes.maxDexBonus").negative.find(
              (o) => o.name === obj.name
            );
            if (sInfo) sInfo.value = itemMDex;
            else {
              getSourceInfo(this.sourceInfo, "data.attributes.maxDexBonus").negative.push({
                name: obj.name,
                value: itemMDex,
                ignoreNull: false,
              });
            }
          }
        }
      });

    // Return result
    const totalACP = acp.armor + acp.shield;
    let result = {
      maxDexBonus: null,
      acp: totalACP,
    };
    setProperty(this.data, "data.attributes.acp.gear", totalACP);
    if (mdex.armor !== null || mdex.shield !== null)
      result.maxDexBonus = Math.min(mdex.armor ?? Number.POSITIVE_INFINITY, mdex.shield ?? Number.POSITIVE_INFINITY);

    // Set armor penalty to attack rolls
    setProperty(this.data, "data.attributes.acp.attackPenalty", attackACPPenalty);

    return result;
  }

  prepareItemLinks() {
    if (!this.items) return;

    for (let a of this.items) {
      if (a.data.data.links == null) continue;

      for (let l of Object.keys(a.data.data.links)) {
        if (LinkFunctions[l] != null) {
          LinkFunctions[l].call(this, a, a.data.data.links[l]);
        }
      }
    }
  }

  _setSourceDetails(extraData) {
    const actorData = this.data;
    let sourceDetails = {};
    // Get empty source arrays
    for (let b of Object.keys(CONFIG.FFD20.buffTargets)) {
      let buffTargets = getChangeFlat.call(this, b, null);
      if (!(buffTargets instanceof Array)) buffTargets = [buffTargets];
      for (let bt of buffTargets) {
        if (!sourceDetails[bt]) sourceDetails[bt] = [];
      }
    }
    // Add additional source arrays not covered by changes
    sourceDetails["data.attributes.bab.total"] = [];

    // Add base values to certain bonuses
    sourceDetails["data.attributes.ac.normal.total"].push({ name: game.i18n.localize("FFD20.Base"), value: 10 });
    sourceDetails["data.attributes.ac.touch.total"].push({ name: game.i18n.localize("FFD20.Base"), value: 10 });
    sourceDetails["data.attributes.ac.flatFooted.total"].push({ name: game.i18n.localize("FFD20.Base"), value: 10 });
    sourceDetails["data.attributes.cmd.total"].push({ name: game.i18n.localize("FFD20.Base"), value: 10 });
    sourceDetails["data.attributes.cmd.flatFootedTotal"].push({ name: game.i18n.localize("FFD20.Base"), value: 10 });
    for (let [a, abl] of Object.entries(actorData.data.abilities)) {
      sourceDetails[`data.abilities.${a}.total`].push({ name: game.i18n.localize("FFD20.Base"), value: abl.value });
      // Add ability penalty, damage and drain
      if (abl.damage != null && abl.damage !== 0) {
        sourceDetails[`data.abilities.${a}.total`].push({
          name: game.i18n.localize("FFD20.AbilityDamage"),
          value: `-${Math.floor(Math.abs(abl.damage) / 2)} (Mod only)`,
        });
      }
      if (abl.drain != null && abl.drain !== 0) {
        sourceDetails[`data.abilities.${a}.total`].push({
          name: game.i18n.localize("FFD20.AbilityDrain"),
          value: -Math.abs(abl.drain),
        });
      }
    }

    // Add wound threshold data
    {
      const hpconf = game.settings.get("ffd20", "healthConfig").variants;
      const wtUsage = this.data.type === "npc" ? hpconf.npc.useWoundThresholds : hpconf.pc.useWoundThresholds;
      if (wtUsage > 0) {
        const wtData = this.getWoundThresholdData(actorData);

        if (wtData.level > 0) {
          const changeFlatKeys = ["~attackCore", "cmd", "init", "allSavingThrows", "ac", "skills", "abilityChecks"];
          for (let fk of changeFlatKeys) {
            let flats = getChangeFlat.call(this, fk, "penalty", actorData.data);
            if (!(flats instanceof Array)) flats = [flats];
            for (let k of flats) {
              if (!k) continue;
              sourceDetails[k].push({
                name: game.i18n.localize(CONFIG.FFD20.woundThresholdConditions[wtData.level]),
                value: -wtData.penalty,
              });
            }
          }
        }
      }
    }

    // Add extra data
    const rollData = this.getRollData();
    for (let [changeTarget, changeGrp] of Object.entries(extraData)) {
      for (let grp of Object.values(changeGrp)) {
        if (grp.length > 0) {
          sourceDetails[changeTarget] = sourceDetails[changeTarget] || [];
          for (let src of grp) {
            if (!src.operator) src.operator = "add";
            let srcInfo = this.constructor._translateSourceInfo(src.type, src.subtype, src.name);
            let srcValue =
              src.value != null
                ? src.value
                : RollFFD20$1.safeRoll(src.formula || "0", rollData, [changeTarget, src, this], {
                    suppressError: !this.testUserPermission(game.user, "OWNER"),
                  }).total;
            if (src.operator === "set") srcValue = game.i18n.localize("FFD20.SetTo").format(srcValue);
            if (!(src.operator === "add" && srcValue === 0) || src.ignoreNull === false) {
              sourceDetails[changeTarget].push({
                name: srcInfo,
                value: srcValue,
              });
            }
          }
        }
      }
    }

    this.sourceDetails = sourceDetails;
  }

  _getInherentTotalsKeys() {
    // Determine base keys
    const keys = {
      "data.attributes.ac.normal.total": 10,
      "data.attributes.ac.touch.total": 10,
      "data.attributes.ac.flatFooted.total": 10,
      "data.attributes.cmd.total": 10,
      "data.attributes.cmd.flatFootedTotal": 10,
      "data.attributes.acp.armorBonus": 0,
      "data.attributes.acp.shieldBonus": 0,
      "data.attributes.maxDexBonus": null,
      "temp.ac.armor": 0,
      "temp.ac.shield": 0,
      "temp.ac.natural": 0,
      "data.attributes.sr.total": 0,
      "data.attributes.init.bonus": 0,
      "data.attributes.init.total": 0,
      "data.attributes.cmb.total": 0,
      "data.attributes.hp.max": getProperty(this.data, "data.attributes.hp.base") ?? 0,
      "data.attributes.vigor.max": getProperty(this.data, "data.attributes.vigor.base") ?? 0,
      "data.attributes.wounds.max": getProperty(this.data, "data.attributes.wounds.base") ?? 0,
      "data.attributes.mp.max": getProperty(this.data, "data.attributes.mp.base") ?? 0,
      "data.attributes.attack.general": 0,
      "data.attributes.attack.melee": 0,
      "data.attributes.attack.ranged": 0,
      "data.attributes.attack.critConfirm": 0,
      "data.attributes.mDex": { armorBonus: 0, shieldBonus: 0 },
      "data.attributes.damage.general": 0,
      "data.attributes.damage.weapon": 0,
      "data.attributes.damage.spell": 0,
      "data.attributes.damage.shared": 0,
      "data.attributes.woundThresholds.level": 0,
      "data.attributes.woundThresholds.penaltyBase": 0,
      "data.attributes.woundThresholds.penalty": 0,
      "data.abilities.str.checkMod": 0,
      "data.abilities.dex.checkMod": 0,
      "data.abilities.con.checkMod": 0,
      "data.abilities.int.checkMod": 0,
      "data.abilities.wis.checkMod": 0,
      "data.abilities.cha.checkMod": 0,
      "data.details.carryCapacity.bonus.total": 0,
      "data.details.carryCapacity.multiplier.total": 0,
    };

    // Determine skill keys
    try {
      const skillKeys = getChangeFlat.call(this, "skills", "skills");
      for (let k of skillKeys) {
        keys[k] = 0;
      }
    } catch (err) {
      console.warn("Could not determine skills for an unknown actor in the creation process", this);
    }

    return keys;
  }

  _resetInherentTotals() {
    const keys = this._getInherentTotalsKeys();

    // Reset totals
    for (const [k, v] of Object.entries(keys)) {
      setProperty(this.data, k, v);
    }
  }

  async refresh() {
    if (this.isOwner) {
      return this.update({});
    }
  }

  /**
   * Prepare Character type specific data
   */
  _prepareCharacterData() {
    if (!hasProperty(this.data, "data.details.level.value")) return;

    // Experience bar
    let prior = this.getLevelExp(this.data.data.details.level.value - 1 || 0),
      max = this.getLevelExp(this.data.data.details.level.value || 1);

    this.data.data.details.xp.pct =
      ((Math.max(prior, Math.min(max, this.data.data.details.xp.value)) - prior) / (max - prior)) * 100 || 0;
  }

  /* -------------------------------------------- */

  /**
   * Prepare NPC type specific data
   */
  _prepareNPCData() {}

  /**
   * Return reduced movement speed.
   *
   * @param {number} value - The non-reduced movement speed.
   * @returns {number} The reduced movement speed.
   */
  static getReducedMovementSpeed(value) {
    const incr = 5;

    if (value <= 0) return value;
    if (value < 2 * incr) return incr;
    value = Math.floor(value / incr) * incr;

    let result = 0,
      counter = 2;
    for (let a = incr; a <= value; a += counter * incr) {
      result += incr;
      if (counter === 1) counter = 2;
      else counter = 1;
    }

    return result;
  }

  /**
   * Return increased amount of spell slots by ability score modifier. use this for bonus mp
   *
   * @param {number} mod - The associated ability modifier.
   * @param {number} level - Spell level.
   * @returns {number} Amount of spell levels to increase.
   */
  static getSpellSlotIncrease(mod, level) {
    if (level === 0) return 0;
    if (mod <= 0) return 0;
    return Math.max(0, Math.ceil((mod + 1 - level) / 4));
  }

  /**
   * Return the amount of experience required to gain a certain character level.
   *
   * @param level {number}  The desired level
   * @returns {number}       The XP required
   */
  getLevelExp(level) {
    const expConfig = game.settings.get("ffd20", "experienceConfig");
    const expTrack = expConfig.track;
    // Preset experience tracks
    if (["fast", "medium", "slow"].includes(expTrack)) {
      const levels = CONFIG.FFD20.CHARACTER_EXP_LEVELS[expTrack];
      return levels[Math.min(level, levels.length - 1)];
    }
    // Custom formula experience track
    let totalXP = 0;
    if (expConfig.custom.formula.length > 0) {
      for (let a = 0; a < level; a++) {
        const rollData = this.getRollData();
        rollData.level = a + 1;
        const roll = RollFFD20$1.safeRoll(expConfig.custom.formula, rollData);
        totalXP += roll.total;
      }
    }
    return Math.max(1, totalXP);
  }

  /* -------------------------------------------- */

  /**
   * Return the amount of experience granted by killing a creature of a certain CR.
   *
   * @param cr {null | number}     The creature's challenge rating
   * @returns {number}       The amount of experience granted per kill
   */
  getCRExp(cr) {
    if (cr < 1.0) return Math.max(400 * cr, 0);
    return CONFIG.FFD20.CR_EXP_LEVELS[cr];
  }

  /* -------------------------------------------- */
  /*  Socket Listeners and Handlers
  /* -------------------------------------------- */

  async preUpdate(data) {
    data = flattenObject(data);

    // Apply settings
    // Set used spellbook flags
    {
      const re = new RegExp(/^spellbook-([a-zA-Z]+)-inuse$/);
      const sbData = Object.entries(data)
        .filter((o) => {
          const result = o[0].match(re);
          if (result) delete data[o[0]];
          return result;
        })
        .map((o) => {
          return { spellbook: o[0].replace(re, "$1"), inUse: o[1] };
        });

      let usedSpellbooks = [];
      if (data["data.attributes.spells.usedSpellbooks"])
        usedSpellbooks = duplicate(data["data.attributes.spells.usedSpellbooks"]);
      else if (hasProperty(this.data, "data.attributes.spells.usedSpellbooks"))
        usedSpellbooks = duplicate(getProperty(this.data, "data.attributes.spells.usedSpellbooks"));

      for (let o of sbData) {
        if (o.inUse === true && !usedSpellbooks.includes(o.spellbook)) usedSpellbooks.push(o.spellbook);
        else if (o.inUse === false && usedSpellbooks.includes(o.spellbook))
          usedSpellbooks.splice(usedSpellbooks.indexOf(o.spellbook), 1);
      }
      data["data.attributes.spells.usedSpellbooks"] = usedSpellbooks;
    }

    // Apply changes in Actor size to Token width/height
    if (data["data.traits.size"] && this.data.data.traits.size !== data["data.traits.size"]) {
      let size = CONFIG.FFD20.tokenSizes[data["data.traits.size"]];
      if (!this.isToken && !getProperty(this.data, "token.flags.ffd20.staticSize")) {
        data["token.width"] = size.w;
        data["token.height"] = size.h;
        data["token.scale"] = size.scale;
      }
    }

    // Make certain variables absolute
    const _absoluteKeys = Object.keys(this.data.data.abilities)
      .reduce((arr, abl) => {
        arr.push(`data.abilities.${abl}.userPenalty`, `data.abilities.${abl}.damage`, `data.abilities.${abl}.drain`);
        return arr;
      }, [])
      .concat("data.attributes.energyDrain")
      .filter((k) => {
        return data[k] != null;
      });
    for (const k of _absoluteKeys) {
      data[k] = Math.abs(data[k]);
    }

    // Apply changes in resources
    for (let [k, v] of Object.entries(data)) {
      if (k.match(/^data\.resources\.([a-zA-Z0-9]+)\.value$/)) {
        const resKey = RegExp.$1;
        const itemId = getProperty(this.data, `data.resources.${resKey}._id`);
        if (itemId && itemId.length) {
          const updateData = mergeObject(this._queuedItemUpdates[itemId] ?? {}, {
            "data.uses.value": v,
          });
          if (!isObjectEmpty(updateData)) {
            this._queuedItemUpdates[itemId] = updateData;
          }
        }
      }
    }

    // Make only 1 fear condition active at most
    {
      const keys = ["shaken", "frightened", "panicked"];
      for (let k of keys) {
        k = `data.attributes.conditions.${k}`;
        if (data[k] === true) {
          for (let k2 of keys) {
            k2 = `data.attributes.conditions.${k2}`;
            if (k2 !== k) data[k2] = false;
          }
        }
      }
    }

    // Update experience
    this._updateExp(data);

    return data;
  }

  /**
   * Extend the default update method to enhance data before submission.
   * See the parent Entity.update method for full details.
   *
   * @param {object} data     The data with which to update the Actor
   * @param {object} options  Additional options which customize the update workflow
   * @returns {Promise}        A Promise which resolves to the updated Entity
   */
  async update(data, options = {}) {
    this._trackPreviousAttributes();

    // Avoid regular update flow for explicitly non-recursive update calls
    if (options.recursive === false) {
      return super.update(data, options);
    }

    data = await this.preUpdate(data);

    // Update changes
    let diff = diffObject(flattenObject(this.data), data);

    // Diff token data
    if (data.token != null) {
      diff.token = diffObject(this.data.token, data.token);
    }

    let result = diff;
    if (!isObjectEmpty(diff) && options.skipUpdate !== true) {
      return super.update(diff, mergeObject(options, { recursive: true }));
    }
    return result;
  }

  _onUpdate(data, options, userId, context) {
    if (userId === game.user.id) {
      this.toggleConditionStatusIcons();
    }

    super._onUpdate(data, options, userId, context);

    // Resize token(s)
    {
      const sizeKey = getProperty(data, "data.traits.size");
      if (sizeKey) {
        let size = CONFIG.FFD20.tokenSizes[sizeKey];
        let tokens = this.getActiveTokens(false, true).filter((o) => {
          if (getProperty(o.data, "flags.ffd20.staticSize")) return false;
          if (!getProperty(o.data, "actorLink")) return false;
          return true;
        });
        tokens.forEach((o) => {
          o.update({ width: size.w, height: size.h, scale: size.scale });
        });
      }
    }
  }

  async doQueuedUpdates() {
    if (!this.testUserPermission(game.user, "OWNER")) return;
    if (this._queuedUpdates == null) return;

    const diff = diffObject(duplicate(this.data._source), expandObject(this._queuedUpdates), { inner: true });
    this._queuedUpdates = {};
    if (!isObjectEmpty(diff)) {
      await this.update(diff);
    }
  }

  _preCreateEmbeddedDocuments(embeddedName, result, options, userId) {
    this._trackPreviousAttributes();

    super._preCreateEmbeddedDocuments(...arguments);
  }

  _onCreateEmbeddedDocuments(embeddedName, documents, result, options, userId) {
    if (userId === game.user.id && embeddedName === "Item") {
      this.toggleConditionStatusIcons();
    }
    super._onCreateEmbeddedDocuments(...arguments);
  }

  _preDeleteEmbeddedDocuments(embeddedName, result, options, userId) {
    this._trackPreviousAttributes();

    super._preDeleteEmbeddedDocuments(...arguments);
  }

  _preUpdateEmbeddedDocuments(embeddedName, result, options, userId) {
    this._trackPreviousAttributes();

    super._preUpdateEmbeddedDocuments(...arguments);
  }

  _onUpdateEmbeddedDocuments(embeddedName, documents, result, options, userId) {
    // Work around the issue where updating embedded entities on Tokens used a parameter less
    // NOTE: This is a dirty workaround which is a bug in core Foundry. Once this is fixed in Foundry, this should be undone.
    if (!(documents instanceof Array && result instanceof Array)) {
      userId = options;
      options = result;
      result = documents;
    }

    if (userId === game.user.id && embeddedName === "Item") {
      this.toggleConditionStatusIcons();
    }

    super._preUpdateEmbeddedDocuments(...arguments);

    if (this.sheet) this.sheet.render();

    // Redraw token effects
    const tokens = this.getActiveTokens();
    for (let t of tokens) {
      t.drawEffects();
    }
  }

  /**
   * Makes sure experience values are correct in update data.
   *
   * @param {object} data - The update data, as per ActorFFD20.update()
   * @param updateData
   */
  _updateExp(updateData) {
    // Get total level
    const classes = this.items.filter((o) => o.type === "class" && o.data.countforexp === "exp");
    const level = classes
      .filter((o) => o.data.data.classType !== "mythic")
      .reduce((cur, o) => cur + o.data.data.level, 0);

    // The following is not for NPCs
    if (this.data.type !== "character") return;

    if (updateData["data.details.xp.value"] == null) return;

    // Translate update exp value to number
    let newExp = updateData["data.details.xp.value"],
      resetExp = false;
    if (typeof newExp === "string") {
      const curExp =
        typeof this.data.data.details.xp.value === "number"
          ? this.data.data.details.xp.value
          : parseInt(this.data.data.details.xp.value);
      if (newExp.match(/^\+([0-9]+)$/)) {
        newExp = curExp + parseInt(RegExp.$1);
      } else if (newExp.match(/^-([0-9]+)$/)) {
        newExp = curExp - parseInt(RegExp.$1);
      } else if (newExp === "") {
        resetExp = true;
      } else if (newExp.match(/^([0-9]+)$/)) {
        newExp = parseInt(newExp);
      } else {
        newExp = curExp;
      }

      updateData["data.details.xp.value"] = newExp;
    }
    const maxExp = this.getLevelExp(level);
    updateData["data.details.xp.max"] = maxExp;

    if (resetExp) {
      const minExp = level > 0 ? this.getLevelExp(level - 1) : 0;
      updateData["data.details.xp.value"] = minExp;
    }
  }

  async _onCreate(data, options, userId, context) {
    if (game.userId === userId) {
      if (data.type === "character") this.update({ "token.actorLink": true }, { updateChanges: false });
    }

    super._onCreate(data, options, userId, context);
  }

  updateItemResources(itemData) {
    const activationType = game.settings.get("ffd20", "unchainedActionEconomy")
      ? itemData.data.unchainedAction?.activation?.type
      : itemData.data.activation?.type;
    if (itemData.data.uses?.per && activationType) {
      const itemTag = !itemData.data.useCustomTag ? createTag(itemData.name) : itemData.data.tag;
      const resKey = `data.resources.${itemTag}`;
      let curUses = itemData.data.uses;

      const res = { value: 0, max: 0, _id: null };
      setProperty(this.data, resKey, res);
      res.value = curUses.value;
      res.max = curUses.max;
      res._id = itemData._id;
      return true;
    }

    return false;
  }

  /* -------------------------------------------- */

  /**
   * See the base Actor class for API documentation of this method
   *
   * @param itemData
   * @param options
   */
  async createOwnedItem(itemData, options) {
    let t = itemData.type;
    let initial = {};
    // Assume NPCs are always proficient with weapons and always have spells prepared
    const hasPlayerOwner = this.hasPlayerOwner;
    if (!hasPlayerOwner) {
      if (t === "weapon") initial["data.proficient"] = true;
      if (["weapon", "equipment"].includes(t)) initial["data.equipped"] = true;
    }
    if (t === "spell") {
      if (this.sheet != null && this.sheet._spellbookTab != null) {
        initial["data.spellbook"] = this.sheet._spellbookTab;
      }
    }

    // Alter change ids
    for (const c of getProperty(itemData, "data.changes") || []) {
      c._id = randomID(8);
    }

    mergeObject(itemData, initial);
    return ItemFFD20.create(itemData, { parent: this });
  }

  /* -------------------------------------------- */
  /*  Rolls                                       */
  /* -------------------------------------------- */

  /**
   * Cast a Spell, consuming a spell slot of a certain level, FIX temp mp uses
   *
   * @param {ItemFFD20} item   The spell being cast by the actor
   * @param {MouseEvent} ev The click event
   * @param root0
   * @param root0.skipDialog
   */
  async useSpell(item, ev, { skipDialog = false } = {}) {
    if (!this.isOwner) {
      const msg = game.i18n.localize("FFD20.ErrorNoActorPermissionAlt").format(this.name);
      console.warn(msg);
      return ui.notifications.warn(msg);
    }
    if (item.data.type !== "spell") throw new Error("Wrong Item type");

    if (
      getProperty(item.data, "data.preparation.mode") !== "atwill" &&
      item.getSpellUses() < item.chargeCost &&
      item.autoDeductCharges
    ) {
      const msg = game.i18n.localize("FFD20.ErrorNoMPLeft");
      console.warn(msg);
      return ui.notifications.warn(msg);
    }

    // Invoke the Item roll
    return item.useAttack({ ev: ev, skipDialog: skipDialog });
  }

  async createAttackFromWeapon(item) {
    if (!this.isOwner) {
      const msg = game.i18n.localize("FFD20.ErrorNoActorPermissionAlt").format(this.name);
      console.warn(msg);
      return ui.notifications.warn(msg);
    }

    if (item.data.type !== "weapon") throw new Error("Wrong Item type");

    // Get attack template
    let attackData = { data: {} };
    for (const template of game.data.system.template.Item.attack.templates) {
      mergeObject(attackData.data, game.data.system.template.Item.templates[template]);
    }
    mergeObject(attackData.data, duplicate(game.data.system.template.Item.attack));
    attackData = flattenObject(attackData);

    // Add ability modifiers
    const isMelee = getProperty(item.data, "data.weaponSubtype") !== "ranged";

    if (isMelee)
      attackData["data.ability.attack"] = getProperty(this.data, "data.attributes.attack.meleeAbility") || "str";
    else attackData["data.ability.attack"] = getProperty(this.data, "data.attributes.attack.rangedAbility") || "dex";

    if (isMelee) {
      attackData["data.ability.damage"] = "str";
      if (item.data.data.weaponSubtype === "2h" && isMelee) {
        attackData["data.ability.damageMult"] = 1.5;
        attackData["data.held"] = "2h";
      }
    }

    // Add misc things
    attackData["type"] = "attack";
    attackData["name"] = item.data.name;
    attackData["data.masterwork"] = item.data.data.masterwork;
    attackData["data.nonlethal"] = item.data.data.nonlethal;
    attackData["data.attackType"] = "weapon";
    attackData["data.enh"] = item.data.data.enh;
    attackData["data.ability.critRange"] = item.data.data.weaponData.critRange || 20;
    attackData["data.ability.critMult"] = item.data.data.weaponData.critMult || 2;
    attackData["data.actionType"] = isMelee ? "mwak" : "rwak";
    attackData["data.activation.type"] = "attack";
    attackData["data.duration.units"] = "inst";
    attackData["data.range.units"] = "melee";
    attackData["data.broken"] = item.data.data.broken;
    attackData["data.range.maxIncrements"] = item.data.data.weaponData.maxRangeIncrements;
    attackData["img"] = item.data.img;

    // Add additional attacks
    attackData["data.formulaicAttacks.count.formula"] = "ceil(@attributes.bab.total / 5) - 1";
    attackData["data.formulaicAttacks.bonus.formula"] = "@formulaicAttack * -5";

    // Add damage formula
    if (item.data.data.weaponData.damageRoll) {
      const die = item.data.data.weaponData.damageRoll || "1d4";
      let part = die;
      let dieCount = 1,
        dieSides = 4;
      if (die.match(/^([0-9]+)d([0-9]+)$/)) {
        dieCount = parseInt(RegExp.$1);
        dieSides = parseInt(RegExp.$2);
        // const weaponSize = Object.keys(CONFIG.FFD20.sizeChart).indexOf(item.data.data.weaponData.size) - 4;
        part = `sizeRoll(${dieCount}, ${dieSides}, @size)`;
      }
      const bonusFormula = getProperty(item.data, "data.weaponData.damageFormula");
      if (bonusFormula != null && bonusFormula.length) part = `${part} + ${bonusFormula}`;
      attackData["data.damage.parts"] = [[part, item.data.data.weaponData.damageType || ""]];
    }

    // Add attack bonus formula
    {
      const bonusFormula = getProperty(item.data, "data.weaponData.attackFormula");
      if (bonusFormula != null && bonusFormula.length) attackData["data.attackBonus"] = bonusFormula;
    }

    // Set reach
    if (isMelee && getProperty(item.data, "data.properties.rch") === true) {
      attackData["data.range.units"] = "reach";
    }

    // Add range
    if (!isMelee && getProperty(item.data, "data.weaponData.range") != null) {
      attackData["data.range.units"] = "ft";
      attackData["data.range.value"] = getProperty(item.data, "data.weaponData.range").toString();
    }

    // Create attack
    if (hasProperty(attackData, "data.templates")) delete attackData["data.templates"];
    const itemData = await this.createOwnedItem(expandObject(attackData));

    // Create link
    if (itemData.type === "attack") {
      // check for correct itemData, Foundry #3419
      const newItem = this.items.find((o) => o.id === itemData.id);
      if (newItem) {
        await item.createItemLink("children", "data", newItem, itemData.id);
      }
    }

    ui.notifications.info(game.i18n.localize("FFD20.NotificationCreatedAttack").format(item.data.name));
  }

  /* -------------------------------------------- */

  getSkillInfo(skillId) {
    let skl,
      sklName,
      parentSkill;
    const skillParts = skillId.split("."),
      isSubSkill = skillParts[1] === "subSkills" && skillParts.length === 3;
    if (isSubSkill) {
      skillId = skillParts[0];
      skl = this.data.data.skills[skillId].subSkills[skillParts[2]];
      if (!skl) return null;
      sklName = `${CONFIG.FFD20.skills[skillId]} (${skl.name})`;
      parentSkill = this.getSkillInfo(skillId);
    } else {
      skl = this.data.data.skills[skillId];
      if (!skl) return null;
      if (skl.name != null) {
        sklName = skl.name;
      } else sklName = CONFIG.FFD20.skills[skillId];
    }

    const result = duplicate(skl);
    result.id = skillId;
    result.name = sklName;
    result.bonus = skl.mod; // deprecated; backwards compatibility

    if (parentSkill) result.parentSkill = parentSkill;

    return result;
  }

  /**
   * Roll a Skill Check
   * Prompt the user for input regarding Take 10/Take 20 and any Situational Bonus
   *
   * @param {string} skillId      The skill id (e.g. "per", or "prf.subSkills.prf1")
   * @param {object} options      Options which configure how the skill check is rolled
   */
  rollSkill(
    skillId,
    options = { event: null, skipDialog: false, staticRoll: null, chatMessage: true, noSound: false, dice: "1d20" }
  ) {
    if (!this.isOwner) {
      const msg = game.i18n.localize("FFD20.ErrorNoActorPermissionAlt").format(this.name);
      console.warn(msg);
      return ui.notifications.warn(msg);
    }

    const allowed = Hooks.call("actorRoll", this, "skill", skillId, options);
    if (allowed === false) return;

    const skl = this.getSkillInfo(skillId);

    // Add contextual attack string
    let notes = [];
    let rollData = this.getRollData();
    const noteObjects = this.getContextNotes(`skill.${skillId}`);
    for (let noteObj of noteObjects) {
      rollData.item = {};
      if (noteObj.item != null) rollData = noteObj.item.getRollData();

      for (let note of noteObj.notes) {
        notes.push(...note.split(/[\n\r]+/).map((o) => TextEditor.enrichHTML(o, { rollData: rollData })));
      }
    }
    // Add untrained note
    if (skl.rt && !skl.rank) {
      notes.push(game.i18n.localize("FFD20.Untrained"));
    }

    // Gather changes
    let parts = [];
    const changes = this.changes.filter((c) => {
      let cf = getChangeFlat.call(this, c.subTarget, c.modifier);
      if (!(cf instanceof Array)) cf = [cf];

      return cf.includes(`data.skills.${skillId}.changeBonus`);
    });

    // Add ability modifier
    if (skl.ability) {
      parts.push(`@abilities.${skl.ability}.mod[${CONFIG.FFD20.abilities[skl.ability]}]`);
    }

    // Add rank
    if (skl.rank > 0) {
      parts.push(`${skl.rank}[${game.i18n.localize("FFD20.SkillRankPlural")}]`);
      if (skl.cs) {
        parts.push(`3[${game.i18n.localize("FFD20.CSTooltip")}]`);
      }
    }

    // Add armor check penalty
    if (skl.acp && rollData.attributes.acp.total !== 0) {
      parts.push(`-@attributes.acp.total[${game.i18n.localize("FFD20.ACPLong")}]`);
    }

    // Add Wound Thresholds info
    if (rollData.attributes.woundThresholds?.penalty > 0) {
      parts.push(
        `- @attributes.woundThresholds.penalty[${game.i18n.localize(
          CONFIG.FFD20.woundThresholdConditions[rollData.attributes.woundThresholds.level]
        )}]`
      );
    }

    // Add changes
    for (let c of changes) {
      if (!c.value) continue;
      parts.push(`${c.value}[${c.flavor}]`);
    }

    let props = [];
    if (notes.length > 0) props.push({ header: game.i18n.localize("FFD20.Notes"), value: notes });
    return DiceFFD20.d20Roll({
      event: options.event,
      fastForward: options.skipDialog === true,
      staticRoll: options.staticRoll,
      parts,
      dice: options.dice,
      data: rollData,
      subject: { skill: skillId },
      title: game.i18n.localize("FFD20.SkillCheck").format(skl.name),
      speaker: ChatMessage.getSpeaker({ actor: this }),
      chatTemplate: "systems/ffd20/templates/chat/roll-ext.hbs",
      chatTemplateData: { hasProperties: props.length > 0, properties: props },
      chatMessage: options.chatMessage,
      noSound: options.noSound,
      compendiumEntry: CONFIG.FFD20.skillCompendiumEntries[skillId],
    });
  }

  /* -------------------------------------------- */

  /**
   * Roll a generic ability test or saving throw.
   * Prompt the user for input on which variety of roll they want to do.
   *
   * @param {string} abilityId     The ability id (e.g. "str")
   * @param {object} options      Options which configure how ability tests or saving throws are rolled
   */
  rollAbility(abilityId, options = { noSound: false, dice: "1d20" }) {
    this.rollAbilityTest(abilityId, options);
  }

  rollBAB(options = { chatMessage: true, noSound: false, dice: "1d20" }) {
    if (!this.isOwner) {
      const msg = game.i18n.localize("FFD20.ErrorNoActorPermissionAlt").format(this.name);
      console.warn(msg);
      return ui.notifications.warn(msg);
    }

    const allowed = Hooks.call("actorRoll", this, "bab", null, options);
    if (allowed === false) return;

    return DiceFFD20.d20Roll({
      event: options.event,
      parts: [`@mod[${game.i18n.localize("FFD20.BABAbbr")}]`],
      dice: options.dice,
      data: { mod: this.data.data.attributes.bab.total },
      subject: { core: "bab" },
      title: game.i18n.localize("FFD20.BAB"),
      speaker: ChatMessage.getSpeaker({ actor: this }),
      takeTwenty: false,
      chatTemplate: "systems/ffd20/templates/chat/roll-ext.hbs",
      chatMessage: options.chatMessage,
      noSound: options.noSound,
    });
  }

  rollCMB(options = { ability: null, chatMessage: true, noSound: false, dice: "1d20" }) {
    if (!this.isOwner) {
      const msg = game.i18n.localize("FFD20.ErrorNoActorPermissionAlt").format(this.name);
      console.warn(msg);
      return ui.notifications.warn(msg);
    }

    const allowed = Hooks.call("actorRoll", this, "cmb", null, options);
    if (allowed === false) return;

    // Add contextual notes
    let notes = [];
    let rollData = this.getRollData();
    const noteObjects = this.getContextNotes("misc.cmb");
    for (let noteObj of noteObjects) {
      rollData.item = {};
      if (noteObj.item != null) rollData = noteObj.item.getRollData();

      for (let note of noteObj.notes) {
        notes.push(...note.split(/[\n\r]+/).map((o) => TextEditor.enrichHTML(o, { rollData: rollData })));
      }
    }

    const parts = [];

    const describePart = (value, label) => parts.push(`${value}[${label}]`);
    const srcDetails = (s) => s?.reverse().forEach((d) => describePart(d.value, d.name));
    srcDetails(this.sourceDetails["data.attributes.cmb.total"]);
    srcDetails(this.sourceDetails["data.attributes.attack.shared"]);

    // Unreliable melee/ranged identification
    const isMelee =
      ["mwak", "msak", "mcman"].includes(this.data.data.actionType) ||
      ["melee", "reach"].includes(this.data.data.range.units);
    const isRanged =
      ["rwak", "rsak", "rcman"].includes(this.data.data.actionType) || this.data.data.weaponSubtype === "ranged";

    const changeSources = ["attack"];
    if (isRanged) changeSources.push("rattack");
    if (isMelee) changeSources.push("mattack");
    const effectiveChanges = getHighestChanges(
      this.changes.filter((c) => changeSources.includes(c.subTarget)),
      { ignoreTarget: true }
    );
    effectiveChanges.forEach((ic) => describePart(ic.value, ic.flavor));

    const abl = options.ability ?? this.data.data.attributes.cmbAbility;
    const ablMod = getProperty(this.data, `data.abilities.${abl}.mod`) ?? 0;
    if (ablMod != 0) describePart(ablMod, CONFIG.FFD20.abilities[abl]);

    // Add grapple note
    if (this.data.data.attributes.conditions.grappled) {
      notes.push("+2 to Grapple");
    }

    let props = [];
    if (notes.length > 0) props.push({ header: game.i18n.localize("FFD20.Notes"), value: notes });
    return DiceFFD20.d20Roll({
      event: options.event,
      parts,
      dice: options.dice,
      data: this.getRollData(),
      subject: { core: "cmb" },
      title: game.i18n.localize("FFD20.CMB"),
      speaker: ChatMessage.getSpeaker({ actor: this }),
      takeTwenty: false,
      chatTemplate: "systems/ffd20/templates/chat/roll-ext.hbs",
      chatTemplateData: { hasProperties: props.length > 0, properties: props },
      chatMessage: options.chatMessage,
      noSound: options.noSound,
    });
  }

  rollAttack(options = { melee: true, chatMessage: true, noSound: false, dice: "1d20" }) {
    if (!this.isOwner) {
      const msg = game.i18n.localize("FFD20.ErrorNoActorPermissionAlt").format(this.name);
      console.warn(msg);
      return ui.notifications.warn(msg);
    }

    const sources = [
      ...this.sourceDetails["data.attributes.attack.shared"],
      // ...this.sourceDetails["data.attributes.attack.general"],
      // ...this.sourceDetails[`data.attributes.attack.${options.melee ? "melee" : "ranged"}`],
    ];

    // Add contextual notes
    let notes = [];
    let rollData = this.getRollData();
    const noteObjects = [...this.getContextNotes("attacks.effect"), ...this.getContextNotes("attacks.attack")];
    for (let noteObj of noteObjects) {
      rollData.item = {};
      if (noteObj.item != null) rollData = noteObj.item.getRollData();

      for (let note of noteObj.notes) {
        notes.push(...note.split(/[\n\r]+/).map((o) => TextEditor.enrichHTML(o, { rollData: rollData })));
      }
    }
    rollData.item = {};

    let changes = sources
      .filter((item) => Number.isInteger(item.value))
      .map((i) => {
        return `${i.value}[${i.name}]`;
      });

    // Add attack bonuses from changes
    const attackTargets = ["attack"].concat(options.melee ? ["mattack"] : ["rattack"]);
    const attackChanges = this.changes.filter((c) => {
      return attackTargets.includes(c.subTarget);
    });
    changes.push(
      ...attackChanges.map((c) => {
        c.applyChange(this);
        return `${c.value}[${c.parent ? c.parent.name : c.data.modifier}]`;
      })
    );

    // Add ability modifier
    const atkAbl = getProperty(this.data, `data.attributes.attack.${options.melee ? "melee" : "ranged"}Ability`);
    changes.push(`${getProperty(this.data, `data.abilities.${atkAbl}.mod`)}[${CONFIG.FFD20.abilities[atkAbl]}]`);

    getProperty(this.data, "data.traits.size");
    rollData.sizeBonus = CONFIG.FFD20.sizeMods[getProperty(this.data, "data.traits.size") ?? "med"];
    if (rollData.sizeBonus != 0) changes.push(`@sizeBonus[${game.i18n.localize("FFD20.Size")}]`);

    let props = [];
    if (notes.length > 0) props.push({ header: game.i18n.localize("FFD20.Notes"), value: notes });
    return DiceFFD20.d20Roll({
      event: options.event,
      parts: changes,
      dice: options.dice,
      data: rollData,
      subject: { core: "attack" },
      title: game.i18n.localize(`FFD20.${options.melee ? "Melee" : "Ranged"}`),
      speaker: ChatMessage.getSpeaker({ actor: this }),
      takeTwenty: false,
      chatTemplate: "systems/ffd20/templates/chat/roll-ext.hbs",
      chatTemplateData: { hasProperties: props.length > 0, properties: props },
      chatMessage: options.chatMessage,
      noSound: options.noSound,
    });
  }

  rollCL(spellbookKey, options = { chatMessage: true, noSound: false, dice: "1d20" }) {
    const spellbook = this.data.data.attributes.spells.spellbooks[spellbookKey];
    const rollData = duplicate(this.getRollData());
    rollData.cl = spellbook.cl.total;

    const allowed = Hooks.call("actorRoll", this, "cl", spellbookKey, options);
    if (allowed === false) return;

    // Add contextual caster level string
    const notes = this.getContextNotesParsed(`spell.cl.${spellbookKey}`);

    // Wound Threshold penalty
    const wT = this.getWoundThresholdData();
    if (wT.valid) notes.push(game.i18n.localize(CONFIG.FFD20.woundThresholdConditions[wT.level]));

    let props = [];
    if (notes.length > 0) props.push({ header: game.i18n.localize("FFD20.Notes"), value: notes });
    return DiceFFD20.d20Roll({
      event: event,
      parts: [`@cl[${game.i18n.localize("FFD20.CasterLevel")}]`],
      data: rollData,
      subject: { core: "cl" },
      title: game.i18n.localize("FFD20.CasterLevelCheck"),
      speaker: ChatMessage.getSpeaker({ actor: this }),
      takeTwenty: false,
      chatTemplate: "systems/ffd20/templates/chat/roll-ext.hbs",
      chatTemplateData: { hasProperties: props.length > 0, properties: props },
      chatMessage: options.chatMessage,
      noSound: options.noSound,
    });
  }

  rollConcentration(spellbookKey, options = { chatMessage: true, noSound: false, dice: "1d20" }) {
    const spellbook = this.data.data.attributes.spells.spellbooks[spellbookKey];
    const rollData = duplicate(this.getRollData());
    rollData.cl = spellbook.cl.total;
    rollData.mod = this.data.data.abilities[spellbook.ability]?.mod ?? 0;
    rollData.concentrationBonus = spellbook.concentration;

    const allowed = Hooks.call("actorRoll", this, "concentration", spellbookKey, options);
    if (allowed === false) return;

    // Add contextual concentration string
    const notes = this.getContextNotesParsed(`spell.concentration.${spellbookKey}`);

    // Wound Threshold penalty
    const wT = this.getWoundThresholdData();
    if (wT.valid) notes.push(game.i18n.localize(CONFIG.FFD20.woundThresholdConditions[wT.level]));
    // TODO: Make the penalty show separate of the CL.total.

    let props = [];
    if (notes.length > 0) props.push({ header: game.i18n.localize("FFD20.Notes"), value: notes });

    let formulaRoll = 0;
    if (spellbook.concentrationFormula.length)
      formulaRoll = RollFFD20$1.safeRoll(spellbook.concentrationFormula, rollData).total;
    rollData.formulaBonus = formulaRoll;

    return DiceFFD20.d20Roll({
      event: event,
      parts: [
        `@cl[${game.i18n.localize("FFD20.CasterLevel")}] + @mod[${
          CONFIG.FFD20.abilities[spellbook.ability]
        }] + (@concentrationBonus + @formulaBonus)[${game.i18n.localize("FFD20.ByBonus")}]`,
      ],
      dice: options.dice,
      data: rollData,
      subject: { core: "concentration" },
      title: game.i18n.localize("FFD20.ConcentrationCheck"),
      speaker: ChatMessage.getSpeaker({ actor: this }),
      takeTwenty: false,
      chatTemplate: "systems/ffd20/templates/chat/roll-ext.hbs",
      chatTemplateData: { hasProperties: props.length > 0, properties: props },
      chatMessage: options.chatMessage,
      noSound: options.noSound,
    });
  }

  getDefenseHeaders() {
    const data = this.data.data;
    const headers = [];

    const reSplit = CONFIG.FFD20.re.traitSeparator;
    let misc = [];

    // Damage reduction
    if (data.traits.dr.length) {
      headers.push({ header: game.i18n.localize("FFD20.DamRed"), value: data.traits.dr.split(reSplit) });
    }
    // Energy resistance
    if (data.traits.eres.length) {
      headers.push({ header: game.i18n.localize("FFD20.EnRes"), value: data.traits.eres.split(reSplit) });
    }
    // Damage vulnerabilities
    if (data.traits.dv.value.length || data.traits.dv.custom.length) {
      const value = [].concat(
        data.traits.dv.value.map((obj) => {
          return CONFIG.FFD20.damageTypes[obj];
        }),
        data.traits.dv.custom.length > 0 ? data.traits.dv.custom.split(";") : []
      );
      headers.push({ header: game.i18n.localize("FFD20.DamVuln"), value: value });
    }
    // Condition resistance
    if (data.traits.cres.length) {
      headers.push({ header: game.i18n.localize("FFD20.ConRes"), value: data.traits.cres.split(reSplit) });
    }
    // Immunities
    if (
      data.traits.di.value.length ||
      data.traits.di.custom.length ||
      data.traits.ci.value.length ||
      data.traits.ci.custom.length
    ) {
      const value = [].concat(
        data.traits.di.value.map((obj) => {
          return CONFIG.FFD20.damageTypes[obj];
        }),
        data.traits.di.custom.length > 0 ? data.traits.di.custom.split(";") : [],
        data.traits.ci.value.map((obj) => {
          return CONFIG.FFD20.conditionTypes[obj];
        }),
        data.traits.ci.custom.length > 0 ? data.traits.ci.custom.split(";") : []
      );
      headers.push({ header: game.i18n.localize("FFD20.ImmunityPlural"), value: value });
    }
    // Spell Resistance
    if (data.attributes.sr.total > 0) {
      misc.push(game.i18n.localize("FFD20.SpellResistanceNote").format(data.attributes.sr.total));
    }

    if (misc.length > 0) {
      headers.push({ header: game.i18n.localize("FFD20.MiscShort"), value: misc });
    }

    return headers;
  }

  getInitiativeContextNotes() {
    let notes = this.getContextNotes("misc.init").reduce((arr, o) => {
      for (let n of o.notes) arr.push(...n.split(/[\n\r]+/));
      return arr;
    }, []);

    let notesHTML;
    if (notes.length > 0) {
      // Format notes if they're present
      let notesHTMLParts = [];
      notes.forEach((note) => notesHTMLParts.push(`<span class="tag">${note}</span>`));
      notesHTML =
        '<div class="flexcol property-group gm-sensitive"><label>' +
        game.i18n.localize("FFD20.Notes") +
        '</label> <div class="flexrow">' +
        notesHTMLParts.join("") +
        "</div></div>";
    }

    return [notes, notesHTML];
  }

  async rollInitiative({ createCombatants = false, rerollInitiative = false, initiativeOptions = {} } = {}) {
    // Obtain (or create) a combat encounter
    let combat = game.combat;
    if (!combat) {
      if (game.user.isGM && canvas.scene) {
        combat = await game.combats.documentClass.create({ scene: canvas.scene.id, active: true });
      } else {
        ui.notifications.warn(game.i18n.localize("COMBAT.NoneActive"));
        return null;
      }
    }

    // Create new combatants
    if (createCombatants) {
      const tokens = this.isToken ? [this.token] : this.getActiveTokens();
      const createData = tokens.reduce((arr, t) => {
        if (t.inCombat) return arr;
        arr.push({ tokenId: t.id, hidden: t.data.hidden });
        return arr;
      }, []);
      await combat.createEmbeddedDocuments("Combatant", createData);
    }

    // Iterate over combatants to roll for
    const combatantIds = combat.combatants.reduce((arr, c) => {
      if (c.actor.id !== this.id || (this.isToken && c.data.tokenId !== this.token.id)) return arr;
      if (c.initiative && !rerollInitiative) return arr;
      arr.push(c.id);
      return arr;
    }, []);
    return combatantIds.length ? combat.rollInitiative(combatantIds, initiativeOptions) : combat;
  }

  rollSavingThrow(
    savingThrowId,
    options = { event: null, chatMessage: true, noSound: false, skipPrompt: true, dice: "1d20" }
  ) {
    if (!this.isOwner) {
      const msg = game.i18n.localize("FFD20.ErrorNoActorPermissionAlt").format(this.name);
      console.warn(msg);
      return ui.notifications.warn(msg);
    }

    const allowed = Hooks.call("actorRoll", this, "save", savingThrowId, options);
    if (allowed === false) return;

    // Add contextual notes
    let notes = [];
    let rollData = this.getRollData();
    const noteObjects = this.getContextNotes(`savingThrow.${savingThrowId}`);
    for (let noteObj of noteObjects) {
      rollData.item = {};
      if (noteObj.item != null) rollData = noteObj.item.getRollData();

      for (let note of noteObj.notes) {
        notes.push(...note.split(/[\n\r]+/).map((o) => TextEditor.enrichHTML(o, { rollData: rollData })));
      }
    }

    let parts = [];

    // Get base
    const base = getProperty(this.data, `data.attributes.savingThrows.${savingThrowId}.base`);
    if (base) parts.push(`${base}[${game.i18n.localize("FFD20.Base")}]`);

    // Add changes
    let changeBonus = [];
    const changes = this.changes.filter((c) => ["allSavingThrows", savingThrowId].includes(c.subTarget));
    {
      // Get damage bonus
      changeBonus = getHighestChanges(
        changes.filter((c) => {
          c.applyChange(this);
          return !["set", "="].includes(c.operator);
        }),
        { ignoreTarget: true }
      ).reduce((cur, c) => {
        if (c.value)
          cur.push({
            value: c.value,
            source: c.flavor,
          });
        return cur;
      }, []);
    }
    for (let c of changeBonus) {
      parts.push(`${c.value}[${c.source}]`);
    }

    // Wound Threshold penalty
    if (rollData.attributes.woundThresholds.penalty > 0) {
      notes.push(game.i18n.localize(CONFIG.FFD20.woundThresholdConditions[rollData.attributes.woundThresholds.level]));
      parts.push(
        `- @attributes.woundThresholds.penalty[${game.i18n.localize(
          CONFIG.FFD20.woundThresholdConditions[rollData.attributes.woundThresholds.level]
        )}]`
      );
    }

    // Roll saving throw
    let props = this.getDefenseHeaders();
    if (notes.length > 0) props.push({ header: game.i18n.localize("FFD20.Notes"), value: notes });
    const label = CONFIG.FFD20.savingThrows[savingThrowId];
    return DiceFFD20.d20Roll({
      event: options.event,
      parts,
      dice: options.dice,
      situational: true,
      data: rollData,
      subject: { save: savingThrowId },
      title: game.i18n.localize("FFD20.SavingThrowRoll").format(label),
      speaker: ChatMessage.getSpeaker({ actor: this }),
      takeTwenty: false,
      fastForward: options.skipPrompt !== false ? true : false,
      chatTemplate: "systems/ffd20/templates/chat/roll-ext.hbs",
      chatTemplateData: { hasProperties: props.length > 0, properties: props },
      chatMessage: options.chatMessage,
      noSound: options.noSound,
    });
  }

  /* -------------------------------------------- */

  /**
   * Roll an Ability Test
   * Prompt the user for input regarding Advantage/Disadvantage and any Situational Bonus
   *
   * @param {string} abilityId    The ability ID (e.g. "str")
   * @param {object} options      Options which configure how ability tests are rolled
   */
  rollAbilityTest(abilityId, options = { chatMessage: true, noSound: false, dice: "1d20" }) {
    if (!this.isOwner) {
      const msg = game.i18n.localize("FFD20.ErrorNoActorPermissionAlt").format(this.name);
      console.warn(msg);
      return ui.notifications.warn(msg);
    }

    const allowed = Hooks.call("actorRoll", this, "ability", abilityId, options);
    if (allowed === false) return;

    // Add contextual notes
    let notes = [];
    let rollData = this.getRollData();
    const noteObjects = this.getContextNotes(`abilityChecks.${abilityId}`);
    for (let noteObj of noteObjects) {
      rollData.item = {};
      if (noteObj.item != null) rollData = noteObj.item.getRollData();

      for (let note of noteObj.notes) {
        notes.push(...note.split(/[\n\r]+/).map((o) => TextEditor.enrichHTML(o, { rollData: rollData })));
      }
    }

    const label = CONFIG.FFD20.abilities[abilityId];
    const abl = this.data.data.abilities[abilityId];

    const parts = [`@abilities.${abilityId}.mod[${label}]`];
    if (abl.checkMod != 0) {
      const changes = this.sourceDetails[`data.abilities.${abilityId}.checkMod`];
      for (let c of changes) parts.push(`${c.value}[${c.name}]`);
    }
    if (this.data.data.attributes.energyDrain) {
      parts.push("-@attributes.energyDrain");
    }

    // Wound Threshold penalty
    if (rollData.attributes.woundThresholds.penalty > 0) {
      notes.push(game.i18n.localize(CONFIG.FFD20.woundThresholdConditions[rollData.attributes.woundThresholds.level]));
      parts.push(
        `- @attributes.woundThresholds.penalty[${game.i18n.localize(
          CONFIG.FFD20.woundThresholdConditions[rollData.attributes.woundThresholds.level]
        )}]`
      );
    }

    const props = [];
    if (notes.length > 0) props.push({ header: game.i18n.localize("FFD20.Notes"), value: notes });

    return DiceFFD20.d20Roll({
      event: options.event,
      parts,
      dice: options.dice,
      data: rollData,
      subject: { ability: abilityId },
      title: game.i18n.localize("FFD20.AbilityTest").format(label),
      speaker: ChatMessage.getSpeaker({ actor: this }),
      chatTemplate: "systems/ffd20/templates/chat/roll-ext.hbs",
      chatTemplateData: { hasProperties: props.length > 0, properties: props },
      chatMessage: options.chatMessage,
      noSound: options.noSound,
    });
  }

  /**
   * Show defenses in chat
   */
  async rollDefenses() {
    if (!this.isOwner) {
      const msg = game.i18n.localize("FFD20.ErrorNoActorPermissionAlt").format(this.name);
      console.warn(msg);
      return ui.notifications.warn(msg);
    }
    let rollData = this.getRollData();

    // Add contextual AC notes
    let acNotes = [];
    if (this.data.data.attributes.acNotes.length > 0) acNotes = this.data.data.attributes.acNotes.split(/[\n\r]+/);
    const acNoteObjects = this.getContextNotes("misc.ac");
    for (let noteObj of acNoteObjects) {
      rollData.item = {};
      if (noteObj.item != null) rollData = noteObj.item.getRollData();

      for (let note of noteObj.notes) {
        acNotes.push(...note.split(/[\n\r]+/).map((o) => TextEditor.enrichHTML(o, { rollData: rollData })));
      }
    }

    // Add contextual CMD notes
    let cmdNotes = [];
    if (this.data.data.attributes.cmdNotes.length > 0) cmdNotes = this.data.data.attributes.cmdNotes.split(/[\n\r]+/);
    const cmdNoteObjects = this.getContextNotes("misc.cmd");
    for (let noteObj of cmdNoteObjects) {
      rollData.item = {};
      if (noteObj.item != null) rollData = noteObj.item.getRollData();

      for (let note of noteObj.notes) {
        cmdNotes.push(...note.split(/[\n\r]+/).map((o) => TextEditor.enrichHTML(o, { rollData: rollData })));
      }
    }

    // Add contextual SR notes
    let srNotes = [];
    if (this.data.data.attributes.srNotes.length > 0) srNotes = this.data.data.attributes.srNotes.split(/[\n\r]+/);
    const srNoteObjects = this.getContextNotes("misc.sr");
    for (let noteObj of srNoteObjects) {
      rollData.item = {};
      if (noteObj.item != null) rollData = noteObj.item.getRollData();

      for (let note of noteObj.notes) {
        srNotes.push(...note.split(/[\n\r]+/).map((o) => TextEditor.enrichHTML(o, { rollData: rollData })));
      }
    }

    // Add misc data
    const reSplit = CONFIG.FFD20.re.traitSeparator;
    // Damage Reduction
    let drNotes = [];
    if (this.data.data.traits.dr.length) {
      drNotes = this.data.data.traits.dr.split(reSplit);
    }
    // Energy Resistance
    let energyResistance = [];
    if (this.data.data.traits.eres.length) {
      energyResistance.push(...this.data.data.traits.eres.split(reSplit));
    }
    // Damage Immunity
    if (this.data.data.traits.di.value.length || this.data.data.traits.di.custom.length) {
      const values = [
        ...this.data.data.traits.di.value.map((obj) => {
          return CONFIG.FFD20.damageTypes[obj];
        }),
        ...(this.data.data.traits.di.custom.length > 0 ? this.data.data.traits.di.custom.split(reSplit) : []),
      ];
      energyResistance.push(...values.map((o) => game.i18n.localize("FFD20.ImmuneTo").format(o)));
    }
    // Damage Vulnerability
    if (this.data.data.traits.dv.value.length || this.data.data.traits.dv.custom.length) {
      const values = [
        ...this.data.data.traits.dv.value.map((obj) => {
          return CONFIG.FFD20.damageTypes[obj];
        }),
        ...(this.data.data.traits.dv.custom.length > 0 ? this.data.data.traits.dv.custom.split(reSplit) : []),
      ];
      energyResistance.push(...values.map((o) => game.i18n.localize("FFD20.VulnerableTo").format(o)));
    }

    // Wound Threshold penalty
    const wT = this.getWoundThresholdData();
    if (wT.valid) {
      const wTlabel = game.i18n.localize(CONFIG.FFD20.woundThresholdConditions[wT.level]);
      acNotes.push(wTlabel);
      cmdNotes.push(wTlabel);
    }

    // Get actor's token
    const token =
      this.token instanceof TokenDocument
        ? this.token.object
        : this.token ?? canvas.tokens.placeables.find((t) => t.actor && t.actor.id === this.id);

    // Create message
    const d = this.data.data;
    const data = {
      actor: this,
      name: this.name,
      tokenId: this.token ? `${this.token.uuid}` : null,
      ac: {
        normal: d.attributes.ac.normal.total,
        touch: d.attributes.ac.touch.total,
        flatFooted: d.attributes.ac.flatFooted.total,
        notes: acNotes,
      },
      cmd: {
        normal: d.attributes.cmd.total,
        flatFooted: d.attributes.cmd.flatFootedTotal,
        notes: cmdNotes,
      },
      misc: {
        sr: d.attributes.sr.total,
        srNotes: srNotes,
        drNotes: drNotes,
        energyResistance: energyResistance,
      },
      tokenUuid: token?.document.uuid,
    };
    // Add regeneration and fast healing
    if ((getProperty(d, "traits.fastHealing") || "").length || (getProperty(d, "traits.regen") || "").length) {
      data.regen = {
        regen: d.traits.regen,
        fastHealing: d.traits.fastHealing,
      };
    }

    setProperty(data, "flags.ffd20.subject", "defenses");

    await createCustomChatMessage("systems/ffd20/templates/chat/defenses.hbs", data, {
      speaker: ChatMessage.getSpeaker({ actor: this }),
    });
  }

  /* -------------------------------------------- */

  /**
   * Apply rolled dice damage to the token or tokens which are currently controlled.
   * This allows for damage to be scaled by a multiplier to account for healing, critical hits, or resistance
   * If Shift is held, will prompt for adjustments based on damage reduction and energy resistances
   *
   * @param {number} value - The amount of damage to deal.
   * @param {object} [options] - Object containing default settings for overriding
   * @param {boolean} [options.forceDialog=true] - Forces the opening of a Dialog as if Shift was pressed
   * @param {string} [options.reductionDefault] - Default value for Damage Reduction
   * @param {boolean} [options.asNonlethal] - Marks the damage as non-lethal
   * @returns {Promise}
   */
  static async applyDamage(value, { forceDialog = false, reductionDefault = "", asNonlethal = false } = {}) {
    const promises = [];
    var controlled = canvas.tokens.controlled,
      healingInvert = 1,
      numReg = /(\d+)/g,
      sliceReg = /[^,;\n]*(\d+)[^,;\n]*/g,
      sliceReg2 = /[^,;\n]+/g;

    //if (!controlled) return;

    const _submit = async function (form, multiplier) {
      if (form) {
        value = form.find('[name="damage"]').val();
        let dR = form.find('[name="damage-reduction"]').val();
        value = value.length ? RollFFD20$1.safeRoll(value, {}, []).total : 0;
        dR = dR.length ? RollFFD20$1.safeRoll(dR, {}, []).total : 0;
        if (multiplier < 0) {
          value = Math.ceil(value * multiplier);
          value = Math.min(value - dR, 0);
        } else {
          value = Math.floor(value * (multiplier ?? 1));
          value = Math.max(value - dR, 0);
        }
        let checked = [...form.find(".tokenAffected:checked")].map((tok) => tok.name.replace("affect.", ""));
        controlled = controlled.filter((con) => checked.includes(con.id));
      }
      for (let t of controlled) {
        let a = t.actor,
          hp = a.data.data.attributes.hp,
          tmp = parseInt(hp.temp) || 0;

        // Handle nonlethal damage
        let nld = 0;
        if (asNonlethal && value > 0) {
          nld = Math.min(hp.max - hp.nonlethal, value);
          value -= nld;
        }

        // Temp HP adjustment
        let dt = value > 0 ? Math.min(tmp, value) : 0;

        if (!a.isOwner) {
          const msg = game.i18n.localize("FFD20.ErrorNoActorPermissionAlt").format(this.name);
          console.warn(msg);
          ui.notifications.warn(msg);
          continue;
        }
        promises.push(
          t.actor.update({
            "data.attributes.hp.nonlethal": hp.nonlethal + nld,
            "data.attributes.hp.temp": tmp - dt,
            "data.attributes.hp.value": Math.clamped(hp.value - (value - dt), -100, hp.max),
          })
        );
      }
      return Promise.all(promises);
    };

    if (game.keyboard.isDown("Shift") ? !forceDialog : forceDialog) {
      if (value < 0) {
        healingInvert = -1;
        value = -1 * value;
      }
      let tokens = controlled.map((tok) => {
        return {
          _id: tok.id,
          name: tok.name,
          dr: tok.actor.data.data.traits.dr.match(sliceReg),
          eres: tok.actor.data.data.traits.eres.match(sliceReg),
          di: [
            ...tok.actor.data.data.traits.di.value,
            ...(tok.actor.data.data.traits.di.custom.match(sliceReg2) ?? []),
          ],
          dv: [
            ...tok.actor.data.data.traits.dv.value,
            ...(tok.actor.data.data.traits.dv.custom.match(sliceReg2) ?? []),
          ],
          checked: true,
        };
      });

      reductionDefault = reductionDefault ?? "";

      // Dialog configuration and callbacks
      let template = "systems/ffd20/templates/apps/damage-dialog.hbs";
      let dialogData = {
        damage: value,
        healing: healingInvert == -1 ? true : false,
        damageReduction: reductionDefault,
        tokens: tokens,
        nonlethal: asNonlethal,
      };
      const html = await renderTemplate(template, dialogData);

      return new Promise((resolve) => {
        const buttons = {};
        buttons.normal = {
          label: game.i18n.localize("FFD20.Apply"),
          callback: (html) => resolve(_submit.call(this, html, 1 * healingInvert)),
        };
        buttons.half = {
          label: game.i18n.localize("FFD20.ApplyHalf"),
          callback: (html) => resolve(_submit.call(this, html, 0.5 * healingInvert)),
        };

        var d = new Dialog(
          {
            title: healingInvert > 0 ? game.i18n.localize("FFD20.ApplyDamage") : game.i18n.localize("FFD20.ApplyHealing"),
            content: html,
            buttons: buttons,
            default: "normal",
            close: (html) => {
              resolve(false);
            },
            render: (inp) => {
              /**
               *
               */
              function swapSelected() {
                let checked = [...inp[0].querySelectorAll('.selected-tokens input[type="checkbox"]')];
                checked.forEach((chk) => (chk.checked = !chk.checked));
              }
              /**
               * @param e
               */
              function setReduction(e) {
                inp[0].querySelector('input[name="damage-reduction"]').value =
                  e.currentTarget.innerText.match(numReg) ?? "";
              }
              /**
               * @param event
               */
              function mouseWheelAdd(event) {
                const el = event.currentTarget;

                //Digits with optional sign only
                if (/[^\d+-]|(?:\d[+-])/.test(el.value.trim())) return;

                const value = parseFloat(el.value) || 0;
                const increase = -Math.sign(event.originalEvent.deltaY);

                el.value = (value + increase).toString();
              }

              inp.on("click", 'a[name="swap-selected"]', swapSelected);
              inp.on("click", 'a[name="clear-reduction"], p.notes a', setReduction);
              inp.on("wheel", "input", mouseWheelAdd);
            },
          },
          {
            classes: ["dialog", "ffd20", "apply-hit-points"],
          }
        );
        d.render(true);
      });
    } else return _submit();
  }

  /**
   * Returns effective Wound Threshold multiplier with rules and overrides applied.
   *
   * @param data
   */
  getWoundThresholdMultiplier(data = null) {
    data = data ?? this.data;

    const hpconf = game.settings.get("ffd20", "healthConfig").variants;
    const conf = this.data.type === "npc" ? hpconf.npc : hpconf.pc;
    const override = getProperty(data, "data.attributes.woundThresholds.override") ?? -1;
    return override >= 0 && conf.allowWoundThresholdOverride ? override : conf.useWoundThresholds;
  }

  /**
   * Returns Wound Threshold relevant data.
   *
   * @param {*} rollData Provided valid rollData
   * @param data
   */
  getWoundThresholdData(data = null) {
    data = data ?? this.data;

    const woundMult = this.getWoundThresholdMultiplier(data),
      woundLevel = getProperty(data, "data.attributes.woundThresholds.level") ?? 0,
      woundPenalty = woundLevel * woundMult + (getProperty(data, "data.attributes.woundThresholds.mod") ?? 0);
    return {
      level: woundLevel,
      penalty: woundPenalty,
      multiplier: woundMult,
      valid: woundLevel > 0 && woundMult > 0,
    };
  }

  /**
   * Updates attributes.woundThresholds.level variable.
   */
  updateWoundThreshold() {
    const hpconf = game.settings.get("ffd20", "healthConfig").variants;
    const usage = this.data.type === "npc" ? hpconf.npc.useWoundThresholds : hpconf.pc.useWoundThresholds;
    if (!usage) {
      setProperty(this.data, "data.attributes.woundThresholds.level", 0);
      setProperty(this.data, "data.attributes.woundThresholds.penaltyBase", 0);
      setProperty(this.data, "data.attributes.woundThresholds.penalty", 0);
      return;
    }
    const curHP = getProperty(this.data, "data.attributes.hp.value"),
      tempHP = getProperty(this.data, "data.attributes.hp.temp") || 0,
      maxHP = getProperty(this.data, "data.attributes.hp.max");

    let level = usage > 0 ? Math.clamped(4 - Math.ceil(((curHP + tempHP) / maxHP) * 4), 0, 3) : 0;
    if (Number.isNaN(level)) level = 0; // Division by 0 due to max HP on new actors.

    const wtMult = this.getWoundThresholdMultiplier();
    const wtMod = getProperty(this.data, "data.attributes.woundThresholds.mod") ?? 0;

    setProperty(this.data, "data.attributes.woundThresholds.level", level);
    setProperty(this.data, "data.attributes.woundThresholds.penaltyBase", level * wtMult); // To aid relevant formulas
    setProperty(this.data, "data.attributes.woundThresholds.penalty", level * wtMult + wtMod);

    const penalty = getProperty(this.data, "data.attributes.woundThresholds.penalty");
    const changeFlatKeys = ["cmb", "cmd", "init", "allSavingThrows", "ac", "skills", "allChecks"];
    for (let fk of changeFlatKeys) {
      let flats = getChangeFlat.call(this, fk, "penalty", this.data.data);
      if (!(flats instanceof Array)) flats = [flats];
      for (let k of flats) {
        if (!k) continue;
        const curValue = getProperty(this.data, k);
        setProperty(this.data, k, curValue - penalty);
      }
    }
  }

  get allSkills() {
    let result = [];
    for (let [k, s] of Object.entries(this.data.data.skills)) {
      if (!s) continue;
      result.push(k);
      if (s.subSkills) {
        for (let k2 of Object.keys(s.subSkills)) {
          result.push(`${k}.subSkills.${k2}`);
        }
      }
    }
    return result;
  }

  get allNotes() {
    let result = [];

    const noteItems = this.items.filter((o) => {
      return o.data.data.contextNotes != null;
    });

    for (let o of noteItems) {
      if (!o.isActive) continue;
      if (!o.data.data.contextNotes || o.data.data.contextNotes.length === 0) continue;
      result.push({ notes: o.data.data.contextNotes, item: o });
    }

    return result;
  }

  /**
   * @returns {ItemFFD20[]} All items on this actor, including those in containers.
   */
  get allItems() {
    return [...this.containerItems, ...Array.from(this.items)];
  }

  /**
   * Generates an array with all the active context-sensitive notes for the given context on this actor.
   *
   * @param {string} context - The context to draw from.
   */
  getContextNotes(context) {
    let result = this.allNotes;

    // Attacks
    if (context.match(/^attacks\.(.+)/)) {
      const key = RegExp.$1;
      for (let note of result) {
        note.notes = note.notes
          .filter((o) => {
            return o.subTarget === key;
          })
          .map((o) => {
            return o.text;
          });
      }

      return result;
    }

    // Skill
    if (context.match(/^skill\.(.+)/)) {
      const skillKey = RegExp.$1;
      const skill = this.getSkillInfo(skillKey);
      const ability = skill.ability;
      for (let note of result) {
        note.notes = note.notes
          .filter((o) => {
            return (
              // Check for skill.context or skill.xyz.subSkills.context
              o.subTarget === context ||
              o.subTarget.split(".")?.[3] === context.split(".")?.[1] ||
              o.subTarget === `${ability}Skills` ||
              o.subTarget === "skills"
            );
          })
          .map((o) => {
            return o.text;
          });
      }

      return result;
    }

    // Saving throws
    if (context.match(/^savingThrow\.(.+)/)) {
      const saveKey = RegExp.$1;
      for (let note of result) {
        note.notes = note.notes
          .filter((o) => {
            return o.subTarget === saveKey || o.subTarget === "allSavingThrows";
          })
          .map((o) => {
            return o.text;
          });
      }

      if (this.data.data.attributes.saveNotes != null && this.data.data.attributes.saveNotes !== "") {
        result.push({ notes: [this.data.data.attributes.saveNotes], item: null });
      }

      return result;
    }

    // Ability checks
    if (context.match(/^abilityChecks\.(.+)/)) {
      const ablKey = RegExp.$1;
      for (let note of result) {
        note.notes = note.notes
          .filter((o) => {
            return o.subTarget === `${ablKey}Checks` || o.subTarget === "allChecks";
          })
          .map((o) => {
            return o.text;
          });
      }

      return result;
    }

    // Misc
    if (context.match(/^misc\.(.+)/)) {
      const miscKey = RegExp.$1;
      for (let note of result) {
        note.notes = note.notes
          .filter((o) => {
            return o.subTarget === miscKey;
          })
          .map((o) => {
            return o.text;
          });
      }

      return result;
    }

    if (context.match(/^spell\.concentration\.([a-z]+)$/)) {
      const spellbookKey = RegExp.$1;
      for (let note of result) {
        note.notes = note.notes
          .filter((o) => {
            return o.subTarget === "concentration";
          })
          .map((o) => {
            return o.text;
          });
      }

      const spellbookNotes = getProperty(
        this.data,
        `data.attributes.spells.spellbooks.${spellbookKey}.concentrationNotes`
      );
      if (spellbookNotes.length) {
        result.push({ notes: spellbookNotes.split(/[\n\r]+/), item: null });
      }

      return result;
    }

    if (context.match(/^spell\.cl\.([a-z]+)$/)) {
      const spellbookKey = RegExp.$1;
      for (let note of result) {
        note.notes = note.notes
          .filter((o) => {
            return o.subTarget === "cl";
          })
          .map((o) => {
            return o.text;
          });
      }

      const spellbookNotes = getProperty(this.data, `data.attributes.spells.spellbooks.${spellbookKey}.clNotes`);
      if (spellbookNotes.length) {
        result.push({ notes: spellbookNotes.split(/[\n\r]+/), item: null });
      }

      return result;
    }

    if (context.match(/^spell\.effect$/)) {
      for (let note of result) {
        note.notes = note.notes.filter((o) => o.subTarget === "spellEffect").map((o) => o.text);
      }

      return result;
    }

    return [];
  }

  /**
   * Returns a list of already parsed context notes.
   *
   * @param {string} context - The context to draw notes from.
   * @returns {string[]} The resulting notes, already parsed.
   */
  getContextNotesParsed(context) {
    const noteObjects = this.getContextNotes(context);

    return noteObjects.reduce((cur, o) => {
      for (let note of o.notes) {
        cur.push(TextEditor.enrichHTML(note, { rollData: o.item != null ? o.item.getRollData() : this.getRollData() }));
      }

      return cur;
    }, []);
  }

  async createEmbeddedDocuments(embeddedName, createData, options = {}) {
    let noArray = false;
    if (!(createData instanceof Array)) {
      createData = [createData];
      noArray = true;
    }

    return super.createEmbeddedDocuments(embeddedName, noArray ? createData[0] : createData, options);
  }

  /**
   * @typedef {object} MobilityPenaltyResult
   * @property {number|null} maxDexBonus - The maximum dexterity bonus allowed for this result.
   * @property {number} acp - The armor check penalty of this result.
   */

  /**
   * Computes encumbrance values for this actor.
   *
   * @returns {MobilityPenaltyResult} The resulting penalties from encumbrance.
   */
  _computeEncumbrance() {
    const carry = this.getCarryCapacity();
    setProperty(this.data, "data.attributes.encumbrance.levels.light", carry.light);
    setProperty(this.data, "data.attributes.encumbrance.levels.medium", carry.medium);
    setProperty(this.data, "data.attributes.encumbrance.levels.heavy", carry.heavy);
    setProperty(this.data, "data.attributes.encumbrance.levels.carry", carry.heavy * 2);
    setProperty(this.data, "data.attributes.encumbrance.levels.drag", carry.heavy * 5);

    const carriedWeight = Math.max(0, this.getCarriedWeight());
    setProperty(this.data, "data.attributes.encumbrance.carriedWeight", Math.round(carriedWeight * 10) / 10);

    // Determine load level
    let encLevel = 0;
    if (carriedWeight > 0) {
      if (carriedWeight > this.data.data.attributes.encumbrance.levels.light) encLevel++;
      if (carriedWeight > this.data.data.attributes.encumbrance.levels.medium) encLevel++;
    }
    setProperty(this.data, "data.attributes.encumbrance.level", encLevel);

    let result = {
      maxDexBonus: null,
      acp: 0,
    };

    switch (getProperty(this.data, "data.attributes.encumbrance.level")) {
      case 1:
        result.acp = 3;
        result.maxDexBonus = 3;
        break;
      case 2:
        result.acp = 6;
        result.maxDexBonus = 1;
        break;
    }

    return result;
  }

  _calculateCoinWeight() {
    const coinWeightDivisor = game.settings.get("ffd20", "coinWeight");
    if (!coinWeightDivisor) return 0;
    return (
      Object.values(this.data.data.currency).reduce((cur, amount) => {
        return cur + amount;
      }, 0) / coinWeightDivisor
    );
  }

  getCarryCapacity() {
    // Determine carrying capacity
    const carryCapacity = this.data.data.details.carryCapacity;
    const carryStr = this.data.data.abilities.str.total + carryCapacity.bonus.total;
    let carryMultiplier = carryCapacity.multiplier.total;
    const size = this.data.data.traits.size;
    if (this.data.data.attributes.quadruped) carryMultiplier *= CONFIG.FFD20.encumbranceMultipliers.quadruped[size];
    else carryMultiplier *= CONFIG.FFD20.encumbranceMultipliers.normal[size];
    const table = CONFIG.FFD20.encumbranceLoads;

    let heavy = Math.floor(table[carryStr] * carryMultiplier);
    if (carryStr >= table.length) {
      let nextValidStrength = carryStr;
      let multiplierCount = 0;
      while (nextValidStrength >= table.length) {
        nextValidStrength -= 10;
        multiplierCount++;
      }

      heavy = Math.floor(table[nextValidStrength] * Math.pow(4, multiplierCount) * carryMultiplier);
    }
    // Convert to world unit system
    heavy = convertWeight(heavy);

    return {
      light: Math.floor(heavy / 3),
      medium: Math.floor((heavy / 3) * 2),
      heavy: heavy,
    };
  }

  getCarriedWeight() {
    // Determine carried weight
    const physicalItems = this.items.filter((o) => {
      return o.data.data.weight != null;
    });
    const weight = physicalItems.reduce((cur, o) => {
      if (!o.data.data.carried) return cur;
      return cur + o.data.data.weight * o.data.data.quantity;
    }, this._calculateCoinWeight());

    return convertWeight(weight);
  }

  /**
   * @returns {number} The total amount of currency this actor has, in gold pieces
   */
  mergeCurrency() {
    return this.getTotalCurrency("currency") + this.getTotalCurrency("altCurrency");
  }

  getTotalCurrency(category = "currency") {
    const currencies = getProperty(this.data.data, category);
    return (currencies.pgil * 1000 + currencies.gil * 100 + currencies.sgil * 10 + currencies.cgil) / 100;
  }

  /**
   * Converts currencies of the given category to the given currency type
   *
   * @param {string} category - Either 'currency' or 'altCurrency'.
   * @param {string} type - Either 'pgil', 'gil', 'sgil' or 'cgil'. Converts as much currency as possible to this type.
   */
  convertCurrency(category = "currency", type = "pgil") {
    const totalValue =
      category === "currency" ? this.getTotalCurrency("currency") : this.getTotalCurrency("altCurrency");
    let values = [0, 0, 0, 0];
    switch (type) {
      case "pgil":
        values[0] = Math.floor(totalValue / 10);
        values[1] = Math.max(0, Math.floor(totalValue) - values[0] * 10);
        values[2] = Math.max(0, Math.floor(totalValue * 10) - values[0] * 100 - values[1] * 10);
        values[3] = Math.max(0, Math.floor(totalValue * 100) - values[0] * 1000 - values[1] * 100 - values[2] * 10);
        break;
      case "gil":
        values[1] = Math.floor(totalValue);
        values[2] = Math.max(0, Math.floor(totalValue * 10) - values[1] * 10);
        values[3] = Math.max(0, Math.floor(totalValue * 100) - values[1] * 100 - values[2] * 10);
        break;
      case "sgil":
        values[2] = Math.floor(totalValue * 10);
        values[3] = Math.max(0, Math.floor(totalValue * 100) - values[2] * 10);
        break;
      case "cgil":
        values[3] = Math.floor(totalValue * 100);
        break;
    }

    const updateData = {};
    updateData[`data.${category}.pgil`] = values[0];
    updateData[`data.${category}.gil`] = values[1];
    updateData[`data.${category}.sgil`] = values[2];
    updateData[`data.${category}.cgil`] = values[3];
    return this.update(updateData);
  }

  /**
   * Import a new owned Item from a compendium collection
   * The imported Item is then added to the Actor as an owned item.
   *
   * @param collection {String}     The name of the pack from which to import
   * @param entryId {String}        The ID of the compendium entry to import
   */
  importItemFromCollection(collection, entryId) {
    const pack = game.packs.find((p) => p.collection === collection);
    if (pack.metadata.entity !== "Item") return;

    return pack.getDocument(entryId).then((ent) => {
      console.log(`${vtt} | Importing Item ${ent.name} from ${collection}`);

      let data = duplicate(ent.data);
      if (this.sheet != null && this.sheet.rendered) {
        data = mergeObject(data, this.sheet.getDropData(data));
      }
      delete data._id;
      return this.createOwnedItem(data);
    });
  }

  getRollData(options = { refresh: false }) {
    let result = this.data.data;

    // Return cached data, if applicable
    let skipRefresh = !options.refresh && this._rollData;
    if (skipRefresh) {
      result = this._rollData;

      // Clear certain fields
      const clearFields = CONFIG.FFD20.temporaryRollDataFields.actor;
      for (let k of clearFields) {
        const arr = k.split(".");
        const k2 = arr.slice(0, -1).join(".");
        const k3 = arr.slice(-1)[0];
        if (k2 === "") delete result[k];
        else {
          const obj = getProperty(result, k2);
          if (typeof obj === "object") delete obj[k3];
        }
      }
    }

    /* ----------------------------- */
    /* Always add the following data
    /* ----------------------------- */
    // Add combat round, if in combat
    if (game.combats?.viewed) {
      result.combat = {
        round: game.combat.round || 0,
      };
    }

    // Add denied Dex to AC
    setProperty(result, "conditions.loseDexToAC", this.flags.loseDexToAC);

    // Return cached data, if applicable
    if (skipRefresh) {
      Hooks.callAll("ffd20.getRollData", this, result, false);

      return result;
    }

    /* ----------------------------- */
    /* Set the following data on a refresh
    /* ----------------------------- */
    // Set size index
    {
      const sizeChart = Object.keys(CONFIG.FFD20.sizeChart);
      result.size = sizeChart.indexOf(getProperty(result, "traits.size"));
    }

    // Set class data
    const baseSavingThrows = {};
    result.classes = {};
    this.data.items
      .filter((obj) => {
        return obj.type === "class";
      })
      .forEach((cls) => {
        let tag = cls.data.data.tag;
        if (!tag) {
          if (cls.data.data["useCustomTag"] !== true) tag = createTag(cls.name);
          else return;
        }

        let healthConfig = game.settings.get("ffd20", "healthConfig");
        const hasPlayerOwner = this.hasPlayerOwner;
        healthConfig =
          cls.data.data.classType === "racial"
            ? healthConfig.hitdice.Racial
            : hasPlayerOwner
            ? healthConfig.hitdice.PC
            : healthConfig.hitdice.NPC;
        const classType = cls.data.data.classType || "base";
        result.classes[tag] = {
          level: cls.data.data.countforexp === "exp" ? cls.data.data.level : 0, // account for nonexp
          lvl: cls.data.data.level,
          name: cls.name,
          spellList: cls.data.data.parentClass,
          hd: cls.data.data.countforexp === "exp" ? cls.data.data.hd : 0, // account for nonexp
          bab: cls.data.data.countforexp === "exp" ? cls.data.data.bab : 0, // account for nonexp
          hp: cls.data.data.countforexp === "exp" ? healthConfig.auto : 0, // account for nonexp
          mp: cls.data.data.mp,
          savingThrows: {
            fort: 0,
            ref: 0,
            will: 0,
          },
          fc: {
            hp: classType === "base" ? cls.data.data.fc.hp.value : 0,
            skill: classType === "base" ? cls.data.data.fc.skill.value : 0,
            alt: classType === "base" ? cls.data.data.fc.alt.value : 0,
          },
        };

        for (let k of Object.keys(result.classes[tag].savingThrows)) {
          let formula = CONFIG.FFD20.classSavingThrowFormulas[classType][cls.data.data.savingThrows[k].value];
          if (formula == null) formula = "0";
          result.classes[tag].savingThrows[k] = RollFFD20$1.safeRoll(formula, { level: cls.data.data.level }).total;

          // Set base saving throws
          baseSavingThrows[k] = baseSavingThrows[k] ?? 0;
          baseSavingThrows[k] += result.classes[tag].savingThrows[k];
        }
      });

    // Add more info for formulas
    if (this.data.items) {
      result.armor = { type: 0 };
      result.shield = { type: 0 };

      // Determine equipped armor type
      const armor = this.data.items.filter(
        (o) => o.data.type === "equipment" && o.data.data.equipmentType === "armor" && o.data.data.equipped
      );
      let eqArmor = { total: Number.NEGATIVE_INFINITY, ac: 0, enh: 0 };
      for (let o of armor) {
        const subtype = o.data.data.equipmentSubtype;
        if (subtype === "lightArmor" && result.armor.type < 1) result.armor.type = 1;
        else if (subtype === "mediumArmor" && result.armor.type < 2) result.armor.type = 2;
        else if (subtype === "heavyArmor" && result.armor.type < 3) result.armor.type = 3;
        const enhAC = o.data.data.armor.enh ?? 0,
          baseAC = o.data.data.armor.value ?? 0,
          fullAC = baseAC + enhAC;
        if (eqArmor.total < fullAC) {
          eqArmor.ac = baseAC;
          eqArmor.total = fullAC;
          eqArmor.enh = enhAC;
        }
      }
      if (!Number.isFinite(eqArmor.total)) eqArmor.total = 0;
      mergeObject(result.armor, eqArmor);

      // Determine equipped shield type
      const shields = this.data.items.filter(
        (o) => o.data.type === "equipment" && o.data.data.equipmentType === "shield" && o.data.data.equipped
      );
      let eqShield = { total: Number.NEGATIVE_INFINITY, ac: 0, enh: 0 };
      for (let o of shields) {
        const subtype = o.data.data.equipmentSubtype;
        if (subtype === "other" && result.shield.type < 1) result.shield.type = 1;
        else if (subtype === "lightShield" && result.shield.type < 2) result.shield.type = 2;
        else if (subtype === "heavyShield" && result.shield.type < 3) result.shield.type = 3;
        else if (subtype === "towerShield" && result.shield.type < 4) result.shield.type = 4;
        const enhAC = o.data.data.armor.enh ?? 0,
          baseAC = o.data.data.armor.value ?? 0,
          fullAC = baseAC + enhAC;
        if (eqShield.total < fullAC) {
          eqShield.ac = baseAC;
          eqShield.total = fullAC;
          eqShield.enh = enhAC;
        }
      }
      if (!Number.isFinite(eqShield.total)) eqShield.total = 0;
      mergeObject(result.shield, eqShield);
    }

    // Add spellbook info
    const spellbooks = Object.entries(getProperty(result, "attributes.spells.spellbooks"));
    let keyedBooks = [];
    for (let [k, book] of spellbooks) {
      setProperty(result, `spells.${k}`, book);
      setProperty(result, `spells.${k}.abilityMod`, result.abilities[book.ability]?.mod ?? "");
      keyedBooks.push(k);
    }
    const aliasBooks = spellbooks.map((x) => x[1]).filter((x) => !!x.class && x.class !== "_hd");
    for (let book of aliasBooks) {
      if (!keyedBooks.includes(book.class)) {
        setProperty(result, `spells.${book.class}`, book);
        keyedBooks.push(book.class);
      }
    }

    // Add item dictionary flags
    if (this.itemFlags) result.dFlags = this.itemFlags.dictionary;

    // Add range info
    result.range = this.constructor.getReach(this.data.data.traits.size, this.data.data.traits.stature);

    this._rollData = result;

    // Call hook
    Hooks.callAll("ffd20.getRollData", this, result, true);

    return result;
  }

  static getReach(size = "med", stature = "tall") {
    let result = {
      melee: 5,
      reach: 10,
    };

    switch (size) {
      case "fine":
      case "dim":
        result.melee = 0;
        result.reach = 0;
        break;
      case "tiny":
        result.melee = 0;
        result.reach = 5;
        break;
      case "lg":
        if (stature === "tall") {
          result.melee = 10;
          result.reach = 20;
        }
        break;
      case "huge":
        if (stature === "tall") {
          result.melee = 15;
          result.reach = 30;
        } else {
          result.melee = 10;
          result.reach = 20;
        }
        break;
      case "grg":
        if (stature === "tall") {
          result.melee = 20;
          result.reach = 40;
        } else {
          result.melee = 15;
          result.reach = 30;
        }
        break;
      case "col":
        if (stature === "tall") {
          result.melee = 30;
          result.reach = 60;
        } else {
          result.melee = 20;
          result.reach = 40;
        }
        break;
    }

    return result;
  }

  getCR() {
    if (this.data.type !== "npc") return 0;
    const data = this.data.data;

    const base = data.details.cr.base;
    if (this.items == null) return base;

    // Gather CR from templates
    const templates = this.items.filter(
      (o) => o.type === "feat" && o.data.data.featType === "template" && !o.data.data.disabled
    );
    return templates.reduce((cur, o) => {
      const crOffset = o.data.data.crOffset;
      if (typeof crOffset === "string" && crOffset.length)
        cur += RollFFD20$1.safeRoll(crOffset, this.getRollData(data)).total;
      return cur;
    }, base);
  }

  async deleteEmbeddedEntity(embeddedName, data, options = {}) {
    if (embeddedName === "Item") {
      if (!(data instanceof Array)) data = [data];

      // Add children to list of items to be deleted
      const _addChildren = async function (id) {
        const item = this.items.find((o) => o._id === id);
        const children = await item.getLinkedItems("children");
        for (let child of children) {
          if (!data.includes(child._id)) {
            data.push(child._id);
            await _addChildren.call(this, child._id);
          }
        }
      };
      for (let id of data) {
        await _addChildren.call(this, id);
      }

      // Remove links to this item (and child items)
      for (const id of data) {
        for (const i of this.items) {
          await i.removeItemLink(id);
        }
      }
    }

    super.deleteEmbeddedEntity(embeddedName, data, options);
  }

  getQuickActions() {
    const actualChargeCost = (i) => (i != null ? Math.floor(i.charges / i.chargeCost) : 0),
      actualMaxCharge = (i) => (i != null ? Math.floor(i.maxCharges / i.chargeCost) : 0);
    return this.items
      .filter(
        (o) =>
          (o.data.type === "attack" || o.data.type === "spell" || (o.data.type === "feat" && !o.data.data.disabled)) &&
          getProperty(o.data, "data.showInQuickbar") === true
      )
      .sort((a, b) => {
        return a.data.data.sort - b.data.data.sort;
      })
      .map((o) => {
        return {
          item: o,
          get haveAnyCharges() {
            return (this.item.isCharged && this.item.chargeCost !== 0) || this.hasAmmo;
          },
          maxCharge: o.isCharged ? actualMaxCharge(o) : 0,
          get charges() {
            return this.item.isCharged
              ? this.recharging
                ? -this.item.chargeCost
                : actualChargeCost(this.item)
              : this.ammoValue;
          },
          hasAmmo: o.data.data.links?.ammunition?.length > 0 ?? false,
          ammoValue:
            o.data.data.links?.ammunition
              ?.map((l) => this.items.get(l.id))
              .filter((l) => l != null)
              .map((l) => actualChargeCost(l))
              .reduce((a, b) => a + b, 0) ?? 0,
          recharging: o.isCharged && o.chargeCost < 0,
          color1: ItemFFD20.getTypeColor(o.type, 0),
          color2: ItemFFD20.getTypeColor(o.type, 1),
        };
      });
  }

  async toggleConditionStatusIcons() {
    const buffTextures = this._calcBuffTextures();

    if (!this.testUserPermission(game.user, "OWNER")) return;
    const fx = [...this.effects];

    // Create and delete buff ActiveEffects
    let toCreate = [];
    let toDelete = [];
    let toUpdate = [];
    for (let [id, obj] of Object.entries(buffTextures)) {
      const existing = fx.find((f) => f.data.origin === id);
      if (!existing) {
        if (obj.active) toCreate.push(obj.item.getRawEffectData());
      } else {
        if (!obj.active) toDelete.push(existing.id);
        else {
          const existingData = existing.data.toObject();
          const mergedData = mergeObject(existingData, obj.item.getRawEffectData(), { inplace: false });
          const diffData = diffObject(existingData, mergedData);
          if (!isObjectEmpty(diffData)) {
            diffData._id = existing.id;
            toUpdate.push(diffData);
          }
        }
      }
    }

    // Create and delete condition ActiveEffects
    for (let condKey of Object.keys(CONFIG.FFD20.conditions)) {
      const idx = fx.findIndex((e) => e.getFlag("core", "statusId") === condKey);
      const hasCondition = this.data.data.attributes.conditions[condKey] === true;
      const hasEffectIcon = idx >= 0;

      if (hasCondition && !hasEffectIcon) {
        toCreate.push({
          "flags.core.statusId": condKey,
          name: CONFIG.FFD20.conditions[condKey],
          icon: CONFIG.FFD20.conditionTextures[condKey],
        });
      } else if (!hasCondition && hasEffectIcon) {
        const removeEffects = fx.filter((e) => e.getFlag("core", "statusId") === condKey);
        toDelete.push(...removeEffects.map((e) => e.id));
      }
    }

    if (toDelete.length) await this.deleteEmbeddedDocuments("ActiveEffect", toDelete);
    if (toCreate.length) await this.createEmbeddedDocuments("ActiveEffect", toCreate);
    if (toUpdate.length) await this.updateEmbeddedDocuments("ActiveEffect", toUpdate);
  }

  // @Object { id: { title: String, type: buff/string, img: imgPath, active: true/false }, ... }
  _calcBuffTextures() {
    const buffs = this.items.filter((o) => o.type === "buff");
    return buffs.reduce((acc, cur) => {
      const id = cur.uuid;
      if (cur.data.data.hideFromToken) return acc;

      if (!acc[id]) acc[id] = { id: cur.id, label: cur.name, icon: cur.img, item: cur };
      if (cur.data.data.active) acc[id].active = true;
      else acc[id].active = false;
      return acc;
    }, {});
  }

  refreshAbilityModifiers() {
    for (let k of Object.keys(this.data.data.abilities)) {
      const total = getProperty(this.data, `data.abilities.${k}.total`);
      if (total == null) {
        setProperty(this.data, `data.abilities.${k}.mod`, 0);
      } else {
        const penalty = Math.abs(getProperty(this.data, `data.abilities.${k}.penalty`) || 0);
        const damage = getProperty(this.data, `data.abilities.${k}.damage`);
        const newMod = Math.max(-5, Math.floor((total - 10) / 2) - Math.floor(penalty / 2) - Math.floor(damage / 2));
        setProperty(this.data, `data.abilities.${k}.mod`, newMod);

        // Store previous ability score
        if (!game.ffd20.isMigrating && this._initialized && this._prevAbilityScores) {
          const prevMod = this._prevAbilityScores?.[k].mod ?? 0;
          const diffMod = newMod - prevMod;
          const result = getProperty(this.data, `data.abilities.${k}.mod`) + diffMod;

          setProperty(this._prevAbilityScores, `${k}.total`, total);
          setProperty(this._prevAbilityScores, `${k}.mod`, result);
        }
      }
    }
  }

  importFromJSON(json) {
    // Set _initialized flag to prevent faults (such as HP changing incorrectly)
    this._initialized = false;

    // Import from JSON
    const data = JSON.parse(json);
    delete data._id;
    data.effects = [];

    // Update data
    this.data.update(data, { recursive: false });
    return this.update(data, { diff: false, recursive: false });
  }

  /**
   * @typdef MaxAndValue
   * @type {object}
   * @property {number} max - The maximum value.
   * @property {number} value - The current value.
   * @returns {MaxAndValue} An object with a property `value` which refers to the current used feats, and `max` which refers to the maximum available feats.
   */
  getFeatCount() {
    const result = { max: 0, value: 0 };
    result.value = this.items.filter((o) => {
      return o.type === "feat" && o.data.data.featType === "feat" && !o.data.data.disabled;
    }).length;

    // Add feat count by level
    const totalLevels = this.items
      .filter((o) => o.type === "class" && ["base", "npc", "prestige", "racial"].includes(o.data.data.classType))
      .reduce((cur, o) => {
        return cur + o.data.data.level;
      }, 0);
    result.max += Math.ceil(totalLevels / 2);

    // Bonus feat formula
    const featCountRoll = RollFFD20$1.safeRoll(this.data.data.details.bonusFeatFormula || "0", this.getRollData());
    result.max += featCountRoll.total;
    if (featCountRoll.err) {
      const msg = game.i18n
        .localize("FFD20.ErrorActorFormula")
        .format(game.i18n.localize("FFD20.BonusFeatFormula"), this.actor.name);
      console.error(msg);
      ui.notifications.error(msg);
    }

    // Changes
    this.changes
      .filter((o) => o.subTarget === "bonusFeats")
      .forEach((o) => {
        if (!o.value) return;

        result.max += o.value;
      });

    return result;
  }

  /**
   * @param {string} flagName - The name/key of the flag to search for.
   * @returns {boolean} Whether this actor has any owned item with the given flag.
   */
  hasItemBooleanFlag(flagName) {
    return getProperty(this, `itemFlags.boolean.${flagName}`) != null;
  }

  async performRest({ restoreHealth = true, longTermCare = false, aidedCare = false, restoreDailyUses = true, hours = 8 } = {}) {
    const actorData = this.data.data;

    const updateData = {};
    // Restore health and ability damage
    if (restoreHealth === true) {
      const hd = actorData.attributes.hd.total;
      const mprev = actorData.attributes.mp.recover;
      let heal = {
        hp: hd,
        mp: mprev, // change this to reflect total caster level and casting mods
        abl: 1,
        nonlethal: hours * hd,
      };
      if (longTermCare === true && aidedCare === false) {
        heal.hp *= 2;
        heal.mp *= 2;
        heal.abl *= 2;
      }
      if (longTermCare === false && aidedCare === true) {
        heal.hp *= 2;
        heal.mp *= 2;
        heal.abl *= 2;
      }
      if (longTermCare === true && aidedCare === true) {
        heal.hp *= 5;
        heal.mp *= 5;
        heal.abl *= 5;
      }

      updateData["data.attributes.hp.value"] = Math.min(
        actorData.attributes.hp.value + heal.hp,
        actorData.attributes.hp.max
      );
      updateData["data.attributes.mp.value"] = Math.min(
        actorData.attributes.mp.value + heal.mp,
        actorData.attributes.mp.max
      );
      updateData["data.attributes.hp.nonlethal"] = Math.max(
        0,
        (actorData.attributes.hp.nonlethal || 0) - heal.nonlethal
      );
      for (let [key, abl] of Object.entries(actorData.abilities)) {
        let dmg = Math.abs(abl.damage);
        updateData[`data.abilities.${key}.damage`] = Math.max(0, dmg - heal.abl);
      }
    }

    let itemUpdates = [];
    // Restore daily uses of spells, feats, etc.
    if (restoreDailyUses === true) {
      // Update spellbooks
      for (let [sbKey, sb] of Object.entries(getProperty(actorData, `attributes.spells.spellbooks`) || {})) {
        for (let a = 0; a < 10; a++) {
          updateData[`data.attributes.spells.spellbooks.${sbKey}.spells.spell${a}.value`] =
            getProperty(sb, `spells.spell${a}.max`) || 0;
        }
      }

      // refresh limitbreak uses
      updateData["data.attributes.limitbreak.value"] = actorData.attributes.limitbreak.max;

      // Update charged items
      for (let item of this.items) {
        let itemUpdate = { _id: item.id };
        const itemData = item.data.data;

        if (itemData.uses && itemData.uses.per === "day" && itemData.uses.value !== itemData.uses.max) {
          itemUpdate["data.uses.value"] = itemData.uses.max;
          itemUpdates.push(itemUpdate);
        } else if (item.type === "spell") {
          const spellbook = getProperty(actorData, `attributes.spells.spellbooks.${itemData.spellbook}`),
            isSpontaneous = spellbook.spontaneous;
          if (!isSpontaneous) {
            if (itemData.preparation.preparedAmount < itemData.preparation.maxAmount) {
              itemUpdate["data.preparation.preparedAmount"] = itemData.preparation.maxAmount;
              itemUpdates.push(itemUpdate);
            }
            if (!getProperty(item.data, "data.domain")) {
              let sbUses =
                updateData[
                  `data.attributes.spells.spellbooks.${itemData.spellbook}.spells.spell${itemData.level}.value`
                ] || 0;
              sbUses -= itemData.preparation.maxAmount;
              updateData[
                `data.attributes.spells.spellbooks.${itemData.spellbook}.spells.spell${itemData.level}.value`
              ] = sbUses;
            }
          }
        }
      }

      for (let [key, spellbook] of Object.entries(actorData.attributes.spells.spellbooks)) {
        // Restore spellbooks using spell points
        if (spellbook.spellPoints.useSystem) {
          // Try to roll restoreFormula, fall back to restoring max spell points
          let restorePoints = spellbook.spellPoints.max;
          if (spellbook.spellPoints.restoreFormula) {
            const restoreRoll = RollFFD20$1.safeRoll(spellbook.spellPoints.restoreFormula, this.getRollData());
            if (restoreRoll.err) console.error(restoreRoll.err, spellbook.spellPoints.restoreFormula);
            else restorePoints = Math.min(spellbook.spellPoints.value + restoreRoll.total, spellbook.spellPoints.max);
          }
          updateData[`data.attributes.spells.spellbooks.${key}.spellPoints.value`] = restorePoints;
        }
      }
    }

    const proceed = Hooks.call(
      "actorRest",
      this,
      {
        restoreHealth,
        longTermCare,
        aidedCare,
        restoreDailyUses,
        hours,
      },
      updateData,
      itemUpdates
    );
    if (proceed === false) return false;

    await this.updateEmbeddedDocuments("Item", itemUpdates);
    return this.update(updateData);
  }

  _trackPreviousAttributes() {
    // Track HP, Wounds, Vigor and MP
    this._prevAttributes = this._prevAttributes || {};
    for (const k of ["data.attributes.hp", "data.attributes.wounds", "data.attributes.vigor", "data.attributes.mp"]) {
      const max = getProperty(this.data, `${k}.max`);
      if (this._prevAttributes[k] != null) continue;
      this._prevAttributes[k] = max;
    }

    // Track ability scores
    this._prevAbilityScores = this._prevAbilityScores || {};
    for (const k of Object.keys(this.data.data.abilities)) {
      this._prevAbilityScores[k] = {
        total: this.data.data.abilities[k].total,
        mod: this.data.data.abilities[k].mod,
      };
    }
  }

  _applyPreviousAttributes() {
    if (!game.ffd20.isMigrating && this._initialized) {
      // Apply HP, Wounds and Vigor
      if (this._prevAttributes) {
        for (const [k, prevMax] of Object.entries(this._prevAttributes)) {
          if (prevMax == null) continue;
          const newMax = getProperty(this.data, `${k}.max`) || 0;
          const prevValue = getProperty(this.data, `${k}.value`);
          const newValue = prevValue + (newMax - prevMax);
          // if (k === "data.attributes.hp") console.log(prevMax, newMax, prevValue, newValue);
          if (prevValue !== newValue) this._queuedUpdates[`${k}.value`] = newValue;
        }
      }
      this._prevAttributes = null;

      // Clear previous ability score tracking
      this._prevAbilityScores = null;
    }
  }

  /**
   * @override
   */
  async modifyTokenAttribute(attribute, value, isDelta = false, isBar = true) {
    let entity = this,
      current = getProperty(this.data.data, attribute),
      updates = {};
    if (attribute.startsWith("resources.")) {
      const itemTag = attribute.split(".").slice(-1)[0];
      entity = this.items.find((item) => item.data.data.tag === itemTag);
    }
    if (!entity) return;

    // Special key
    if (attribute === "attributes.hp") {
      if (!isDelta) value = (current.temp + current.value - value) * -1;
      let dt = value;
      if (current.temp > 0 && value < 0) {
        dt = Math.min(0, current.temp + value);
        updates["data.attributes.hp.temp"] = Math.max(0, current.temp + value);
      }
      updates["data.attributes.hp.value"] = Math.min(current.value + dt, current.max);
      // Absolute
    } else if (!isDelta) {
      if (entity instanceof Actor) {
        if (typeof entity[`data.${attribute}.value`] === "undefined") updates[`data.${attribute}`] = value;
        else updates[`data.${attribute}.value`] = value;
      } else {
        updates["data.uses.value"] = value;
      }
      // Relative
    } else {
      if (entity instanceof Actor) {
        if (current.value !== undefined)
          updates[`data.${attribute}.value`] = Math.clamped(current.min || 0, current.value + value, current.max);
        else updates[`data.${attribute}`] = current + value;
      } else {
        updates["data.uses.value"] = current.value + value;
      }
    }

    const allowed = Hooks.call("modifyTokenAttribute", { attribute, value, isDelta, isBar }, updates);
    return allowed !== false ? entity.update(updates) : this;
  }
}

/**
 * A helper class for building MeasuredTemplates for FFD20 spells and abilities
 *
 * @augments {MeasuredTemplate}
 */
class AbilityTemplate extends MeasuredTemplate {
  /**
   * A factory method to create an AbilityTemplate instance using provided data
   *
   * @param {string} type -             The type of template ("cone", "circle", "rect" or "ray")
   * @param {number} distance -         The distance/size of the template
   * @param options
   * @returns {AbilityTemplate|null}     The template object, or null if the data does not produce a template
   */
  static fromData(options) {
    let type = options.type;
    let distance = options.distance;
    if (!type) return null;
    if (!distance) return null;
    if (!canvas.scene) return null;
    if (!["cone", "circle", "rect", "ray"].includes(type)) return null;

    // Prepare template data
    const templateData = {
      t: type,
      user: game.user.id,
      distance: distance || 5,
      direction: 0,
      x: 0,
      y: 0,
      fillColor: options.color ? options.color : game.user.color,
      texture: options.texture ? options.texture : null,
      _id: randomID(16),
    };

    // Additional type-specific data
    switch (type) {
      case "cone":
        if (game.settings.get("ffd20", "measureStyle") === true) templateData.angle = 90;
        else templateData.angle = 53.13;
        break;
      case "rect":
        templateData.distance = Math.sqrt(Math.pow(distance, 2) + Math.pow(distance, 2));
        templateData.direction = 45;
        break;
      case "ray":
        templateData.width = 5;
        break;
    }

    // Return the template constructed from the item data
    const cls = CONFIG.MeasuredTemplate.documentClass;
    const template = new cls(templateData, { parent: canvas.scene });
    const object = new this(template);
    return object;
  }

  /* -------------------------------------------- */

  /**
   * Creates a preview of the spell template
   *
   * @param {Event} event   The initiating click event
   */
  async drawPreview(event) {
    const initialLayer = canvas.activeLayer;
    this.draw();
    this.active = true;
    this.layer.activate();
    this.layer.preview.addChild(this);
    return this.activatePreviewListeners(initialLayer);
  }

  /* -------------------------------------------- */

  /**
   * Activate listeners for the template preview
   *
   * @param {CanvasLayer} initialLayer  The initially active CanvasLayer to re-activate after the workflow is complete
   * @returns {Promise<boolean>} Returns true if placed, or false if cancelled
   */
  activatePreviewListeners(initialLayer) {
    return new Promise((resolve) => {
      const handlers = {};
      let moveTime = 0;

      const ffd20Style = game.settings.get("ffd20", "measureStyle") === true;

      // Update placement (mouse-move)
      handlers.mm = (event) => {
        event.stopPropagation();
        let now = Date.now(); // Apply a 20ms throttle
        if (now - moveTime <= 20) return;
        const center = event.data.getLocalPosition(this.layer);
        let pos = canvas.grid.getSnappedPosition(center.x, center.y, 2);
        this.data.x = pos.x;
        this.data.y = pos.y;
        this.refresh();
        canvas.app.render();
        moveTime = now;
      };

      // Cancel the workflow (right-click)
      handlers.rc = (event, canResolve = true) => {
        this.layer.preview.removeChildren();
        canvas.stage.off("mousemove", handlers.mm);
        canvas.stage.off("mousedown", handlers.lc);
        canvas.app.view.oncontextmenu = null;
        canvas.app.view.onwheel = null;
        // Clear highlight
        this.active = false;
        const hl = canvas.grid.getHighlightLayer(`Template.${this.id}`);
        hl.clear();

        initialLayer.activate();
        if (canResolve) resolve(false);
      };

      // Confirm the workflow (left-click)
      handlers.lc = async (event) => {
        handlers.rc(event, false);

        // Confirm final snapped position
        this.data.update(this.data);

        // Create the template
        const result = await canvas.scene.createEmbeddedDocuments("MeasuredTemplate", [this.data]);
        resolve(result);
      };

      // Rotate the template by 3 degree increments (mouse-wheel)
      handlers.mw = (event) => {
        if (event.ctrlKey) event.preventDefault(); // Avoid zooming the browser window
        event.stopPropagation();
        let delta, snap;
        if (event.ctrlKey) {
          if (this.data.t === "rect") {
            delta = Math.sqrt(canvas.dimensions.distance * canvas.dimensions.distance);
          } else {
            delta = canvas.dimensions.distance;
          }
          this.data.distance += delta * -Math.sign(event.deltaY);
        } else {
          if (ffd20Style && this.data.t === "cone") {
            delta = 90;
            snap = event.shiftKey ? delta : 45;
          } else {
            delta = canvas.grid.type > CONST.GRID_TYPES.SQUARE ? 30 : 15;
            snap = event.shiftKey ? delta : 5;
          }
          if (this.data.t === "rect") {
            snap = Math.sqrt(Math.pow(5, 2) + Math.pow(5, 2));
            this.data.distance += snap * -Math.sign(event.deltaY);
          } else {
            this.data.direction += snap * Math.sign(event.deltaY);
          }
        }
        this.refresh();
      };

      // Activate listeners
      if (this.controlIcon) this.controlIcon.removeAllListeners();
      canvas.stage.on("mousemove", handlers.mm);
      canvas.stage.on("mousedown", handlers.lc);
      canvas.app.view.oncontextmenu = handlers.rc;
      canvas.app.view.onwheel = handlers.mw;
      this.hitArea = new PIXI.Polygon([]);
    });
  }

  refresh() {
    if (!this.template) return;
    if (!canvas.scene) return;

    super.refresh();

    if (this.active) {
      this.highlightGrid();
    }

    return this;
  }
}

class ChatAttack {
  constructor(item, { label = "", primaryAttack = true, rollData = {} } = {}) {
    this.primaryAttack = primaryAttack;
    this._rollData = rollData;
    this.setItem(item);
    this.label = label;

    this.attack = {
      flavor: "",
      total: 0,
      isCrit: false,
      isFumble: false,
      roll: null,
    };
    this.critConfirm = {
      flavor: "",
      total: 0,
      isCrit: false,
      isFumble: false,
      roll: null,
    };
    this.hasAttack = false;
    this.hasCritConfirm = false;

    this.damage = {
      flavor: "",
      tooltip: "",
      total: 0,
      rolls: [],
      parts: [],
    };
    this.critDamage = {
      flavor: "",
      tooltip: "",
      total: 0,
      rolls: [],
      parts: [],
    };
    this.hasDamage = false;
    this.hasRange = item.hasRange;
    this.minimumDamage = false;
    this.damageRows = [];

    this.notesOnly = true;

    this.cards = {};
    this.hasCards = false;
    this.attackNotes = [];
    this.effectNotes = [];
    this.attackNotesHTML = "";
    this.effectNotesHTML = "";
  }

  get critRange() {
    if (this.item.data.data.broken) return 20;
    return getProperty(this.item, "data.data.ability.critRange") || 20;
  }

  /**
   * Sets the attack's item reference.
   *
   * @param {ItemFFD20} item - The item to reference.
   */
  setItem(item) {
    if (item == null) {
      this.rollData = this._rollData;
      this.item = null;
      return;
    }

    this.item = item;
    this.rollData = mergeObject(duplicate(this.item.getRollData()), this._rollData);

    this.setRollData();
  }

  /**
   * Applies changes to the roll data.
   */
  setRollData() {
    let data = this.rollData;
    // Set critical hit multiplier
    data.critMult = 1;
    data.critCount = 0;
    // Add critical confirmation bonus
    data.critConfirmBonus = RollFFD20.safeTotal(data.item.critConfirmBonus || "0") ?? 0;
    // Determine ability multiplier
    if (data.item.ability.damageMult != null) data.ablMult = data.item.ability.damageMult;
    // Lower ability multiplier for secondary attacks
    if (this.primaryAttack === false && getProperty(data.ablMult > 0)) {
      data.ablMult = 0.5;
    }
  }

  setAttackNotesHTML() {
    if (this.attackNotes.length === 0) {
      this.attackNotesHTML = "";
      return;
    }

    let result = "";
    for (let n of this.attackNotes) {
      if (n.length > 0) {
        result += `<span class="tag">${n}</span>`;
      }
    }
    const inner = TextEditor.enrichHTML(result, { rollData: this.rollData });
    this.attackNotesHTML = `<div class="flexcol property-group gm-sensitive attack-notes"><label>${game.i18n.localize(
      "FFD20.AttackNotes"
    )}</label><div class="flexrow">${inner}</div></div>`;
  }

  setEffectNotesHTML() {
    if (this.effectNotes.length === 0) {
      this.effectNotesHTML = "";
      return;
    }

    let result = "";
    for (let n of this.effectNotes) {
      if (n.length > 0) {
        result += `<span class="tag">${n}</span>`;
      }
    }
    const inner = TextEditor.enrichHTML(result, { rollData: this.rollData });
    this.effectNotesHTML = `<div class="flexcol property-group gm-sensitive effect-notes"><label>${game.i18n.localize(
      "FFD20.EffectNotes"
    )}</label><div class="flexrow">${inner}</div></div>`;
  }

  async addAttack({ bonus = null, extraParts = [], critical = false, conditionalParts = {} } = {}) {
    if (!this.item) return;

    this.hasAttack = true;
    this.notesOnly = false;
    let data = this.attack;
    if (critical === true) {
      data = this.critConfirm;
      if (this.rollData.critConfirmBonus !== 0) {
        extraParts.push(`@critConfirmBonus[${game.i18n.localize("FFD20.CriticalConfirmation")}]`);
      }

      const ccKey = game.ffd20.utils.getChangeFlat.call(this.item, "critConfirm");
      this.item.parentActor?.sourceDetails[ccKey]?.forEach((c) => extraParts.push(`(${c.value})[${c.name}]`));

      // Add conditionals for critical confirmation
      if (conditionalParts["attack.crit"]?.length) extraParts.push(...conditionalParts["attack.crit"]);
    } else {
      // Add conditional attack bonus
      if (conditionalParts["attack.normal"]?.length) extraParts.push(...conditionalParts["attack.normal"]);
    }

    // Add broken penalty
    if (this.item.data.data.broken && !critical) {
      const label = game.i18n.localize("FFD20.Broken");
      extraParts.push(`-2[${label}]`);
    }

    // Roll attack
    let roll = this.item.rollAttack({
      data: this.rollData,
      bonus: bonus,
      extraParts: extraParts,
      primaryAttack: this.primaryAttack,
    });
    data.roll = roll;
    let d20 = roll.dice.length ? roll.dice[0].total : roll.terms[0].total;
    let critType = 0;
    const isCmb = ["mcman", "rcman"].includes(this.item.data.data.actionType);
    if ((d20 >= this.critRange && !critical && !isCmb) || (d20 === 20 && (critical || isCmb))) critType = 1;
    else if (d20 === 1) critType = 2;

    // Add tooltip
    data.flavor = critical ? game.i18n.localize("FFD20.CriticalConfirmation") : this.label;
    data.total = roll.total;
    data.isCrit = critType === 1;
    data.isFumble = critType === 2;
    data.rollJSON = escape(JSON.stringify(roll));
    data.formula = roll.formula;

    // Add crit confirm
    if (!critical && !isCmb && d20 >= this.critRange && this.rollData.item.ability.critMult > 1) {
      this.hasCritConfirm = true;
      this.rollData.critMult = Math.max(1, this.rollData.item.ability.critMult - 1);
      if (this.item.data.data.broken) this.rollData.critMult = 1;

      await this.addAttack({ bonus: bonus, extraParts: extraParts, critical: true, conditionalParts });
    }

    if (this.attackNotes === "") this.addAttackNotes();
  }

  addAttackNotes() {
    if (!this.item) return;

    const type = this.item.data.data.actionType;
    const typeMap = {
      rsak: ["ranged", /*"spell",*/ "rangedSpell"],
      rwak: ["ranged", /*"weapon",*/ "rangedWeapon"],
      rcman: ["ranged"],
      mwak: ["melee", /*"weapon",*/ "meleeWeapon"],
      msak: ["melee", /*"spell",*/ "meleeSpell"],
      mcman: ["melee"],
    };

    let notes = [];
    if (this.item != null && this.item.actor != null) {
      notes.push(...this.item.actor.getContextNotesParsed("attacks.attack"));
      if ((typeMap[type]?.length || 0) > 0)
        typeMap[type].forEach((subTarget) =>
          notes.push(...this.item.actor.getContextNotesParsed(`attacks.${subTarget}`))
        );
    }
    if (this.item != null && this.item.data.data.attackNotes) {
      notes.push(...this.item.data.data.attackNotes);
    }
    if (["mcman", "rcman"].includes(this.item?.data.data.actionType)) {
      notes.push(...this.item?.actor?.getContextNotesParsed("misc.cmb"));
    }

    this.attackNotes = notes;
    this.setAttackNotesHTML();
  }

  async addDamage({ extraParts = [], critical = false, conditionalParts = {} } = {}) {
    if (!this.item) return;

    this.hasDamage = true;
    this.notesOnly = false;
    let data = this.damage;
    if (critical === true) data = this.critDamage;

    let rollData = duplicate(this.rollData);
    // Enforce critical multiplier
    rollData.critCount = 0;

    // Roll damage
    const repeatCount = critical ? Math.max(1, rollData.critMult) : 1;
    for (let repeat = 0; repeat < repeatCount; ++repeat) {
      if (critical) rollData.critCount++;
      const rolls = this.item.rollDamage({
        data: rollData,
        extraParts: extraParts,
        primaryAttack: this.primaryAttack,
        critical: critical,
        conditionalParts,
      });
      data.rolls = rolls;
      // Add damage parts
      for (let roll of rolls) {
        const dtype = roll.damageType;
        data.parts.push(new DamagePart(roll.roll.total, dtype, roll.roll, roll.type));
      }
    }

    // Consolidate damage parts based on damage type
    let tooltips = "";

    // Add tooltip
    for (let p of Object.values(data.parts)) {
      tooltips += await renderTemplate("systems/ffd20/templates/internal/damage-tooltip.hbs", {
        part: p,
      });
    }

    // Add normal data
    let flavor;
    if (!critical) flavor = this.item.isHealing ? game.i18n.localize("FFD20.Healing") : game.i18n.localize("FFD20.Damage");
    else
      flavor = this.item.isHealing
        ? game.i18n.localize("FFD20.HealingCritical")
        : game.i18n.localize("FFD20.DamageCritical");

    // Determine total damage
    let totalDamage = data.parts.reduce((cur, p) => {
      return cur + p.amount;
    }, 0);
    if (critical) {
      totalDamage = this.damage.parts.reduce((cur, p) => {
        return cur + p.amount;
      }, totalDamage);
    }

    // Handle minimum damage rule
    let minimumDamage = false;
    if (totalDamage < 1) {
      totalDamage = 1;
      minimumDamage = true;
      flavor = game.i18n.localize("FFD20.Nonlethal");
    }

    // Add card
    if (critical) {
      if (!this.cards.critical)
        this.cards.critical = {
          label: game.i18n.localize(this.item.isHealing ? "FFD20.HealingCritical" : "FFD20.DamageCritical"),
          items: [],
        };
      if (this.item.isHealing) {
        this.cards.critical.items.push({
          label: game.i18n.localize("FFD20.Apply"),
          value: -totalDamage,
          action: "applyDamage",
        });
        this.cards.critical.items.push({
          label: game.i18n.localize("FFD20.ApplyHalf"),
          value: -Math.floor(totalDamage / 2),
          action: "applyDamage",
        });
      } else {
        this.cards.critical.items.push({
          label: game.i18n.localize("FFD20.Apply"),
          value: totalDamage,
          action: "applyDamage",
          tags: minimumDamage ? "nonlethal" : "",
        });
        this.cards.critical.items.push({
          label: game.i18n.localize("FFD20.ApplyHalf"),
          value: Math.floor(totalDamage / 2),
          action: "applyDamage",
          tags: minimumDamage ? "nonlethal" : "",
        });
      }
    } else {
      if (!this.cards.damage)
        this.cards.damage = {
          label: game.i18n.localize(this.item.isHealing ? "FFD20.Healing" : "FFD20.Damage"),
          items: [],
        };
      if (this.item.isHealing) {
        this.cards.damage.items.push({
          label: game.i18n.localize("FFD20.Apply"),
          value: -totalDamage,
          action: "applyDamage",
        });
        this.cards.damage.items.push({
          label: game.i18n.localize("FFD20.ApplyHalf"),
          value: -Math.floor(totalDamage / 2),
          action: "applyDamage",
        });
      } else {
        this.cards.damage.items.push({
          label: game.i18n.localize("FFD20.Apply"),
          value: totalDamage,
          action: "applyDamage",
          tags: minimumDamage ? "nonlethal" : "",
        });
        this.cards.damage.items.push({
          label: game.i18n.localize("FFD20.ApplyHalf"),
          value: Math.floor(totalDamage / 2),
          action: "applyDamage",
          tags: minimumDamage ? "nonlethal" : "",
        });
      }
    }

    // Finalize data
    data.flavor = flavor;
    data.tooltip = tooltips;
    data.total = totalDamage;
  }

  addEffectNotes() {
    if (!this.item) return;

    let notes = [];
    if (this.item != null && this.item.actor != null) {
      notes = this.item.actor.getContextNotes("attacks.effect").reduce((arr, o) => {
        for (let n of o.notes) {
          arr.push(...n.split(/[\n\r]+/));
        }
        return arr;
      }, []);

      // Spell specific notes
      if (this.item.type === "spell") {
        this.item.actor.getContextNotes("spell.effect").forEach((o) => {
          for (let n of o.notes) notes.push(...n.split(/[\n\r]+/));
        });
      }
    }

    if (this.item != null && this.item.data.data.effectNotes) {
      notes.push(...this.item.data.data.effectNotes);
    }

    this.effectNotes = notes;
    this.setEffectNotesHTML();
  }

  addAmmunitionCards() {
    this.cards.recoverAmmo = { label: game.i18n.localize("FFD20.RecoverAmmunition"), items: [] };
    this.cards.recoverAmmo.items.push({ label: game.i18n.localize("FFD20.Recover"), action: "recoverAmmo" });
    this.cards.recoverAmmo.items.push({ label: game.i18n.localize("FFD20.ForceRecover"), action: "forceRecoverAmmo" });
  }

  finalize() {
    this.hasCards = Object.keys(this.cards).length > 0;

    // Determine damage rows for chat cards
    // this.damageRows = [];
    for (let a = 0; a < Math.max(this.damage.parts.length, this.critDamage.parts.length); a++) {
      this.damageRows.push({ normal: null, crit: null });
    }
    for (let a = 0; a < this.damage.parts.length; a++) {
      this.damageRows[a].normal = this.damage.parts[a];
    }
    for (let a = 0; a < this.critDamage.parts.length; a++) {
      this.damageRows[a].crit = this.critDamage.parts[a];
    }

    return this;
  }
}

class DamagePart {
  constructor(amount, damageType, roll, type = "normal") {
    this.amount = amount;
    this.damageType = damageType;
    if (!this.damageType) this.damageType = "Untyped";
    this.type = type;
    this.roll = {
      json: escape(JSON.stringify(roll)),
      formula: roll.formula,
      total: roll.total,
    };
  }
}

class ScriptEditor extends FormApplication {
  constructor(options = {}) {
    super(options);

    this.command = options.command || "";
    this.name = options.name || null;

    this._promises = {
      submit: [],
    };
  }

  static get defaultOptions() {
    return mergeObject(super.defaultOptions, {
      classes: ["ffd20", "script-editor"],
      template: "systems/ffd20/templates/apps/script-editor.hbs",
      width: 640,
      height: 560,
    });
  }

  getData() {
    const data = {};

    data.command = this.command || "";
    data.name = this.name;

    data.canEdit = {
      name: data.name != null,
    };

    return data;
  }

  awaitResult() {
    let callback;
    const promise = new Promise((resolve) => {
      callback = resolve;
    });
    this._promises.submit.push({ callback, promise, resolved: false });
    return promise;
  }

  activateListeners(html) {
    html.find('button[type="submit"]').click(this._onSubmit.bind(this));
  }

  _updateObject(event, formData) {
    this.command = formData["command"];
    this.name = formData["name"] || null;

    const result = {
      command: this.command,
      name: this.name,
    };

    this.resolvePromises("submit", result);
  }

  resolvePromises(type, result) {
    for (let p of this._promises[type]) {
      if (!p.resolved) {
        p.callback(result);
        p.resolved = true;
      }
    }
  }

  async close(...args) {
    super.close(...args);

    this.resolvePromises("submit", null);
  }
}

class ItemScriptCall {
  static create(data, parent) {
    const result = new this();

    result.data = mergeObject(this.defaultData, data);
    result.parent = parent;

    return result;
  }

  static get defaultData() {
    return {
      _id: randomID(16),
      name: game.i18n.localize("FFD20.ScriptCalls.NewName"),
      img: "icons/svg/dice-target.svg",
      type: "script",
      value: "",
      category: "",
      hidden: false,
    };
  }

  get id() {
    return this.data._id;
  }
  get type() {
    return this.data.type;
  }
  get value() {
    return this.data.value;
  }
  get category() {
    return this.data.category;
  }
  get name() {
    return this.data.name;
  }
  get hidden() {
    return this.data.hidden;
  }

  async getScriptBody() {
    return this.type === "script" ? this.value : (await fromUuid(this.value))?.data.command ?? "";
  }

  async update(data, options = {}) {
    if (this.parent != null) {
      const rawChange = this.parent.data.data.scriptCalls.find((o) => o._id === this.id);
      const idx = this.parent.data.data.scriptCalls.indexOf(rawChange);
      if (idx >= 0) {
        data = Object.entries(data).reduce((cur, o) => {
          cur[`data.scriptCalls.${idx}.${o[0]}`] = o[1];
          return cur;
        }, {});
        return this.parent.update(data, options);
      }
    }
  }

  // Opens up the editor for this script call
  async edit() {
    // For Macros
    if (this.type === "macro") {
      const macro = await fromUuid(this.value);
      let err;
      if (macro) {
        if (macro.testUserPermission(game.user, "OBSERVER")) {
          macro.sheet.render(true);
        } else {
          err = game.i18n.format("DOCUMENT.SheetPermissionWarn", { document: macro.documentName });
        }
      } else {
        err = game.i18n.format("FFD20.ErrorNoMacroID", { id: this.value });
      }

      if (err) {
        console.error(err);
        ui.notifications.error(err);
      }
    }
    // For regular script calls
    else {
      const scriptEditor = new ScriptEditor({ command: this.value, name: this.name }).render(true);
      const result = await scriptEditor.awaitResult();
      if (result) {
        return this.update({ value: result.command, name: result.name });
      }
    }
  }

  /**
   * Executes the script.
   *
   * @param {object} shared - An object passed between script calls, and which is passed back as a result of ItemFFD20.executeScriptCalls.
   * @param {object.<string, object>} extraParams - A dictionary containing extra parameters to pass on to the call.
   */
  async execute(shared, extraParams = {}) {
    // Add variables to the evaluation scope
    const item = this.parent;
    const actor = item.parentActor;
    const token =
      actor?.token?.object ?? (actor ? canvas.tokens.placeables.find((t) => t.actor?.id === actor.id) : null);

    // Attempt script execution
    const body = `(async () => {
      ${await this.getScriptBody()}
    })()`;
    const fn = Function("item", "actor", "token", "shared", ...Object.keys(extraParams), body);
    try {
      return fn.call(this, item, actor, token, shared, ...Object.values(extraParams));
    } catch (err) {
      ui.notifications.error(`There was an error in your script/macro syntax. See the console (F12) for details`);
      console.error(err);
    }
  }
}

/**
 * Override and extend the basic :class:`Item` implementation
 */
class ItemFFD20 extends Item {
  constructor(...args) {
    super(...args);

    /**
     * @property {object} links
     * Links are stored here during runtime.
     */
    if (this.links === undefined) this.links = {};

    /**
     * @property {object} _rollData
     * Cached roll data for this item.
     */
    if (this._rollData === undefined) this._rollData = null;
  }

  static isInventoryItem(type) {
    return ["weapon", "equipment", "consumable", "loot", "container"].includes(type);
  }

  /**
   * @returns {string[]} The keys of data variables to memorize between updates, for e.g. determining the difference in update.
   */
  get memoryVariables() {
    return ["data.quantity", "data.level"];
  }

  /* -------------------------------------------- */
  /*  Item Properties                             */
  /* -------------------------------------------- */

  get isOwned() {
    return super.isOwned || this.parentItem != null;
  }

  get isActive() {
    if (this.type === "buff") return this.data.data.active;
    if (this.type === "equipment" || this.type === "weapon") return this.data.data.equipped;
    if (this.type === "loot" && this.data.data.subType === "gear") return this.data.data.equipped;
    if (this.type === "feat") return !this.data.data.disabled;
    return true;
  }

  /**
   * Does the Item implement an attack roll as part of its usage
   *
   * @type {boolean}
   */
  get hasAttack() {
    return ["mwak", "rwak", "msak", "rsak", "mcman", "rcman"].includes(this.data.data.actionType);
  }

  get hasMultiAttack() {
    return (
      this.hasAttack &&
      ((this.data.data.attackParts != null && this.data.data.attackParts.length > 0) ||
        this.data.data.formulaicAttacks?.count?.value > 0)
    );
  }

  get hasTemplate() {
    const v = getProperty(this.data, "data.measureTemplate.type");
    const s = getProperty(this.data, "data.measureTemplate.size");
    return (
      typeof v === "string" && v !== "" && ((typeof s === "string" && s.length > 0) || (typeof s === "number" && s > 0))
    );
  }

  get hasSound() {
    return !!this.data.data.soundEffect;
  }

  get hasAction() {
    return this.hasAttack || this.hasDamage || this.hasEffect || this.hasSave || this.hasTemplate || this.hasSound;
  }

  get isSingleUse() {
    return getProperty(this.data, "data.uses.per") === "single" || !hasProperty(this.data, "data.uses.per");
  }

  get isCharged() {
    if (this.type === "spell" && this.maxCharges > 0 && this.chargeCost > 0) return true;
    if (this.type === "consumable" && getProperty(this.data, "data.uses.per") === "single") return true;
    return ["day", "week", "charges"].includes(getProperty(this.data, "data.uses.per"));
  }

  get autoDeductCharges() {
    return this.type === "spell"
      ? getProperty(this.data, "data.preparation.autoDeductCharges") === true
      : this.isCharged && getProperty(this.data, "data.uses.autoDeductCharges") === true;
  }

  get charges() {
    // No actor? No charges!
    if (!this.parent) return 0;

    // Get linked charges
    const link = getProperty(this, "links.charges");
    if (link) return link.charges;

    // Get own charges
    if (this.type === "spell") return this.getSpellUses();
    if (this.isSingleUse) return getProperty(this.data, "data.quantity");
    return getProperty(this.data, "data.uses.value") || 0;
  }

  get maxCharges() {
    // No actor? No charges!
    if (!this.parent) return 0;

    // Get linked charges
    const link = getProperty(this, "links.charges");
    if (link) return link.maxCharges;

    // Get own charges
    if (this.type === "spell") return this.getSpellUses(true);
    if (this.isSingleUse) return getProperty(this.data, "data.quantity");
    return getProperty(this.data, "data.uses.max") || 0;
  }

  get chargeCost() {
    if (this.type === "spell") {
      if (this.useSpellPoints()) return this.getSpellPointCost();
      if (this.spellLevel === 0) return 0;
      return 1;
    }

    const formula = getProperty(this.data, "data.uses.autoDeductChargesCost");
    if (!(typeof formula === "string" && formula.length > 0)) return 1;
    const cost = RollFFD20$1.safeRoll(formula, this.getRollData()).total;
    return cost;
  }

  get spellbook() {
    if (this.type !== "spell") return null;
    if (this.parent == null) return null;

    const spellbookIndex = this.data.data.spellbook;
    return this.parent?.data?.data.attributes.spells.spellbooks[spellbookIndex];
  }

  get casterLevel() {
    const spellbook = this.spellbook;
    if (!spellbook) return null;

    return spellbook.cl.total + (this.data.data.clOffset || 0);
  }

  get spellLevel() {
    if (this.type !== "spell") return null;

    return this.data.data.level + (this.data.data.slOffset || 0);
  }

  get auraStrength() {
    const cl = getProperty(this.data, "data.cl") || 0;
    if (cl < 1) {
      return 0;
    } else if (cl < 6) {
      return 1;
    } else if (cl < 12) {
      return 2;
    } else if (cl < 21) {
      return 3;
    }
    return 4;
  }

  // Returns range (in system configured units)
  get range() {
    let range = getProperty(this.data, "data.range.value");
    const rangeType = getProperty(this.data, "data.range.units");

    if (rangeType == null) return null;

    switch (rangeType) {
      case "melee":
      case "touch":
        return convertDistance(getProperty(this.getRollData(), "range.melee") || 0)[0];
      case "reach":
        return convertDistance(getProperty(this.getRollData(), "range.reach") || 0)[0];
      case "close":
        return convertDistance(RollFFD20$1.safeRoll("25 + floor(@cl / 2) * 5", this.getRollData()).total)[0];
      case "medium":
        return convertDistance(RollFFD20$1.safeRoll("100 + @cl * 10", this.getRollData()).total)[0];
      case "long":
        return convertDistance(RollFFD20$1.safeRoll("400 + @cl * 40", this.getRollData()).total)[0];
      case "mi":
        return convertDistance(range * 5280)[0];
      default:
        return convertDistance(range)[0];
    }
  }

  get minRange() {
    const rng = this.data.data.range;
    if (rng.minUnits !== "" && rng.minValue !== null) {
      const rollData = this.getRollData();
      const formula = { melee: "@range.melee", reach: "@range.reach" }[rng.minUnits] ?? (rng.minValue || "0");
      return convertDistance(RollFFD20$1.safeRoll(formula, rollData).total)[0];
    }
    return 0;
  }

  get maxRange() {
    return this.data.data.range.maxIncrements * this.range;
  }

  get parentActor() {
    if (this.parent) return this.parent;

    let actor = null;
    let p = this.parentItem;
    while (!actor && p) {
      actor = p.actor;
      p = p.parentItem;
    }
    return actor;
  }

  get limited() {
    if (this.parentItem) return this.parentItem.limited;
    return super.limited;
  }

  getName(forcePlayerPerspective = false) {
    if (game.user.isGM && !forcePlayerPerspective) return this.name;
    if (getProperty(this.data, "data.identified") === false && getProperty(this.data, "data.unidentified.name"))
      return getProperty(this.data, "data.unidentified.name");
    return this.name;
  }

  testUserPermission(user, permission, { exact = false } = {}) {
    if (this.parentActor) return this.parentActor.testUserPermission(user, permission, { exact });
    if (this.parentItem) return this.parentItem.testUserPermission(user, permission, { exact });
    return super.testUserPermission(user, permission, { exact });
  }

  get permission() {
    if (this.parentActor) return this.parentActor.permission;
    return super.permission;
  }

  /**
   * @param {object} [rollData] - Data to pass to the roll. If none is given, get new roll data.
   * @returns {number} The Difficulty Class for this item.
   */
  getDC(rollData = null) {
    // No actor? No DC!
    if (!this.parent) return 0;

    rollData = rollData ?? this.getRollData();
    const data = rollData.item;

    let result = 10;

    // Get conditional save DC bonus
    const dcBonus = rollData["dcBonus"] ?? 0;

    if (this.type === "spell") {
      const spellbook = this.spellbook;
      if (spellbook != null) {
        let formula = spellbook.baseDCFormula;
        if (data.save.dc.length > 0) formula += ` + ${data.save.dc}`;
        result = RollFFD20$1.safeRoll(formula, rollData).total + dcBonus;
      }
      return result;
    }
    const dcFormula = getProperty(data, "save.dc")?.toString() || "0";
    try {
      result = RollFFD20$1.safeRoll(dcFormula, rollData).total + dcBonus;
    } catch (e) {
      console.error(e, dcFormula);
    }
    return result;
  }

  /**
   * @param {string} type - The item type (such as "attack" or "equipment")
   * @param {number} colorType - 0 for the primary color, 1 for the secondary color
   * @returns {string} A color hex, in the format "#RRGGBB"
   */
  static getTypeColor(type, colorType) {
    switch (colorType) {
      case 0:
        switch (type) {
          case "feat":
            return "#8900EA";
          case "spell":
            return "#5C37FF";
          case "class":
            return "#85B1D2";
          case "race":
            return "#00BD29";
          case "attack":
            return "#F21B1B";
          case "weapon":
          case "equipment":
          case "consumable":
          case "loot":
            return "#E5E5E5";
          case "buff":
            return "#FDF767";
          default:
            return "#FFFFFF";
        }
      case 1:
        switch (type) {
          case "feat":
            return "#5F00A3";
          case "spell":
            return "#4026B2";
          case "class":
            return "#6A8DA8";
          case "race":
            return "#00841C";
          case "attack":
            return "#A91212";
          case "weapon":
          case "equipment":
          case "consumable":
          case "loot":
            return "#B7B7B7";
          case "buff":
            return "#FDF203";
          default:
            return "#C1C1C1";
        }
    }

    return "#FFFFFF";
  }

  get typeColor() {
    return this.constructor.getTypeColor(this.type, 0);
  }

  get typeColor2() {
    return this.constructor.getTypeColor(this.type, 1);
  }

  static get defaultConditional() {
    return {
      default: false,
      name: "",
      modifiers: [],
    };
  }

  static get defaultConditionalModifier() {
    return {
      formula: "",
      target: "",
      subTarget: "",
      type: "",
      critical: "",
    };
  }

  static get defaultContextNote() {
    return {
      text: "",
      subTarget: "",
    };
  }

  /**
   * Generic charge addition (or subtraction) function that either adds charges
   * or quantity, based on item data.
   *
   * @param {number} value       - The amount of charges to add.
   * @returns {Promise}
   */
  async addCharges(value) {
    // Add link charges
    const link = getProperty(this, "links.charges");
    if (link) return link.addCharges(value);

    // Add own charges
    if (getProperty(this.data, "data.uses.per") === "single" && getProperty(this.data, "data.quantity") == null) return;

    if (this.type === "spell") return this.addSpellUses(value);

    let prevValue = this.isSingleUse
      ? getProperty(this.data, "data.quantity")
      : getProperty(this.data, "data.uses.value");

    if (this.isSingleUse) await this.update({ "data.quantity": prevValue + value });
    else await this.update({ "data.uses.value": prevValue + value });
  }

  /* -------------------------------------------- */

  /**
   * Does the Item implement a damage roll as part of its usage
   *
   * @type {boolean}
   */
  get hasDamage() {
    return !!(this.data.data.damage && this.data.data.damage.parts.length);
  }

  /**
   * Does the item have range defined.
   *
   * @type {boolean}
   */
  get hasRange() {
    return this.data.data.range?.units != null;
  }

  /* -------------------------------------------- */

  /**
   * Does the item provide an amount of healing instead of conventional damage?
   *
   * @returns {boolean}
   */
  get isHealing() {
    return this.data.data.actionType === "heal" && this.data.data.damage.parts.length;
  }

  get hasEffect() {
    return this.hasDamage || (this.data.data.effectNotes != null && this.data.data.effectNotes.length > 0);
  }

  /* -------------------------------------------- */

  /**
   * Does the Item implement a saving throw as part of its usage
   *
   * @type {boolean}
   */
  get hasSave() {
    return typeof this.data.data.save?.type === "string" && this.data.data.save?.type.length > 0;
  }

  /**
   * Should the item show unidentified data
   *
   * @type {boolean}
   */
  get showUnidentifiedData() {
    return !game.user.isGM && getProperty(this.data, "data.identified") === false;
  }

  /* -------------------------------------------- */
  /*	Data Preparation														*/
  /* -------------------------------------------- */

  /**
   * Augment the basic Item data model with additional dynamic data.
   */
  prepareData() {
    let itemData = super.prepareData() || this.data;
    const data = itemData.data;
    const C = CONFIG.FFD20;
    const labels = {};

    // Physical items
    if (hasProperty(itemData, "data.weight")) {
      // Sync name
      if (!hasProperty(this.data, "data.identifiedName")) setProperty(this.data, "data.identifiedName", this.name);
      // Prepare unidentified cost
      if (!hasProperty(this.data, "data.unidentified.price")) setProperty(this.data, "data.unidentified.price", 0);

      // Convert weight according metric system (lb vs kg)
      let usystem = game.settings.get("ffd20", "weightUnits"); // override
      if (usystem === "default") usystem = game.settings.get("ffd20", "units");
      itemData.data.weightConverted = convertWeight(itemData.data.weight);
      itemData.data.weightUnits = usystem === "metric" ? game.i18n.localize("FFD20.Kgs") : game.i18n.localize("FFD20.Lbs");
      itemData.data.priceUnits = game.i18n.localize("FFD20.CurrencyGil").toLowerCase();

      // Set basic data
      itemData.data.hp = itemData.data.hp || { max: 10, value: 10 };
      itemData.data.hardness = itemData.data.hardness || 0;
      itemData.data.carried = itemData.data.carried == null ? true : itemData.data.carried;

      // Equipped label
      const checkYes = '<i class="fas fa-check"></i>';
      const checkNo = '<i class="fas fa-times"></i>';
      labels.equipped = "";
      if (itemData.data.equipped === true) labels.equipped = checkYes;
      else labels.equipped = checkNo;

      // Carried label
      labels.carried = "";
      if (itemData.data.carried === true) labels.carried = checkYes;
      else labels.carried = checkNo;

      // Identified label
      labels.identified = "";
      if (itemData.data.identified === true) labels.identified = checkYes;
      else labels.identified = checkNo;

      // Slot label
      if (itemData.data.slot) {
        // Add equipment slot
        const equipmentType = getProperty(this.data, "data.equipmentType") || null;
        if (equipmentType != null) {
          const equipmentSlot = getProperty(this.data, "data.slot") || null;
          labels.slot = equipmentSlot == null ? null : CONFIG.FFD20.equipmentSlots[equipmentType]?.[equipmentSlot];
        } else labels.slot = null;
      }
    }

    // Spell Level,  School, and Components
    if (itemData.type === "spell") {
      labels.level = C.spellLevels[data.level];
      labels.school = C.spellSchools[data.school];
      labels.components = this.getSpellComponents()
        .map((o) => o[0])
        .join(" ");
    }

    // Feat Items
    else if (itemData.type === "feat") {
      labels.featType = C.featTypes[data.featType];

      // Ability type
      if (data.abilityType && data.abilityType !== "none") {
        labels.abilityType = C.abilityTypes[data.abilityType].short;
      } else if (labels.abilityType) {
        delete labels.abilityType;
      }
    }

    // Buff Items
    else if (itemData.type === "buff") {
      labels.buffType = C.buffTypes[data.buffType];

      if (this.data.data.duration) {
        const dur = this.data.data.duration;
        const unit = C.timePeriodsShort[dur.units];
        if (unit && dur.value) {
          const val = RollFFD20$1.safeTotal(dur.value, this.getRollData());
          labels.duration = [val, unit].filterJoin(" ");
        } else {
          labels.duration = null;
        }
      }
    }

    // Weapon Items
    else if (itemData.type === "weapon") {
      // Type and subtype labels
      let wType = getProperty(this.data, "data.weaponType");
      let typeKeys = Object.keys(C.weaponTypes);
      if (!typeKeys.includes(wType)) wType = typeKeys[0];

      let wSubtype = getProperty(this.data, "data.weaponSubtype");
      let subtypeKeys = Object.keys(C.weaponTypes[wType]).filter((o) => !o.startsWith("_"));
      if (!subtypeKeys.includes(wSubtype)) wSubtype = subtypeKeys[0];

      labels.weaponType = C.weaponTypes[wType]._label;
      labels.weaponSubtype = C.weaponTypes[wType][wSubtype];
    }

    // Equipment Items
    else if (itemData.type === "equipment") {
      // Type and subtype labels
      let eType = getProperty(this.data, "data.equipmentType");
      let typeKeys = Object.keys(C.equipmentTypes);
      if (!typeKeys.includes(eType)) eType = typeKeys[0];

      let eSubtype = getProperty(this.data, "data.equipmentSubtype");
      let subtypeKeys = Object.keys(C.equipmentTypes[eType]).filter((o) => !o.startsWith("_"));
      if (!subtypeKeys.includes(eSubtype)) eSubtype = subtypeKeys[0];
      if (eType === "materia") {
        itemData.data.isMateria = true;
        itemData.data.size = "fine";
        if (itemData.data.materiaRarity === "common") {
          itemData.data.materiaCombatXp.lv1 = 0;
        } else {
          itemData.data.materiaCombatXp.lv1 = Math.pow(2, 1) * 1250 * C.materiaRarityMath[itemData.data.materiaRarity];
        }
        itemData.data.materiaCombatXp.lv2 = Math.pow(2, 2) * 1250 * C.materiaRarityMath[itemData.data.materiaRarity];
        itemData.data.materiaCombatXp.lv3 = Math.pow(2, 3) * 1250 * C.materiaRarityMath[itemData.data.materiaRarity];
        itemData.data.materiaCombatXp.mastered =
          Math.pow(2, 4) * 1250 * C.materiaRarityMath[itemData.data.materiaRarity];
        if (itemData.data.materiaCombatXp.value < itemData.data.materiaCombatXp.lv1) {
          itemData.data.materiaLevel = "0";
          itemData.data.materiaCombatXp.next = itemData.data.materiaCombatXp.lv1;
        } else {
          if (itemData.data.materiaCombatXp.value < itemData.data.materiaCombatXp.lv2) {
            itemData.data.materiaLevel = "1";
            itemData.data.materiaCombatXp.next = itemData.data.materiaCombatXp.lv2;
          } else {
            if (itemData.data.materiaCombatXp.value < itemData.data.materiaCombatXp.lv3) {
              itemData.data.materiaLevel = "2";
              itemData.data.materiaCombatXp.next = itemData.data.materiaCombatXp.lv3;
            } else {
              if (itemData.data.materiaCombatXp.value < itemData.data.materiaCombatXp.mastered) {
                itemData.data.materiaLevel = "3";
                itemData.data.materiaCombatXp.next = itemData.data.materiaCombatXp.mastered;
              } else {
                itemData.data.materiaLevel = "Mastered";
                itemData.data.materiaCombatXp.next = "0";
              }
            }
          }
        }
      }

      labels.equipmentType = C.equipmentTypes[eType]._label;
      labels.equipmentSubtype = C.equipmentTypes[eType][eSubtype];

      // AC labels
      const ac = (data.armor.value || 0) + (data.armor.enh || 0);
      labels.armor = ac > 0 ? `${ac} AC` : "";
      if (data.armor.dex === "") data.armor.dex = null;
      else if (typeof data.armor.dex === "string" && /\d+/.test(data.armor.dex)) {
        data.armor.dex = parseInt(data.armor.dex);
      }
      // Add enhancement bonus
      if (data.armor.enh == null) data.armor.enh = 0;
    }

    // Activated Items
    if (Object.prototype.hasOwnProperty.call(data, "activation")) {
      const activationTypes = game.settings.get("ffd20", "unchainedActionEconomy")
        ? CONFIG.FFD20.abilityActivationTypes_unchained
        : CONFIG.FFD20.abilityActivationTypes;
      const activationTypesPlural = game.settings.get("ffd20", "unchainedActionEconomy")
        ? CONFIG.FFD20.abilityActivationTypesPlurals_unchained
        : CONFIG.FFD20.abilityActivationTypesPlurals;

      // Ability Activation Label
      let act = game.settings.get("ffd20", "unchainedActionEconomy")
        ? getProperty(data, "unchainedAction.activation") || {}
        : getProperty(data, "activation") || {};
      if (act && act.cost > 1 && activationTypesPlural[act.type] != null) {
        labels.activation = [act.cost.toString(), activationTypesPlural[act.type]].filterJoin(" ");
      } else if (act) {
        labels.activation = [
          ["minute", "hour", "action"].includes(act.type) && act.cost ? act.cost.toString() : "",
          activationTypes[act.type],
        ].filterJoin(" ");
      }

      // Target Label
      let tgt = data.target || {};
      if (["none", "touch", "personal"].includes(tgt.units)) tgt.value = null;
      if (["none", "personal"].includes(tgt.type)) {
        tgt.value = null;
        tgt.units = null;
      }
      labels.target = [tgt.value, C.distanceUnits[tgt.units], C.targetTypes[tgt.type]].filterJoin(" ");
      if (labels.target) labels.target = `${game.i18n.localize("FFD20.Target")}: ${labels.target}`;

      // Range Label
      let rng = duplicate(data.range || {});
      if (!["ft", "mi", "spec"].includes(rng.units)) {
        rng.value = null;
        rng.long = null;
      } else if (typeof rng.value === "string" && rng.value.length) {
        try {
          rng.value = RollFFD20$1.safeTotal(rng.value, this.getRollData()).toString();
        } catch (err) {
          console.error(err);
        }
      }
      labels.range = [rng.value, rng.long ? `/ ${rng.long}` : null, C.distanceUnits[rng.units]].filterJoin(" ");
      if (labels.range.length > 0) labels.range = [`${game.i18n.localize("FFD20.Range")}:`, labels.range].join(" ");

      // Duration Label
      let dur = duplicate(data.duration || {});
      if (["inst", "perm", "spec", "seeText"].includes(dur.units)) dur.value = game.i18n.localize("FFD20.Duration") + ":";
      else if (typeof dur.value === "string" && this.parentActor) {
        dur.value = RollFFD20$1.safeRoll(dur.value || "0", this.getRollData(), [this.name, "Duration"]).total.toString();
      }
      labels.duration = [dur.value, C.timePeriods[dur.units]].filterJoin(" ");
    }

    // Item Actions
    if (Object.prototype.hasOwnProperty.call(data, "actionType")) {
      // Damage
      let dam = data.damage || {};
      if (dam.parts && dam.parts instanceof Array) {
        labels.damage = dam.parts
          .map((d) => d[0])
          .join(" + ")
          .replace(/\+ -/g, "- ");
        labels.damageTypes = dam.parts.map((d) => d[1]).join(", ");
      }

      // Add attack parts
      if (!data.attack) data.attack = { parts: [] };
    }

    // Assign labels
    this.labels = labels;

    this.prepareLinks();

    // Update changes
    if (this.data.data.changes instanceof Array) {
      this.changes = this._prepareChanges(this.data.data.changes);
    }

    // Update script calls
    if (this.data.data.scriptCalls instanceof Array) {
      this.scriptCalls = this._prepareScriptCalls(this.data.data.scriptCalls);
    }

    // Update contained items
    if (this.data.data.inventoryItems instanceof Array) {
      this.items = this._prepareInventory(this.data.data.inventoryItems);
    }

    // Initialize tag for items that have tagged template
    const taggedTypes = game.system.template.Item.types.filter((t) =>
      game.system.template.Item[t].templates?.includes("tagged")
    );
    if (this.data.data["useCustomTag"] !== true && taggedTypes.includes(this.data.type)) {
      const name = this.name;
      this.data.data.tag = createTag(name);
    }

    if (!this.actor) {
      this.prepareDerivedItemData();
    }

    return itemData;
  }

  prepareDerivedItemData() {
    // Parse formulaic attacks
    if (this.hasAttack) {
      this.parseFormulaicAttacks({ formula: getProperty(this.data, "data.formulaicAttacks.count.formula") });
    }

    // Update maximum uses
    this._updateMaxUses();

    // Add saving throw DC label
    if (hasProperty(this.data, "data.actionType") && this.hasSave) {
      // Save DC
      if (this.hasSave) {
        this.labels.save = `DC ${this.getDC()}`;
      }
    }

    // Re-render sheet, if open
    if (this.sheet?.rendered) {
      this.sheet?.render();
    }
  }

  prepareLinks() {
    if (!this.links) return;

    for (let [k, i] of Object.entries(this.links)) {
      switch (k) {
        case "charges": {
          const uses = i.data.data.uses;
          for (let [k, v] of Object.entries(uses)) {
            if (["autoDeductCharges", "autoDeductChargesCost"].includes(k)) continue;
            this.data.data.uses[k] = v;
          }
          break;
        }
      }
    }
  }

  _prepareChanges(changes) {
    const prior = this.changes;
    const collection = new Collection();
    for (let c of changes) {
      let change = null;
      if (prior && prior.has(c._id)) {
        change = prior.get(c._id);
        change.data = c;
        change.prepareData();
      } else change = ItemChange.create(c, this);
      collection.set(c._id || change.data._id, change);
    }
    return collection;
  }

  _prepareScriptCalls(scriptCalls) {
    const prior = this.scriptCalls;
    const collection = new Collection();
    for (let s of scriptCalls) {
      let scriptCall = null;
      if (prior && prior.has(s.id)) {
        scriptCall = prior.get(s.id);
        scriptCall.data = s;
      } else scriptCall = ItemScriptCall.create(s, this);
      collection.set(s._id || scriptCall.data._id, scriptCall);
    }
    return collection;
  }

  _prepareInventory(inventory) {
    const prior = this.items;
    const collection = new Collection();
    for (let o of inventory) {
      let item = null;
      if (prior && prior.has(o._id)) {
        item = prior.get(o._id);
        item.data.update(o);
        item.prepareData();
      } else {
        item = new CONFIG.Item.documentClass(o);
        item.parentItem = this;
      }

      collection.set(o._id || item.data._id, item);
    }
    return collection;
  }

  /**
   * Executes all script calls on this item of a specified category.
   *
   * @param {string} category - The category of script calls to call.
   * @param {object.<string, object>} [extraParams={}] - A dictionary of extra parameters to pass as variables for use in the script.
   * @returns {Promise.<object>} The shared object between calls which may have been given data.
   */
  async executeScriptCalls(category, extraParams = {}) {
    const scripts = this.scriptCalls?.filter((o) => o.category === category) ?? [];
    const shared = {};

    for (let s of scripts) {
      await s.execute(shared, extraParams);
    }

    return shared;
  }

  async update(data, options = {}) {
    // Avoid regular update flow for explicitly non-recursive update calls
    if (options.recursive === false) {
      return super.update(data, options);
    }
    const srcData = mergeObject(duplicate(this.data), data, { inplace: false });

    // Make sure changes remains an array
    if (Object.keys(data).filter((e) => e.startsWith("data.changes.")).length > 0) {
      let changeIndexes = [];
      let subData = Object.entries(data).filter((e) => e[0].startsWith("data.changes."));
      let arr = duplicate(this.data.data.changes || []);

      // Get pre update data for changes
      subData.forEach((entry) => {
        const i = entry[0].split(".").slice(2)[0];

        // Add change update data
        if (!changeIndexes.includes(i)) {
          changeIndexes.push(i);
          const changeID = this.data.data.changes[i]._id;
          const change = this.changes.get(changeID);
          if (change) {
            const changeDataPrefix = `data.changes.${i}.`;
            const thisChangeData = subData
              .filter((o) => o[0].startsWith(changeDataPrefix))
              .reduce((cur, o) => {
                const key = o[0].slice(changeDataPrefix.length);
                cur[key] = o[1];
                return cur;
              }, {});
            const preUpdateData = change.preUpdate(thisChangeData);

            // Apply pre-update data to the data to be parsed
            for (const [k, v] of Object.entries(preUpdateData)) {
              const dataKey = `data.changes.${i}.${k}`;
              data[dataKey] = v;
            }
          }
        }
      });
      // Refresh sub-data
      subData = Object.entries(data).filter((e) => e[0].startsWith("data.changes."));

      subData.forEach((entry) => {
        let subKey = entry[0].split(".").slice(2);
        let i = subKey[0];
        let subKey2 = subKey.slice(1).join(".");

        if (!arr[i]) arr[i] = {};

        // Remove property
        if (subKey[subKey.length - 1].startsWith("-=")) {
          const obj = flattenObject(arr[i]);
          subKey[subKey.length - 1] = subKey[subKey.length - 1].slice(2);
          const deleteKeys = Object.keys(obj).filter((o) => o.startsWith(subKey.slice(1).join(".")));
          for (let k of deleteKeys) {
            if (Object.prototype.hasOwnProperty.call(obj, k)) {
              delete obj[k];
            }
          }
          arr[i] = expandObject(obj);
        }
        // Add or change property
        else {
          arr[i] = mergeObject(arr[i], expandObject({ [subKey2]: entry[1] }));
        }

        delete data[entry[0]];
      });
      linkData(srcData, data, "data.changes", arr);
    }

    // Make sure inventory contents remains an array
    if (Object.keys(data).filter((e) => e.startsWith("data.inventoryItems.")).length > 0) {
      let subData = Object.entries(data).filter((e) => e[0].startsWith("data.inventoryItems."));
      let arr = duplicate(this.data.data.inventoryItems || []);
      subData.forEach((entry) => {
        let subKey = entry[0].split(".").slice(2);
        let i = subKey[0];
        let subKey2 = subKey.slice(1).join(".");
        if (!arr[i]) arr[i] = {};

        // Remove property
        if (subKey[subKey.length - 1].startsWith("-=")) {
          const obj = flattenObject(arr[i]);
          subKey[subKey.length - 1] = subKey[subKey.length - 1].slice(2);
          const deleteKeys = Object.keys(obj).filter((o) => o.startsWith(subKey.slice(1).join(".")));
          for (let k of deleteKeys) {
            if (Object.prototype.hasOwnProperty.call(obj, k)) {
              delete obj[k];
            }
          }
          arr[i] = expandObject(obj);
        }
        // Add or change property
        else {
          arr[i] = mergeObject(arr[i], expandObject({ [subKey2]: entry[1] }));
        }

        delete data[entry[0]];
      });
      linkData(srcData, data, "data.inventoryItems", arr);
    }

    // Make sure stuff remains an array
    {
      const keepArray = [
        { key: "data.attackParts" },
        { key: "data.damage.parts" },
        { key: "data.damage.critParts" },
        { key: "data.damage.nonCritParts" },
        { key: "data.contextNotes" },
        { key: "data.scriptCalls" },
        { key: "data.attackNotes" },
        { key: "data.effectNotes" },
      ];

      for (let kArr of keepArray) {
        if (Object.keys(data).filter((e) => e.startsWith(`${kArr.key}.`)).length > 0) {
          let subData = Object.entries(data).filter((e) => e[0].startsWith(`${kArr.key}.`));
          let arr = duplicate(getProperty(this.data, kArr.key) || []);
          const keySeparatorCount = (kArr.key.match(/\./g) || []).length;
          subData.forEach((entry) => {
            let subKey = entry[0].split(".").slice(keySeparatorCount + 1);
            let i = subKey[0];
            let subKey2 = subKey.slice(1).join(".");
            if (!arr[i]) arr[i] = {};

            // Single entry array
            if (!subKey2) {
              arr[i] = entry[1];
            }
            // Remove property
            else if (subKey[subKey.length - 1].startsWith("-=")) {
              const obj = flattenObject(arr[i]);
              subKey[subKey.length - 1] = subKey[subKey.length - 1].slice(2);
              const deleteKeys = Object.keys(obj).filter((o) => o.startsWith(subKey.slice(1).join(".")));
              for (let k of deleteKeys) {
                if (Object.prototype.hasOwnProperty.call(obj, k)) {
                  delete obj[k];
                }
              }
              arr[i] = expandObject(obj);
            }
            // Add or change property
            else {
              arr[i] = mergeObject(arr[i], expandObject({ [subKey2]: entry[1] }));
            }

            delete data[entry[0]];
          });

          linkData(srcData, data, kArr.key, arr);
        }
      }
    }

    // Remove non-array conditionals data
    {
      let subData = Object.keys(data).filter((e) => e.startsWith("data.conditionals."));
      if (subData.length > 0) subData.forEach((s) => delete data[s]);
    }

    // Update weight from base weight
    if (srcData.data.baseWeight !== undefined) {
      const baseWeight = srcData.data.baseWeight || 0;
      const weightReduction = Math.max(0, 1 - (srcData.data.weightReduction || 0) / 100);

      let contentsWeight = (srcData.data.inventoryItems || []).reduce((cur, i) => {
        return cur + (getProperty(i, "data.weight") || 0) * (getProperty(i, "data.quantity") || 0);
      }, 0);
      contentsWeight += this._calculateCoinWeight(srcData);
      contentsWeight = Math.round(contentsWeight * weightReduction * 10) / 10;

      linkData(srcData, data, "data.weight", baseWeight + contentsWeight);
    }
    // Update price from base price
    if (data["data.basePrice"] != null) {
      linkData(srcData, data, "data.price", getProperty(srcData, "data.basePrice") || 0);
    }
    if (data["data.unidentified.basePrice"] != null) {
      linkData(srcData, data, "data.unidentified.price", getProperty(srcData, "data.unidentified.basePrice") || 0);
    }

    // Update name
    if (data["data.identifiedName"]) linkData(srcData, data, "name", data["data.identifiedName"]);
    else if (data["name"]) linkData(srcData, data, "data.identifiedName", data["name"]);

    // Update description
    if (this.type === "spell") await this._updateSpellDescription(data, srcData);

    // Update weight according metric system (lb vs kg)
    if (data["data.weightConverted"] != null) {
      linkData(srcData, data, "data.weight", convertWeightBack(data["data.weightConverted"]));
    }

    // Set weapon subtype
    if (data["data.weaponType"] != null && data["data.weaponType"] !== getProperty(this.data, "data.weaponType")) {
      const type = data["data.weaponType"];
      const subtype = data["data.weaponSubtype"] || getProperty(this.data, "data.weaponSubtype") || "";
      const keys = Object.keys(CONFIG.FFD20.weaponTypes[type]).filter((o) => !o.startsWith("_"));
      if (!subtype || !keys.includes(subtype)) {
        linkData(srcData, data, "data.weaponSubtype", keys[0]);
      }
    }

    // Set equipment subtype and slot
    if (
      data["data.equipmentType"] != null &&
      data["data.equipmentType"] !== getProperty(this.data, "data.equipmentType")
    ) {
      // Set subtype
      const type = data["data.equipmentType"];
      const subtype = data["data.equipmentSubtype"] || getProperty(this.data, "data.equipmentSubtype") || "";
      let keys = Object.keys(CONFIG.FFD20.equipmentTypes[type]).filter((o) => !o.startsWith("_"));
      if (!subtype || !keys.includes(subtype)) {
        linkData(srcData, data, "data.equipmentSubtype", keys[0]);
      }

      // Set slot
      const slot = data["data.slot"] || getProperty(this.data, "data.slot") || "";
      keys = Object.keys(CONFIG.FFD20.equipmentSlots[type]);
      if (!slot || !keys.includes(slot)) {
        linkData(srcData, data, "data.slot", keys[0]);
      }
    }

    // Try to convert dictionary flags to numbers
    if (data["data.flags.dictionary"] !== undefined) {
      let flags = data["data.flags.dictionary"];

      for (let f of flags) {
        let value = f[1];
        // Try to convert value to a number
        if (typeof value === "string" && value.match(/^[0-9]+(?:\.[0-9]+)?$/)) {
          const newValue = parseFloat(value);
          if (!Number.isNaN(newValue)) {
            value = newValue;
          }
          f[1] = value;
        }
      }
    }

    // Make sure charges doesn't exceed max charges, and vice versa
    {
      let charges = 0;
      let maxCharges = 0;
      let target = "value";

      if (this.type === "spell") {
        if (data["data.preparation.maxAmount"] != null) target = "max";
        charges = data["data.preparation.preparedAmount"];
        maxCharges = data["data.preparation.maxAmount"];
      } else {
        if (data["data.uses.max"] != null) target = "max";
        charges = data["data.uses.value"];
        maxCharges = data["data.uses.max"];
      }

      if (target === "value" && charges > maxCharges) maxCharges = charges;
      else if (target === "max" && maxCharges < charges) charges = maxCharges;

      const link = getProperty(this, "links.charges");
      if (!link) {
        if (this.type === "spell") {
          linkData(srcData, data, "data.preparation.preparedAmount", charges);
          linkData(srcData, data, "data.preparation.maxAmount", maxCharges);
        } else {
          linkData(srcData, data, "data.uses.value", charges);
          linkData(srcData, data, "data.uses.max", maxCharges);
        }
      } else {
        // Update charges for linked items
        if (data["data.uses.value"] != null) {
          if (link && getProperty(link, "links.charges") == null) {
            await link.update({ "data.uses.value": data["data.uses.value"] });
          }
        }
      }
    }

    this.memorizeVariables();

    let diff = diffObject(flattenObject(this.data), data);
    // Filter diff for arrays that haven't changed. Single level depth with speed as priority
    for (let d in diff) {
      if (!(diff[d] instanceof Array)) continue;
      let origData = getProperty(this.data, d) || [];
      if (diff[d].length !== origData.length) continue;
      let anyDiff = diff[d].some((obj, idx) => {
        if (!isObjectEmpty(diffObject(obj, origData[idx]))) return true;
      });
      if (!anyDiff && !(diff[d] instanceof Array)) delete diff[d];
    }

    if (Object.keys(diff).length && !options.skipUpdate) {
      if (this.parentItem == null) {
        await super.update(diff, options);
      } else {
        // Determine item index to update in parent
        const parentInventory = this.parentItem.data.data.inventoryItems || [];
        const parentItem = parentInventory.find((o) => o._id === this.id);
        const idx = parentInventory.indexOf(parentItem);

        if (idx >= 0) {
          // Replace keys to suit parent item
          for (let [k, v] of Object.entries(diff)) {
            delete diff[k];
            diff[`data.inventoryItems.${idx}.${k}`] = v;
          }

          // Set parent weight
          const contentsWeight = parentInventory.reduce((cur, i) => {
            if (i._id === this.id)
              return cur + (getProperty(srcData, "data.weight") || 0) * (getProperty(srcData, "data.quantity") || 0);
            return cur + (getProperty(i, "data.weight") || 0) * (getProperty(i, "data.quantity") || 0);
          }, 0);
          diff["data.weight"] = (getProperty(this.parentItem.data, "data.baseWeight") || 0) + contentsWeight;

          // Update parent item
          await this.parentItem.update(diff);
          await this.render();
        }
      }
    } else if (options.skipUpdate) {
      diff["_id"] = this.id;
    }

    // Update tokens and the actor using this item
    const actor = this.parent;
    if (actor) {
      // Update actor
      {
        let effectUpdates = {};
        // Update token effects
        if (diff["data.hideFromToken"] != null) {
          const fx = actor.effects.find((fx) => fx.data.origin === this.uuid);
          if (fx) {
            effectUpdates[fx.id] = effectUpdates[fx.id] || {
              "flags.ffd20.show": !diff["data.hideFromToken"],
            };
          }
        }

        // Update effects
        effectUpdates = Object.entries(effectUpdates).reduce((cur, o) => {
          const obj = o[1];
          obj._id = o[0];
          cur.push(obj);
          return cur;
        }, []);
        if (effectUpdates.length) await actor.updateEmbeddedDocuments("ActiveEffect", effectUpdates);
      }

      // Update tokens
      let promises = [];
      const tokens = canvas.tokens.placeables.filter((token) => token.actor?.id === actor.id);
      for (const token of tokens) {
        const tokenUpdateData = {};

        // Update tokens with this item as a resource bar
        if (diff["data.uses.value"] != null) {
          for (const barKey of ["bar1", "bar2"]) {
            const bar = token.document.getBarAttribute(barKey);
            if (bar && bar.attribute === `resources.${this.data.data.tag}`) {
              tokenUpdateData[`${barKey}.value`] = diff["data.uses.value"];
            }
          }
        }

        if (!isObjectEmpty(tokenUpdateData)) {
          promises.push(token.document.update(tokenUpdateData));
        }
      }
      if (promises.length) await Promise.all(promises);
    }
  }

  memorizeVariables() {
    const memKeys = this.memoryVariables;
    this._memoryVariables = {};
    for (let k of memKeys) {
      if (hasProperty(this.data, k)) {
        this._memoryVariables[k] = getProperty(this.data, k);
      }
    }
  }

  _onUpdate(changed, options, userId) {
    super._onUpdate(changed, options, userId);

    // Call 'toggle' script calls
    {
      let state = null;
      if (this.data.type === "buff") state = getProperty(changed, "data.active");
      if (this.data.type === "feat") state = getProperty(changed, "data.disabled") === true ? false : true;
      if (state != null) {
        this.executeScriptCalls("toggle", { state });
      }
    }

    // Call 'equip' script calls
    {
      const equipped = getProperty(changed, "data.equipped");
      if (equipped != null) {
        this.executeScriptCalls("equip", { equipped });
      }
    }

    // Call 'changeQuantity' script calls
    if (this._memoryVariables?.["data.quantity"] !== undefined) {
      const quantity = {
        previous: this._memoryVariables["data.quantity"],
        new: getProperty(this.data, "data.quantity"),
      };
      if (quantity.new != null && quantity.new !== quantity.previous) {
        this.executeScriptCalls("changeQuantity", { quantity });
      }
    }

    // Call 'changeLevel' script calls
    if (this._memoryVariables?.["data.level"] !== undefined) {
      const level = {
        previous: parseInt(this._memoryVariables["data.level"]),
        new: parseInt(getProperty(this.data, "data.level")),
      };
      for (let [k, v] of Object.entries(level)) {
        if (Number.isNaN(v)) level[k] = null;
      }
      if (level.new !== undefined && level.new !== level.previous) {
        this.executeScriptCalls("changeLevel", { level });
      }
    }

    // Forget memory variables
    this._memoryVariables = null;
  }

  _updateContentsWeight(data, { srcData = null } = {}) {
    if (!srcData) srcData = duplicate(this.data);

    let result = getProperty(srcData, "data.baseWeight") || 0;

    result += this.items.reduce((cur, i) => {
      return cur + (getProperty(i, "data.weight") || 0);
    }, 0);

    linkData(srcData, data, "data.weight", result);
  }

  _updateMaxUses() {
    // No actor? No charges!
    if (!this.parent) return;

    // No charges? No charges!
    if (!["day", "week", "charges"].includes(getProperty(this.data, "data.uses.per"))) return;

    const rollData = this.getRollData();

    if (hasProperty(this.data, "data.uses.maxFormula")) {
      const maxFormula = getProperty(this.data, "data.uses.maxFormula");
      if (maxFormula !== "" && !formulaHasDice(maxFormula)) {
        let roll = RollFFD20$1.safeRoll(maxFormula, rollData);
        setProperty(this.data, "data.uses.max", roll.total);
      } else if (formulaHasDice(maxFormula)) {
        const msg = game.i18n
          .localize("FFD20.WarningNoDiceAllowedInFormula")
          .format(game.i18n.localize("FFD20.ChargePlural"), this.name);
        console.warn(msg);
        ui.notifications.warn(msg);
      }
    }
  }

  //Creates a simple ActiveEffect from a buff item. Returns the effect
  async toEffect({ noCreate = false } = {}) {
    if (!this.parent || this.type !== "buff") return;

    const existing = this.parent.effects.find((e) => e.data.origin == this.uuid);
    if (existing || noCreate) return existing;

    // Add a new effect
    const createData = { label: this.name, icon: this.img, origin: this.uuid, disabled: !this.data.data.active };
    createData["flags.ffd20.show"] = !this.data.data.hideFromToken && !game.settings.get("ffd20", "hideTokenConditions");
    const effect = ActiveEffect.create(createData, { parent: this.parent });

    return effect;
  }

  // Determines the starting data for an ActiveEffect based off this item
  getRawEffectData() {
    const createData = { label: this.name, icon: this.img, origin: this.uuid, disabled: !this.isActive };
    if (this.type === "buff")
      createData["flags.ffd20.show"] = !this.data.data.hideFromToken && !game.settings.get("ffd20", "hideTokenConditions");
    return createData;
  }

  // Fetches all this item's script calls of a specified category
  getScriptCalls(category) {
    return this.scriptCalls?.filter((s) => s.category === category) ?? [];
  }

  /* -------------------------------------------- */

  /**
   * Roll the item to Chat, creating a chat card which contains follow up attack or damage roll options
   *
   * @param altChatData
   * @param root0
   * @param root0.addDC
   * @returns {Promise}
   */
  async roll(altChatData = {}, { addDC = true } = {}) {
    const actor = this.parent;
    if (actor && !actor.isOwner) {
      const msg = game.i18n.localize("FFD20.ErrorNoActorPermissionAlt").format(actor.name);
      console.warn(msg);
      return ui.notifications.warn(msg);
    }

    const allowed = Hooks.call("itemUse", this, "description", { altChatData, addDC });
    if (allowed === false) return;

    // Basic template rendering data
    const token = this.parent.token;
    const saveType = getProperty(this.data, "data.save.type");
    const saveDC = this.getDC();
    const templateData = {
      actor: this.parent,
      tokenId: token ? token.uuid : null,
      item: this.data,
      data: this.getChatData(),
      labels: this.labels,
      hasAttack: this.hasAttack,
      hasMultiAttack: this.hasMultiAttack,
      hasAction: this.hasAction || this.isCharged,
      isHealing: this.isHealing,
      hasDamage: this.hasDamage,
      hasRange: this.hasRange,
      hasEffect: this.hasEffect,
      isVersatile: this.isVersatile,
      hasSave: this.hasSave && addDC,
      isSpell: this.data.type === "spell",
      save: {
        dc: saveDC,
        type: saveType,
        label: game.i18n
          .localize("FFD20.SavingThrowButtonLabel")
          .format(CONFIG.FFD20.savingThrows[saveType], saveDC.toString()),
      },
      hasExtraProperties: false,
      extraProperties: [],
    };

    // Add combat info
    if (game.combat) {
      let combatProps = [];
      // Add round info
      combatProps.push(game.i18n.localize("FFD20.CombatInfo_Round").format(game.combat.round));

      if (combatProps.length > 0) {
        templateData.extraProperties.push({ header: game.i18n.localize("FFD20.CombatInfo_Header"), value: combatProps });
        templateData.hasExtraProperties = true;
      }
    }

    // Roll spell failure chance
    if (templateData.isSpell && this.parent != null && this.parent.spellFailure > 0) {
      const spellbook = getProperty(this.parent.data, `data.attributes.spells.spellbooks.${this.data.data.spellbook}`);
      if (spellbook && spellbook.arcaneSpellFailure) {
        templateData.spellFailure = RollFFD20$1.safeRoll("1d100").total;
        templateData.spellFailureSuccess = templateData.spellFailure > this.parentActor.spellFailure;
      }
    }

    // Render the chat card template
    const templateType = ["consumable"].includes(this.data.type) ? this.data.type : "item";
    const template = `systems/ffd20/templates/chat/${templateType}-card.hbs`;

    // Determine metadata
    const metadata = {};
    metadata.item = this.id;

    // Basic chat message data
    const chatData = flattenObject(
      mergeObject(
        {
          user: game.user.id,
          type: CONST.CHAT_MESSAGE_TYPES.OTHER,
          speaker: ChatMessage.getSpeaker({ actor: this.parent }),
          flags: {
            core: {
              canPopout: true,
            },
            ffd20: {
              metadata,
            },
          },
        },
        altChatData
      )
    );

    // Toggle default roll mode
    let rollMode = chatData.rollMode || game.settings.get("core", "rollMode");
    if (["gmroll", "blindroll"].includes(rollMode)) chatData["whisper"] = ChatMessage.getWhisperRecipients("GM");
    if (rollMode === "blindroll") chatData["blind"] = true;

    // Create the chat message
    return createCustomChatMessage(template, templateData, chatData);
  }

  /* -------------------------------------------- */
  /*  Chat Cards																	*/
  /* -------------------------------------------- */

  getChatData(htmlOptions, rollData = null) {
    const data = duplicate(this.data.data);
    const labels = this.labels;

    if (!rollData) rollData = this.getRollData();

    htmlOptions = mergeObject(htmlOptions || {}, rollData);

    // Rich text description
    if (this.showUnidentifiedData) {
      data.description.value = TextEditor.enrichHTML(data.description.unidentified, { rollData: htmlOptions });
    } else {
      data.description.value = TextEditor.enrichHTML(data.description.value, { rollData: htmlOptions });
    }

    // General equipment properties
    const props = [];
    if (Object.prototype.hasOwnProperty.call(data, "equipped") && ["weapon", "equipment"].includes(this.data.type)) {
      props.push(data.equipped ? game.i18n.localize("FFD20.Equipped") : game.i18n.localize("FFD20.NotEquipped"));
    }

    if (!this.showUnidentifiedData) {
      // Gather dynamic labels
      const dynamicLabels = {};
      dynamicLabels.range = labels.range || "";
      dynamicLabels.level = labels.sl || "";
      // Range
      if (data.range != null) {
        let rangeValue = [0, "ft"];
        switch (data.range.units) {
          case "close":
            rangeValue = convertDistance(25 + Math.floor(rollData.cl / 2) * 5);
            break;
          case "medium":
            rangeValue = convertDistance(100 + rollData.cl * 10);
            break;
          case "long":
            rangeValue = convertDistance(400 + rollData.cl * 40);
            break;
          case "ft":
          case "mi":
            rangeValue = convertDistance(RollFFD20$1.safeRoll(data.range.value || "0", rollData).total, data.range.units);
            break;
          case "spec":
            rangeValue = convertDistance(RollFFD20$1.safeRoll(data.range.value || "0", rollData).total);
            break;
        }
        dynamicLabels.range =
          rangeValue[0] > 0
            ? game.i18n.localize("FFD20.RangeNote").format(`${rangeValue[0]} ${CONFIG.FFD20.measureUnits[rangeValue[1]]}`)
            : null;
      }

      // Add Difficulty Modifier (DC) label
      props.push(labels.save);

      // Duration
      if (data.duration != null) {
        if (!["inst", "perm"].includes(data.duration.units) && typeof data.duration.value === "string") {
          let duration = RollFFD20$1.safeRoll(data.duration.value || "0", rollData).total;
          dynamicLabels.duration = [duration, CONFIG.FFD20.timePeriods[data.duration.units]].filterJoin(" ");
        }
      }

      // Item type specific properties
      const fn = this[`_${this.data.type}ChatData`];
      if (fn) fn.bind(this)(data, labels, props);

      // Ability activation properties
      if (Object.prototype.hasOwnProperty.call(data, "activation")) {
        props.push(labels.target, labels.activation, dynamicLabels.range, dynamicLabels.duration);
      }
    }

    // Add SR reminder
    if (this.type === "spell") {
      if (data.sr) {
        props.push(game.i18n.localize("FFD20.SpellResistance"));
      }
    }

    // Add ability type label
    if (this.type === "feat") {
      if (labels.abilityType) {
        props.push(labels.abilityType);
      }
    }

    // Add charges
    if (this.isCharged && !this.data.data.atWill) {
      if (this.type === "spell" && this.useSpellPoints()) {
        props.push(`${game.i18n.localize("FFD20.SpellPoints")}: ${this.charges}/${this.maxCharges}`);
      } else {
        props.push(`${game.i18n.localize("FFD20.ChargePlural")}: ${this.charges}/${this.maxCharges}`);
      }
    }

    // Filter properties and return
    data.properties = props.filter((p) => !!p);
    return data;
  }

  /* -------------------------------------------- */
  /*  Item Rolls - Attack, Damage, Saves, Checks  */
  /* -------------------------------------------- */

  async use({ ev = null, skipDialog = false, chatMessage = true } = {}) {
    if (this.type === "spell") {
      return this.useSpell(ev, { skipDialog, chatMessage });
    } else if (this.hasAction) {
      return this.useAttack({ ev, skipDialog, chatMessage });
    }

    if (this.isCharged) {
      if (this.charges < this.chargeCost) {
        if (this.isSingleUse) {
          const msg = game.i18n.localize("FFD20.ErrorNoQuantity");
          console.warn(msg);
          return ui.notifications.warn(msg);
        }
        const msg = game.i18n.localize("FFD20.ErrorInsufficientCharges").format(this.name);
        console.warn(msg);
        return ui.notifications.warn(msg);
      }
      if (this.autoDeductCharges) {
        await this.addCharges(-this.chargeCost);
      }
    }
    if (this.data.data.soundEffect) this.data.data.soundEffect;

    const useScriptCalls = this.scriptCalls.filter((o) => o.category === "use");
    if (useScriptCalls.length > 0) {
      const data = { chatMessage };

      return this.executeScriptCalls("use", { attacks: [], template: undefined, data });
    }
    // Show a chat card if this item doesn't have 'use' type script call(s)
    else {
      if (chatMessage) return this.roll();
      else return { descriptionOnly: true }; // nothing to show for printing description
    }
  }

  parseFormulaicAttacks({ formula = null } = {}) {
    if (!this.parentActor) return;

    const exAtkCountFormula = formula ?? (this.data.data.formulaicAttacks?.count?.formula || "");
    let extraAttacks = 0,
      xaroll;
    const rollData = this.getRollData();
    if (exAtkCountFormula.length > 0) {
      xaroll = RollFFD20$1.safeRoll(exAtkCountFormula, rollData);
      extraAttacks = Math.min(50, Math.max(0, xaroll.total)); // Arbitrarily clamp attacks
    }
    if (xaroll?.err) {
      const msg = game.i18n.localize("FFD20.ErrorItemFormula").format(this.name, this.actor?.name);
      console.warn(msg, xaroll.err, exAtkCountFormula);
      ui.notifications.warn(msg);
    }

    // Test bonus attack formula
    const exAtkBonusFormula = this.data.data.formulaicAttacks?.bonus || "";
    try {
      if (exAtkBonusFormula.length > 0) {
        rollData["attackCount"] = 1;
        RollFFD20$1.safeRoll(exAtkBonusFormula, rollData);
      }
    } catch (err) {
      const msg = game.i18n.localize("FFD20.ErrorItemFormula").format(this.name, this.actor?.name);
      console.warn(msg, err, exAtkBonusFormula);
      ui.notifications.warn(msg);
    }

    // Update item
    setProperty(this.data, "data.formulaicAttacks.count.value", extraAttacks);

    return extraAttacks;
  }

  /**
   * Cast a Spell, consuming a spell slot of a certain level
   *
   * @param {MouseEvent} ev - The click event
   * @param {object} options - Additional options
   * @param {boolean} options.skipDialog - Whether to skip the roll dialog
   * @param options.chatMessage
   * @returns {Promise<ChatMessage|void|null>} The chat message created by the spell's usage
   */
  async useSpell(ev, { skipDialog = false, chatMessage = true } = {}) {
    if (!this.testUserPermission(game.user, "OWNER")) {
      const msg = game.i18n.localize("FFD20.ErrorNoActorPermissionAlt").format(this.name);
      console.warn(msg);
      return ui.notifications.warn(msg);
    }
    if (this.data.type !== "spell") throw new Error("Wrong Item type");

    if (
      getProperty(this.data, "data.preparation.mode") !== "atwill" &&
      this.getSpellUses() < this.chargeCost &&
      this.autoDeductCharges
    ) {
      const msg = game.i18n.localize("FFD20.ErrorNoSpellsLeft");
      console.warn(msg);
      return ui.notifications.warn(msg);
    }

    // Invoke the Item roll
    return this.useAttack({ ev: ev, skipDialog: skipDialog, chatMessage });
  }

  async useAttack({ ev = null, skipDialog = false, chatMessage = true, dice = "1d20" } = {}) {
    if (ev && ev.originalEvent) ev = ev.originalEvent;
    const actor = this.parent;
    if (actor && !actor.isOwner) {
      const msg = game.i18n.localize("FFD20.ErrorNoActorPermissionAlt").format(actor.name);
      console.warn(msg);
      return ui.notifications.warn(msg);
    }

    if (this.type === "feat" && this.data.data.disabled) {
      const msg = game.i18n.localize("FFD20.ErrorFeatDisabled");
      console.warn(msg);
      return ui.notifications.warn(msg);
    }

    const itemQuantity = getProperty(this.data, "data.quantity");
    if (itemQuantity != null && itemQuantity <= 0) {
      const msg = game.i18n.localize("FFD20.ErrorNoQuantity");
      console.warn(msg);
      return ui.notifications.warn(msg);
    }

    if (this.isCharged && this.charges < this.chargeCost) {
      const msg = game.i18n.localize("FFD20.ErrorInsufficientCharges").format(this.name);
      console.warn(msg);
      return ui.notifications.warn(msg);
    }

    // Check ammunition links
    let ammoLinks = [],
      ammoAvailable;
    if (this.type === "attack") {
      ammoLinks = await this.getLinkedItems("ammunition", true);
      for (let l of ammoLinks) {
        if (ammoAvailable == null) ammoAvailable = l.item.charges;
        else ammoAvailable = Math.min(ammoAvailable, l.item.charges);

        if (l.item.charges <= 0) {
          const msg = game.i18n.localize("FFD20.WarningInsufficientAmmunition").format(l.item.name);
          console.warn(msg);
          return ui.notifications.warn(msg);
        }
      }
    }

    const allowed = Hooks.call("itemUse", this, "attack", { ev, skipDialog, dice });
    if (allowed === false) return;

    const rollData = duplicate(this.getRollData());
    rollData.d20 = dice !== "1d20" ? dice : "";

    let template;
    const _roll = async function (fullAttack, form) {
      let attackExtraParts = [],
        damageExtraParts = [],
        primaryAttack = true,
        hasteAttackRequired = false,
        manyshotDamageRequired = false,
        rapidShotAttackRequired = false,
        useMeasureTemplate = this.hasTemplate && game.settings.get("ffd20", "placeMeasureTemplateOnQuickRolls"),
        rollMode = game.settings.get("core", "rollMode"),
        conditionals,
        result,
        casterLevelCheck = false,
        concentrationCheck = false;

      // Get form data
      if (form) {
        rollData.d20 = form.find('[name="d20"]').val();
        rollData.attackBonus = form.find('[name="attack-bonus"]').val();
        if (rollData.attackBonus) attackExtraParts.push("@attackBonus");
        rollData.damageBonus = form.find('[name="damage-bonus"]').val();
        if (rollData.damageBonus) damageExtraParts.push("@damageBonus");
        rollMode = form.find('[name="rollMode"]').val();

        // Point-Blank Shot
        if (form.find('[name="point-blank-shot"]').prop("checked")) {
          rollData.pointBlankBonus = 1;
          attackExtraParts.push(`@pointBlankBonus[${game.i18n.localize("FFD20.PointBlankShot")}]`);
          damageExtraParts.push(`@pointBlankBonus[${game.i18n.localize("FFD20.PointBlankShot")}]`);
        }

        // Haste
        hasteAttackRequired = fullAttack && form.find('[name="haste-attack"]').prop("checked");

        // Manyshot
        manyshotDamageRequired = fullAttack && form.find('[name="manyshot"]').prop("checked");

        // Rapid Shot
        rapidShotAttackRequired = fullAttack && form.find('[name="rapid-shot"]').prop("checked");
        if (rapidShotAttackRequired) {
          rollData.rapidShotPenalty = -2;
          attackExtraParts.push(`@rapidShotPenalty[${game.i18n.localize("FFD20.RapidShot")}]`);
        }

        // Primary Attack (for natural attacks)
        let html = form.find('[name="primary-attack"]');
        if (typeof html.prop("checked") === "boolean") {
          primaryAttack = html.prop("checked");
        }
        rollData.item.primaryAttack = primaryAttack;

        // Use measure template
        html = form.find('[name="measure-template"]');
        if (typeof html.prop("checked") === "boolean") {
          useMeasureTemplate = html.prop("checked");
        }
        // Damage ability multiplier
        html = form.find('[name="damage-ability-multiplier"]');
        if (html.length > 0) {
          rollData.item.ability.damageMult = parseFloat(html.val());
        }

        // Held type
        html = form.find('[name="held"]');
        if (html.length > 0) {
          setProperty(rollData, "item.held", html.val());
        }

        // Power Attack
        if (form.find('[name="power-attack"]').prop("checked")) {
          rollData.powerAttackBonus = (1 + Math.floor(getProperty(rollData, "attributes.bab.total") / 4)) * 2;
          if (getProperty(this.data, "data.attackType") === "natural") {
            if (primaryAttack && rollData.item.ability.damageMult >= 1.5) rollData.powerAttackBonus *= 1.5;
            else if (!primaryAttack) rollData.powerAttackBonus *= 0.5;
          } else {
            if (getProperty(rollData, "item.held") === "2h") rollData.powerAttackBonus *= 1.5;
            else if (getProperty(rollData, "item.held") === "oh") rollData.powerAttackBonus *= 0.5;
          }
          const label = ["rwak", "rsak"].includes(this.data.data.actionType)
            ? game.i18n.localize("FFD20.DeadlyAim")
            : game.i18n.localize("FFD20.PowerAttack");
          damageExtraParts.push(`@powerAttackBonus[${label}]`);
          rollData.powerAttackPenalty = -(1 + Math.floor(getProperty(rollData, "attributes.bab.total") / 4));
          attackExtraParts.push(`@powerAttackPenalty[${label}]`);
        }

        // Conditionals
        html = form.find(".conditional");
        if (html.length > 0) {
          conditionals = html
            .map(function () {
              if ($(this).prop("checked")) return Number($(this).prop("name").split(".")[1]);
            })
            .get();
        }

        // Caster level offset
        html = form.find('[name="cl-offset"]');
        if (html.length > 0) {
          rollData.cl += parseInt(html.val());
        }
        // Spell level offset
        html = form.find('[name="sl-offset"]');
        if (html.length > 0) {
          rollData.sl += parseInt(html.val());
        }

        // CL check enabled
        html = form.find('[name="cl-check"]:checked');
        if (html.length > 0) casterLevelCheck = true;

        // Concentration enabled
        html = form.find('[name="concentration"]:checked');
        if (html.length > 0) concentrationCheck = true;
      }

      // Prepare the chat message data
      let chatTemplateData = {
        name: this.name,
        type: CONST.CHAT_MESSAGE_TYPES.OTHER,
        rollMode: rollMode,
      };

      // Conditional defaults for fast-forwarding
      if (conditionals === undefined) {
        conditionals = this.data.data.conditionals?.reduce((arr, con, i) => {
          if (con.default) arr.push(i);
          return arr;
        }, []);
      }

      // Create attacks
      const attackName = this.data.data.attackName;
      const allAttacks = fullAttack
        ? this.data.data.attackParts.reduce(
            (cur, r) => {
              cur.push({ bonus: r[0], label: r[1] });
              return cur;
            },
            [{ bonus: "", label: attackName ? attackName : `${game.i18n.localize("FFD20.Attack")}` }]
          )
        : [{ bonus: "", label: attackName ? attackName : `${game.i18n.localize("FFD20.Attack")}` }];
      let attacks = [];

      let ammoId = ammoLinks?.filter((l) => l.item.charges > 0).map((l) => l.item.id);
      const subtractAmmo = function (value = 1) {
        if (!ammoLinks.length) return;
        let promises = [];
        for (let l of ammoLinks) {
          promises.push(l.item.addCharges(-value));
        }
        return Promise.all(promises);
      };
      let ammoUsed = 0;

      // Create conditionalParts from all enabled conditional modifiers
      let conditionalPartsCommon = {};

      // Helper to get localized name from CONFIG.FFD20 objects
      const localizeType = (target, type) => {
        let result = this.getConditionalModifierTypes(target);
        return game.i18n.localize(result[type]) || type;
      };

      if (conditionals) {
        let conditionalData = {};
        for (const i of conditionals) {
          const conditional = this.data.data.conditionals[i];
          const tag = createTag(conditional.name);
          for (const [i, modifier] of conditional.modifiers.entries()) {
            // Adds a formula's result to rollData to allow referencing it.
            // Due to being its own roll, this will only correctly work for static formulae.
            const conditionalRoll = RollFFD20$1.safeRoll(modifier.formula, rollData);
            if (conditionalRoll.err) {
              const msg = game.i18n.format("FFD20.WarningConditionalRoll", { number: i + 1, name: conditional.name });
              console.warn(msg);
              ui.notifications.warn(msg);
              // Skip modifier to avoid multiple errors from one non-evaluating entry
              continue;
            } else conditionalData[[tag, i].join(".")] = RollFFD20$1.safeRoll(modifier.formula, rollData).total;

            // Create a key string for the formula array
            const partString = `${modifier.target}.${modifier.subTarget}${
              modifier.critical ? "." + modifier.critical : ""
            }`;
            // Add formula in simple format
            if (["attack", "effect", "misc"].includes(modifier.target)) {
              const hasFlavor = /\[.*\]/.test(modifier.formula);
              const flavoredFormula = hasFlavor ? modifier.formula : `(${modifier.formula})[${conditional.name}]`;
              conditionalPartsCommon[partString] = [...(conditionalPartsCommon[partString] ?? []), flavoredFormula];
            }
            // Add formula as array for damage
            else if (modifier.target === "damage") {
              conditionalPartsCommon[partString] = [
                ...(conditionalPartsCommon[partString] ?? []),
                Object.values(CONFIG.FFD20.bonusModifiers).includes(modifier.type)
                  ? [modifier.formula, modifier.type, true]
                  : [modifier.formula, localizeType(modifier.target, modifier.type), false],
              ];
            }
            // Add formula to the size property
            else if (modifier.target === "size") {
              rollData.size += conditionalRoll.total;
            }
          }
        }
        // Expand data into rollData to enable referencing in formulae
        rollData.conditionals = expandObject(conditionalData, 5);

        // Add specific pre-rolled rollData entries
        for (const target of ["effect.cl", "effect.dc", "misc.charges"]) {
          if (conditionalPartsCommon[target] != null) {
            const formula = conditionalPartsCommon[target].join("+");
            const roll = RollFFD20$1.safeRoll(formula, rollData, [target, formula]).total;
            switch (target) {
              case "effect.cl":
                rollData.cl += roll;
                break;
              case "effect.dc":
                rollData.dcBonus = roll;
                break;
              case "misc.charges":
                rollData.chargeCostBonus = roll;
                break;
            }
          }
        }
      }

      // Formulaic extra attacks
      if (fullAttack) {
        const exAtkCountFormula = getProperty(this.data, "data.formulaicAttacks.count.formula"),
          exAtkCount = RollFFD20$1.safeRoll(exAtkCountFormula, rollData)?.total ?? 0,
          exAtkBonusFormula = this.data.data.formulaicAttacks?.bonus?.formula || "0";
        if (exAtkCount > 0) {
          try {
            const frollData = duplicate(rollData); // temporary duplicate to avoid contaminating the actual rolldata
            const fatlabel = this.data.data.formulaicAttacks.label || game.i18n.localize("FFD20.FormulaAttack");
            for (let i = 0; i < exAtkCount; i++) {
              frollData["formulaicAttack"] = i + 1; // Add and update attack counter
              const bonus = RollFFD20$1.safeRoll(exAtkBonusFormula, frollData).total;
              allAttacks.push({
                bonus: `(${bonus})[${game.i18n.localize("FFD20.Iterative")}]`,
                label: fatlabel.format(i + 2),
              });
            }
          } catch (err) {
            console.error(err);
          }
        }
      }

      // Determine charge cost
      let cost = 0;
      if (this.autoDeductCharges) {
        cost = this.chargeCost;
        let uses = this.charges;
        if (this.data.type === "spell" && this.useSpellPoints()) {
          cost = this.getSpellPointCost(rollData);
          uses = this.getSpellUses();
        }
        // Add charge cost from conditional modifiers
        cost += rollData["chargeCostBonus"] ?? 0;

        // Cancel usage on insufficient charges
        if (cost > uses) {
          const msg = game.i18n.localize("FFD20.ErrorInsufficientCharges").format(this.name);
          console.warn(msg);
          ui.notifications.warn(msg);
          return;
        }
      }
      // Save chargeCost as rollData entry for following formulae
      rollData.chargeCost = cost;

      if (this.hasAttack) {
        let ammoRequired = allAttacks.length;
        if (hasteAttackRequired) ammoRequired++;
        if (manyshotDamageRequired) ammoRequired++;
        if (rapidShotAttackRequired) ammoRequired++;
        ammoRequired = Math.min(ammoAvailable, ammoRequired);

        let hasteAttack, rapidShotAttack;

        for (
          let a = 0;
          (ammoLinks.length && ammoUsed < ammoRequired) || (!ammoLinks.length && a < allAttacks.length);
          a++
        ) {
          let atk = allAttacks[a];

          // Combine conditional modifiers for attack a attack and damage
          const conditionalParts = {
            "attack.normal": [
              ...(conditionalPartsCommon[`attack.attack.${a}.normal`] ?? []),
              ...(conditionalPartsCommon["attack.allAttack.normal"] ?? []),
            ], //`
            "attack.crit": [
              ...(conditionalPartsCommon[`attack.attack.${a}.crit`] ?? []),
              ...(conditionalPartsCommon["attack.allAttack.crit"] ?? []),
            ], //`
            "damage.normal": [
              ...(conditionalPartsCommon[`damage.attack.${a}.normal`] ?? []),
              ...(conditionalPartsCommon["damage.allDamage.normal"] ?? []),
            ], //`
            "damage.crit": [
              ...(conditionalPartsCommon[`damage.attack.${a}.crit`] ?? []),
              ...(conditionalPartsCommon["damage.allDamage.crit"] ?? []),
            ], //`
            "damage.nonCrit": [
              ...(conditionalPartsCommon[`damage.attack.${a}.nonCrit`] ?? []),
              ...(conditionalPartsCommon["damage.allDamage.nonCrit"] ?? []),
            ], //`
          };

          // Create attack object
          let attack = new ChatAttack(this, { label: atk.label, primaryAttack: primaryAttack, rollData: rollData });

          // Add attack roll
          await attack.addAttack({
            extraParts: duplicate(attackExtraParts).concat([atk.bonus]),
            conditionalParts,
          });

          // Add damage
          if (this.hasDamage) {
            await attack.addDamage({ extraParts: duplicate(damageExtraParts), critical: false, conditionalParts });

            // Add critical hit damage
            if (attack.hasCritConfirm) {
              await attack.addDamage({ extraParts: duplicate(damageExtraParts), critical: true, conditionalParts });
            }
          }

          // Add attack notes
          if (a === 0) attack.addAttackNotes();

          // Add effect notes
          attack.addEffectNotes();

          // Add to list
          attacks.push(attack);
          ammoUsed++;

          // Add additional damage for Manyshot
          if (a === 0 && manyshotDamageRequired && (!ammoLinks.length || ammoUsed < ammoAvailable)) {
            const conditionalParts = {
              "damage.normal": [
                ...(conditionalPartsCommon[`damage.attack.${a}.normal`] ?? []),
                ...(conditionalPartsCommon["damage.allDamage.normal"] ?? []),
              ], //`
              "damage.nonCrit": [
                ...(conditionalPartsCommon[`damage.attack.${a}.nonCrit`] ?? []),
                ...(conditionalPartsCommon["damage.allDamage.nonCrit"] ?? []),
              ], //`
            };

            let manyshot = new ChatAttack(this, {
              label: game.i18n.localize("FFD20.Manyshot"),
              rollData: rollData,
              primaryAttack: primaryAttack,
            });
            // Add damage
            await manyshot.addDamage({
              extraParts: duplicate(damageExtraParts),
              critical: false,
              conditionalParts,
            });
            manyshot.damage.flavor = manyshot.label;

            // Add effect notes
            manyshot.addEffectNotes();

            // Add to list (don't delay this one; we want it next to Attack #1)
            attacks.push(manyshot);
            ammoUsed++;
          }

          // Create additional attack for Haste
          if (a === 0 && hasteAttackRequired && (!ammoLinks.length || ammoUsed < ammoAvailable)) {
            // Combine conditional modifiers for Haste attack and damage
            const conditionalParts = {
              "attack.normal": [
                ...(conditionalPartsCommon[`attack.hasteAttack.normal`] ?? []),
                ...(conditionalPartsCommon["attack.allAttack.normal"] ?? []),
              ], //`
              "attack.crit": [
                ...(conditionalPartsCommon[`attack.hasteAttack.crit`] ?? []),
                ...(conditionalPartsCommon["attack.allAttack.crit"] ?? []),
              ], //`
              "damage.normal": [
                ...(conditionalPartsCommon[`damage.hasteDamage.normal`] ?? []),
                ...(conditionalPartsCommon["damage.allDamage.normal"] ?? []),
              ], //`
              "damage.crit": [
                ...(conditionalPartsCommon[`damage.hasteDamage.crit`] ?? []),
                ...(conditionalPartsCommon["damage.allDamage.crit"] ?? []),
              ], //`
              "damage.nonCrit": [
                ...(conditionalPartsCommon[`damage.hasteDamage.nonCrit`] ?? []),
                ...(conditionalPartsCommon["damage.allDamage.nonCrit"] ?? []),
              ], //`
            }; //`

            // Create attack object, then add attack roll
            hasteAttack = new ChatAttack(this, {
              label: game.i18n.localize("FFD20.Haste"),
              rollData: rollData,
              primaryAttack: primaryAttack,
            });
            await hasteAttack.addAttack({
              bonus: atk.bonus,
              extraParts: duplicate(attackExtraParts),
              conditionalParts,
            });

            // Add damage
            if (this.hasDamage) {
              await hasteAttack.addDamage({
                extraParts: duplicate(damageExtraParts),
                critical: false,
                conditionalParts,
              });

              // Add critical hit damage
              if (hasteAttack.hasCritConfirm) {
                await hasteAttack.addDamage({
                  extraParts: duplicate(damageExtraParts),
                  critical: true,
                  conditionalParts,
                });
              }
            }

            // Add effect notes
            hasteAttack.addEffectNotes();

            // Deliberately not pushing this attack yet, but do account for ammo.
            ammoUsed++;
          }

          // Create attack for Rapid Shot
          if (a === 0 && rapidShotAttackRequired && (!ammoLinks.length || ammoUsed < ammoAvailable)) {
            // Combine conditional modifiers for Rapid Shot attack and damage
            const conditionalParts = {
              "attack.normal": [
                ...(conditionalPartsCommon[`attack.rapidShotAttack.normal`] ?? []),
                ...(conditionalPartsCommon["attack.allAttack.normal"] ?? []),
              ], //`
              "attack.crit": [
                ...(conditionalPartsCommon[`attack.rapidShotAttack.crit`] ?? []),
                ...(conditionalPartsCommon["attack.allAttack.crit"] ?? []),
              ], //`
              "damage.normal": [
                ...(conditionalPartsCommon[`damage.rapidShotDamage.normal`] ?? []),
                ...(conditionalPartsCommon["damage.allDamage.normal"] ?? []),
              ], //`
              "damage.crit": [
                ...(conditionalPartsCommon[`damage.rapidShotDamage.crit`] ?? []),
                ...(conditionalPartsCommon["damage.allDamage.crit"] ?? []),
              ], //`
              "damage.nonCrit": [
                ...(conditionalPartsCommon[`damage.rapidShotDamage.nonCrit`] ?? []),
                ...(conditionalPartsCommon["damage.allDamage.nonCrit"] ?? []),
              ], //`
            }; //`

            // Create attack object, then add attack roll
            rapidShotAttack = new ChatAttack(this, {
              label: game.i18n.localize("FFD20.RapidShot"),
              rollData: rollData,
              primaryAttack: primaryAttack,
            });
            await rapidShotAttack.addAttack({
              bonus: atk.bonus,
              extraParts: duplicate(attackExtraParts),
              conditionalParts,
            });

            // Add damage
            if (this.hasDamage) {
              await rapidShotAttack.addDamage({
                extraParts: duplicate(damageExtraParts),
                critical: false,
                conditionalParts,
              });

              // Add critical hit damage
              if (rapidShotAttack.hasCritConfirm) {
                await rapidShotAttack.addDamage({
                  extraParts: duplicate(damageExtraParts),
                  critical: true,
                  conditionalParts,
                });
              }
            }

            // Add effect notes
            rapidShotAttack.addEffectNotes();

            // Deliberately not pushing this attack yet, but do account for ammo.
            ammoUsed++;
          }
        }

        // Pushing was delayed until now so that these appear after iteratives in chat
        if (hasteAttack != null) attacks.push(hasteAttack);
        if (rapidShotAttack != null) attacks.push(rapidShotAttack);
      }
      // Add damage only
      else if (this.hasDamage) {
        ammoUsed = 1;

        // Set conditional modifiers
        const conditionalParts = {
          "damage.normal": conditionalPartsCommon["damage.allDamage.normal"] ?? [],
        };

        let attack = new ChatAttack(this, { rollData: rollData, primaryAttack: primaryAttack });
        // Add damage
        await attack.addDamage({ extraParts: duplicate(damageExtraParts), critical: false, conditionalParts });

        // Add effect notes
        attack.addEffectNotes();

        // Add to list
        attacks.push(attack);
      }
      // Add effect notes only
      else {
        let attack = new ChatAttack(this, { rollData: rollData, primaryAttack: primaryAttack });

        // Add effect notes
        attack.addEffectNotes();

        // Add to list
        attacks.push(attack);
      }
      if (ammoLinks.length) {
        attacks.forEach((atk) => atk.addAmmunitionCards());
      }
      chatTemplateData.attacks = attacks.map((o) => o.finalize());

      // Prompt measure template
      if (useMeasureTemplate) {
        // Determine size
        let dist = getProperty(this.data, "data.measureTemplate.size");
        if (typeof dist === "string") {
          dist = RollFFD20$1.safeRoll(getProperty(this.data, "data.measureTemplate.size"), rollData).total;
        }
        dist = convertDistance(dist)[0];

        // Create data object
        const templateOptions = {
          type: getProperty(this.data, "data.measureTemplate.type"),
          distance: dist,
        };
        if (getProperty(this.data, "data.measureTemplate.overrideColor")) {
          templateOptions.color = getProperty(this.data, "data.measureTemplate.customColor");
        }
        if (getProperty(this.data, "data.measureTemplate.overrideTexture")) {
          templateOptions.texture = getProperty(this.data, "data.measureTemplate.customTexture");
        }

        // Create template
        template = AbilityTemplate.fromData(templateOptions);
        if (template) {
          const sheetRendered = this.parent?.sheet?._element != null;
          if (sheetRendered) this.parent.sheet.minimize();
          template = await template.drawPreview(ev);
          if (!template) {
            if (sheetRendered) this.parent.sheet.maximize();
            return;
          }
        }
      }

      // Set chat data
      let chatData = {
        speaker: ChatMessage.getSpeaker({ actor: this.parent }),
        rollMode: rollMode,
        "flags.ffd20.noRollRender": true,
      };

      // Set attack sound
      if (this.data.data.soundEffect) chatData.sound = this.data.data.soundEffect;
      // Set dice sound if neither attack sound nor Dice so Nice are available
      else if (game.dice3d == null || !game.dice3d.isEnabled()) chatData.sound = CONFIG.sounds.dice;

      // Dice So Nice integration
      if (game.dice3d != null && game.dice3d.isEnabled()) {
        // Use try to make sure a chat card is rendered even if DsN fails
        try {
          // Define common visibility options for whole attack
          let whisper,
            blind = false;
          switch (rollMode) {
            case "gmroll":
              whisper = game.users.contents.filter((u) => u.isGM).map((u) => u._id);
              break;
            case "selfroll":
              whisper = [game.user._id];
              break;
            case "blindroll":
              whisper = game.users.contents.filter((u) => u.isGM).map((u) => u._id);
              blind = true;
              break;
          }

          const mergeRolls = game.settings.get("dice-so-nice", "enabledSimultaneousRolls");
          const skipRolls = game.settings.get("dice-so-nice", "immediatelyDisplayChatMessages");

          /**
           * Visually roll dice
           *
           * @async
           * @param {DicePool[]} pools - An array of DicePools to be rolled together
           * @returns {Promise} A Promise that is resolved when all rolls have been displayed
           */
          const showRoll = async (pools) => {
            if (mergeRolls) {
              return Promise.all(pools.map((pool) => game.dice3d.showForRoll(pool, game.user, true, whisper, blind)));
            } else {
              for (const pool of pools) {
                await game.dice3d.showForRoll(pool, game.user, true, whisper, blind);
              }
            }
          };

          /** @type {DicePool[]} */
          const pools = [];

          for (const atk of attacks) {
            // Create DicePool for attack and damage rolls
            const attackPool = new DicePool();
            if (atk.attack.roll) attackPool.rolls.push(atk.attack.roll);
            attackPool.rolls.push(...(atk.damage?.rolls?.map((dmgRoll) => dmgRoll.roll) ?? []));

            // Create DicePool for crit confirmation and crit damage rolls
            const critPool = new DicePool();
            if (atk.hasCritConfirm) critPool.rolls.push(atk.critConfirm.roll);
            critPool.rolls.push(...(atk.critDamage?.rolls?.map((dmgRoll) => dmgRoll.roll) ?? []));

            // Add non-empty pools to the array of rolls to be displayed
            if (attackPool.rolls.length) pools.push(attackPool);
            if (critPool.rolls.length) pools.push(critPool);
          }

          if (pools.length) {
            // Chat card is to be shown immediately
            if (skipRolls) showRoll(pools);
            // Wait for rolls to finish before showing the chat card
            else await showRoll(pools);
          }
        } catch (e) {
          console.error(e);
        }
      }

      // Subtract uses
      await this.addCharges(-cost);

      // Post message
      if (attacks.length) {
        // Get extra text and properties
        let props = [];
        let extraText = "";
        if (chatTemplateData.attacks.length > 0) extraText = chatTemplateData.attacks[0].attackNotesHTML;

        const itemChatData = this.getChatData(null, rollData);
        const properties = itemChatData.properties;

        // Add actual cost
        if (cost && !this.data.data.atWill) {
          if (this.data.type === "spell" && this.useSpellPoints()) {
            properties.push(`${game.i18n.localize("FFD20.SpellPointsCost")}: ${cost}`);
          } else {
            properties.push(`${game.i18n.localize("FFD20.ChargeCost")}: ${cost}`);
          }
        }

        // Add info for broken state
        if (this.data.data.broken) {
          properties.push(game.i18n.localize("FFD20.Broken"));
        }

        // Nonlethal
        if (this.data.data.nonlethal) properties.push(game.i18n.localize("FFD20.Nonlethal"));

        // Add info for Power Attack to melee, Deadly Aim to ranged attacks
        if (attackExtraParts.includes("@powerAttackPenalty")) {
          if (this.data.data.actionType === "rwak") properties.push(game.i18n.localize("FFD20.DeadlyAim"));
          if (this.data.data.actionType === "mwak") properties.push(game.i18n.localize("FFD20.PowerAttack"));
        }

        // Add info for Point-Blank shot
        if (attackExtraParts.includes("@pointBlankBonus")) properties.push(game.i18n.localize("FFD20.PointBlankShot"));

        // Add info for Rapid Shot
        if (attackExtraParts.includes("@rapidShotPenalty")) properties.push(game.i18n.localize("FFD20.RapidShot"));

        // Add ammo-remaining counter or out-of-ammunition warning
        if (ammoLinks.length) {
          if (ammoUsed === ammoAvailable) {
            properties.push(game.i18n.localize("FFD20.AmmoDepleted"));
          } else {
            properties.push(game.i18n.localize("FFD20.AmmoRemaining").format(ammoAvailable - ammoUsed));
          }
        }

        // Add Armor Check Penalty's application to attack rolls info
        if (this.hasAttack && rollData.attributes.acp.attackPenalty > 0)
          properties.push(game.i18n.localize("FFD20.ArmorCheckPenalty"));

        // Add conditionals info
        if (conditionals?.length) {
          conditionals.forEach((c) => {
            properties.push(this.data.data.conditionals[c].name);
          });
        }

        // Add Wound Thresholds info
        if (rollData.attributes.woundThresholds.level > 0)
          properties.push(
            game.i18n.localize(CONFIG.FFD20.woundThresholdConditions[rollData.attributes.woundThresholds.level])
          );

        if (properties.length > 0) props.push({ header: game.i18n.localize("FFD20.InfoShort"), value: properties });

        // Add combat info
        if (game.combat) {
          let combatProps = [];
          // Add round info
          combatProps.push(game.i18n.localize("FFD20.CombatInfo_Round").format(game.combat.round));

          if (combatProps.length > 0) {
            props.push({ header: game.i18n.localize("FFD20.CombatInfo_Header"), value: combatProps });
          }
        }

        // Add CL notes
        if (this.data.type === "spell" && this.parent) {
          const clNotes = this.parent.getContextNotesParsed(`spell.cl.${this.data.data.spellbook}`);

          if (clNotes.length) {
            props.push({
              header: game.i18n.localize("FFD20.CLNotes"),
              value: clNotes,
            });
          }
        }

        // Get saving throw data
        const save = getProperty(this.data, "data.save.type");
        const saveDC = this.getDC(rollData);
        const token =
          this.parentActor?.token ??
          canvas.tokens.placeables.find((t) => t.actor && t.actor.id === this.parentActor?.id);

        const templateData = mergeObject(
          chatTemplateData,
          {
            tokenUuid: token ? token.document?.uuid ?? token.uuid : null,
            extraText: extraText,
            data: itemChatData,
            hasExtraText: extraText.length > 0,
            properties: props,
            hasProperties: props.length > 0,
            item: this.data,
            actor: this.parent.data,
            hasSave: this.hasSave,
            save: {
              dc: saveDC,
              type: save,
              label: game.i18n
                .localize("FFD20.SavingThrowButtonLabel")
                .format(CONFIG.FFD20.savingThrows[save], saveDC.toString()),
            },
          },
          { inplace: false }
        );

        // Range
        {
          const range = this.range;
          if (range != null) {
            templateData.range = range;
            if (typeof range === "string") {
              templateData.range = RollFFD20$1.safeRoll(range, rollData).total;
              templateData.rangeFormula = range;
            }
            let usystem = game.settings.get("ffd20", "distanceUnits"); // override
            if (usystem === "default") usystem = game.settings.get("ffd20", "units");
            templateData.rangeLabel = usystem === "metric" ? `${templateData.range} m` : `${templateData.range} ft.`;

            const rangeUnits = getProperty(this.data, "data.range.units");
            if (["melee", "touch", "reach", "close", "medium", "long"].includes(rangeUnits)) {
              templateData.rangeLabel = CONFIG.FFD20.distanceUnits[rangeUnits];
            }
          }
        }

        // Spells
        if (this.type === "spell" && this.parent != null) {
          // Spell failure
          if (this.parent.spellFailure > 0) {
            const spellbook = getProperty(
              this.parent.data,
              `data.attributes.spells.spellbooks.${this.data.data.spellbook}`
            );
            if (spellbook && spellbook.arcaneSpellFailure) {
              const roll = RollFFD20$1.safeRoll("1d100");
              templateData.spellFailure = roll.total;
              templateData.spellFailureRoll = roll;
              templateData.spellFailureSuccess = templateData.spellFailure > this.parentActor.spellFailure;
            }
          }
          // Caster Level Check
          templateData.casterLevelCheck = casterLevelCheck;
          // Concentration check
          templateData.concentrationCheck = concentrationCheck;
        }
        // Add metadata
        const metadata = {};
        metadata.item = this.id;
        metadata.template = template ? template.id : null;
        metadata.rolls = {
          attacks: {},
        };
        // Add attack rolls
        for (let a = 0; a < attacks.length; a++) {
          const atk = attacks[a];
          const attackRolls = { attack: null, damage: {}, critConfirm: null, critDamage: {} };
          // Add attack roll
          if (atk.attack.roll) attackRolls.attack = atk.attack.roll.toJSON();
          // Add damage rolls
          if (atk.damage.rolls.length) {
            for (let b = 0; b < atk.damage.rolls.length; b++) {
              const r = atk.damage.rolls[b];
              attackRolls.damage[b] = {
                damageType: r.damageType,
                roll: r.roll.toJSON(),
              };
            }
          }
          // Add critical confirmation roll
          if (atk.critConfirm.roll) attackRolls.critConfirm = atk.critConfirm.roll.toJSON();
          // Add critical damage rolls
          if (atk.critDamage.rolls.length) {
            for (let b = 0; b < atk.critDamage.rolls.length; b++) {
              const r = atk.critDamage.rolls[b];
              attackRolls.critDamage[b] = {
                damageType: r.damageType,
                roll: r.roll.toJSON(),
              };
            }
          }

          metadata.rolls.attacks[a] = attackRolls;
        }

        if (ammoId.length > 0) metadata.ammo = { id: ammoId, quantity: ammoUsed };
        if (saveDC) metadata.save = { dc: saveDC, type: save };
        if (this.type === "spell") metadata.spell = { cl: rollData.cl, sl: rollData.sl };

        setProperty(chatData, "flags.ffd20.metadata", metadata);
        setProperty(chatData, "flags.core.canPopout", true);

        Hooks.call("itemUse", this, "postAttack", { ev, skipDialog, chatData, templateData });

        // Create message
        const t = game.settings.get("ffd20", "attackChatCardTemplate");
        if (chatMessage) result = await createCustomChatMessage(t, templateData, chatData);
        else result = { template: t, data: templateData, chatData };
      }
      // Post chat card even without action
      else {
        if (chatMessage) result = this.roll();
        else result = { descriptionOnly: true };
      }

      // Subtract ammunition
      await subtractAmmo(ammoUsed);

      // Extra options for script call
      const data = { chatMessage, fullAttack };

      // Execute script call
      await this.executeScriptCalls("use", {
        attacks,
        template,
        data,
        conditionals: conditionals.map((c) => this.data.data.conditionals[c]),
      });

      return result;
    };

    // Handle fast-forwarding
    if (skipDialog) return _roll.call(this, true);

    // Render modal dialog
    let htmlTemplate = "systems/ffd20/templates/apps/attack-roll-dialog.hbs";
    let dialogData = {
      data: rollData,
      item: this.data.data,
      config: CONFIG.FFD20,
      rollMode: game.settings.get("core", "rollMode"),
      rollModes: CONFIG.Dice.rollModes,
      hasAttack: this.hasAttack,
      hasDamage: this.hasDamage,
      hasDamageAbility: getProperty(this.data, "data.ability.damage") !== "",
      isNaturalAttack: getProperty(this.data, "data.attackType") === "natural",
      isWeaponAttack: getProperty(this.data, "data.attackType") === "weapon",
      isMeleeWeaponAttackAction: getProperty(this.data, "data.actionType") === "mwak",
      isRangedWeaponAttackAction: getProperty(this.data, "data.actionType") === "rwak",
      isAttack: this.type === "attack",
      isSpell: this.type === "spell",
      hasTemplate: this.hasTemplate,
    };
    const html = await renderTemplate(htmlTemplate, dialogData);

    let result = await new Promise((resolve) => {
      const buttons = {};
      if (this.hasAttack) {
        if (this.type !== "spell") {
          buttons.normal = {
            label: game.i18n.localize("FFD20.SingleAttack"),
            callback: (html) => resolve((_roll.call(this, false, html))),
          };
        }

        let showFullAttack = false;

        if (["mwak", "rwak"].includes(getProperty(this.data, "data.actionType"))) {
          showFullAttack = true;
        } else if ((getProperty(this.data, "data.AttackParts") || []).length) {
          showFullAttack = true;
        } else {
          // Fetch formulaic attacks and ensure .value is set
          let fmAtks = getProperty(this.data, "data.formulaicAttacks.count.value");
          if (fmAtks == null && getProperty(this.data, "data.formulaicAttacks.count.formula")?.length > 0) {
            fmAtks = getProperty(this.data, "data.formulaicAttacks.count.value");
            if (fmAtks > 0) showFullAttack = true;
          }
        }

        if (showFullAttack || this.type === "spell") {
          buttons.multi = {
            label: this.type === "spell" ? game.i18n.localize("FFD20.Cast") : game.i18n.localize("FFD20.FullAttack"),
            callback: (html) => resolve((_roll.call(this, true, html))),
          };
        }
      } else {
        buttons.normal = {
          label: this.type === "spell" ? game.i18n.localize("FFD20.Cast") : game.i18n.localize("FFD20.Use"),
          callback: (html) => resolve((_roll.call(this, false, html))),
        };
      }
      new Dialog(
        {
          title: `${game.i18n.localize("FFD20.Use")}: ${this.name}`,
          content: html,
          buttons: buttons,
          default: buttons.multi != null ? "multi" : "normal",
          close: (html) => {
            resolve(false);
          },
        },
        {
          classes: ["dialog", "ffd20", "use-attack"],
        }
      ).render(true);
    });

    return result;
  }

  /**
   * Finds, filters and alters changes relevant to a context, and returns the result (as an array)
   *
   * @param {string} [context="mattack"] - The given context. Either "mattack", "rattack", "wdamage", "sdamage".
   * @returns {ItemChange[]} The resulting changes.
   */
  getContextChanges(context = "attack") {
    let result = this.actor.changes;

    switch (context) {
      case "mattack":
      case "rattack": {
        const subTargetList = ["attack", context];
        result = result.filter((c) => {
          if (!subTargetList.includes(c.subTarget)) return false;
          return true;
        });
        // Add masterwork bonus
        if (getProperty(this.data, "data.masterwork") === true && !getProperty(this.data, "data.enh")) {
          result.push(
            ItemChange.create({
              formula: "1",
              operator: "add",
              target: "attack",
              subTarget: "attack",
              modifier: "enh",
              value: 1,
              flavor: game.i18n.localize("FFD20.Masterwork"),
            })
          );
        }
        // Add enhancement bonus
        if (getProperty(this.data, "data.enh")) {
          const enh = getProperty(this.data, "data.enh");
          result.push(
            ItemChange.create({
              formula: enh.toString(),
              operator: "add",
              target: "attack",
              subTarget: "attack",
              modifier: "enh",
              value: enh,
              flavor: game.i18n.localize("FFD20.EnhancementBonus"),
            })
          );
        }
        break;
      }
      case "wdamage":
      case "sdamage": {
        const subTargetList = ["damage", context];
        result = result.filter((c) => {
          if (!subTargetList.includes(c.subTarget)) return false;
          return true;
        });
        // Add enhancement bonus
        if (getProperty(this.data, "data.enh")) {
          const enh = getProperty(this.data, "data.enh");
          result.push(
            ItemChange.create({
              formula: enh.toString(),
              operator: "add",
              target: "attack",
              subTarget: "attack",
              modifier: "enh",
              value: enh,
              flavor: game.i18n.localize("FFD20.EnhancementBonus"),
            })
          );
        }
        break;
      }
    }

    return result;
  }

  /**
   * Place an attack roll using an item (weapon, feat, spell, or equipment)
   * Rely upon the DiceFFD20.d20Roll logic for the core implementation
   *
   * @param root0
   * @param root0.data
   * @param root0.extraParts
   * @param root0.bonus
   * @param root0.primaryAttack
   */
  rollAttack({ data = null, extraParts = [], bonus = null, primaryAttack = true } = {}) {
    const rollData = duplicate(data ?? this.getRollData());
    const itemData = rollData.item;

    rollData.item.primaryAttack = primaryAttack;

    const isRanged = ["rwak", "rsak", "rcman"].includes(itemData.actionType);
    const isCMB = ["mcman", "rcman"].includes(itemData.actionType);

    // Determine size bonus
    rollData.sizeBonus = !isCMB
      ? CONFIG.FFD20.sizeMods[rollData.traits.size]
      : CONFIG.FFD20.sizeSpecialMods[rollData.traits.size];

    // Add misc bonuses/penalties
    rollData.item.proficiencyPenalty = -4;

    // Determine ability score modifier
    let abl = itemData.ability.attack;

    // Define Roll parts
    let parts = [];

    this.parentActor.sourceDetails["data.attributes.attack.shared"]
      ?.reverse()
      .forEach((s) => parts.push(`${s.value}[${s.name}]`));

    // CMB specific modifiers
    if (isCMB) {
      this.parentActor.sourceDetails["data.attributes.cmb.total"]
        ?.reverse()
        .forEach((s) => parts.push(`${s.value}[${s.name}]`));
    }

    // Add size bonus
    if (rollData.sizeBonus !== 0) parts.push(`@sizeBonus[${game.i18n.localize("FFD20.Size")}]`);

    // Add ability modifier
    if (abl != "" && rollData.abilities[abl] != null && rollData.abilities[abl].mod !== 0) {
      parts.push(`@abilities.${abl}.mod[${CONFIG.FFD20.abilities[abl]}]`);
    }
    // Add bonus parts
    parts = parts.concat(extraParts);
    // Add attack bonus
    if (typeof itemData.attackBonus === "string" && !["", "0"].includes(itemData.attackBonus)) {
      parts.push(itemData.attackBonus);
    }
    // Backwards compatibility
    else if (typeof itemData.attackBonus === "number") {
      rollData.item.attackBonus = itemData.attackBonus;
      parts.push(`@item.attackBonus[${game.i18n.localize("FFD20.AttackRollBonus")}]`);
    }

    // Add change bonus
    const changes = this.getContextChanges(isRanged ? "rattack" : "mattack");
    let changeBonus = [];
    {
      // Get attack bonus
      changeBonus = getHighestChanges(
        changes.filter((c) => {
          c.applyChange(this.actor);
          return !["set", "="].includes(c.operator);
        }),
        { ignoreTarget: true }
      ).reduce((cur, c) => {
        cur.push({
          value: c.value,
          source: c.flavor,
        });
        return cur;
      }, []);
    }
    for (let c of changeBonus) {
      parts.push(`${c.value}[${RollFFD20$1.cleanFlavor(c.source)}]`);
    }

    // Add proficiency penalty
    if (this.data.type === "attack" && !itemData.proficient) {
      parts.push(`@item.proficiencyPenalty[${game.i18n.localize("FFD20.ProficiencyPenalty")}]`);
    }
    // Add secondary natural attack penalty
    if (primaryAttack === false) parts.push(`-5[${game.i18n.localize("FFD20.SecondaryAttack")}]`);
    // Add bonus
    if (bonus) {
      rollData.bonus = RollFFD20$1.safeRoll(bonus, rollData).total;
      parts.push(`@bonus[${game.i18n.localize("FFD20.SituationalBonus")}]`);
    }

    if ((rollData.d20 ?? "") === "") rollData.d20 = "1d20";

    let roll = RollFFD20$1.safeRoll([rollData.d20, ...parts.filter((p) => !!p)].join("+"), rollData);
    return roll;
  }

  /* -------------------------------------------- */

  /**
   * Only roll the item's effect.
   *
   * @param root0
   * @param root0.critical
   * @param root0.primaryAttack
   */
  rollEffect({ critical = false, primaryAttack = true } = {}) {
    const rollData = this.getRollData();

    if (!this.hasEffect) {
      throw new Error("You may not make an Effect Roll with this Item.");
    }

    // Determine critical multiplier
    rollData.critMult = 1;
    if (critical) rollData.critMult = this.data.data.ability.critMult;
    // Determine ability multiplier
    if (this.data.data.ability.damageMult != null) rollData.ablMult = this.data.data.ability.damageMult;
    if (primaryAttack === false && rollData.ablMult > 0) rollData.ablMult = 0.5;

    // Create effect string
    let effectNotes = this.parent.getContextNotes("attacks.effect").reduce((cur, o) => {
      o.notes
        .reduce((cur2, n) => {
          cur2.push(...n.split(/[\n\r]+/));
          return cur2;
        }, [])
        .forEach((n) => {
          cur.push(n);
        });
      return cur;
    }, []);
    effectNotes.push(...this.data.data.effectNotes);
    let effectContent = "";
    for (let fx of effectNotes) {
      if (fx.length > 0) {
        effectContent += `<span class="tag">${fx}</span>`;
      }
    }

    if (effectContent.length === 0) return "";

    const inner = TextEditor.enrichHTML(effectContent, { rollData: rollData });
    return `<div class="flexcol property-group"><label>${game.i18n.localize(
      "FFD20.EffectNotes"
    )}</label><div class="flexrow">${inner}</div></div>`;
  }

  /**
   * Place an attack roll using an item (weapon, feat, spell, or equipment)
   * Rely upon the DiceFFD20.d20Roll logic for the core implementation
   *
   * @param options
   */
  async rollFormula(options = {}) {
    const itemData = this.data.data;
    if (!itemData.formula) {
      throw new Error(game.i18n.localize("FFD20.ErrorNoFormula").format(this.name));
    }

    // Define Roll Data
    const rollData = this.parent.getRollData();
    rollData.item = itemData;
    const title = `${this.name} - ${game.i18n.localize("FFD20.OtherFormula")}`;

    const roll = RollFFD20$1.safeRoll(itemData.formula, rollData);
    return roll.toMessage({
      speaker: ChatMessage.getSpeaker({ actor: this.parent }),
      flavor: itemData.chatFlavor || title,
      rollMode: game.settings.get("core", "rollMode"),
    });
  }

  /**
   * Place a damage roll using an item (weapon, feat, spell, or equipment)
   * Rely upon the DiceFFD20.damageRoll logic for the core implementation
   *
   * @param root0
   * @param root0.data
   * @param root0.critical
   * @param root0.extraParts
   * @param root0.conditionalParts
   * @param root0.primaryAttack
   */
  rollDamage({ data = null, critical = false, extraParts = [], conditionalParts = {}, primaryAttack = true } = {}) {
    const rollData = duplicate(data ?? this.getRollData());

    if (!this.hasDamage) {
      throw new Error("You may not make a Damage Roll with this Item.");
    }

    // Determine critical multiplier
    rollData.critMult = 1;
    if (critical) rollData.critMult = this.data.data.ability.critMult;
    // Determine ability multiplier
    if (rollData.ablMult == null) rollData.ablMult = this.data.data.ability.damageMult;
    if (primaryAttack === false && rollData.ablMult > 0) rollData.ablMult = 0.5;

    // Define Roll parts
    let parts = this.data.data.damage.parts.map((p) => {
      return { base: p[0], extra: [], damageType: p[1], type: "normal" };
    });
    // Add conditionals damage
    conditionalParts["damage.normal"]?.forEach((p) => {
      const [base, damageType, isExtra] = p;
      isExtra ? parts[0].extra.push(base) : parts.push({ base, extra: [], damageType, type: "normal" });
    });
    // Add critical damage parts
    if (critical === true) {
      if (getProperty(this.data, "data.damage.critParts") != null) {
        parts = parts.concat(
          this.data.data.damage.critParts.map((p) => {
            return { base: p[0], extra: [], damageType: p[1], type: "crit" };
          })
        );
      }
      // Add conditional critical damage parts
      conditionalParts["damage.crit"]?.forEach((p) => {
        const [base, damageType, isExtra] = p;
        isExtra ? parts[0].extra.push(base) : parts.push({ base, extra: [], damageType, type: "crit" });
      });
    }
    // Add non-critical damage parts
    if (critical === false) {
      if (getProperty(this.data, "data.damage.nonCritParts") != null) {
        parts = parts.concat(
          this.data.data.damage.nonCritParts.map((p) => {
            return { base: p[0], extra: [], damageType: p[1], type: "nonCrit" };
          })
        );
      }
      // Add conditional non-critical damage parts
      conditionalParts["damage.nonCrit"]?.forEach((p) => {
        const [base, damageType, isExtra] = p;
        isExtra ? parts[0].extra.push(base) : parts.push({ base, extra: [], damageType, type: "nonCrit" });
      });
    }

    if (!this.isHealing) {
      const isSpell = ["msak", "rsak"].includes(this.data.data.actionType);
      const changes = this.getContextChanges(isSpell ? "sdamage" : "wdamage");
      let changeBonus = [];
      {
        // Get damage bonus
        changeBonus = getHighestChanges(
          changes.filter((c) => {
            c.applyChange(this.actor);
            return !["set", "="].includes(c.operator);
          }),
          { ignoreTarget: true }
        ).reduce((cur, c) => {
          if (c.value)
            cur.push({
              value: c.value,
              source: c.flavor,
            });
          return cur;
        }, []);
      }
      for (let c of changeBonus) {
        parts[0].extra.push(`${c.value}[${c.source}]`);
      }

      // Add broken penalty
      if (this.data.data.broken) {
        const label = game.i18n.localize("FFD20.Broken");
        parts[0].extra.push(`-2[${label}]`);
      }
    }

    // Determine ability score modifier
    let abl = this.data.data.ability.damage;
    if (typeof abl === "string" && abl !== "") {
      // Determine ability score bonus
      rollData.ablDamage = Math.floor(rollData.abilities[abl].mod * rollData.ablMult);
      if (rollData.abilities[abl].mod < 0) rollData.ablDamage = rollData.abilities[abl].mod;

      // Determine ability score label
      const ablLabel = CONFIG.FFD20.abilities[abl];

      // Add ability score
      parts[0].extra.push(`@ablDamage[${ablLabel}]`);
    }

    // Create roll
    let rolls = [];
    for (let a = 0; a < parts.length; a++) {
      const part = parts[a];
      let rollParts = [];
      if (a === 0) rollParts = [...part.extra, ...extraParts];
      const roll = {
        roll: RollFFD20$1.safeRoll([part.base, ...rollParts].join(" + "), rollData),
        damageType: part.damageType,
        type: part.type,
      };
      rolls.push(roll);
    }

    return rolls;
  }

  /* -------------------------------------------- */

  /**
   * Use a consumable item
   *
   * @param options
   */
  async useConsumable(options = { chatMessage: true }) {
    let itemData = this.data.data;
    let parts = itemData.damage.parts;
    const data = this.getRollData();

    const allowed = Hooks.call("itemUse", this, "consumable", options);
    if (allowed === false) return;

    // Add effect string
    let effectStr = "";
    if (typeof itemData.effectNotes === "string" && itemData.effectNotes.length) {
      effectStr = DiceFFD20.messageRoll({
        data: data,
        msgStr: itemData.effectNotes,
      });
    }

    parts = parts.map((obj) => {
      return obj[0];
    });
    // Submit the roll to chat
    if (effectStr === "") {
      RollFFD20$1.safeRoll(parts.join(" + ")).toMessage({
        speaker: ChatMessage.getSpeaker({ actor: this.parentActor }),
        flavor: game.i18n.localize("FFD20.UsesItem").format(this.name),
      });
    } else {
      const chatTemplate = "systems/ffd20/templates/chat/roll-ext.hbs";
      const chatTemplateData = { hasExtraText: true, extraText: effectStr };
      // Execute the roll
      let roll = RollFFD20$1.safeRoll(parts.join("+"), data);

      // Create roll template data
      const rollData = mergeObject(
        {
          user: game.user._id,
          formula: roll.formula,
          tooltip: await roll.getTooltip(),
          total: roll.total,
        },
        chatTemplateData || {}
      );

      // Create chat data
      let chatData = {
        user: game.user._id,
        type: CONST.CHAT_MESSAGE_TYPES.CHAT,
        rollMode: game.settings.get("core", "rollMode"),
        sound: CONFIG.sounds.dice,
        speaker: ChatMessage.getSpeaker({ actor: this.parent }),
        flavor: game.i18n.localize("FFD20.UsesItem").format(this.name),
        roll: roll,
        content: await renderTemplate(chatTemplate, rollData),
      };
      // Handle different roll modes
      switch (chatData.rollMode) {
        case "gmroll":
          chatData["whisper"] = game.users.contents.filter((u) => u.isGM).map((u) => u._id);
          break;
        case "selfroll":
          chatData["whisper"] = [game.user._id];
          break;
        case "blindroll":
          chatData["whisper"] = game.users.contents.filter((u) => u.isGM).map((u) => u._id);
          chatData["blind"] = true;
      }

      // Send message
      if (options.chatMessage) ChatMessage.create(chatData);

      return roll;
    }
  }

  /* -------------------------------------------- */

  /**
   * @returns {object} An object with data to be used in rolls in relation to this item.
   */
  getRollData() {
    const result = this.parent != null && this.parent.data ? this.parent.getRollData() : {};

    result.item = this.data.data;
    if (this.type === "spell" && this.parent != null) {
      const spellbook = this.spellbook;
      if (spellbook != null) {
        const spellAbility = spellbook.ability;
        let ablMod = "";
        if (spellAbility !== "") ablMod = getProperty(this.parent.data, `data.abilities.${spellAbility}.mod`);

        result.cl = this.casterLevel || 0;
        result.sl = this.spellLevel || 0;
        result.classLevel =
          spellbook.class === "_hd"
            ? result.attributes.hd.total
            : spellbook.class?.length > 0
            ? getProperty(result, `classes.${spellbook.class}.level`) || 0 // `
            : 0;
        result.ablMod = ablMod;
      }
    }
    if (this.type === "buff") result.item.level = this.data.data.level;

    // Add dictionary flag
    if (this.data.data.tag) {
      result.item.dFlags = getProperty(result, `dFlags.${this.data.data.tag}`);
    }

    // Set aura strength
    setProperty(result, "item.auraStrength", this.auraStrength);

    this._rollData = result.item;

    Hooks.callAll("ffd20.getRollData", this, result, true);

    return result;
  }

  /* -------------------------------------------- */

  static chatListeners(html) {
    html.on("click", ".card-buttons button", this._onChatCardButton.bind(this));
    html.on("click", ".item-name", this._onChatCardToggleContent.bind(this));
  }

  /* -------------------------------------------- */

  static async _onChatCardButton(event) {
    event.preventDefault();

    // Extract card data
    const button = event.currentTarget;
    button.disabled = true;
    const card = button.closest(".chat-card");
    const messageId = card.closest(".message").dataset.messageId;
    const message = game.messages.get(messageId);
    const action = button.dataset.action;

    // Validate permission to proceed with the roll
    let isTargetted = ["save", "applyDamage"].includes(action);
    if (!(isTargetted || game.user.isGM || message.isAuthor)) return;

    // Get the Actor from a synthetic Token
    const actor = await this._getChatCardActor(card);
    if (!actor) {
      if (action === "applyDamage") {
        await this._onChatCardAction(action, { button: button });
        button.disabled = false;
      }
      return;
    }

    // Get the Item
    const item = actor.items.get(card.dataset.itemId);

    // Perform action
    if (!(await this._onChatCardAction(action, { button: button, item: item }))) {
      button.disabled = false;
    }
  }

  static async _onChatCardAction(action, { button = null, item = null } = {}) {
    // Get card targets
    // const targets = isTargetted ? this._getChatCardTargets(card) : [];

    // Consumable usage
    if (action === "consume") await item.useConsumable({ event });
    // Apply damage
    else if (action === "applyDamage") {
      let asNonlethal = [...button.closest(".chat-message")?.querySelectorAll(".tag")]
        .map((o) => o.innerText)
        .includes(game.i18n.localize("FFD20.Nonlethal"));
      if (button.dataset.tags?.split(" ").includes("nonlethal")) asNonlethal = true;

      const value = button.dataset.value;
      if (!isNaN(parseInt(value))) ActorFFD20.applyDamage(parseInt(value), { asNonlethal });
    }
    // Recover ammunition
    else if (["recoverAmmo", "forceRecoverAmmo"].includes(action)) {
      if (!item) return;

      const ammoLinks = await item.getLinkedItems("ammunition", true);
      let recovered = false;
      let failed = false;
      let promises = [];

      for (let l of ammoLinks) {
        let chance = 100;
        if (action === "recoverAmmo") {
          chance = l.linkData.recoverChance;
        }

        if (chance >= Math.random() * 100) {
          recovered = true;
          promises.push(l.item.addCharges(1));
        } else {
          failed = true;
        }
      }

      // Disable button
      if (button) {
        button.disabled = true;
        if (recovered && !failed) {
          button.style.backgroundColor = "#00AA00";
        } else if (!recovered && failed) {
          button.style.backgroundColor = "#AA0000";
        } else if (recovered && failed) {
          button.style.backgroundColor = "#0000AA";
        }
      }

      await Promise.all(promises);

      return true;
    } else if (action === "concentration") {
      item.parentActor.rollConcentration(item.data.data.spellbook);
    } else if (action === "caster-level-check") {
      item.parentActor.rollCL(item.data.data.spellbook);
    }

    return false;
  }

  /* -------------------------------------------- */

  /**
   * Handle toggling the visibility of chat card content when the name is clicked
   *
   * @param {Event} event   The originating click event
   * @private
   */
  static _onChatCardToggleContent(event) {
    event.preventDefault();
    const header = event.currentTarget;
    const card = header.closest(".chat-card");
    const content = card.querySelector(".card-content");
    content.style.display = content.style.display === "none" ? "block" : "none";

    // Update chat popout size
    const popout = header.closest(".chat-popout");
    if (popout) {
      popout.style.height = "auto";
    }
  }

  /**
   * Get the Actor which is the author of a chat card
   *
   * @param {HTMLElement} card    The chat card being used
   * @returns {Actor|null}         The Actor entity or null
   * @private
   */
  static async _getChatCardActor(card) {
    // Case 1 - a synthetic actor from a Token
    const tokenUuid = card.dataset.tokenId;
    if (tokenUuid) {
      return (await fromUuid(tokenUuid))?.actor;
    }

    // Case 2 - use Actor ID directory
    const actorId = card.dataset.actorId;
    return game.actors.get(actorId) || null;
  }

  /**
   * Updates the spell's description.
   */

  async _updateSpellDescription(updateData, srcData) {
    const reSplit = CONFIG.FFD20.re.traitSeparator;

    const label = {
      school: (CONFIG.FFD20.spellSchools[getProperty(srcData, "data.school")] || "").toLowerCase(),
      multi: getProperty(srcData, "data.multi"),
      multischool: (CONFIG.FFD20.multiSchools[getProperty(srcData, "data.multischool")] || "").toLowerCase(),
      subschool: getProperty(srcData, "data.subschool") || "",
      types: "",
    };
    const data = {
      data: mergeObject(this.data.data, srcData.data, { inplace: false }),
      label: label,
    };

    // Set subschool and types label
    const types = getProperty(srcData, "data.types");
    if (typeof types === "string" && types.length > 0) {
      label.types = types.split(reSplit).join(", ");
    }
    // Set information about when the spell is learned
    data.learnedAt = {};
    data.learnedAt.class = (getProperty(srcData, "data.learnedAt.class") || [])
      .map((o) => {
        return `${o[0]} ${o[1]}`;
      })
      .sort()
      .join(", ");
    data.learnedAt.domain = (getProperty(srcData, "data.learnedAt.domain") || [])
      .map((o) => {
        return `${o[0]} ${o[1]}`;
      })
      .sort()
      .join(", ");
    data.learnedAt.subDomain = (getProperty(srcData, "data.learnedAt.subDomain") || [])
      .map((o) => {
        return `${o[0]} ${o[1]}`;
      })
      .sort()
      .join(", ");
    data.learnedAt.elementalSchool = (getProperty(srcData, "data.learnedAt.elementalSchool") || [])
      .map((o) => {
        return `${o[0]} ${o[1]}`;
      })
      .sort()
      .join(", ");
    data.learnedAt.bloodline = (getProperty(srcData, "data.learnedAt.bloodline") || [])
      .map((o) => {
        return `${o[0]} ${o[1]}`;
      })
      .sort()
      .join(", ");

    // Set casting time label
    const act = game.settings.get("ffd20", "unchainedActionEconomy")
      ? getProperty(srcData, "data.unchainedAction.activation")
      : getProperty(srcData, "data.activation");
    if (act != null) {
      const activationCost = act.cost;
      const activationType = act.type;
      const activationTypes = game.settings.get("ffd20", "unchainedActionEconomy")
        ? CONFIG.FFD20.abilityActivationTypes_unchained
        : CONFIG.FFD20.abilityActivationTypes;
      const activationTypesPlurals = game.settings.get("ffd20", "unchainedActionEconomy")
        ? CONFIG.FFD20.abilityActivationTypesPlurals_unchained
        : CONFIG.FFD20.abilityActivationTypesPlurals;

      if (activationType) {
        if (activationTypesPlurals[activationType] != null) {
          if (activationCost === 1) label.castingTime = `${activationTypes[activationType]}`;
          else label.castingTime = `${activationTypesPlurals[activationType]}`;
        } else label.castingTime = `${activationTypes[activationType]}`;
      }
      if (!Number.isNaN(activationCost) && label.castingTime != null)
        label.castingTime = `${activationCost} ${label.castingTime}`;
      if (label.castingTime) label.castingTime = label.castingTime.toLowerCase();
    }

    // Set components label
    label.components = this.getSpellComponents(srcData).join(", ");

    // Set duration label
    {
      const duration = getProperty(srcData, "data.spellDuration");
      if (duration) label.duration = duration;
    }
    // Set effect label
    {
      const effect = getProperty(srcData, "data.spellEffect");
      if (effect) label.effect = effect;
    }
    // Set targets label
    {
      const targets = getProperty(srcData, "data.target.value");
      if (targets) label.targets = targets;
    }
    // Set range label
    {
      const rangeUnit = getProperty(srcData, "data.range.units");
      const rangeValue = getProperty(srcData, "data.range.value");

      if (rangeUnit != null && rangeUnit !== "none") {
        label.range = (CONFIG.FFD20.distanceUnits[rangeUnit] || "").toLowerCase();
        let units = game.settings.get("ffd20", "distanceUnits"); // override
        if (units === "default") units = game.settings.get("ffd20", "units");
        if (rangeUnit === "close")
          label.range = `${label.range} ${game.i18n.localize(
            units == "metric" ? "FFD20.SpellRangeShortMetric" : "FFD20.SpellRangeShort"
          )}`;
        else if (rangeUnit === "medium")
          label.range = `${label.range} ${game.i18n.localize(
            units == "metric" ? "FFD20.SpellRangeMediumMetric" : "FFD20.SpellRangeMedium"
          )}`;
        else if (rangeUnit === "long")
          label.range = `${label.range} ${game.i18n.localize(
            units == "metric" ? "FFD20.SpellRangeLongMetric" : "FFD20.SpellRangeLong"
          )}`;
        else if (["ft", "mi"].includes(rangeUnit)) {
          if (!rangeValue) label.range = "";
          else label.range = `${rangeValue} ${label.range}`;
        }
      }
    }
    // Set area label
    {
      const area = getProperty(srcData, "data.spellArea");

      if (area) label.area = area;
    }

    // Set DC and SR
    {
      const savingThrowDescription = getProperty(srcData, "data.save.description");
      if (savingThrowDescription) label.savingThrow = savingThrowDescription;
      else label.savingThrow = "none";

      const sr = getProperty(srcData, "data.sr");
      label.sr = (sr === true ? game.i18n.localize("FFD20.Yes") : game.i18n.localize("FFD20.No")).toLowerCase();

      if (getProperty(srcData, "data.range.units") !== "personal") data.useDCandSR = true;
    }

    linkData(
      srcData,
      updateData,
      "data.description.value",
      await renderTemplate("systems/ffd20/templates/internal/spell-description.hbs", data)
    );
  }

  getSpellComponents(srcData) {
    if (!srcData) srcData = duplicate(this.data);
    const reSplit = CONFIG.FFD20.re.traitSeparator;

    let components = [];
    for (let [key, value] of Object.entries(getProperty(srcData, "data.components"))) {
      if (key === "value" && value.length > 0) components.push(...value.split(reSplit));
      else if (key === "verbal" && value) components.push("V");
      else if (key === "somatic" && value) components.push("S");
      else if (key === "material" && value) components.push("M");
      else if (key === "focus" && value) components.push("F");
    }
    if (getProperty(srcData, "data.components.divineFocus") === 1) components.push("DF");
    const df = getProperty(srcData, "data.components.divineFocus");
    // Sort components
    const componentsOrder = ["V", "S", "M", "F", "DF"];
    components.sort((a, b) => {
      let index = [componentsOrder.indexOf(a), components.indexOf(b)];
      if (index[0] === -1 && index[1] === -1) return 0;
      if (index[0] === -1 && index[1] >= 0) return 1;
      if (index[0] >= 0 && index[1] === -1) return -1;
      return index[0] - index[1];
    });
    components = components.map((o) => {
      if (o === "M") {
        if (df === 2) o = "M/DF";
        if (getProperty(srcData, "data.materials.value")) o = `${o} (${getProperty(srcData, "data.materials.value")})`;
      }
      if (o === "F") {
        if (df === 3) o = "F/DF";
        if (getProperty(srcData, "data.materials.focus")) o = `${o} (${getProperty(srcData, "data.materials.focus")})`;
      }
      return o;
    });
    return components;
  }

  /* -------------------------------------------- */

  /**
   * Get the Actor which is the author of a chat card
   *
   * @param {HTMLElement} card    The chat card being used
   * @returns {Array.<Actor>}      The Actor entity or null
   * @private
   */
  static _getChatCardTargets(card) {
    const character = game.user.character;
    const controlled = canvas.tokens.controlled;
    const targets = controlled.reduce((arr, t) => (t.actor ? arr.concat([t.actor]) : arr), []);
    if (character && controlled.length === 0) targets.push(character);
    if (!targets.length) throw new Error(`You must designate a specific Token as the roll target`);
    return targets;
  }

  useSpellPoints() {
    if (!this.parent) return false;
    if (this.data.type !== "spell") return false;

    const spellbookKey = this.data.data.spellbook;
    const spellbook = getProperty(this.parent.data, `data.attributes.spells.spellbooks.${spellbookKey}`);
    return getProperty(spellbook, "spellPoints.useSystem") || false;
  }

  getSpellPointCost(rollData = null) {
    if (!rollData) rollData = this.getRollData();

    const roll = RollFFD20$1.safeRoll(getProperty(this.data, "data.spellPoints.cost") || "0", rollData);
    return roll.total;
  }

  async addSpellUses(value, data = null) {
    if (!this.parent) return;
    if (this.data.data.atWill) return;

    const spellbook = getProperty(this.parent.data, `data.attributes.spells.spellbooks.${this.data.data.spellbook}`),
      isSpontaneous = spellbook.spontaneous,
      spellbookKey = getProperty(this.data, "data.spellbook") || "primary",
      spellLevel = getProperty(this.data, "data.level");

    if (this.useSpellPoints()) {
      const curUses = this.getSpellUses();
      const updateData = {};
      const tempMP = getProperty(this.parent.data, "data.attributes.mp.temp");
      const curMP = getProperty(this.parent.data, "data.attributes.mp.temp");

      // check for temp mp
      if(tempMP === 0){
        // if temp mp is 0 do normal
        updateData["data.attributes.mp.value"] = curUses + value;
        return this.parent.update(updateData);
        } else {
          // else check if temp mp is greater then spell cost
          // if so deduct from temp and then from normal
          if(tempMP >= (value * -1)){
          // else deduct from temp
          updateData["data.attributes.mp.temp"] = tempMP + value;
            return this.parent.update(updateData);
            } else {
            let leftMP = tempMP + value;
          updateData["data.attributes.mp.temp"] = 0;
          updateData["data.attributes.mp.value"] = curMP + leftMP;
          return this.parent.update(updateData);}
        }
    } else {
      const newCharges = isSpontaneous
        ? Math.max(0, (getProperty(spellbook, `spells.spell${spellLevel}.value`) || 0) + value)
        : Math.max(0, (getProperty(this.data, "data.preparation.preparedAmount") || 0) + value);

      if (!isSpontaneous) {
        const key = "data.preparation.preparedAmount";
        if (data == null) {
          data = {};
          data[key] = newCharges;
          return this.update(data);
        } else {
          data[key] = newCharges;
        }
      } else {
        const key = `data.attributes.spells.spellbooks.${spellbookKey}.spells.spell${spellLevel}.value`;
        const actorUpdateData = {};
        actorUpdateData[key] = newCharges;
        return this.parent.update(actorUpdateData);
      }
    }

    return null;
  }

  getSpellUses(max = false) {
    if (!this.parent) return 0;
    if (this.data.data.atWill) return Number.POSITIVE_INFINITY;

    const spellbook = getProperty(this.parent.data, `data.attributes.spells.spellbooks.${this.data.data.spellbook}`),
      isSpontaneous = spellbook.spontaneous,
      spellLevel = getProperty(this.data, "data.level");

    if (this.useSpellPoints()) {
      if (max) return getProperty(this.parent.data.data.attributes, "mp.max");
      return (getProperty(this.parent.data.data.attributes, "mp.value") + getProperty(this.parent.data.data.attributes, "mp.temp")); // added for temp mp
    } else {
      if (isSpontaneous) {
        if (getProperty(this.data, "data.preparation.spontaneousPrepared") === true) {
          if (max) return getProperty(spellbook, `spells.spell${spellLevel}.max`) || 0;
          return getProperty(spellbook, `spells.spell${spellLevel}.value`) || 0;
        }
      } else {
        if (max) return getProperty(this.data, "data.preparation.maxAmount") || 0;
        return getProperty(this.data, "data.preparation.preparedAmount") || 0;
      }
    }

    return 0;
  }

  static async toConsumable(origData, type) {
    let data = duplicate(game.system.template.Item.consumable);
    for (let t of data.templates) {
      mergeObject(data, duplicate(game.system.template.Item.templates[t]));
    }
    delete data.templates;
    data = {
      type: "consumable",
      name: origData.name,
      data: data,
    };

    const slcl = this.getMinimumCasterLevelBySpellData(origData.data);
    const materialPrice = getProperty(origData, "data.materials.gilValue") || 0;

    // Set consumable type
    data.data.consumableType = type;

    // Set range
    data.data.range.units = origData.data.range.units;
    data.data.range.value = origData.data.range.value;
    switch (data.data.range.units) {
      case "close":
        data.data.range.value = RollFFD20$1.safeRoll("25 + floor(@cl / 2) * 5", { cl: slcl[1] }).total.toString();
        data.data.range.units = "ft";
        break;
      case "medium":
        data.data.range.value = RollFFD20$1.safeRoll("100 + @cl * 10", { cl: slcl[1] }).total.toString();
        data.data.range.units = "ft";
        break;
      case "long":
        data.data.range.value = RollFFD20$1.safeRoll("400 + @cl * 40", { cl: slcl[1] }).total.toString();
        data.data.range.units = "ft";
        break;
    }

    // Set name
    if (type === "wand") {
      data.name = game.i18n.localize("FFD20.CreateItemWandOf").format(origData.name);
      data.img = "systems/ffd20/icons/items/inventory/wand-star.jpg";
      data.data.price = Math.max(0.5, slcl[0]) * slcl[1] * 750 + materialPrice * 50;
      data.data.hardness = 5;
      data.data.hp.max = 5;
      data.data.hp.value = 5;
    } else if (type === "potion") {
      data.name = game.i18n.localize("FFD20.CreateItemPotionOf").format(origData.name);
      data.img = "systems/ffd20/icons/items/potions/minor-blue.jpg";
      data.data.price = Math.max(0.5, slcl[0]) * slcl[1] * 50 + materialPrice;
      data.data.hardness = 1;
      data.data.hp.max = 1;
      data.data.hp.value = 1;
      data.data.range.value = 0;
      data.data.range.units = "personal";
    } else if (type === "scroll") {
      data.name = game.i18n.localize("FFD20.CreateItemScrollOf").format(origData.name);
      data.img = "systems/ffd20/icons/items/inventory/scroll-magic.jpg";
      data.data.price = Math.max(0.5, slcl[0]) * slcl[1] * 25 + materialPrice;
      data.data.hardness = 0;
      data.data.hp.max = 1;
      data.data.hp.value = 1;
    }

    // Set charges
    if (type === "wand") {
      data.data.uses.maxFormula = "50";
      data.data.uses.value = 50;
      data.data.uses.max = 50;
      data.data.uses.per = "charges";
    } else {
      data.data.uses.per = "single";
    }

    // Set activation method
    data.data.activation.type = "standard";

    // Set measure template
    if (type !== "potion") {
      data.data.measureTemplate = getProperty(origData, "data.measureTemplate");
    }

    // Set damage formula
    data.data.actionType = origData.data.actionType;
    for (let d of getProperty(origData, "data.damage.parts")) {
      d[0] = d[0].replace(/@sl/g, slcl[0]);
      d[0] = d[0].replace(/@cl/g, "@item.cl");
      data.data.damage.parts.push(d);
    }

    // Set saves
    data.data.save.description = origData.data.save.description;
    data.data.save.dc = 10 + slcl[0] + Math.floor(slcl[0] / 2) + "";

    // Copy variables
    data.data.attackNotes = origData.data.attackNotes;
    data.data.effectNotes = origData.data.effectNotes;
    data.data.attackBonus = origData.data.attackBonus;
    data.data.critConfirmBonus = origData.data.critConfirmBonus;
    data.data.aura.school = origData.data.school;

    // Set Caster Level
    data.data.cl = slcl[1];

    // Set description
    data.data.description.value = await renderTemplate("systems/ffd20/templates/internal/consumable-description.hbs", {
      origData: origData,
      data: data,
      isWand: type === "wand",
      isPotion: type === "potion",
      isScroll: type === "scroll",
      sl: slcl[0],
      cl: slcl[1],
      config: CONFIG.FFD20,
    });

    return data;
  }

  /**
   * @param {object} itemData - A spell item's data.
   * @returns {number[]} An array containing the spell level and caster level.
   */
  static getMinimumCasterLevelBySpellData(itemData) {
    const learnedAt = getProperty(itemData, "learnedAt.class").reduce((cur, o) => {
      const classes = o[0].split("/");
      for (let cls of classes) cur.push([cls, o[1]]);
      return cur;
    }, []);
    let result = [9, 20];
    for (let o of learnedAt) {
      result[0] = Math.min(result[0], o[1]);

      const tc = CONFIG.FFD20.classCasterType[o[0]] || "high";
      if (tc === "high") {
        result[1] = Math.min(result[1], 1 + Math.max(0, o[1] - 1) * 2);
      } else if (tc === "med") {
        result[1] = Math.min(result[1], 1 + Math.max(0, o[1] - 1) * 3);
      } else if (tc === "low") {
        result[1] = Math.min(result[1], 4 + Math.max(0, o[1] - 1) * 3);
      }
    }

    return result;
  }

  async _onLevelChange(curLevel, newLevel) {
    if (!this.parent) return;

    // Add items associated to this class
    if (newLevel > curLevel) {
      const classAssociations = (getProperty(this.data, "data.links.classAssociations") || []).filter((o, index) => {
        o.__index = index;
        return o.level > curLevel && o.level <= newLevel;
      });

      let newItems = [];
      for (let co of classAssociations) {
        const collection = co.id.split(".").slice(0, 2).join(".");
        const itemId = co.id.split(".")[2];
        const pack = game.packs.get(collection);
        const item = await pack.getDocument(itemId);

        const itemData = duplicate(item.data);

        // Set temporary flag
        setProperty(itemData, "flags.ffd20.__co", duplicate(co));

        delete itemData._id;
        newItems.push({ data: itemData, co: co });
      }

      if (newItems.length) {
        const items = await CONFIG.Item.documentClass.create(
          newItems.map((o) => o.data),
          { parent: this.parentActor }
        );

        let updateData = [];
        const classUpdateData = { _id: this.data._id };
        updateData.push(classUpdateData);
        for (let i of items) {
          const co = i.getFlag("ffd20", "__co");
          // Set class association flags
          classUpdateData[`flags.ffd20.links.classAssociations.${i.id}`] = co.level;
          // Remove temporary flag
          updateData.push({ _id: i.data._id, "flags.ffd20.-=__co": null });
        }
        if (updateData.length) {
          await this.parentActor.refresh();
          await CONFIG.Item.documentClass.updateDocuments(updateData, { parent: this.parentActor });
        }
      }
      // const newItemData = await ItemFFD20.create(itemData, { parent: this.parent });
      // const newItem = this.parent.items.find((o) => o.id === newItemData.id);

      // // await this.setFlag("ffd20", `links.classAssociations.${newItemData._id}`, co.level);
      // selfUpdateData[`flags.ffd20.links.classAssociations.${newItemData.id}`] = co.level;
      // await this.createItemLink("children", "data", newItem, newItem.id);
      // }
    }

    // Remove items associated to this class
    if (newLevel < curLevel) {
      let associations = duplicate(this.getFlag("ffd20", "links.classAssociations") || {});
      let itemIds = [];
      for (let [id, level] of Object.entries(associations)) {
        const item = this.parent.items.find((o) => o.id === id);
        if (!item) {
          delete associations[id];
          continue;
        }

        if (level > newLevel) {
          itemIds.push(item.id);
          delete associations[id];
        }
      }
      await this.setFlag("ffd20", "links.classAssociations", associations);
      await CONFIG.Item.documentClass.deleteDocuments(itemIds, { parent: this.parent });
    }

    // Call level change hook
    Hooks.call("ffd20.classLevelChange", this.actor, this, curLevel, newLevel);
  }

  /**
   * @param {string} linkType - The type of link.
   * @param {string} dataType - Either "compendium", "data" or "world".
   * @param {object} targetItem - The target item to link to.
   * @param {string} itemLink - The link identifier for the item.
   * @returns {boolean} Whether a link to the item is possible here.
   */
  canCreateItemLink(linkType, dataType, targetItem, itemLink) {
    const actor = this.parent;
    const sameActor = actor && targetItem.actor && targetItem.actor.id === actor.id;

    // Don't create link to self
    const itemId = itemLink.split(".").slice(-1)[0];
    if (itemId === this.id) return false;

    // Don't create existing links
    const links = getProperty(this.data, `data.links.${linkType}`) || [];
    if (links.filter((o) => o.id === itemLink).length) return false;

    const targetLinks = getProperty(targetItem.data, `data.links.${linkType}`);
    if (["children", "charges", "ammunition"].includes(linkType) && sameActor) {
      if (linkType === "charges") {
        // Prevent the closing of charge link loops
        if (targetLinks.length > 0) {
          ui.notifications.warn(
            game.i18n.localize("FFD20.WarningCannotCreateChargeLink").format(this.name, targetItem.name)
          );
          return false;
        } else if (targetItem.links.charges != null) {
          // Prevent the linking of one item to multiple resource pools
          ui.notifications.warn(
            game.i18n
              .localize("FFD20.WarningCannotCreateChargeLink2")
              .format(this.name, targetItem.name, targetItem.links.charges.name)
          );
          return false;
        }
      }
      return true;
    }

    if (linkType === "classAssociations" && dataType === "compendium") return true;

    return false;
  }

  /**
   * @param {string} linkType - The type of link.
   * @param {string} dataType - Either "compendium", "data" or "world".
   * @param {object} targetItem - The target item to link to.
   * @param {string} itemLink - The link identifier for the item.
   * @returns {Array} An array to insert into this item's link data.
   */
  generateInitialLinkData(linkType, dataType, targetItem, itemLink) {
    const result = {
      id: itemLink,
      dataType: dataType,
      name: targetItem.name,
      img: targetItem.data.img,
      hiddenLinks: {},
    };

    if (linkType === "classAssociations") {
      result.level = 1;
    }

    if (linkType === "ammunition") {
      result.recoverChance = 50;
    }

    return result;
  }

  /**
   * Creates a link to another item.
   *
   * @param {string} linkType - The type of link.
   * e.g. "children", "charges", "classAssociations" or "ammunition".
   * @param {string} dataType - Either "compendium", "data" or "world".
   * @param {object} targetItem - The target item to link to.
   * @param {string} itemLink - The link identifier for the item.
   * e.g. "world.NExqvEMCMbDuDxv5" (world item), "ffd20.feats.NExqvEMCMbDuDxv5" (compendium item) or
   * "NExqvEMCMbDuDxv5" (item on same actor)
   * @returns {boolean} Whether a link was created.
   */
  async createItemLink(linkType, dataType, targetItem, itemLink) {
    if (this.canCreateItemLink(linkType, dataType, targetItem, itemLink)) {
      const updateData = {};
      let _links = duplicate(getProperty(this.data, `data.links.${linkType}`) || []);
      const link = this.generateInitialLinkData(linkType, dataType, targetItem, itemLink);
      _links.push(link);
      updateData[`data.links.${linkType}`] = _links;

      // Call link creation hook
      await this.update(updateData);
      Hooks.callAll("createItemLink", this, link, linkType);

      /**
       * @TODO This is a really shitty way of re-rendering the actor sheet, so I should change this method at some point,
       * but the premise is that the actor sheet should show data for newly linked items, and it won't do it immediately for some reason
       */
      window.setTimeout(() => {
        if (this.parent) this.parent.sheet.render();
      }, 50);

      return true;
    } else if (linkType === "children" && dataType !== "data") {
      const itemData = duplicate(targetItem.data);
      delete itemData._id;

      // Default to spell-like tab until a selector is designed in the Links tab or elsewhere
      if (getProperty(itemData, "type") === "spell") setProperty(itemData, "data.spellbook", "spelllike");

      const newItemData = await this.parent.createOwnedItem(itemData);
      const newItem = this.parent.items.get(newItemData._id);

      await this.createItemLink("children", "data", newItem, newItem._id);
    }

    return false;
  }

  async getLinkedItems(type, extraData = false) {
    const items = getProperty(this.data, `data.links.${type}`);
    if (!items) return [];

    let result = [];
    for (let l of items) {
      let item = await this.getLinkItem(l, extraData);
      if (item) result.push(item);
    }

    return result;
  }

  async getAllLinkedItems() {
    let result = [];

    for (let items of Object.values(getProperty(this.data, "data.links"))) {
      for (let l of items) {
        let item = await this.getLinkItem(l);
        if (item) result.push(item);
      }
    }

    return result;
  }

  /**
   * Removes all link references to an item.
   *
   * @param {string} id - The id of the item to remove links to.
   */
  async removeItemLink(id) {
    const updateData = {};
    for (let [k, linkItems] of Object.entries(getProperty(this.data, "data.links") || {})) {
      let items = duplicate(linkItems);
      for (let a = 0; a < items.length; a++) {
        let item = items[a];
        if (item.id === id) {
          items.splice(a, 1);
          a--;
        }
      }

      if (linkItems.length > items.length) {
        updateData[`data.links.${k}`] = items;
      }
    }

    if (Object.keys(updateData).length) {
      return this.update(updateData);
    }
  }

  async getLinkItem(l, extraData = false) {
    const id = l.id.split(".");
    let item;

    // Compendium entry
    if (l.dataType === "compendium") {
      const pack = game.packs.get(id.slice(0, 2).join("."));
      if (!pack) return null;
      item = await pack.getDocument(id[2]);
    }
    // World entry
    else if (l.dataType === "world") {
      item = game.items.get(id[1]);
    }
    // Same actor's item
    else if (this.parent != null && this.parent.items != null) {
      item = this.parent.items.find((o) => o.id === id[0]);
    }

    // Package extra data
    if (extraData) {
      item = { item: item, linkData: l };
    }

    return item;
  }

  async updateLinkItems() {
    // Update link items
    const linkGroups = getProperty(this.data, "data.links") || {};
    for (let links of Object.values(linkGroups)) {
      for (let l of links) {
        const i = await this.getLinkItem(l);
        if (i == null) {
          l.name = l.name + (l.name?.indexOf("[x]") > -1 ? "" : " [x]");
          l.img = CONST.DEFAULT_TOKEN;
          continue;
        }
        l.name = i.name;
        l.img = i.img;
      }
    }
  }

  _cleanLink(oldLink, linkType) {
    if (!this.parent) return;

    const otherItem = this.parent.items.find((o) => o.id === oldLink.id);
    if (linkType === "charges" && otherItem && hasProperty(otherItem, "links.charges")) {
      delete otherItem.links.charges;
    }
  }

  /**
   * Generates lists of change subtargets this item can have.
   *
   * @param {string} target - The target key, as defined in CONFIG.FFD20.buffTargets.
   * @returns {object.<string, string>} A list of changes
   */
  getChangeSubTargets(target) {
    let result = {};
    // Add specific skills
    if (target === "skill") {
      if (this.parent == null) {
        for (let [s, skl] of Object.entries(CONFIG.FFD20.skills)) {
          result[`skill.${s}`] = skl;
        }
      } else {
        const actorSkills = mergeObject(duplicate(CONFIG.FFD20.skills), this.parent.data.data.skills);
        for (let [s, skl] of Object.entries(actorSkills)) {
          if (!skl.subSkills) {
            if (skl.custom) result[`skill.${s}`] = skl.name;
            else result[`skill.${s}`] = CONFIG.FFD20.skills[s];
          } else {
            for (let [s2, skl2] of Object.entries(skl.subSkills)) {
              result[`skill.${s}.subSkills.${s2}`] = `${CONFIG.FFD20.skills[s]} (${skl2.name})`;
            }
          }
        }
      }
    }
    // Add static subtargets
    else if (hasProperty(CONFIG.FFD20.buffTargets, target)) {
      for (let [k, v] of Object.entries(CONFIG.FFD20.buffTargets[target])) {
        if (!k.startsWith("_") && !k.startsWith("~")) result[k] = v;
      }
    }

    return result;
  }

  /**
   * Generates a list of targets this modifier can have.
   *
   * @param {ItemFFD20} item - The item for which the modifier is to be created.
   * @returns {object.<string, string>} A list of targets
   */
  getConditionalTargets() {
    let result = {};
    if (this.hasAttack) result["attack"] = game.i18n.localize(CONFIG.FFD20.conditionalTargets.attack._label);
    if (this.hasDamage) result["damage"] = game.i18n.localize(CONFIG.FFD20.conditionalTargets.damage._label);
    if (this.type === "attack") {
      result["size"] = game.i18n.localize(CONFIG.FFD20.conditionalTargets.size._label);
    }
    if (this.type === "spell" || this.hasSave)
      result["effect"] = game.i18n.localize(CONFIG.FFD20.conditionalTargets.effect._label);
    // Only add Misc target if subTargets are available
    if (Object.keys(this.getConditionalSubTargets("misc")).length > 0) {
      result["misc"] = game.i18n.localize(CONFIG.FFD20.conditionalTargets.misc._label);
    }
    return result;
  }

  /**
   * Generates lists of conditional subtargets this attack can have.
   *
   * @param {string} target - The target key, as defined in CONFIG.FFD20.conditionTargets.
   * @returns {object.<string, string>} A list of conditionals
   */
  getConditionalSubTargets(target) {
    let result = {};
    // Add static targets
    if (hasProperty(CONFIG.FFD20.conditionalTargets, target)) {
      for (let [k, v] of Object.entries(CONFIG.FFD20.conditionalTargets[target])) {
        if (!k.startsWith("_") && !k.startsWith("~")) result[k] = v;
      }
    }
    // Add subtargets depending on attacks
    if (["attack", "damage"].includes(target)) {
      // Add specific attacks
      if (this.hasAttack) {
        result["attack.0"] = `${game.i18n.localize("FFD20.Attack")} 1`;
      } else {
        delete result["rapidShotDamage"];
      }
      if (this.hasMultiAttack) {
        for (let [k, v] of Object.entries(this.data.data.attackParts)) {
          result[`attack.${Number(k) + 1}`] = v[1];
        }
      }
    }
    // Add subtargets affecting effects
    if (target === "effect") {
      if (this.data.type === "spell") result["cl"] = game.i18n.localize("FFD20.CasterLevel");
      if (this.hasSave) result["dc"] = game.i18n.localize("FFD20.DC");
    }
    // Add misc subtargets
    if (target === "misc") {
      // Add charges subTarget with specific label
      if (this.type === "spell" && this.useSpellPoints()) result["charges"] = game.i18n.localize("FFD20.SpellPointsCost");
      else if (this.isCharged && this.type !== "spell") result["charges"] = game.i18n.localize("FFD20.ChargeCost");
    }
    return result;
  }

  /* Generates lists of conditional modifier bonus types applicable to a formula.
   * @param {string} target - The target key as defined in CONFIG.FFD20.conditionTargets.
   * @returns {Object.<string, string>} A list of bonus types.
   * */
  getConditionalModifierTypes(target) {
    let result = {};
    if (target === "attack" || target === "damage") {
      // Add bonusModifiers from CONFIG.FFD20.bonusModifiers
      for (let [k, v] of Object.entries(CONFIG.FFD20.bonusModifiers)) {
        result[k] = v;
      }
    }
    if (target === "damage") {
      for (let [k, v] of Object.entries(CONFIG.FFD20.damageTypes)) {
        result[k] = v;
      }
    }
    return result;
  }

  /* Generates a list of critical applications for a given formula target.
   * @param {string} target - The target key as defined in CONFIG.FFD20.conditionalTargets.
   * @returns {Object.<string, string>} A list of critical applications.
   * */
  getConditionalCritical(target) {
    let result = {};
    // Attack bonuses can only apply as critical confirm bonus
    if (target === "attack") {
      result = { ...result, normal: "FFD20.Normal", crit: "FFD20.CriticalConfirmBonus" };
    }
    // Damage bonuses can be multiplied or not
    if (target === "damage") {
      result = { ...result, normal: "FFD20.Normal" };
      if (this.hasAttack) {
        result = { ...result, crit: "FFD20.CritDamageBonusFormula", nonCrit: "FFD20.NonCritDamageBonusFormula" };
      }
    }
    return result;
  }

  async addChange() {
    const change = new ItemChange({}, this);
    return change;
  }

  async createContainerContent(data, options = { raw: false }) {
    let embeddedName = "Item";
    const user = game.user;
    const itemOptions = { temporary: false, renderSheet: false };

    let inventory = duplicate(getProperty(this.data, "data.inventoryItems") || []);
    // Iterate over data to create
    data = data instanceof Array ? data : [data];
    if (!(itemOptions.temporary || itemOptions.noHook)) {
      for (let d of data) {
        const allowed = Hooks.call(`preCreate${embeddedName}`, this, d, itemOptions, user.id);
        if (allowed === false) {
          console.debug(`${vtt} | ${embeddedName} creation prevented by preCreate hook`);
          return null;
        }

        d._id = randomID(16);
      }
    }

    // Add to updates
    const items = data.map((o) => {
      if (!options.raw) {
        let template = duplicate(game.system.template.Item[o.type]);
        if (template.templates instanceof Array) {
          template.templates.forEach((t) => {
            template = mergeObject(template, game.system.template.Item.templates[t]);
          });
        }
        delete template.templates;

        o.data = mergeObject(template, o.data || {});
      }

      return o;
    });
    inventory.push(...items);

    // Filter items with duplicate _id
    {
      let ids = [];
      inventory = inventory.filter((i) => {
        if (ids.includes(i._id)) return false;
        ids.push(i._id);
        return true;
      });
    }

    await this.update({ "data.inventoryItems": inventory });
  }

  getContainerContent(itemId) {
    return this.items.get(itemId);
  }

  async deleteContainerContent(data) {
    let embeddedName = "ContainerContent";
    const user = game.user;
    const options = { noHook: false };

    // Iterate over data to create
    data = data instanceof Array ? data : [data];
    const ids = new Set(data);

    // Iterate over elements of the collection
    const inventory = duplicate(getProperty(this.data, "data.inventoryItems") || []).filter((d) => {
      if (!ids.has(d._id)) return true;

      // Call pre-update hooks to ensure the update is allowed to proceed
      if (!options.noHook) {
        const allowed = Hooks.call(`preDelete${embeddedName}`, this, d, options, user.id);
        if (allowed === false) {
          console.debug(`${vtt} | ${embeddedName} update prevented by preUpdate hook`);
          return true;
        }
      }

      // Remove entity from collection
      return false;
    }, []);

    // Trigger the Socket workflow
    await this.update({ "data.inventoryItems": inventory });
  }

  async updateContainerContents(data) {
    let embeddedName = "ContainerContent";
    const user = game.user;
    const options = { diff: true };

    // Structure the update data
    const pending = new Map();
    data = data instanceof Array ? data : [data];
    for (let d of data) {
      if (!d._id) throw new Error("You must provide an id for every Embedded Entity in an update operation");
      pending.set(d._id, d);
    }

    // Difference each update against existing data
    const updates = this.items.reduce((arr, d) => {
      if (!pending.has(d.id)) return arr;
      let update = pending.get(d.id);

      // Diff the update against current data
      if (options.diff) {
        update = diffObject(d.data, expandObject(update));
        if (isObjectEmpty(update)) return arr;
        update["_id"] = d.id;
      }

      // Call pre-update hooks to ensure the update is allowed to proceed
      if (!options.noHook) {
        const allowed = Hooks.call(`preUpdate${embeddedName}`, this, d, update, options, user.id);
        if (allowed === false) {
          console.debug(`${vtt} | ${embeddedName} update prevented by preUpdate hook`);
          return arr;
        }
      }

      // Stage the update
      arr.push(update);
      return arr;
    }, []);
    if (!updates.length) return [];
    let inventory = duplicate(this.data.data.inventoryItems).map((o) => {
      for (let u of updates) {
        if (u._id === o._id) return mergeObject(o, u);
      }
      return o;
    });

    // Filter items with duplicate _id
    {
      let ids = [];
      inventory = inventory.filter((i) => {
        if (ids.includes(i._id)) return false;
        ids.push(i._id);
        return true;
      });
    }

    await this.update({ "data.inventoryItems": inventory });
  }

  /**
   * @returns {number} The total amount of currency this item contains, in gil pieces
   */
  getTotalCurrency() {
    const currencies = getProperty(this.data, "data.currency");
    if (!currencies) return 0;
    return (currencies.pgil * 1000 + currencies.gil * 100 + currencies.sgil * 10 + currencies.cgil) / 100;
  }

  getValue({ recursive = true, sellValue = 0.5 } = {}) {
    // Add item's contained currencies
    let result = this.getTotalCurrency();

    // Add item's price
    if (this.showUnidentifiedData)
      result +=
        (getProperty(this.data, "data.unidentified.price") || 0) * (getProperty(this.data, "data.quantity") || 0);
    else result += (getProperty(this.data, "data.price") || 0) * (getProperty(this.data, "data.quantity") || 0);

    // Modify sell value
    if (!(this.data.type === "loot" && this.data.data.subType === "tradeGoods")) result *= sellValue;

    if (!this.items || !recursive) return result;

    // Add item's content items' values
    this.items.forEach((i) => {
      result += i.getValue({ recursive: recursive, sellValue: sellValue });
    });

    return result;
  }

  /**
   * Converts currencies of the given category to the given currency type
   *
   * @param {string} type - Either 'pgil', 'ggil', 'sgil' or 'cgil'. Converts as much currency as possible to this type.
   */
  convertCurrency(type = "pgil") {
    const totalValue = this.getTotalCurrency();
    let values = [0, 0, 0, 0];
    switch (type) {
      case "pgil":
        values[0] = Math.floor(totalValue / 10);
        values[1] = Math.max(0, Math.floor(totalValue) - values[0] * 10);
        values[2] = Math.max(0, Math.floor(totalValue * 10) - values[0] * 100 - values[1] * 10);
        values[3] = Math.max(0, Math.floor(totalValue * 100) - values[0] * 1000 - values[1] * 100 - values[2] * 10);
        break;
      case "gil":
        values[1] = Math.floor(totalValue);
        values[2] = Math.max(0, Math.floor(totalValue * 10) - values[1] * 10);
        values[3] = Math.max(0, Math.floor(totalValue * 100) - values[1] * 100 - values[2] * 10);
        break;
      case "sgil":
        values[2] = Math.floor(totalValue * 10);
        values[3] = Math.max(0, Math.floor(totalValue * 100) - values[2] * 10);
        break;
      case "cgil":
        values[3] = Math.floor(totalValue * 100);
        break;
    }

    const updateData = {};
    updateData[`data.currency.pgil`] = values[0];
    updateData[`data.currency.gil`] = values[1];
    updateData[`data.currency.sgil`] = values[2];
    updateData[`data.currency.cgil`] = values[3];
    return this.update(updateData);
  }

  _calculateCoinWeight(data) {
    const coinWeightDivisor = game.settings.get("ffd20", "coinWeight");
    if (!coinWeightDivisor) return 0;
    return (
      Object.values(getProperty(data, "data.currency") || {}).reduce((cur, amount) => {
        return cur + amount;
      }, 0) / coinWeightDivisor
    );
  }

  async delete(context = {}) {
    if (this.data.type === "class") {
      await this._onLevelChange(this.data.data.level, 0);
    }

    return super.delete(context);
  }
  /**
   * Sets a boolean flag on this item.
   *
   * @param {string} flagName - The name/key of the flag to set.
   * @returns {Promise<boolean>} Whether something was changed.
   */
  async addItemBooleanFlag(flagName) {
    let flags = getProperty(this.data, "data.flags.boolean") || [];

    if (flags.filter((f) => f[0] === flagName).length === 0) {
      await this.update({ "data.flags.boolean": flags.concat([[flagName]]) });
      return true;
    }

    return false;
  }

  /**
   * Removes a boolean flag from this item.
   *
   * @param {string} flagName - The name/key of the flag to remove.
   * @returns {Promise<boolean>} Whether something was changed.
   */
  async removeItemBooleanFlag(flagName) {
    let flags = getProperty(this.data, "data.flags.boolean") || [];

    if (flags.filter((f) => f[0] === flagName).length > 0) {
      flags = flags.filter((f) => f[0] !== flagName);
      await this.update({ "data.flags.boolean": flags });
      return true;
    }

    return false;
  }

  /**
   * @param {string} flagName - The name/key of the flag on this item.
   * @returns {boolean} Whether the flag was found on this item.
   */
  hasItemBooleanFlag(flagName) {
    const flags = getProperty(this.data, "data.flags.boolean") || [];

    return flags.map((f) => f[0]).includes(flagName);
  }

  /**
   * Sets a dictionary flag value on this item.
   *
   * @param {string} flagName - The name/key of the flag to set.
   * @param {number|string} value - The flag's new value.
   * @returns {Promise<boolean>} Whether something was changed.
   */
  async setItemDictionaryFlag(flagName, value) {
    let flags = duplicate(getProperty(this.data, "data.flags.dictionary") || []);

    let doUpdate = false;
    let foundFlag = false;
    for (let f of flags) {
      if (f[0] === flagName) {
        foundFlag = true;
        if (f[1] !== value) {
          f[1] = value;
          doUpdate = true;
        }
      }
    }
    if (!foundFlag) {
      flags.push([flagName, value]);
      doUpdate = true;
    }

    if (doUpdate) {
      await this.update({ "data.flags.dictionary": flags });
      return true;
    }

    return false;
  }

  /**
   * Removes a dictionary flag from this item.
   *
   * @param {string} flagName - The name/key of the flag to remove.
   * @returns {Promise<boolean>} Whether something was changed.
   */
  async removeItemDictionaryFlag(flagName) {
    let flags = duplicate(getProperty(this.data, "data.flags.dictionary") || []);

    let doUpdate = false;
    for (let a = 0; a < flags.length; a++) {
      let f = flags[a];
      if (f[0] === flagName) {
        flags.splice(a, 1);
        a--;
        doUpdate = true;
      }
    }

    if (doUpdate) {
      await this.update({ "data.flags.dictionary": flags });
      return true;
    }

    return false;
  }

  /**
   * @param {string} flagName - The name/key of the flag to get.
   * @returns {object} The value stored in the flag.
   */
  getItemDictionaryFlag(flagName) {
    const flags = getProperty(this.data, "data.flags.dictionary") || [];

    const flag = flags.find((f) => {
      return f[0] === flagName;
    });
    return flag ? flag[1] : undefined;
  }

  /**
   * @returns {number[]} Simple array describing the individual guaranteed attacks.
   */
  get attackArray() {
    const itemData = this.data.data,
      rollData = this.getRollData(),
      attacks = [0];

    const appendAttack = (formula) => {
      const bonus = RollFFD20$1.safeRoll(formula, rollData).total;
      if (Number.isFinite(bonus)) attacks.push(bonus);
    };

    // Static extra attacks
    const extraAttacks = itemData.attackParts.map((n) => n[0]?.toString().trim()).filter((n) => n?.length > 0);
    for (let formula of extraAttacks) appendAttack(formula);

    // Formula-based extra attacks
    const fmAtk = itemData.formulaicAttacks?.count?.formula?.trim();
    if (fmAtk?.length > 0) {
      const fmAtkBonus = itemData.formulaicAttacks?.bonus?.formula?.trim() ?? "0";
      const count = RollFFD20$1.safeRoll(fmAtk, rollData);
      for (let i = 0; i < count.total; i++) {
        rollData.formulaicAttack = i + 1;
        appendAttack(fmAtkBonus);
      }
    }

    // Conditional modifiers
    const condBonuses = new Array(attacks.length).fill(0);
    itemData.conditionals
      .filter((c) => c.default && c.modifiers.find((sc) => sc.target === "attack"))
      .forEach((c) => {
        c.modifiers.forEach((cc) => {
          const bonusRoll = RollFFD20$1.safeRoll(cc.formula, rollData);
          if (bonusRoll.total == 0) return;
          if (cc.subTarget?.match(/^attack\.(\d+)$/)) {
            const atk = parseInt(RegExp.$1, 10);
            if (atk in condBonuses) condBonuses[atk] += bonusRoll.total;
          }
        });
      });

    const sources = this.attackSources;
    const totalBonus = sources.reduce((f, s) => f + s.value, 0);

    return attacks.map((a, i) => a + totalBonus + condBonuses[i]);
  }

  /**
   * @returns {object[]} Array of value and label pairs for attack bonus sources on the main attack.
   */
  get attackSources() {
    const sources = [];

    const actorData = this.parentActor?.data.data,
      itemData = this.data.data;

    if (!actorData) return sources;
    const rollData = this.getRollData();

    // Attack type identification
    const isMelee =
      ["mwak", "msak", "mcman"].includes(this.data.data.actionType) ||
      ["melee", "reach"].includes(this.data.data.range.units);
    const isRanged =
      ["rwak", "rsak", "rcman"].includes(this.data.data.actionType) || this.data.data.weaponSubtype === "ranged";
    const isManeuver = ["mcman", "rcman"].includes(this.data.data.actionType);

    const describePart = (value, label, sort = 0) => {
      sources.push({ value, label, sort });
    };

    // BAB is last for some reason, array is reversed to try make it the first.
    const srcDetails = (s) => s?.reverse().forEach((d) => describePart(d.value, d.name, -10));

    // Unreliable melee/ranged identification
    const sizeBonus = !isManeuver
      ? CONFIG.FFD20.sizeMods[rollData.traits.size]
      : CONFIG.FFD20.sizeSpecialMods[rollData.traits.size];

    // Add size bonus
    if (sizeBonus != 0) describePart(sizeBonus, game.i18n.localize("FFD20.Size"), -20);

    srcDetails(this.parentActor.sourceDetails["data.attributes.attack.shared"]);
    if (isManeuver) srcDetails(this.parentActor.sourceDetails["data.attributes.cmb.total"]);
    srcDetails(this.parentActor.sourceDetails["data.attributes.attack.general"]);

    const changeSources = ["attack"];
    if (isRanged) changeSources.push("rattack");
    if (isMelee) changeSources.push("mattack");
    const effectiveChanges = getHighestChanges(
      this.parentActor.changes.filter((c) => changeSources.includes(c.subTarget)),
      { ignoreTarget: true }
    );
    effectiveChanges.forEach((ic) => describePart(ic.value, ic.flavor, -800));

    if (itemData.ability.attack) {
      const ablMod = getProperty(actorData, `abilities.${itemData.ability.attack}.mod`) ?? 0;
      describePart(ablMod, CONFIG.FFD20.abilities[itemData.ability.attack], -50);
    }

    // Attack bonus formula
    const bonusRoll = RollFFD20$1.safeRoll(itemData.attackBonus ?? "0", rollData);
    if (bonusRoll.total != 0)
      describePart(bonusRoll.total, bonusRoll.flavor ?? game.i18n.localize("FFD20.AttackRollBonus"), -100);

    // Masterwork or enhancement bonus
    // Only add them if there's no larger enhancement bonus from some other source
    const virtualEnh = itemData.enh ?? (itemData.masterwork ? 1 : 0);
    if (!effectiveChanges.find((i) => i.modifier === "enh" && i.value > virtualEnh)) {
      if (Number.isFinite(itemData.enh) && itemData.enh != 0) {
        describePart(itemData.enh, game.i18n.localize("FFD20.EnhancementBonus"), -300);
      } else if (itemData.masterwork) {
        describePart(1, game.i18n.localize("FFD20.Masterwork"), -300);
      }
    }

    // Add proficiency penalty
    if (!itemData.proficient) {
      describePart(-4, game.i18n.localize("FFD20.ProficiencyPenalty"), -500);
    }

    // Broken condition
    if (itemData.broken) {
      describePart(-2, game.i18n.localize("FFD20.Broken"), -500);
    }

    // Add secondary natural attack penalty
    if (!itemData.primaryAttack && itemData.attackType === "natural") {
      describePart(-5, game.i18n.localize("FFD20.SecondaryAttack"), -400);
    }

    // Conditional modifiers
    itemData.conditionals
      .filter((c) => c.default && c.modifiers.find((sc) => sc.target === "attack"))
      .forEach((c) => {
        c.modifiers.forEach((cc) => {
          if (cc.subTarget === "allAttack") {
            const bonusRoll = RollFFD20$1.safeRoll(cc.formula, rollData);
            if (bonusRoll.total == 0) return;
            describePart(bonusRoll.total, c.name, -5000);
          }
        });
      });

    return sources.sort((a, b) => b.sort - a.sort);
  }

  /**
   * Generic damage source retrieval
   */
  get damageSources() {
    const isSpell = ["msak", "rsak"].includes(this.data.data.actionType);
    const changes = this.getContextChanges(isSpell ? "sdamage" : "wdamage");
    const highest = getHighestChanges(changes, { ignoreTarget: true });
    return highest;
  }

  /**
   * Generic damage source retrieval, includes default conditionals
   */
  get allDamageSources() {
    const conds = this.data.data.conditionals
      .filter((c) => c.default)
      .filter((c) => c.modifiers.find((m) => m.target === "damage"));
    const rollData = this.getRollData();

    const mods = Object.keys(CONFIG.FFD20.bonusModifiers);

    // Turn relevant conditionals into structure accepted by getHighestChanges
    const fakeCondChanges = [];
    for (let c of conds) {
      for (let m of c.modifiers) {
        if (m.target !== "damage") continue;
        const roll = RollFFD20$1.safeRoll(m.formula, rollData);
        if (roll.err) continue;
        fakeCondChanges.push({
          flavor: c.name,
          value: roll.total,
          modifier: mods.includes(m.type) ? m.type : "untyped",
          formula: m.formula,
        });
      }
    }
    return getHighestChanges([...this.damageSources, ...fakeCondChanges], { ignoreTarget: true });
  }
}

/**
 * Creates a tag from a string.
 * For example, if you input the string "Wizard of Oz 2", you will get "wizardOfOz2"
 *
 * @param str
 */
const createTag = function (str) {
  if (str.length === 0) str = "tag";
  return str
    .replace(/[^a-zA-Z0-9\s]/g, "")
    .split(/\s+/)
    .map((s, a) => {
      s = s.toLowerCase();
      if (a > 0) s = s.substring(0, 1).toUpperCase() + s.substring(1);
      return s;
    })
    .join("");
};

/**
 * Creates tabs for a sheet object
 *
 * @param html
 * @param tabGroups
 * @param existingTabs
 */
const createTabs = function (html, tabGroups, existingTabs = null) {
  // Create recursive activation/callback function
  const _recursiveActivate = function (rtabs, tabName = null) {
    if (rtabs.__dormant) return;

    if (tabName == null) this._initialTab[rtabs.group] = rtabs.active;
    else {
      rtabs.activate(tabName);
      this._initialTab[rtabs.group] = tabName;
    }

    // Recursively activate tabs
    for (let subTab of rtabs.subTabs) {
      _recursiveActivate.call(this, subTab, subTab.active);
    }
  };

  // Recursively bind tabs
  const _recursiveBind = function (rtabs) {
    rtabs.bind(html[0]);

    if (html.find(`nav[data-group="${rtabs.group}"]`).length > 0) rtabs.__dormant = false;
    else rtabs.__dormant = true;

    for (let subTab of rtabs.subTabs) {
      _recursiveBind.call(this, subTab);
    }
  };

  // Create all tabs
  const _func = function (group, children, tabs = null) {
    let dormant = false;
    if (html.find(`nav[data-group="${group}"]`).length === 0) dormant = true;

    if (this._initialTab == null) this._initialTab = {};

    const subHtml = html.find(`.${group}-body > div[data-group="${group}"]`);
    const activeSubHtml = subHtml.filter(".active");
    const initial =
      this._initialTab[group] !== undefined
        ? this._initialTab[group]
        : activeSubHtml.length > 0
        ? activeSubHtml[0].dataset.tab
        : "";

    // Set up data for scroll position and active tab
    if (this._initialTab[group] === undefined) this._initialTab[group] = initial;

    // Determine tab type
    const tabsElem = html.find(`.tabs[data-group="${group}"]`)[0];
    let cls = TabsV2;
    if (tabsElem) {
      let type = tabsElem.dataset.tabsType;
      if (type === "list") {
        cls = ListTabs;
      }
    }

    // Create tabs object
    if (!tabs) {
      tabs = new cls({
        navSelector: `.tabs[data-group="${group}"]`,
        contentSelector: `.${group}-body`,
        initial,
        callback: (_, tabs) => {
          _recursiveActivate.call(this, tabs);
        },
      });
      tabs.__dormant = dormant;

      // Recursively create tabs
      tabs.group = group;
      tabs.subTabs = [];
      for (let [childKey, subChildren] of Object.entries(children)) {
        const childTabs = _func.call(this, childKey, subChildren);
        if (childTabs != null) {
          tabs.subTabs.push(childTabs);
          childTabs.parent = tabs;
        }
      }
    }

    _recursiveBind.call(this, tabs);
    return tabs;
  };

  for (const groupKey of Object.keys(tabGroups)) {
    return _func.call(this, groupKey, tabGroups[groupKey], existingTabs);
  }
};

const degtorad = function (degrees) {
  return (degrees * Math.PI) / 180;
};

const linkData = function (expanded, flattened, key, value) {
  setProperty(expanded, key, value);
  flattened[key] = value;
};

const getItemOwner = function (item) {
  if (item.actor) return item.actor;
  if (item._id) {
    return game.actors.contents.filter((o) => {
      return o.items.filter((i) => i._id === item._id).length > 0;
    })[0];
  }
  return null;
};

const CR = {
  fromString(value) {
    if (value === "1/8") return 0.125;
    if (value === "1/6") return 0.1625;
    if (value === "1/4") return 0.25;
    if (value === "1/3") return 0.3375;
    if (value === "1/2") return 0.5;
    return parseFloat(value);
  },

  fromNumber(value) {
    if (value === 0.125) return "1/8";
    if (value === 0.1625) return "1/6";
    if (value === 0.25) return "1/4";
    if (value === 0.3375) return "1/3";
    if (value === 0.5) return "1/2";
    if (!Number.isNumeric(value)) return "0";
    return value.toString();
  },
};

const sizeDieExt = function (origCount, origSides, targetSize = "M", initialSize = "M") {
  const _getSizeIndex = function (size) {
    if (typeof size === "string") return Object.values(CONFIG.FFD20.sizeChart).indexOf(size.toUpperCase());
    return size;
  };
  targetSize = _getSizeIndex(targetSize);
  initialSize = _getSizeIndex(initialSize);
  let skipWarning = false;

  // D10 special rule: https://paizo.com/paizo/faq/v5748nruor1fm#v5748eaic9t3f
  if (origCount > 1 && origSides === 10 && (origCount % 2 === 0 || origCount === 3)) {
    skipWarning = true;
    const d10Arr = [
      { orig: [2, 10], larger: [4, 8], smaller: [2, 8] },
      { orig: [3, 10], larger: [6, 8], smaller: [3, 8] },
      { orig: [4, 10], larger: [8, 8], smaller: [4, 8] },
      { orig: [6, 10], larger: [12, 8], smaller: [6, 8] },
      { orig: [8, 10], larger: [16, 8], smaller: [8, 8] },
    ];
    for (let v of d10Arr) {
      if (v.orig[0] === origCount && v.orig[1] === origSides) {
        if (targetSize < initialSize) {
          initialSize--;
          origCount = v.smaller[0];
          origSides = v.smaller[1];
        } else if (targetSize > initialSize) {
          initialSize++;
          origCount = v.larger[0];
          origSides = v.larger[1];
        }
      }
    }
  }

  // Get initial die type
  let mediumDie = `${origCount}d${origSides}`;
  let mediumDieMax = origCount * origSides;
  let c = duplicate(CONFIG.FFD20.sizeDie);
  {
    if (c.indexOf(mediumDie) === -1) {
      c = c.map((d) => {
        if (d.match(/^([0-9]+)d([0-9]+)$/)) {
          const dieCount = parseInt(RegExp.$1);
          const dieSides = parseInt(RegExp.$2);
          const dieMaxValue = dieCount * dieSides;

          if (dieMaxValue === mediumDieMax) return mediumDie;
        }

        return d;
      });
    }
  }

  // Pick an index from the chart
  let index = c.indexOf(mediumDie),
    formula = mediumDie;
  if (index >= 0) {
    const d6Index = c.indexOf("1d6");
    let d8Index = c.indexOf("1d8");
    if (d8Index === -1) d8Index = c.indexOf("2d4");
    let sizeOffset = initialSize - targetSize;
    let curSize = initialSize;

    // When decreasing in size (e.g. from medium to small)
    while (sizeOffset > 0) {
      if (curSize <= 4 || index <= d8Index) {
        index--;
        sizeOffset--;
        curSize--;
      } else {
        index -= 2;
        sizeOffset--;
        curSize--;
      }
    }
    // When increasing in size (e.g. from medium to large)
    while (sizeOffset < 0) {
      if (curSize <= 3 || index <= d6Index) {
        index++;
        sizeOffset++;
        curSize++;
      } else {
        index += 2;
        sizeOffset++;
        curSize++;
      }
    }

    index = Math.max(0, Math.min(c.length - 1, index));
    formula = c[index];
  }

  if (index === -1 && !skipWarning) {
    const msg = game.i18n.localize("FFD20.WarningNoSizeDie").format(mediumDie, formula);
    console.warn(msg);
    ui.notifications.warn(msg);
  }

  const result = formula.split("d");
  if (result.length === 1) {
    return [new NumericTerm({ number: parseInt(result[0]) })];
  }
  return [new Die({ number: parseInt(result[0]), faces: parseInt(result[1]) })];
};

const normalDie = function (origCount, origSides, crit = 1) {
  return [new Die({ number: origCount * crit, faces: origSides })];
};

const sizeReach = function (size = "M", reach = false, stature = "tall") {
  if (typeof size === "number") size = Object.values(CONFIG.FFD20.sizeChart)[size];
  size = Object.entries(CONFIG.FFD20.sizeChart).find((o) => o[1] === size)[0];

  return [new NumericTerm({ number: ActorFFD20.getReach(size, stature)[reach ? "reach" : "melee"] })];
};

const getActorFromId = function (id) {
  const speaker = ChatMessage.getSpeaker();
  let actor = null;
  if (id) {
    actor = game.actors.tokens[id];
    if (!actor) actor = game.actors.get(id);
  }
  if (speaker.token && !actor) actor = game.actors.tokens[speaker.token];
  if (!actor) actor = game.actors.get(speaker.actor);
  return actor;
};

/**
 * Converts feet to what the world is using as a measurement unit.
 *
 * @param {number} value - The value (in feet) to convert.
 * @param {string} type - The original type to convert from. Either 'ft' (feet, default) or 'mi' (miles, in which case the result is in km (metric))
 * @returns {Array.<number, string>} An array containing the converted value in index 0 and the new unit key in index 1 (for use in CONFIG.FFD20.measureUnits, for example)
 */
const convertDistance = function (value, type = "ft") {
  let system = game.settings.get("ffd20", "distanceUnits"); // override
  if (system === "default") system = game.settings.get("ffd20", "units");
  switch (system) {
    case "metric":
      switch (type) {
        case "mi":
          return [Math.round(value * 1.6 * 100) / 100, "km"];
        default:
          return [Math.round((value / 5) * 1.5 * 100) / 100, "m"];
      }
    default:
      return [value, type];
  }
};

/**
 * Converts lbs to what the world is using as a measurement unit.
 *
 * @param {number} value - The value (in lbs) to convert.
 * @returns {number} The converted value. In the case of the metric system, converts to kg.
 */
const convertWeight = function (value) {
  let system = game.settings.get("ffd20", "weightUnits"); // override
  if (system === "default") system = game.settings.get("ffd20", "units");
  switch (system) {
    case "metric":
      return Math.round((value / 2) * 100) / 100; // 1 kg is not exactly 2 lb but this conversion is officially used by Paizo/BBE
    default:
      return value;
  }
};

/**
 * Converts back to lbs from what the world is using as a measurement unit.
 *
 * @param {number} value - The value to convert back to lbs.
 * @returns {number} The converted value. In the case of the metric system, converts from kg.
 */
const convertWeightBack = function (value) {
  let system = game.settings.get("ffd20", "weightUnits"); // override
  if (system === "default") system = game.settings.get("ffd20", "units");
  switch (system) {
    case "metric":
      return Math.round(value * 2 * 100) / 100; // 1 kg is not exactly 2 lb but this conversion is officially used by Paizo/BBE
    default:
      return value;
  }
};

const naturalSort = function (arr, propertyKey = "") {
  return arr.sort((a, b) => {
    const propA = propertyKey ? getProperty(a, propertyKey) : a;
    const propB = propertyKey ? getProperty(b, propertyKey) : b;
    return new Intl.Collator(game.settings.get("core", "language"), { numeric: true }).compare(propA, propB);
  });
};

const createConsumableSpellDialog = function (itemData, { allowSpell = true } = {}) {
  return new Promise((resolve) => {
    const dialogData = {
      title: game.i18n.localize("FFD20.CreateItemForSpell").format(itemData.name),
      content: game.i18n.localize("FFD20.CreateItemForSpell").format(itemData.name),
      buttons: {
        potion: {
          icon: '<i class="fas fa-prescription-bottle"></i>',
          label: game.i18n.localize("FFD20.CreateItemPotion"),
          callback: () => resolve(createConsumableSpell(itemData, "potion")),
        },
        scroll: {
          icon: '<i class="fas fa-scroll"></i>',
          label: game.i18n.localize("FFD20.CreateItemScroll"),
          callback: () => resolve(createConsumableSpell(itemData, "scroll")),
        },
        wand: {
          icon: '<i class="fas fa-magic"></i>',
          label: game.i18n.localize("FFD20.CreateItemWand"),
          callback: () => resolve(createConsumableSpell(itemData, "wand")),
        },
        spell: {
          icon: '<i class="fas fa-hand-sparkles"></i>',
          label: game.i18n.localize("FFD20.ItemTypeSpell"),
          callback: () => resolve("spell"),
        },
      },
      close: () => {
        resolve(false);
      },
      default: "potion",
    };
    if (!allowSpell) delete dialogData.buttons.spell;
    new Dialog(dialogData, { classes: ["dialog", "ffd20", "create-consumable"] }).render(true);
  });
};

const createConsumableSpell = async function (itemData, type) {
  let data = await ItemFFD20.toConsumable(itemData, type);

  if (data._id) delete data._id;
  return data;
};

const adjustNumberByStringCommand = function (initialValue, cmdStr, maxValue = null) {
  let result = initialValue;

  if (cmdStr.match(/(\+|[=-]?-)([0-9]+)/)) {
    const operator = RegExp.$1;
    let value = parseInt(RegExp.$2);
    if (operator === "--" || operator === "=-") {
      result = -value;
    } else {
      if (operator === "-") value = -value;
      result = initialValue + value;
      if (maxValue) result = Math.min(result, maxValue);
    }
  } else if (cmdStr.match(/^[0-9]+$/)) {
    result = parseInt(cmdStr);
    if (maxValue) result = Math.min(result, maxValue);
  } else if (cmdStr === "") {
    result = 0;
  } else result = parseFloat(cmdStr);

  if (Number.isNaN(result)) result = initialValue;
  return result;
};

const colorToInt = function (color) {
  const rgb = color.rgb().color;
  let integer = ((Math.round(rgb[0]) & 0xff) << 16) + ((Math.round(rgb[1]) & 0xff) << 8) + (Math.round(rgb[2]) & 0xff);

  return integer;
};

/**
 * @typedef {object} BuffTargetItem
 * @property {string} [label] - The buff target's label.
 * @property {string} category - The buff target's category.
 * @property {string} [icon] - The URL to an icon.
 */
/**
 * Assembles an array of all possible buff targets.
 *
 * @param {ActorFFD20} [actor] - An actor for which to specifically get buff targets.
 * @param {string} [type] - Can be set to "contextNotes" to get context notes instead.
 * @returns {object.<string, BuffTargetItem>} The resulting array of buff targets.
 */
const getBuffTargets = function (actor, type = "buffs") {
  const buffTargets = duplicate(
    {
      buffs: CONFIG.FFD20.buffTargets,
      contextNotes: CONFIG.FFD20.contextNoteTargets,
    }[type]
  );

  // Append individual skills to buff targets
  if (actor) {
    for (let s of actor._skillTargets) {
      const sId = s.split(".").slice(1).join(".");
      const skill = actor.getSkillInfo(sId);
      buffTargets[s] = { label: skill.name, category: "skill" };
    }
  } else {
    for (let [k, v] of Object.entries(CONFIG.FFD20.skills)) {
      buffTargets[`skill.${k}`] = { label: v, category: "skill" };
    }
  }

  return buffTargets;
};

/**
 * @typedef {object} BuffTargetCategory
 * @property {string} label - The category's label.
 */
/**
 * Assembles an array of buff targets and their categories, ready to be inserted into a Widget_CategorizedItemPicker.
 *
 * @param {ActorFFD20} [actor] - An actor for which to specifically get buff targets.
 * @param {string} [type] - Can be set to "contextNotes" to get context notes instead.
 * @returns {Widget_CategorizedItemPicker~Category[]}
 */
const getBuffTargetDictionary = function (actor, type = "buffs") {
  const buffTargets = getBuffTargets(actor, type);

  // Assemble initial categories and items
  const targetCategories = duplicate(
    {
      buffs: CONFIG.FFD20.buffTargetCategories,
      contextNotes: CONFIG.FFD20.contextNoteCategories,
    }[type]
  );
  let categories = Object.entries(buffTargets).reduce((cur, o) => {
    const key = o[0];
    const label = o[1].label;
    const category = o[1].category;
    const icon = o[1].icon;

    if (!key.startsWith("~")) {
      cur[category] = cur[category] || {
        label: targetCategories[category].label,
        items: [],
      };
      cur[category].items.push({ key, label, icon });
    }
    return cur;
  }, {});

  // Turn result into a usable format, and sort
  categories = Object.entries(categories).reduce((cur, o) => {
    const key = o[0];
    const label = o[1].label;
    const items = o[1].items;
    cur.push({ key, label, items });
    return cur;
  }, []);
  categories = naturalSort(categories, "label");

  // Return result
  return categories;
};

/**
 * A locale-safe insertion sort of an Array of Objects, not in place. Ignores punctuation and capitalization.
 *
 * @template T
 * @param {Array.<T & {name: string}>} inputArr - Array to be sorted. Each element must have a name property set
 * @returns {T[]} - New sorted Array
 */
const sortArrayByName = function (inputArr) {
  let n = inputArr.length;
  inputArr = duplicate(inputArr).map((o) => {
    o.name = o.name.toLocaleLowerCase();
    return o;
  });
  for (let i = 1; i < n; i++) {
    let current = inputArr[i],
      j = i - 1,
      currentLower = current.name;
    while (j > -1 && currentLower.localeCompare(inputArr[j].name, undefined, { ignorePunctuation: true }) < 0) {
      inputArr[j + 1] = inputArr[j];
      j--;
    }
    inputArr[j + 1] = current;
  }
  return inputArr;
};

/**
 * A simple binary search to be used on sorted arrays
 *
 * @template T
 * @param {T[]} searchArr - Sorted Array to be searched
 * @param {T} el - Element to be compared to array values
 * @param {function(T, T): number} compare_fn - Comparison function to be apply el to every element in ar. Should return an positive/ negative integer or 0 if matching.
 * @returns {number} Index where search is found or negative index indicating where it would be inserted
 */
const binarySearch = function (searchArr, el, compare_fn) {
  var m = 0,
    n = searchArr.length - 1;
  while (m <= n) {
    var k = (n + m) >> 1,
      cmp = compare_fn(el, searchArr[k]);
    if (cmp > 0) {
      m = k + 1;
    } else if (cmp < 0) {
      n = k - 1;
    } else {
      return k;
    }
  }
  return -m - 1;
};

/**
 * Generate permutations of an array. Complexity is O(n!).
 * Should be safe up to 7, though you should probably consider something else if you're reaching that high often.
 *
 * @template T
 * @param {T[]} perm - The Array to be generated upon
 * @returns {Array.<T[]>|false} An Array containing all Array permutations or false if failed.
 */
function uniquePermutations(perm) {
  let total = new Set();
  if (perm.length > 7) {
    console.warn("Array too large. Not attempting.");
    return false;
  }

  for (let i = 0; i < perm.length; i = i + 1) {
    let rest = uniquePermutations(perm.slice(0, i).concat(perm.slice(i + 1)));

    if (!rest.length) {
      total.add([perm[i]]);
    } else {
      for (let j = 0; j < rest.length; j = j + 1) {
        total.add([perm[i]].concat(rest[j]));
      }
    }
  }
  return [...total];
}

/**
 * Searches through compendia quickly using the system generated index caches.
 * Exact matches excluding punctuation and case are prioritized before searching word order permutations.
 *
 * @param {string} searchTerm - The name of the Document being searched for
 * @param {object} [options] - Provides a filter to limit search to specific packs or Document types
 * @param {string[]} [options.packs] - An array of packs to search in
 * @param {"Actor"|"Item"|"Scene"|"JournalEntry"|"Macro"|"RollTable"|"Playlist"} [options.type] - A Document type to limit which packs are searched in
 * @returns {{pack: CompendiumCollection, index: object}|undefined} The index and pack containing it or undefined if no match is found
 */
const findInCompendia = function (searchTerm, options = { packs: [], type: undefined }) {
  let packs;
  if (options?.packs && options.packs.length) packs = options.packs.flatMap((o) => game.packs.get(o) ?? []);
  else packs = game.packs.filter((o) => !options?.type || o.metadata.entity == options.type);

  searchTerm = searchTerm.toLocaleLowerCase();
  let found, foundDoc, foundPack;
  for (let pack of packs) {
    if (!pack.fuzzyIndex) pack.fuzzyIndex = sortArrayByName([...pack.index]);
    found = binarySearch(pack.fuzzyIndex, searchTerm, (sp, it) =>
      sp.localeCompare(it.name, undefined, { ignorePunctuation: true })
    );
    if (found > -1) {
      foundDoc = pack.index.get(pack.fuzzyIndex[found]._id);
      foundPack = pack;
      break;
    }
  }
  if (foundDoc) return { pack: foundPack, index: foundDoc };

  let searchMutations = uniquePermutations(searchTerm.split(/[ _-]/));
  if (searchMutations) searchMutations = searchMutations.map((o) => o.join(" "));
  else {
    // If array is too long, search for just a reversed version and one that pivots around commas/ semicolons
    searchMutations = [null];
    searchMutations.push(searchTerm.split(/[ _-]/).reverse().join(" "));
    searchMutations.push(
      searchTerm
        .split(/[,;] ?/)
        .reverse()
        .flatMap((o) => o.split(" "))
        .join(" ")
    );
  }

  for (let pack of packs) {
    // Skip first mutation since it is already searched for manually before computing mutations
    for (let mut = 1; mut < searchMutations.length; mut++) {
      found = binarySearch(pack.fuzzyIndex, searchMutations[mut], (sp, it) =>
        sp.localeCompare(it.name, undefined, { ignorePunctuation: true })
      );
      if (found > -1) {
        foundDoc = pack.index.get(pack.fuzzyIndex[found]._id);
        foundPack = pack;
        break;
      }
    }
    if (foundDoc) break;
  }

  if (foundDoc) return { pack: foundPack, index: foundDoc };
  return false;
};

const registerHandlebarsHelpers = function () {
  Handlebars.registerHelper("concat", (a, b) => {
    if (typeof a === "number") a = a.toString();
    if (typeof b === "number") b = b.toString();
    return a + b;
  });

  /**
   * Render a MCE editor container with an optional toggle button
   */
  Handlebars.registerHelper("roll-editor", function (options) {
    const item = getProperty(options, "data.root.item");
    const actor = getProperty(options, "data.root.actor");
    const rollData = item != null ? item.getRollData() : actor != null ? actor.getRollData() : {};

    // Create editor
    const target = options.hash["target"];
    if (!target) throw new Error("You must define the name of a target field.");

    // Enrich the content
    const owner = Boolean(options.hash["owner"]);
    const content = TextEditor.enrichHTML(options.hash["content"] || "", {
      secrets: owner,
      entities: true,
      rollData: rollData,
    });

    // Construct the HTML
    let editor = $(`<div class="editor"><div class="editor-content" data-edit="${target}">${content}</div></div>`);

    // Append edit button
    const button = Boolean(options.hash["button"]);
    const editable = Boolean(options.hash["editable"]);
    if (button && editable) editor.append($('<a class="editor-edit"><i class="fas fa-edit"></i></a>'));
    return new Handlebars.SafeString(editor[0].outerHTML);
  });

  Handlebars.registerHelper("convertDistance", (value) => (Number.isFinite(value) ? convertDistance(value)[0] : value));
  Handlebars.registerHelper("distanceUnit", (type) => convertDistance(0, type)[1]);

  Handlebars.registerHelper("itemRange", (item, rollData) => {
    // ItemFFD20.range is not accessible here and is thus largely duplicated here

    let range = getProperty(item, "data.range.value");
    const rangeType = getProperty(item, "data.range.units");

    if (rangeType == null) return null;

    const toFeet = () => {
      let feet;
      switch (rangeType) {
        case "melee":
        case "touch":
          return getProperty(rollData, "range.melee") || 0;
        case "reach":
          return getProperty(rollData, "range.reach") || 0;
        case "close":
          feet = RollFFD20.safeRoll("25 + floor(@cl / 2) * 5", rollData);
          break;
        case "medium":
          feet = RollFFD20.safeRoll("100 + @cl * 10", rollData);
          break;
        case "long":
          feet = RollFFD20.safeRoll("400 + @cl * 40", rollData);
          break;
        case "mi":
          return range * 5280; // TODO: Should remain as miles for shortness
        case "ft":
          feet = RollFFD20.safeRoll(range, rollData);
          break;
        default:
          return range;
      }
      if (feet.err) {
        console.log(feet.err, item);
        return "[x]";
      }
      return feet.total;
    };

    const ft = toFeet();
    if (ft && typeof ft !== "string") {
      const rv = convertDistance(ft);
      return `${rv[0]} ${rv[1]}`;
    } else {
      return "" + (ft ?? "");
    }
  });

  Handlebars.registerHelper("itemDamage", (item, rollData) => {
    if (!item.hasDamage) return null; // It was a mistake to call this

    const actorData = item.document.parentActor.data.data,
      itemData = item.data;

    const rv = [];

    const reduceFormula = (formula) => {
      const roll = RollFFD20.safeRoll(formula, rollData);
      formula = roll.formula.replace(/\[[^\]]+\]/g, ""); // remove flairs
      return [roll, formula];
    };

    const handleParts = (parts) => {
      for (let [formula, _] of parts) {
        const [roll, newformula] = reduceFormula(formula);
        if (roll.total == 0) continue;
        rv.push(newformula);
      }
    };

    // Normal damage parts
    handleParts(itemData.damage.parts);

    // Include ability score only if the string isn't too long yet
    const dmgAbl = itemData.ability.damage;
    const dmgAblMod = Math.floor((actorData.abilities[dmgAbl]?.mod ?? 0) * (itemData.ability.damageMult || 1));
    if (dmgAblMod != 0) rv.push(dmgAblMod);

    // Include damage parts that don't happen on crits
    handleParts(itemData.damage.nonCritParts);

    // Include general sources. Item enhancement bonus is among these.
    const sources = item.document.allDamageSources;
    for (let s of sources) rv.push(s.value);

    if (rv.length === 0) rv.push("NaN"); // Something probably went wrong

    return rv
      .join("+")
      .replace(/\s+/g, "") // remove whitespaces
      .replace(/\+-/, "-") // simplify math logic pt.1
      .replace(/--/g, "+") // simplify math logic pt.2
      .replace(/\+\++/, "+"); // simplify math logic pt.3
  });

  Handlebars.registerHelper("itemAttacks", (item) => {
    const attacks = item.document.attackArray;
    const highest = Math.max(...attacks); // Highest bonus, with assumption the first might not be that.
    return `${attacks.length} (${highest < 0 ? highest : `+${highest}`}${attacks.length > 1 ? "/…" : ""})`;
  });

  /**
   * Returns true if there are conditionals disabled by default.
   */
  Handlebars.registerHelper("optionalConditionals", (item) => {
    return item.data.conditionals.find((c) => !c.default);
  });

  // Fetches ability mod value based on ability key.
  // Avoids contaminating rollData or item data with excess strings.
  Handlebars.registerHelper("abilityMod", (abl, rollData, multiplier) => {
    if (multiplier == null) multiplier = 1;
    return Math.floor(getProperty(rollData, `abilities.${abl}.mod`) * multiplier);
  });

  // Shorten string with ellipsis
  // Favor cutting off near specific symbol within margin of error
  Handlebars.registerHelper("ellipsis", (value, desiredLength, searchStartOffset = -4, searchEndOffset = 2) => {
    const delimiters = /(\s|\+|,)/g;
    // Process only if it's too long
    if (value?.length > desiredLength + searchEndOffset) {
      let cut = 0;

      const end = Math.min(value.length - 1, desiredLength + searchEndOffset),
        start = Math.max(0, desiredLength + searchStartOffset);

      // Find nice cutting position
      for (let i = end; i > start; i--) {
        if (value[i].match(delimiters)?.length > 0) {
          cut = i + 1;
          break;
        }
      }
      if (cut == 0) cut = desiredLength; // No better position found, just cut it.

      return value.substring(0, cut) + "…";
    }
    return value;
  });
};

const tinyMCEInit = function () {
  CONFIG.TinyMCE.content_css.push("/systems/ffd20/ui/mce.css");

  CONFIG.TinyMCE.style_formats[0].items.push(
    {
      title: game.i18n.localize("FFD20.NotImplemented"),
      inline: "span",
      classes: "notImp",
      attributes: { title: game.i18n.localize("FFD20.NotImplemented") },
      remove: "all",
    },
    {
      title: game.i18n.localize("FFD20.StepsRequired"),
      inline: "span",
      classes: "needSteps",
      attributes: { title: game.i18n.localize("FFD20.StepsRequired") },
      remove: "all",
    }
  );
  CONFIG.TinyMCE.formats = Object.assign({}, CONFIG.TinyMCE.formats, {
    removeFormat: [{ selector: "span", classes: "notImp,needSteps", remove: "all" }],
  });

  tinyMCE.on("addeditor", (ev) => {
    registerContextMenu(ev.editor);
  });
};

/**
 * @param editor
 */
function registerContextMenu(editor) {
  var isInfoElement = function (node) {
    if (node.nodeName.toLowerCase() !== "span") node = node.parentNode;
    return (
      node.nodeName.toLowerCase() === "span" &&
      (node.classList.contains("notImp") || node.classList.contains("needSteps"))
    );
  };

  var getInfoElement = function () {
    var node = editor.selection.getNode();
    return isInfoElement(node) ? node.closest("span.notImp,span.needSteps") : null;
  };

  editor.ui.registry.addContextForm("info-form", {
    launch: {
      type: "contextformtogglebutton",
      icon: "warning",
    },
    label: "Info",
    predicate: isInfoElement,
    initValue: function () {
      var elm = getInfoElement();
      return elm ? elm.title : "";
    },
    commands: [
      {
        type: "contextformtogglebutton",
        icon: "warning",
        tooltip: game.i18n.localize("FFD20.NotImplemented"),
        onSetup: function (buttonApi) {
          buttonApi.setActive(!!getInfoElement()?.classList.contains("notImp"));
          var nodeChangeHandler = function () {
            buttonApi.setActive(!editor.readonly && getInfoElement()?.classList.contains("notImp"));
          };
          editor.on("nodechange", nodeChangeHandler);
          return function () {
            editor.off("nodechange", nodeChangeHandler);
          };
        },
        onAction: function (formApi) {
          var value = formApi.getValue(),
            node = getInfoElement();
          editor.setDirty(true);
          editor.dom.setAttribs(node, { title: value, class: "notImp" });
          formApi.hide();
        },
      },
      {
        type: "contextformtogglebutton",
        icon: "selected",
        tooltip: game.i18n.localize("FFD20.StepsRequired"),
        onSetup: function (buttonApi) {
          buttonApi.setActive(!!getInfoElement()?.classList.contains("needSteps"));
          var nodeChangeHandler = function () {
            buttonApi.setActive(!editor.readonly && getInfoElement()?.classList.contains("needSteps"));
          };
          editor.on("nodechange", nodeChangeHandler);
          return function () {
            editor.off("nodechange", nodeChangeHandler);
          };
        },
        onAction: function (formApi) {
          var value = formApi.getValue(),
            node = getInfoElement();
          editor.setDirty(true);
          editor.dom.setAttribs(node, { title: value, class: "needSteps" });
          formApi.hide();
        },
      },
      {
        type: "contextformtogglebutton",
        icon: "close",
        tooltip: game.i18n.localize("FFD20.RemoveInfo"),
        onAction: function (formApi) {
          var node = getInfoElement();
          editor.setDirty(true);
          editor.dom.remove(node, true);
          formApi.hide();
        },
      },
    ],
  });
}

/**
 * Measure the distance between two pixel coordinates
 * See BaseGrid.measureDistance for more details
 *
 * @param segments
 * @param options
 */
const measureDistances = function (segments, options = {}) {
  if (!options.gridSpaces) return BaseGrid.prototype.measureDistances.call(this, segments, options);

  // Track the total number of diagonals
  let nDiagonal = 0;
  const rule = this.parent.diagonalRule;
  const d = canvas.dimensions;

  // Iterate over measured segments
  return segments.map((s) => {
    let r = s.ray;

    // Determine the total distance traveled
    let nx = Math.abs(Math.ceil(r.dx / d.size));
    let ny = Math.abs(Math.ceil(r.dy / d.size));

    // Determine the number of straight and diagonal moves
    let nd = Math.min(nx, ny);
    let ns = Math.abs(ny - nx);
    nDiagonal += nd;

    // Alternative DMG Movement
    if (rule === "5105") {
      let nd10 = Math.floor(nDiagonal / 2) - Math.floor((nDiagonal - nd) / 2);
      let spaces = nd10 * 2 + (nd - nd10) + ns;
      return spaces * canvas.dimensions.distance;
    }

    // Standard PHB Movement
    else return (ns + nd) * canvas.scene.data.gridDistance;
  });
};

/* -------------------------------------------- */

/**
 * Hijack Token health bar rendering to include temporary and temp-max health in the bar display
 * TODO: This should probably be replaced with a formal Token class extension
 */
const _TokenGetBarAttribute = TokenDocument.prototype.getBarAttribute;
TokenDocument.prototype.getBarAttribute = function (barName, { alternative = null } = {}) {
  let data;
  try {
    data = _TokenGetBarAttribute.call(this, barName, { alternative: alternative });
  } catch (e) {
    data = null;
  }
  if (data != null && data.attribute === "attributes.hp") {
    data.value += parseInt(getProperty(this.actor.data, "data.attributes.hp.temp") || 0);
  }

  // Make resources editable
  if (data?.attribute.startsWith("resources.")) data.editable = true;

  return data;
};

/**
 * Condition/ status effects section
 */
const getConditions = function () {
  let core = CONFIG.statusEffects,
    sys = Object.keys(CONFIG.FFD20.conditions).map((c) => {
      return { id: c, label: CONFIG.FFD20.conditions[c], icon: CONFIG.FFD20.conditionTextures[c] };
    });
  if (game.settings.get("ffd20", "coreEffects")) sys.push(...core);
  else sys = [core[0]].concat(sys);
  return sys;
};

const _TokenHUD_getStatusEffectChoices = TokenHUD.prototype._getStatusEffectChoices;
TokenHUD.prototype._getStatusEffectChoices = function () {
  let core = _TokenHUD_getStatusEffectChoices.call(this),
    buffs = {};
  Object.entries(this.object.actor._calcBuffTextures()).forEach((obj, ind) => {
    let [idx, buff] = obj;
    if (buffs[buff.icon] && buff.label) buff.icon += "?" + ind;
    if (buff) {
      buffs[buff.icon] = {
        id: buff.id,
        title: buff.label,
        src: buff.icon,
        isActive: buff.active,
        isOverlay: false,
        cssClass: buff.active ? "active" : "",
      };
    }
  });
  return Object.assign({}, core, buffs);
};

//const TokenHUD__onToggleEffect = TokenHUD.prototype._onToggleEffect;
TokenHUD.prototype._onToggleEffect = function (event, { overlay = false } = {}) {
  event.preventDefault();
  let img = event.currentTarget;
  const effect =
    img.dataset.statusId && this.object.actor
      ? CONFIG.statusEffects.find((e) => e.id === img.dataset.statusId) ?? img.dataset.statusId
      : img.getAttribute("src");
  return this.object.toggleEffect(effect, { overlay });
};

const Token_toggleEffect = Token.prototype.toggleEffect;
Token.prototype.toggleEffect = async function (effect, { active, overlay = false, midUpdate } = {}) {
  let call;
  if (typeof effect == "string") {
    let buffItem = this.actor.items.get(effect);
    if (buffItem) {
      call = await buffItem.update({ "data.active": !buffItem.data.data.active });
    } else call = await Token_toggleEffect.call(this, effect, { active, overlay });
  } else if (effect && !midUpdate && Object.keys(CONFIG.FFD20.conditions).includes(effect.id)) {
    const updates = {};
    updates["data.attributes.conditions." + effect.id] = !this.actor.data.data.attributes.conditions[effect.id];
    call = await this.actor.update(updates);
  } else if (effect) {
    call = await Token_toggleEffect.call(this, effect, { active, overlay });
  }
  if (this.hasActiveHUD) canvas.tokens.hud.refreshStatusIcons();
  return call;
};

/**
 * A specialized form used to select damage or condition types which apply to an Actor
 *
 * @type {BaseEntitySheet}
 */
class ActorTraitSelector extends BaseEntitySheet {
  static get defaultOptions() {
    const options = super.defaultOptions;
    options.classes = ["ffd20", "trait-selector"];
    options.title = "Actor Trait Selection";
    options.template = "systems/ffd20/templates/apps/trait-selector.hbs";
    options.width = 320;
    options.height = "auto";
    return options;
  }

  /* -------------------------------------------- */

  /**
   * Return a reference to the target attribute
   *
   * @type {string}
   */
  get attribute() {
    return this.options.name;
  }

  /* -------------------------------------------- */

  /**
   * Provide data to the HTML template for rendering
   *
   * @type {Object}
   */
  getData() {
    // Get current values
    let attr = getProperty(this.object.data, this.attribute);

    // Populate choices
    const choices = duplicate(this.options.choices);
    for (let [k, v] of Object.entries(choices)) {
      choices[k] = {
        label: v,
        chosen: attr.value.includes(k),
      };
    }

    // Object type
    const updateButton = this.object instanceof Actor ? "FFD20.UpdateActor" : "FFD20.UpdateItem";

    // Return data
    return {
      choices: choices,
      custom: attr.custom,
      updateButton,
    };
  }

  /* -------------------------------------------- */

  /**
   * Update the Actor object with new trait data processed from the form
   *
   * @param event
   * @param formData
   * @private
   */
  _updateObject(event, formData) {
    const choices = [];
    for (let [k, v] of Object.entries(formData)) {
      if (k !== "custom" && v) choices.push(k);
    }
    this.object.update({
      [`${this.attribute}.value`]: choices,
      [`${this.attribute}.custom`]: formData.custom,
    });
  }
}

class ActorRestDialog extends DocumentSheet {
  static get defaultOptions() {
    const options = super.defaultOptions;
    return mergeObject(options, {
      classes: ["ffd20", "actor-rest"],
      template: "systems/ffd20/templates/apps/actor-rest.hbs",
      width: 500,
      closeOnSubmit: true,
    });
  }

  /* -------------------------------------------- */

  /**
   * Configure the title of the special traits selection window to include the Actor name
   *
   * @type {string}
   */
  get title() {
    return `${game.i18n.localize("FFD20.Rest")}: ${this.object.name}`;
  }

  /* -------------------------------------------- */

  /**
   * Update the Actor using the configured options
   * Remove/unset any flags which are no longer configured
   *
   * @param event
   * @param formData
   */
  async _updateObject(event, formData) {
    this.object.performRest({
      /**
       * add rest options
       * Natural healing(8 hours rest, once per 24 hours): Restore HP equal to level plus con  and MP equal to caster level plus primary casting stat. Complete rest(24 hours of rest, no combat or hard training): Double natural healing Aided Healing(8 hours with someone trained in heal 5 ranks or more looking after you): double natural healing Aided Complete Rest(24 hours with someone trained in heal 5 ranks or more looking after you): 5x natural healing There are items that boost natural healing that can be found.
       */
      restoreHealth: formData["restoreHealth"],
      longTermCare: formData["longTermCare"],
      aidedcare: formData["aidedCare"],
      restoreDailyUses: formData["restoreDailyUses"],
      hours: formData["hours"],
    });
  }
}

class ActorSheetFlags extends BaseEntitySheet {
  static get defaultOptions() {
    const options = super.defaultOptions;
    return mergeObject(options, {
      id: "actor-flags",
      classes: ["ffd20"],
      template: "systems/ffd20/templates/apps/actor-flags.hbs",
      width: 500,
      closeOnSubmit: true,
    });
  }

  /* -------------------------------------------- */

  /**
   * Configure the title of the special traits selection window to include the Actor name
   *
   * @type {string}
   */
  get title() {
    return `${game.i18n.localize("FFD20.FlagsTitle")}: ${this.object.name}`;
  }

  /* -------------------------------------------- */

  /**
   * Prepare data used to render the special Actor traits selection UI
   *
   * @returns {Object}
   */
  getData() {
    const data = super.getData();
    data.flags = this._getFlags();
    return data;
  }

  /* -------------------------------------------- */

  /**
   * Prepare an object of flags data which groups flags by section
   * Add some additional data for rendering
   *
   * @returns {Object}
   */
  _getFlags() {
    const flags = {};
    for (let [k, v] of Object.entries(CONFIG.FFD20.characterFlags)) {
      if (!Object.prototype.hasOwnProperty.call(flags, v.section)) flags[v.section] = {};
      let flag = duplicate(v);
      flag.type = v.type.name;
      flag.isCheckbox = v.type === Boolean;
      flag.isSelect = Object.prototype.hasOwnProperty.call(v, "choices");
      flag.value = this.entity.getFlag("FFD20", k);
      flags[v.section][k] = flag;
    }
    return flags;
  }

  /* -------------------------------------------- */

  /**
   * Update the Actor using the configured flags
   * Remove/unset any flags which are no longer configured
   *
   * @param event
   * @param formData
   */
  _updateObject(event, formData) {
    const actor = this.object;

    // Iterate over the flags which may be configured
    const updateData = {};
    for (let [k, v] of Object.entries(CONFIG.ffd20.characterFlags)) {
      if ([undefined, null, "", false].includes(formData[k])) updateData[`-=${k}`] = null;
      else if (v.type === Number && formData[k] === 0) updateData[`-=${k}`] = null;
      else updateData[k] = formData[k];
    }

    // Set the new flags in bulk
    actor.update({ "flags.ffd20": updateData });
  }
}

class PointBuyCalculator extends DocumentSheet {
  constructor(...args) {
    super(...args);

    const actorAbl = this.actor.data.data.abilities;

    this.abilities = [];
    for (let [k, name] of Object.entries(CONFIG.FFD20.abilities)) {
      this.abilities.push({
        key: k,
        name: name,
        value: actorAbl[k]?.value ?? 10,
      });
    }
  }

  static get defaultOptions() {
    return mergeObject(super.defaultOptions, {
      classes: ["ffd20", "pointbuy-calculator"],
      title: "Point Buy Calculator",
      template: "systems/ffd20/templates/apps/pointbuy-calculator.hbs",
      width: 320,
      height: "auto",
      closeOnSubmit: false,
      submitOnClose: false,
    });
  }

  get title() {
    return `${this.options.title}: ${this.object.name}`;
  }

  get actor() {
    return this.document;
  }

  getData() {
    const points = this.getSpentPoints();

    return {
      abilities: this.abilities,
      points: points,
    };
  }

  getSpentPoints() {
    let result = 0;

    for (let a of this.abilities) {
      result += CONFIG.FFD20.abilityCost[a.value];
    }
    return result;
  }

  activateListeners(html) {
    super.activateListeners(html);

    html.find(".ability-control").click(this._onAbilityControl.bind(this));
  }

  _onAbilityControl(event) {
    event.preventDefault();
    const a = event.currentTarget;
    const ablKey = a.closest(".item").dataset.ability;
    const abl = this.abilities.find((o) => o.key === ablKey);

    if (a.classList.contains("add")) {
      abl.value = Math.min(18, abl.value + 1);
    } else if (a.classList.contains("subtract")) {
      abl.value = Math.max(7, abl.value - 1);
    }
    this.render();
  }

  _updateObject() {
    const updateData = {};
    for (let a of this.abilities) {
      updateData[`data.abilities.${a.key}.value`] = a.value;
    }
    this.actor.update(updateData);

    this.close();
  }
}

class Widget_ItemPicker {
  constructor(callback, { items, columns = 3 } = {}) {
    /**
     * @property
     * The HTML element that represents this widget.
     */
    this.element = null;

    /**
     * @property
     * The callback to fire if an item is clicked.
     */
    this.callback = callback;

    /**
     * @typedef Widget_ItemPicker_Item
     * @type {Object}
     * @property {string} value
     * @property {string} label
     */
    /**
     * @property
     * @type Widget_ItemPicker_Item[]
     * The items in this widget.
     */
    this._items = items;

    /**
     * @property
     * @type {number}
     * The maximum amount of columns shown.
     */
    this.columns = columns;
  }

  render(parentElem) {
    // Generate widget
    const rootElem = $($.parseHTML('<div class="widget item-picker"></div>'));
    // Add rows
    let rowElem;
    for (let a = 0; a < this._items.length; a++) {
      const item = this._items[a];
      if (a % this.columns === 0) {
        rowElem = $($.parseHTML('<div class="row"></div>'));
        rootElem.append(rowElem);
      }

      const itemElem = $($.parseHTML(`<div class="item" value="${item.value}">${item.label}</div>`));
      const widthRate = Math.floor(10000 / this.columns) / 100;
      itemElem.css("flex", `0 0 calc(${widthRate}% - 4px)`);
      rowElem.append(itemElem);
    }

    // Replace parent element
    if (!(parentElem instanceof jQuery)) parentElem = $(parentElem);
    rootElem.css("position", "absolute");
    rootElem.css("left", `${parentElem[0].offsetLeft}px`);
    rootElem.css("position", `${parentElem[0].offsetBottom}px`);
    parentElem.parent().append(rootElem);

    this.element = rootElem;

    window.setTimeout(() => {
      this.activateListeners(rootElem);
    }, 10);
  }

  activateListeners(html) {
    // Click item callback
    html.find(".item").click(this._onClickItem.bind(this));

    // Cancel widget
    this._cancelCallback = this._onCancel.bind(this);
    document.addEventListener("click", this._cancelCallback);
  }

  _onCancel(event) {
    event.preventDefault();

    // Don't cancel if this widget was clicked
    const target = event.target;
    let node = target;
    if (node === this.element[0]) return;
    while (node.parentNode) {
      if (node === this.element[0]) return;
      node = node.parentNode;
    }

    this.cancel();
  }

  _onClickItem(event) {
    event.preventDefault();
    const a = event.currentTarget;

    this.callback($(a).attr("value"));
  }

  cancel() {
    document.removeEventListener("click", this._cancelCallback);
    this.element.remove();
  }
}

/**
 * @param root0
 * @param root0.title
 * @param root0.initial
 * @param root0.min
 * @param root0.max
 */
function dialogGetNumber({
  title = "Input Number",
  initial = null,
  min = Number.NEGATIVE_INFINITY,
  max = Number.POSITIVE_INFINITY,
} = {}) {
  return new Promise((resolve) => {
    let cancelled = true;

    new Dialog(
      {
        title: title,
        content: `<input type="number" name="result" min="${min}" max="${max}" value="${initial || 0}">`,
        buttons: {
          ok: {
            label: "Submit",
            callback: (html) => {
              cancelled = false;
              const input = html.find('input[name="result"]');
              resolve(input.val());
            },
          },
        },
        close: () => {
          if (!cancelled) {
            resolve(initial);
          }
        },
        default: "ok",
        render: (htm) => {
          htm.find("input").select();
        },
      },
      {
        classes: ["dialog", "ffd20", "get-number"],
      }
    ).render(true);
  });
}

const dialogGetActor = function (title = "", actors = []) {
  return new Promise((resolve) => {

    let content = "";
    actors.forEach((target) => {
      if (target instanceof Actor) {
        content += `<div class="dialog-get-actor flexrow" data-actor-id="${target._id}"><img src="${target.data.img}"><h2>${target.name}</h2></div>`;
      } else if (target instanceof Item) {
        content += `<div class="dialog-get-actor flexrow" data-item-id="${target._id}"><img src="${target.data.img}"><h2>${target.name}</h2></div>`;
      }
    });

    const dialog = new Dialog(
      {
        title: title,
        content: content,
        buttons: {},
        close: () => {
          {
            resolve(null);
          }
        },
      },
      {
        classes: ["dialog", "ffd20", "get-actor"],
      }
    );

    dialog.activateListeners = function (html) {
      Dialog.prototype.activateListeners.call(this, html);

      html.find(".dialog-get-actor").click((event) => {
        const elem = event.currentTarget;
        const actorId = elem.dataset.actorId;
        if (actorId) {
          resolve({ type: "actor", id: actorId });
        } else {
          const itemId = elem.dataset.itemId;
          if (itemId) {
            resolve({ type: "item", id: itemId });
          }
        }
        this.close();
      });
    };

    dialog.render(true);
  });
};

class LevelUpForm extends DocumentSheet {
  constructor(...args) {
    super(...args);

    /**
     * Tracks whether this form has already been submitted.
     */
    this._submitted = false;
  }

  static get defaultOptions() {
    return mergeObject(super.defaultOptions, {
      classes: ["ffd20", "level-up"],
      template: "systems/ffd20/templates/apps/level-up.hbs",
      width: 500,
      closeOnSubmit: true,
    });
  }

  get title() {
    return game.i18n.format("FFD20.LevelUpForm_Title", { className: this.object.name });
  }

  get actor() {
    return this.object.actor;
  }

  static async addClassWizard(actor, rawData) {
    // Alter initial data
    setProperty(rawData, "data.hp", 0);
    setProperty(rawData, "data.level", 0);

    // Add class item
    let itemData = await actor.createEmbeddedDocuments("Item", [rawData]);
    itemData = itemData instanceof Array ? itemData : [itemData];
    const item = actor.items.get(itemData[0].id);
    if (!item) {
      throw new Error("No class was created at class initialization wizard");
    }

    // Add level up form for new class
    return new Promise((resolve) => {
      const _app = new LevelUpForm(item).render(true);
      Hooks.on("closeLevelUpForm", function _onClose(app) {
        if (app === _app) {
          if (getProperty(item.data, "data.level") === 0) {
            actor.deleteEmbeddedDocuments("Item", [item.id]);
          }
          Hooks.off("closeLevelUpForm", _onClose);
          resolve();
        }
      });
    });
  }

  getData() {
    const result = {};

    result.data = duplicate(this.object.data);
    result.actor = duplicate(this.actor.data);

    // Add health data
    const hpSettings = game.settings.get("ffd20", "healthConfig");
    const hpOptions = this.actor.data.type === "character" ? hpSettings.hitdice.PC : hpSettings.hitdice.NPC;
    result.health = {
      autoHP: hpOptions.auto === true,
      manualValue: Math.ceil(1 + (result.data.data.hd - 1) / 2),
    };

    // Add favored class data
    result.fc = {
      allowed: result.data.data.classType === "base",
      types: [
        { key: "none", label: game.i18n.localize("FFD20.None"), checked: true },
        { key: "hp", label: game.i18n.localize("FFD20.FavouredClassBonus.HP") },
        { key: "skill", label: game.i18n.localize("FFD20.FavouredClassBonus.Skill") },
        { key: "alt", label: game.i18n.localize("FFD20.FavouredClassBonus.Alt") },
      ],
    };

    result.uuid = `${result.actor._id}.${result.data._id}`;

    return result;
  }

  async _updateObject(event, formData) {
    const item = this.object;
    const updateData = {};
    const chatData = {};

    // Add health part
    if (formData["health.manual_value"]) {
      let hp = parseInt(formData["health.manual_value"]);
      chatData.hp = {
        label: "FFD20.LevelUp.Chat.Health.Manual",
        add: hp,
        roll: RollFFD20$1.safeRoll(`${hp}`),
      };
      if (!Number.isNaN(hp)) {
        updateData["data.hp"] = item.data.data.hp + hp;
      }
    } else if (formData["health.roll"]) {
      // Roll for health
      const formula = `1d${item.data.data.hd}`;
      const roll = RollFFD20$1.safeRoll(formula);
      chatData.hp = {
        label: "FFD20.LevelUp.Chat.Health.Roll",
        add: createInlineRollString(roll),
        roll: roll,
      };
      if (!Number.isNaN(roll.total)) {
        updateData["data.hp"] = item.data.data.hp + roll.total;
      }
    }

    // Add favored class part
    if (formData["fc.type"] && formData["fc.type"] !== "none") {
      const key = `data.fc.${formData["fc.type"]}.value`;
      updateData[key] = getProperty(item.data, key) + 1;

      const fcKey = { hp: "HP", skill: "Skill", alt: "Alt" }[formData["fc.type"]];
      chatData.fc = {
        type: formData["fc.type"],
        label: `FFD20.FavouredClassBonus.${fcKey}`,
      };
    }

    // Add level
    chatData.level = {
      previous: item.data.data.level,
      new: item.data.data.level + 1,
    };

    // Update class
    updateData["data.level"] = chatData.level.new;
    this.object.update(updateData);
    await new Promise((resolve) => {
      Hooks.on(
        "ffd20.classLevelChange",
        function _waiter(actor, item) {
          if (item.id === this.object.id) {
            Hooks.off("ffd20.classLevelChange", _waiter);
            resolve();
          }
        }.bind(this)
      );
    });

    // Add new class features to chat data
    {
      const classAssociations = getProperty(this.object.data, "flags.ffd20.links.classAssociations") || {};
      const newAssociations = Object.entries(classAssociations).filter((o) => {
        return o[1] === chatData.level.new;
      });
      chatData.newFeatures = [];
      for (let co of newAssociations) {
        const item = this.actor.items.get(co[0]);
        if (item) chatData.newFeatures.push(duplicate(item.data));
      }
    }

    // Add extra info (new feats, skill ranks, etc.)
    {
      const ex = {};
      chatData.extra = ex;

      // Show new feat count
      const featCount = this.actor.getFeatCount();
      featCount.new = Math.max(0, featCount.max - featCount.value);
      ex.feats = featCount;
      if (featCount.new > 0) {
        ex.enabled = true;
        if (featCount.new === 1) featCount.label = game.i18n.localize("FFD20.LevelUp.Chat.Extra.NewFeat");
        else featCount.label = game.i18n.format("FFD20.LevelUp.Chat.Extra.NewFeats", { newValue: featCount.new });
      }

      // Show new ability score
      const hd = getProperty(this.actor.data, "data.attributes.hd.total");
      if (typeof hd === "number" && hd % 4 === 0) {
        ex.enabled = true;
        ex.newAbilityScore = {
          label: game.i18n.localize("FFD20.LevelUp.Chat.Extra.NewAbilityScore"),
        };
      }
    }

    // Create chat message
    return this.createChatMessage(chatData);
  }

  async createChatMessage(formData) {
    const chatMessageClass = CONFIG.ChatMessage.documentClass;
    const speaker = chatMessageClass.getSpeaker({ actor: this.actor });

    const templateData = {
      formData,
      config: CONFIG.FFD20,
      item: duplicate(this.object.data),
      actor: duplicate(this.actor.data),
    };

    await chatMessageClass.create({
      content: await renderTemplate("systems/ffd20/templates/chat/level-up.hbs", templateData),
      user: game.user.id,
      type: CONST.CHAT_MESSAGE_TYPES.ROLL,
      speaker,
      roll: formData.hp?.roll ?? RollFFD20$1.safeRoll("0"),
    });
  }

  activateListeners(html) {
    html.find(`.switch-check[name="health.roll"]`).change(this._switchHealthRoll.bind(this));

    html.find('button[name="submit"]').click(this._onSubmit.bind(this));
  }

  _onSubmit(event, ...args) {
    event.preventDefault();
    if (this._submitted) return;

    this._submitted = true;
    super._onSubmit(event, ...args);
  }

  _switchHealthRoll(event) {
    const checked = $(event.currentTarget).prop("checked");
    const targetElem = this.element.find(`input[type="text"][name="health.manual_value"]`);

    targetElem.attr("disabled", checked);
  }
}

class CurrencyTransfer extends FormApplication {
  constructor(
    source = { actor: null, container: null, amount: {}, alt: false },
    dest = { actor: null, container: null, amount: {}, alt: false },
    options = {}
  ) {
    super(options);

    if (source.actor) {
      if (typeof source.actor === "string") source.actor = game.actors.get(source.actor);
      if (source.actor.data.type == "npc") source.alt = false;
    }
    if (source.container) {
      source.alt = false;
      if (typeof source.container === "string")
        source.container = source.actor ? source.actor.items.get(source.container) : game.items.get(source.container);
    }
    if (dest.actor) {
      if (typeof dest.actor === "string") dest.actor = game.actors.get(dest.actor);
      if (dest.actor.data.type == "npc") dest.alt = false;
      else if (dest.actor === source.actor && !source.container && !dest.container) dest.alt = !source.alt;
    }
    if (dest.container) {
      if (typeof dest.container === "string")
        dest.container = dest.actor ? dest.actor.items.get(dest.container) : game.items.get(dest.container);
    }

    // Currency checks
    if (source.container) {
      source.amount = mergeObject(source.container.data.data.currency, source.amount ?? {});
    } else if (source.actor) {
      source.amount = mergeObject(
        source.alt ? source.actor.data.data.altCurrency : source.actor.data.data.currency,
        source.amount ?? {}
      );
    } else if (game.user.isGM) {
      source.amount = mergeObject({ pgil: "∞", gil: "∞", sgil: "∞", cgil: "∞" }, source.amount ?? {});
    } else {
      ui.notification.warning("Cannot use Infinite currency transfer as non-gm.");
      return undefined;
    }

    if (!dest.actor && !dest.container) return undefined;

    this.source = source;
    this.dest = dest;
  }

  get title() {
    let title;
    if (!this.source.actor) {
      if (this.source.container) title = this.source.container.name + " ";
      else title = "∞ ";
    } else {
      title = this.source.actor.name + " ";
      if (this.source.container) title += `(${this.source.container.name}) `;
    }
    title += "➤ ";
    if (this.source.actor == this.dest.actor && (this.source.alt || this.dest.alt))
      title += this.dest.alt ? game.i18n.localize("FFD20.WeightlessCurrency") : game.i18n.localize("FFD20.Currency");
    else {
      if (!this.dest.actor) title += this.dest.container.name;
      else {
        title += this.dest.actor.name;
        if (this.dest.container) title += ` (${this.dest.container.name})`;
      }
    }
    return title;
  }

  static get defaultOptions() {
    return mergeObject(super.defaultOptions, {
      classes: ["ffd20", "currency-transfer"],
      template: "systems/ffd20/templates/apps/currency-transfer.hbs",
      width: 380,
      height: 235,
    });
  }

  static get order() {
    return ["pgil", "gil", "sgil", "cgil"]; // Object conversion ordering cannot be trusted in js
  }

  activateListeners(html) {
    html.find('button[type="submit"]').click(this._onSubmit.bind(this));

    html.find("button.cur-range").click(this._curRange.bind(this));

    html.find("input").on("input", this._calcTotal.bind(this));
    $(html.find("input")[0]).trigger("input");
  }

  _updateObject(event, formData) {
    this.dest.amount = {
      pgil: formData.pgil ?? 0,
      gil: formData.gil ?? 0,
      sgil: formData.sgil ?? 0,
      cgil: formData.cgil ?? 0,
    };
    this.constructor.transfer(
      this.source.container ? this.source.container : this.source.actor,
      this.dest.container ? this.dest.container : this.dest.actor,
      this.dest.amount,
      this.source.alt,
      this.dest.alt,
      2
    );
  }

  getData(_options = {}) {
    return {
      source: this.source,
      dest: this.dest,
      options: this.options,
      title: this.title,
      total:
        this.source.amount.gil === "∞"
          ? "∞"
          : this.constructor.order.reduce((acc, c, idx) => acc + this.source.amount[c] * 10 ** (1 - idx), 0),
    };
  }

  _curRange(ev) {
    ev.preventDefault();
    const button = ev.target.closest("button");
    const formField = button.closest(".form-fields");
    const min = button.classList.contains("down");
    const input = formField.querySelector("input");

    if (min) input.value = "";
    else input.value = formField.querySelector("span").textContent;
    $(input).trigger("input");
  }

  _calcTotal(ev) {
    const form = ev.target.closest(".currency-transfer");
    const amounts = Object.fromEntries(
      [...form.querySelectorAll("input")].map((o) => [o.name, parseInt(o.value || 0)])
    );
    const value = this.constructor.order.reduce((acc, c, idx) => acc + amounts[c] * 10 ** (1 - idx), 0);

    form.querySelector(".currency-total .form-fields label").textContent = Math.round(value * 100) / 100 + " gil";
  }

  async close(...args) {
    super.close(...args);
  }

  static _failed(i18nKey) {
    return ui.notifications.error(game.i18n.localize("FFD20.CurrencyFailed") + game.i18n.localize(i18nKey));
  }

  static _directoryDrop(docDestId, event) {
    event.preventDefault();

    // try to extract the data
    let data;
    try {
      data = JSON.parse(event.dataTransfer.getData("text/plain"));
      if (data.type !== "Currency") return;
    } catch (err) {
      return false;
    }

    const destDoc = event.currentTarget.classList.contains("item")
      ? game.items.get(docDestId)
      : game.actors.get(docDestId);
    const sourceActor = data.tokenId ? game.actors.tokens[data.tokenId] : data.actorId;

    if (data.currency && sourceActor) {
      return new CurrencyTransfer(
        { actor: sourceActor, container: data.containerId, alt: data.alt },
        {
          actor: destDoc?.actor ?? destDoc,
          container: destDoc.data.type === "container" ? destDoc.id : null,
          amount: Object.fromEntries([[data.currency, parseInt(data.amount)]]),
        }
      ).render(true);
    }
  }

  /**
   * Transfer an amount of currency to a valid document
   *
   * @param {Document} sourceDoc ActorFFD20 or ItemFFD20 with currency
   * @param {Document} destDoc ActorFFD20 or ItemFFD20 with currency
   * @param {object|number} amount currency object containing transferred amount. Undefined keys will be assumed to be zero. Providing just a number will assume just gil
   * @param {boolean} sourceAlt Use alt currency on source
   * @param {boolean} destAlt Use alt currency on destination
   * @param {number} [allowConversion=false] Attempts to make change with sourceDoc's currency limit
   * @returns {boolean|object} false if failed, object containing amount transferred on success
   */
  static async transfer(sourceDoc, destDoc, amount, sourceAlt = false, destAlt = false, allowConversion = false) {
    if ((!sourceDoc && !game.user.isGM) || !destDoc || !amount) return false;

    if (typeof amount !== "object") amount = { gil: parseInt(amount) };

    this.order.forEach((c) => (amount[c] = amount[c] ?? 0));
    if (!Object.values(amount).find((a) => a > 0)) return this._failed("FFD20.CurrencyInsufficient"), false;

    var sourceCurrency = duplicate(sourceAlt ? sourceDoc?.data.data.altCurrency : sourceDoc?.data.data.currency);
    const destCurrency = duplicate(destAlt ? destDoc.data.data.altCurrency : destDoc.data.data.currency);
    if ((!sourceCurrency && !game.user.isGM) || !destCurrency) return false;
    const originalSource = Object.assign(Object.fromEntries(this.order.map((o) => [o, Infinity])), sourceCurrency);

    const totalAmount = this.order.reduce((acc, c, idx) => acc + amount[c] * 10 ** (1 - idx), 0);
    const totalSource = this.order.reduce((acc, c, idx) => acc + sourceCurrency[c] * 10 ** (1 - idx), 0);

    if (totalAmount > totalSource) return this._failed("FFD20.CurrencyInsufficient"), false;

    if (sourceCurrency) {
      this.order.some((a) => {
        let newSource = sourceCurrency[a] - amount[a];

        if (newSource < 0 && allowConversion) {
          amount = this.convert(originalSource, totalAmount, allowConversion);
          sourceCurrency = Object.fromEntries(this.order.map((o) => [o, originalSource[o] - amount[o]]));
          return true;
        } else sourceCurrency[a] = newSource;
      });
    }

    if (!amount || Object.values(sourceCurrency).find((c) => c < 0)) return false;

    if (!sourceDoc.testUserPermission(game.user, 3) || !destDoc.testUserPermission(game.user, 3)) {
      if (!game.users.find((o) => o.active && o.isGM)) return this._failed("FFD20.CurrencyGMRequired"), false;
      game.socket.emit("system.ffd20", {
        eventType: "currencyTransfer",
        data: {
          sourceActor: sourceDoc.actor?.uuid ?? sourceDoc.uuid,
          destActor: destDoc.actor?.uuid ?? destDoc.uuid,
          sourceContainer: sourceDoc.data.type === "container" ? sourceDoc.id : "",
          destContainer: destDoc.data.type === "container" ? destDoc.id : "",
          sourceAlt: sourceAlt,
          destAlt: destAlt,
          amount: amount,
        },
      });
      return amount;
    }

    this.order.forEach((c) => (destCurrency[c] += amount[c]));
    if (sourceDoc === destDoc)
      return sourceDoc.update({
        "data.altCurrency": sourceAlt ? sourceCurrency : destCurrency,
        "data.currency": destAlt ? sourceCurrency : destCurrency,
      });
    if (sourceAlt) sourceDoc.update({ "data.altCurrency": sourceCurrency });
    else sourceDoc.update({ "data.currency": sourceCurrency });
    if (destAlt) destDoc.update({ "data.altCurrency": destCurrency });
    else destDoc.update({ "data.currency": destCurrency });
    return amount;
  }

  /**
   * Convert totalAmount to a currency object containing
   *
   * @param {object} limit currency object containing max number of coins. Falsey values will assume infinity
   * @param {number|object} totalAmount currency as gil pieces. If provided as a currency object, will convert to gil
   * @returns {boolean|object} false if failed, currency object containing new amounts on conversion success
   */
  static convert(limit, totalAmount) {
    if (!limit) limit = Object.fromEntries(this.order.map((o) => [o, Infinity]));
    else limit = Object.assign({}, limit);
    if (typeof totalAmount !== "number")
      totalAmount = this.order.reduce((acc, cur, idx) => acc + totalAmount?.[cur] * 10 ** (1 - idx));
    if (!totalAmount) return false;
    var amount = {};
    totalAmount =
      this.order.reduce((acc, cur, idx) => {
        let minRequired = Math.min(limit[cur], Math.floor((acc % 10000) / 10 ** (3 - idx))), //Start from left to allow clumping
          inCopper = minRequired * 10 ** (3 - idx);
        amount[cur] = minRequired;
        limit[cur] -= minRequired;
        return acc - inCopper;
      }, totalAmount * 100) / 100; //Operate in copper pieces to avoid floating point errors
    if (totalAmount < 0) return false;
    return amount;
  }
}

/**
 * Extend the basic ActorSheet class to do all the FFD20 things!
 * This sheet is an Abstract layer which is not used.
 *
 * @type {ActorSheet}
 */
class ActorSheetFFD20 extends ActorSheet {
  constructor(...args) {
    super(...args);

    /**
     * The scroll position on the active tab
     *
     * @type {number}
     */
    this._scrollTab = {};
    this._initialTab = {};

    /**
     * Track the set of item filters which are applied
     *
     * @type {Set}
     */
    this._filters = {
      inventory: new Set(),
      "spellbook-primary": new Set(),
      "spellbook-secondary": new Set(),
      "spellbook-tertiary": new Set(),
      "spellbook-quaternary": new Set(),
      "spellbook-spelllike": new Set(),
      features: new Set(),
      buffs: new Set(),
      attacks: new Set(),
      search: {
        inventory: "",
        attacks: "",
        feats: "",
        buffs: "",
        "spellbook-primary": "",
        "spellbook-secondary": "",
        "spellbook-tertiary": "",
        "spellbook-quaternary": "",
        "spellbook-spelllike": "",
      },
    };

    /** Item search */
    this.searchCompositioning = false; // for IME
    this.searchRefresh = true; // Lock out same term search unless sheet also refreshes
    this.searchDelay = 250; // arbitrary ?ms for arbitrarily decent reactivity; MMke this configurable?
    this.searchDelayEvent = null; // setTimeout id
    this.effectiveSearch = {}; // prevent searching the same thing

    /**
     * Track item updates from the actor sheet.
     *
     * @property
     * @private
     * @type {object[]}
     */
    this._itemUpdates = [];

    /**
     * Track hidden elements of the sheet.
     *
     * @property
     */
    this._hiddenElems = {};

    /**
     * Whether a submit has been queued in any way.
     *
     * @property
     */
    this._submitQueued = false;

    /**
     * Whether inner part of this sheet has been rendered already.
     *
     * @property
     */
    this._renderedInner = false;

    /**
     * A dictionary of additional queued updates, to be added on top of the form's data (and cleared afterwards).
     *
     * @property
     * @private
     */
    this._pendingUpdates = {};
  }

  static get defaultOptions() {
    return mergeObject(super.defaultOptions, {
      scrollY: [
        ".inventory-body .inventory-list",
        ".combat-attacks",
        ".spells_primary-body .inventory-list",
        ".spells_secondary-body .inventory-list",
        ".spells_tertiary-body .inventory-list",
        ".spells_quaternary-body .inventory-list",
        ".spells_spelllike-body .inventory-list",
        ".buffs-body .inventory-list",
        ".skillset-body .skills-list.adventure",
        ".skillset-body .skills-list.background",
        ".feats-body",
        ".traits",
        ".actor-notes",
        ".editor-content[data-edit='data.details.biography.value']",
      ],
      dragDrop: [
        { dragSelector: "li.item[data-item-id]" },
        { dragSelector: "label.denomination" },
        { dragSelector: ".race-container.item[data-item-id]" },
        { dragSelector: "li.skill[data-skill]" },
        { dragSelector: "li.sub-skill[data-skill]" },
        { dragSelector: "th.saving-throw[data-savingthrow]" },
        { dragSelector: "th.attribute.cmb[data-attribute]" },
        { dragSelector: "th.attribute.bab[data-attribute]" },
        { dragSelector: "li.generic-defenses[data-drag]" },
        { dragSelector: ".spellcasting-concentration[data-drag]" },
        { dragSelector: ".spellcasting-cl" },
      ],
    });
  }

  /**
   * Returns an object containing feature type specific data relevant to feature organization.
   *
   * @static
   * @type {object.<string, any>}
   */
  static get featTypeData() {
    return {
      template: {
        hasActions: false,
      },
    };
  }

  get currentPrimaryTab() {
    const primaryElem = this.element.find('nav[data-group="primary"] .item.active');
    if (primaryElem.length !== 1) return null;
    return primaryElem.attr("data-tab");
  }

  get currentSpellbookKey() {
    const elems = this.element.find("nav.spellbooks .item.active");
    if (elems.length === 1) return elems.attr("data-tab");
    else return "primary";
  }

  /* -------------------------------------------- */

  /**
   * Add some extra data when rendering the sheet to reduce the amount of logic required within the template.
   *
   * @param options
   */
  async getData(options) {
    let isOwner = this.document.isOwner;
    const data = mergeObject(await super.getData(options), {
      owner: isOwner,
      limited: this.document.limited,
      editable: this.isEditable,
      cssClass: isOwner ? "editable" : "locked",
      isCharacter: this.document.data.type === "character",
      hasRace: false,
      config: CONFIG.FFD20,
      useBGSkills: game.settings.get("ffd20", "allowBackgroundSkills"),
      spellFailure: this.document.spellFailure,
      isGM: game.user.isGM,
      race: this.document.race != null ? this.document.race.data : null,
      usesAnySpellbook: (getProperty(this.document.data, "data.attributes.spells.usedSpellbooks") || []).length > 0,
      sourceData: {},
    });
    data.data = data.data.data;
    const rollData = this.document.getRollData();
    data.rollData = rollData;

    // The Actor and its Items
    if (this.document.isToken) data.token = duplicate(this.document.token.data);
    else data.token = data.actor.token;
    data.items = this.document.items.map((i) => {
      i.data.labels = i.labels;
      i.data.hasAttack = i.hasAttack;
      i.data.hasMultiAttack = i.hasMultiAttack;
      i.data.hasDamage = i.hasDamage;
      i.data.hasRange = i.hasRange;
      i.data.hasEffect = i.hasEffect;
      i.data.hasAction = i.hasAction || i.isCharged || i.getScriptCalls("use").length > 0;
      i.data.showUnidentifiedData = i.showUnidentifiedData;
      if (i.showUnidentifiedData)
        i.data.name =
          getProperty(i.data, "data.unidentified.name") || getProperty(i.data, "data.identifiedName") || i.data.name;
      else i.data.name = getProperty(i.data, "data.identifiedName") || i.data.name;
      return i.data;
    });
    data.items.sort((a, b) => (a.sort || 0) - (b.sort || 0));
    data.labels = this.document.labels || {};
    data.filters = this._filters;

    // Generic melee and ranged attack bonuses, only present for sheet.
    const coreAttack = data.data.attributes.attack.shared + data.data.attributes.attack.general,
      meleeAtkAbl = getProperty(data, `data.abilities.${data.data.attributes.attack.meleeAbility}.mod`),
      rangedAtkAbl = getProperty(data, `data.abilities.${data.data.attributes.attack.rangedAbility}.mod`),
      cmbAbl = getProperty(data, `data.abilities.${data.data.attributes.cmbAbility}.mod`);

    const szCMBMod = CONFIG.FFD20.sizeSpecialMods[data.data.traits.size];

    data.data.attributes.attack.meleeAttackMod = meleeAtkAbl;
    data.data.attributes.attack.rangedAttackMod = rangedAtkAbl;
    data.meleeAttack = coreAttack + data.data.attributes.attack.melee + (meleeAtkAbl ?? 0);
    data.rangedAttack = coreAttack + data.data.attributes.attack.ranged + (rangedAtkAbl ?? 0);
    data.data.attributes.attack.meleeAttackLabel = CONFIG.FFD20.abilities[data.data.attributes.attack.meleeAbility];
    data.data.attributes.attack.rangedAttackLabel = CONFIG.FFD20.abilities[data.data.attributes.attack.rangedAbility];
    data.cmbAttack = coreAttack + szCMBMod + szCMBMod + data.data.attributes.cmb.total + (cmbAbl ?? 0);

    // Add inventory value
    {
      const gilValue = this.calculateTotalItemValue();
      const totalValue = {
        gil: Math.max(0, Math.floor(gilValue)),
        sgil: Math.max(0, Math.floor(gilValue * 10 - Math.floor(gilValue) * 10)),
        cgil: Math.max(
          0,
          Math.floor(
            Math.floor(gilValue * 100 - Math.floor(gilValue) * 100) -
              Math.floor(gilValue * 10 - Math.floor(gilValue) * 10) * 10
          )
        ),
      };
      data.labels.totalValue = game.i18n
        .localize("FFD20.ItemContainerTotalItemValue")
        .format(totalValue.gil, totalValue.sgil, totalValue.cgil);
    }

    // Race type label
    if (data.race) {
      data.raceLabel = CONFIG.FFD20.creatureTypes[data.race.data.creatureType];
      const subTypes = data.race.data.subTypes;
      if (subTypes && subTypes.length) {
        data.raceLabel = `${data.raceLabel} (${subTypes.join(", ")})`;
      }
    }

    // Hit point sources
    if (this.document.sourceDetails != null) data.sourceDetails = expandObject(this.document.sourceDetails);
    else data.sourceDetails = null;

    // Ability Scores
    for (let [a, abl] of Object.entries(data.data.abilities)) {
      abl.label = CONFIG.FFD20.abilities[a];
      abl.sourceDetails = data.sourceDetails != null ? data.sourceDetails.data.abilities[a].total : [];
      abl.totalLabel = abl.total == null ? "-" : abl.total;
    }

    // Armor Class
    for (let [a, ac] of Object.entries(data.data.attributes.ac)) {
      ac.label = CONFIG.FFD20.ac[a];
      ac.valueLabel = CONFIG.FFD20.acValueLabels[a];
      ac.sourceDetails = data.sourceDetails != null ? data.sourceDetails.data.attributes.ac[a].total : [];
    }

    // Saving Throws
    for (let [a, savingThrow] of Object.entries(data.data.attributes.savingThrows)) {
      savingThrow.label = CONFIG.FFD20.savingThrows[a];
      savingThrow.sourceDetails =
        data.sourceDetails != null ? data.sourceDetails.data.attributes.savingThrows[a].total : [];
    }

    // Update skill labels
    const acp = getProperty(this.document.data, "data.attributes.acp.total");
    for (let [s, skl] of Object.entries(data.data.skills)) {
      skl.label = CONFIG.FFD20.skills[s];
      skl.arbitrary = CONFIG.FFD20.arbitrarySkills.includes(s);
      skl.sourceDetails = [];
      skl.compendiumEntry = CONFIG.FFD20.skillCompendiumEntries[s] ?? null;

      // Add skill rank source
      if (skl.rank > 0) {
        skl.sourceDetails.push({ name: game.i18n.localize("FFD20.SkillRankPlural"), value: skl.rank });

        // Add class skill bonus source
        if (skl.cs) {
          skl.sourceDetails.push({ name: game.i18n.localize("FFD20.CSTooltip"), value: 3 });
        }
      }

      // Add ACP source
      if (skl.acp && acp > 0) {
        skl.sourceDetails.push({ name: game.i18n.localize("FFD20.ACPLong"), value: -acp });
      }

      // Add ability modifier source
      skl.sourceDetails.push({
        name: CONFIG.FFD20.abilities[skl.ability],
        value: data.data.abilities[skl.ability].mod,
      });

      // Add misc skill bonus source
      if (data.sourceDetails != null && data.sourceDetails.data.skills[s] != null) {
        skl.sourceDetails = skl.sourceDetails.concat(data.sourceDetails.data.skills[s].changeBonus);
      }

      // Subtract energy drain
      {
        const energyDrain = getProperty(data.data, "data.attributes.energyDrain");
        if (energyDrain) {
          skl.sourceDetails.push({
            name: game.i18n.localize("FFD20.CondTypeEnergyDrain"),
            value: -Math.abs(energyDrain),
          });
        }
      }

      skl.untrained = skl.rt === true && skl.rank <= 0;
      if (skl.subSkills != null) {
        for (let [s2, skl2] of Object.entries(skl.subSkills)) {
          skl2.sourceDetails = [];
          if (skl2.rank > 0) {
            skl2.sourceDetails.push({ name: game.i18n.localize("FFD20.SkillRankPlural"), value: skl2.rank });
            if (skl2.cs) {
              skl2.sourceDetails.push({ name: game.i18n.localize("FFD20.CSTooltip"), value: 3 });
            }
          }
          skl2.sourceDetails.push({
            name: CONFIG.FFD20.abilities[skl2.ability],
            value: data.data.abilities[skl2.ability].mod,
          });
          if (
            data.sourceDetails != null &&
            data.sourceDetails.data.skills[s] != null &&
            data.sourceDetails.data.skills[s].subSkills != null &&
            data.sourceDetails.data.skills[s].subSkills[s2] != null
          ) {
            skl2.sourceDetails = skl2.sourceDetails.concat(data.sourceDetails.data.skills[s].subSkills[s2].changeBonus);
          }
          skl2.untrained = skl2.rt === true && skl2.rank <= 0;
        }
      }
    }

    // Update spellbook info
    for (let [k, spellbook] of Object.entries(getProperty(data.data, "attributes.spells.spellbooks"))) {
      setProperty(
        data.data,
        `attributes.spells.spellbooks.${k}.inUse`,
        (getProperty(data.data, "attributes.spells.usedSpellbooks") || []).includes(k)
      );
    }

    // Control items
    data.items
      .filter((obj) => {
        return obj.type === "spell";
      })
      .forEach((obj) => {
        obj.isPrepared = obj.data.preparation.mode === "prepared";
      });

    // Update traits
    this._prepareTraits(data.data.traits);

    // Prepare owned items
    this._prepareItems(data);

    // Compute encumbrance
    data.encumbrance = this._computeEncumbrance(data);

    // Prepare skillsets
    data.skillsets = this._prepareSkillsets(data.data.skills);

    // Skill rank counting
    const skillRanks = { allowed: 0, used: 0, bgAllowed: 0, bgUsed: 0, sentToBG: 0 };
    // Count used skill ranks
    for (let skl of Object.values(data.data.skills)) {
      if (skl.subSkills != null) {
        for (let subSkl of Object.values(skl.subSkills)) {
          if (data.useBGSkills && skl.background) {
            skillRanks.bgUsed += subSkl.rank;
          } else {
            skillRanks.used += subSkl.rank;
          }
        }
      } else if (data.useBGSkills && skl.background) {
        skillRanks.bgUsed += skl.rank;
      } else {
        skillRanks.used += skl.rank;
      }
    }
    // Count allowed skill ranks
    const sourceData = getSourceInfo(this.document.sourceInfo, "data.skillRanks").positive;
    setProperty(data.sourceData, "skillRanks", sourceData);
    this.document.data.items
      .filter((obj) => {
        return obj.type === "class" && obj.data.data.classType !== "mythic";
      })
      .forEach((cls) => {
        const clsLevel = cls.data.data.level;
        const clsSkillsPerLevel = cls.data.data.skillsPerLevel;
        const fcSkills = cls.data.data.fc.skill.value;
        skillRanks.allowed +=
          Math.max(1, clsSkillsPerLevel + this.document.data.data.abilities.int.mod) * clsLevel + fcSkills;
        if (data.useBGSkills && ["base", "prestige"].includes(cls.data.data.classType))
          skillRanks.bgAllowed += clsLevel * 2;

        sourceData.push({
          name: game.i18n.format("FFD20.SourceInfoSkillRank_ClassBase", { className: cls.name }),
          value: clsSkillsPerLevel * clsLevel,
        });
        if (fcSkills > 0) {
          sourceData.push({
            name: game.i18n.format("FFD20.SourceInfoSkillRank_ClassFC", { className: cls.name }),
            value: fcSkills,
          });
        }
      });
    // Count from intelligence
    if (getProperty(this.actor.data, "data.abilities.int.mod") !== 0) {
      sourceData.push({
        name: game.i18n.localize("FFD20.AbilityInt"),
        value:
          getProperty(this.actor.data, "data.abilities.int.mod") *
          getProperty(this.actor.data, "data.attributes.hd.total"),
      });
    }
    // Count from bonus skill rank formula
    if (this.actor.data.data.details.bonusSkillRankFormula !== "") {
      let roll = RollFFD20.safeRoll(this.actor.data.data.details.bonusSkillRankFormula, rollData);
      if (roll.err) console.error(`An error occurred in the Bonus Skill Rank formula of actor ${this.actor.name}.`);
      skillRanks.allowed += roll.total;
      sourceData.push({
        name: game.i18n.localize("FFD20.SkillBonusRankFormula"),
        value: roll.total,
      });
    }
    // Calculate from changes
    this.actor.changes
      .filter((o) => o.subTarget === "bonusSkillRanks")
      .forEach((o) => {
        if (!o.value) return;

        skillRanks.allowed += o.value;
        sourceData.push({
          name: o.parent ? o.parent.name : game.i18n.localize("FFD20.Change"),
          value: o.value,
        });
      });
    // Calculate used background skills
    if (data.useBGSkills) {
      if (skillRanks.bgUsed > skillRanks.bgAllowed) {
        skillRanks.sentToBG = skillRanks.bgUsed - skillRanks.bgAllowed;
        skillRanks.allowed -= skillRanks.sentToBG;
        skillRanks.bgAllowed += skillRanks.sentToBG;
      }
    }
    data.skillRanks = skillRanks;

    // Feat count
    {
      const sourceData = [];
      setProperty(data.sourceData, "bonusFeats", sourceData);

      // Feat count
      // By level
      data.featCount = {};
      data.featCount.value = this.actor.items.filter(
        (o) => o.type === "feat" && o.data.data.featType === "feat" && !o.data.data.disabled
      ).length;
      const totalLevels = this.document.items
        .filter((o) => o.type === "class" && ["base", "npc", "prestige", "racial"].includes(o.data.data.classType))
        .reduce((cur, o) => {
          return cur + o.data.data.level;
        }, 0);
      data.featCount.byLevel = Math.ceil(totalLevels / 2);
      sourceData.push({
        name: game.i18n.localize("FFD20.Level"),
        value: data.featCount.byLevel,
      });

      // Bonus feat formula
      const featCountRoll = RollFFD20.safeRoll(this.document.data.data.details.bonusFeatFormula || "0", rollData);
      const changes = this.document.changes.filter((c) => c.subTarget === "bonusFeats");
      const changeBonus = getHighestChanges(
        changes.filter((c) => {
          c.applyChange(this.document);
          if (c.parent || c.flavor) {
            sourceData.push({
              name: c.parent?.name ?? c.flavor,
              value: c.value,
            });
          }
          return !["set", "="].includes(c.operator);
        }),
        { ignoreTarget: true }
      ).reduce((cur, c) => {
        return cur + c.value;
      }, 0);
      data.featCount.byFormula = featCountRoll.total + changeBonus;
      if (featCountRoll.err) {
        const msg = game.i18n
          .localize("FFD20.ErrorActorFormula")
          .format(game.i18n.localize("FFD20.BonusFeatFormula"), this.document.name);
        console.error(msg);
        ui.notifications.error(msg);
      }
      if (featCountRoll.total !== 0) {
        sourceData.push({
          name: game.i18n.localize("FFD20.BonusFeatFormula"),
          value: featCountRoll.total,
        });
      }

      // Count total
      data.featCount.total = data.featCount.byLevel + data.featCount.byFormula;
    }

    // Fetch the game settings relevant to sheet rendering.
    {
      const actorType = { character: "pc", npc: "npc" }[this.document.data.type];
      data.healthConfig = game.settings.get("ffd20", "healthConfig");
      data.useWoundsAndVigor = data.healthConfig.variants[actorType].useWoundsAndVigor;
    }

    // Get classes
    data.data.classes = rollData.classes;

    // Determine hidden elements
    this._prepareHiddenElements();
    data.hiddenElems = this._hiddenElems;

    // Create a table of magic items
    {
      const magicItems = this.document.items
        .filter((o) => {
          if (o.showUnidentifiedData) return false;
          if (!o.data.data.carried) return false;

          const school = getProperty(o.data, "data.aura.school");
          const cl = getProperty(o.data, "data.cl");
          return typeof school === "string" && school.length > 0 && typeof cl === "number" && cl > 0;
        })
        .map((o) => {
          const data = {};

          data.name = o.name;
          data.img = o.img;
          data.id = o.id;
          data.cl = getProperty(o.data, "data.cl");
          data.school = getProperty(o.data, "data.aura.school");
          if (CONFIG.FFD20.spellSchools[data.school] != null) {
            data.school = CONFIG.FFD20.spellSchools[data.school];
          }
          data.school = `${CONFIG.FFD20.auraStrengths[o.auraStrength]} <b>${data.school}</b>`;
          data.identifyDC = 15 + data.cl;
          {
            const quantity = getProperty(o.data, "data.quantity") || 0;
            if (quantity > 1) data.quantity = quantity;
          }
          data.identified = getProperty(o.data, "data.identified") === true;

          return data;
        });
      if (magicItems.length > 0) {
        data.table_magicItems = await renderTemplate("systems/ffd20/templates/internal/table_magic-items.hbs", {
          items: magicItems,
          isGM: game.user.isGM,
        });
      }
    }

    // Prepare (interactive) labels
    {
      data.labels.firstClass = game.i18n
        .localize("FFD20.Info_FirstClass")
        .format(
          `<a data-action="compendium" data-action-target="classes" title="${game.i18n.localize(
            "FFD20.OpenCompendium"
          )}">${game.i18n.localize("FFD20.Info_FirstClass_Compendium")}</a>`
        )
        .replace(/[\n\r]+/, "<br>");
    }

    // Return data to the sheet
    return data;
  }

  /* -------------------------------------------- */

  _prepareHiddenElements() {
    // Hide spellbook info
    const spellbooks = getProperty(this.document.data, "data.attributes.spells.spellbooks");
    for (let k of Object.keys(spellbooks)) {
      const key = `spellbook-info_${k}`;
      if (this._hiddenElems[key] == null) this._hiddenElems[key] = true;
    }
  }

  _prepareTraits(traits) {
    const map = {
      // "dr": CONFIG.FFD20.damageTypes,
      di: CONFIG.FFD20.damageTypes,
      dv: CONFIG.FFD20.damageTypes,
      ci: CONFIG.FFD20.conditionTypes,
      languages: CONFIG.FFD20.languages,
      armorProf: CONFIG.FFD20.armorProf,
      weaponProf: CONFIG.FFD20.weaponProf,
    };
    for (let [t, choices] of Object.entries(map)) {
      const trait = traits[t];
      if (!trait) continue;
      let values = [];
      // Prefer total over value for dynamically collected proficiencies
      if (["armorProf", "weaponProf", "languages"].includes(t)) {
        values = trait.total ?? trait.value;
      } else if (trait.value) {
        values = trait.value instanceof Array ? trait.value : [trait.value];
      }
      trait.selected = values.reduce((obj, t) => {
        obj[t] = choices[t];
        return obj;
      }, {});

      // Prefer total over value for dynamically collected proficiencies
      if (trait.customTotal) {
        trait.customTotal
          .split(CONFIG.FFD20.re.traitSeparator)
          .forEach((c, i) => (trait.selected[`custom${i + 1}`] = c.trim()));
      } else if (trait.custom) {
        // Add custom entry
        trait.custom
          .split(CONFIG.FFD20.re.traitSeparator)
          .forEach((c, i) => (trait.selected[`custom${i + 1}`] = c.trim()));
      }
      trait.cssClass = !isObjectEmpty(trait.selected) ? "" : "inactive";
    }
  }

  /* -------------------------------------------- */

  /**
   * Insert a spell into the spellbook object when rendering the character sheet
   *
   * @param {object} data     The Actor data being prepared
   * @param {Array} spells    The spell data being prepared
   * @param {string} bookKey  The key of the spellbook being prepared
   * @private
   */
  _prepareSpellbook(data, spells, bookKey) {
    const owner = this.document.isOwner;
    const book = this.document.data.data.attributes.spells.spellbooks[bookKey];

    let min = 0;
    let max = 9;
    if (book.autoSpellLevelCalculation) {
      min = book.hasCantrips ? 0 : 1;

      const cl = book.cl.autoSpellLevelTotal;

      const castsPerDay = CONFIG.FFD20.casterProgression.castsPerDay[book.spellPreparationMode][book.casterType][cl - 1];
      max = castsPerDay.length - 1;
    }

    // Reduce spells to the nested spellbook structure
    let spellbook = {};
    for (let a = 0; a < 10; a++) {
      if (!isNaN(getProperty(book, `spells.spell${a}.max`))) {
        spellbook[a] = {
          level: a,
          usesSlots: true,
          spontaneous: book.spontaneous,
          canCreate: owner === true,
          canPrepare: data.actor.type === "character",
          label: CONFIG.FFD20.spellLevels[a],
          items: [],
          uses: getProperty(book, `spells.spell${a}.value`) || 0,
          baseSlots: getProperty(book, `spells.spell${a}.base`) || 0,
          slots: getProperty(book, `spells.spell${a}.max`) || 0,
          dataset: { type: "spell", level: a, spellbook: bookKey },
          name: game.i18n.localize(`FFD20.SpellLevel${a}`),
          spellMessage: getProperty(book, `spells.spell${a}.spellMessage`),
        };
      }
    }
    spells.forEach((spell) => {
      const spellBookKey = getProperty(spell, "data.spellbook");
      if (spellBookKey === bookKey) {
        const lvl = spell.data.level ?? min;
        spellbook[lvl]?.items.push(spell);
      }
    });

    for (let a = 0; a < 10; a++) {
      if (spellbook[a]?.items.length === 0 && (a > max || a < min)) delete spellbook[a];
    }

    return spellbook;
  }

  _prepareSkillsets(skillset) {
    let result = {
      all: { skills: {} },
      adventure: { skills: {} },
      background: { skills: {} },
    };

    // sort skills by label
    let keys = Object.keys(skillset).sort(function (a, b) {
      if (skillset[a].custom && !skillset[b].custom) return 1;
      if (!skillset[a].custom && skillset[b].custom) return -1;
      return ("" + skillset[a].label).localeCompare(skillset[b].label);
    });

    keys.forEach((a) => {
      let skl = skillset[a];
      result.all.skills[a] = skl;
      if (skl.background) result.background.skills[a] = skl;
      else result.adventure.skills[a] = skl;
    });

    return result;
  }

  /**
   * Returns the amount of type filters currently active.
   *
   * @param filters
   * @returns {number}
   * @private
   */
  _typeFilterCount(filters) {
    return Array.from(filters).filter((s) => s.startsWith("type-")).length;
  }

  /* -------------------------------------------- */

  /**
   * Determine whether an Owned Item will be shown based on the current set of filters
   *
   * @param items
   * @param filters
   * @returns {boolean}
   * @private
   */
  _filterItems(items, filters) {
    const hasTypeFilter = this._typeFilterCount(filters) > 0;

    return items.filter((item) => {
      const data = item.data;

      // Action usage
      for (let f of ["action", "bonus", "reaction"]) {
        if (filters.has(f)) {
          if (data.activation && data.activation.type !== f) return false;
        }
      }

      if (filters.has("prepared")) {
        if (data.level === 0 || ["pact", "innate"].includes(data.preparation.mode)) return true;
        if (this.document.data.type === "npc") return true;
        return data.preparation.prepared;
      }

      // Equipment-specific filters
      if (filters.has("equipped")) {
        if (data.equipped && data.equipped !== true) return false;
      }

      // Whether active
      if (filters.has("active")) {
        if (!data.active) return false;
      }

      if (item.type === "feat") {
        if (hasTypeFilter && !filters.has(`type-${data.featType}`)) return false;
      }

      if (ItemFFD20.isInventoryItem(item.type)) {
        if (hasTypeFilter && item.type !== "loot" && !filters.has(`type-${item.type}`)) return false;
        else if (hasTypeFilter && item.type === "loot" && !filters.has(`type-${data.subType}`)) return false;
      }

      if (item.type === "spell") {
        if (hasTypeFilter && !filters.has(`type-${data.level}`)) return false;
      }

      if (item.type === "buff") {
        if (hasTypeFilter && !filters.has(`type-${data.buffType}`)) return false;
      }

      if (item.type === "attack") {
        if (hasTypeFilter && !filters.has(`type-${data.attackType}`)) return false;
      }

      return true;
    });
  }

  /* -------------------------------------------- */

  /**
   * Compute the level and percentage of encumbrance for an Actor.
   *
   * @param {object} actorData      The data object for the Actor being rendered
   * @returns {object}               An object describing the character's encumbrance level
   * @private
   */
  _computeEncumbrance(actorData) {
    const carriedWeight = actorData.data.attributes.encumbrance.carriedWeight;
    const load = {
      light: actorData.data.attributes.encumbrance.levels.light,
      medium: actorData.data.attributes.encumbrance.levels.medium,
      heavy: actorData.data.attributes.encumbrance.levels.heavy,
    };
    let carryLabel;
    let usystem = game.settings.get("ffd20", "weightUnits"); // override
    if (usystem === "default") usystem = game.settings.get("ffd20", "units");
    switch (usystem) {
      case "metric":
        carryLabel = game.i18n.localize("FFD20.CarryLabelKg").format(carriedWeight);
        break;
      default:
        carryLabel = game.i18n.localize("FFD20.CarryLabel").format(carriedWeight);
        break;
    }
    const enc = {
      pct: {
        light: Math.max(0, Math.min((carriedWeight * 100) / load.light, 99.5)),
        medium: Math.max(0, Math.min(((carriedWeight - load.light) * 100) / (load.medium - load.light), 99.5)),
        heavy: Math.max(0, Math.min(((carriedWeight - load.medium) * 100) / (load.heavy - load.medium), 99.5)),
      },
      encumbered: {
        light: actorData.data.attributes.encumbrance.level >= 1,
        medium: actorData.data.attributes.encumbrance.level >= 2,
        heavy:
          actorData.data.attributes.encumbrance.carriedWeight >= actorData.data.attributes.encumbrance.levels.heavy,
      },
      light: actorData.data.attributes.encumbrance.levels.light,
      medium: actorData.data.attributes.encumbrance.levels.medium,
      heavy: actorData.data.attributes.encumbrance.levels.heavy,
      aboveHead: actorData.data.attributes.encumbrance.levels.heavy,
      offGround: actorData.data.attributes.encumbrance.levels.heavy * 2,
      dragPush: actorData.data.attributes.encumbrance.levels.heavy * 5,
      value: actorData.data.attributes.encumbrance.carriedWeight,
      carryLabel: carryLabel,
    };

    return enc;
  }

  /* -------------------------------------------- */
  /*  Event Listeners and Handlers
  /* -------------------------------------------- */

  /**
   * Activate event listeners using the prepared sheet HTML
   *
   * @param html {HTML}   The prepared HTML object ready to be rendered into the DOM
   */
  activateListeners(html) {
    super.activateListeners(html);

    this.createTabs(html);

    // Tooltips
    html.mousemove((ev) => this._moveTooltips(ev));

    // Remove default change handler
    html.off("change");
    // Add alternative change handler
    html.find("input,select,textarea").on("change", this._onChangeInput.bind(this));

    // Add general text box (span) handler
    html.find("span.text-box.direct").on("click", (event) => {
      this._onSpanTextInput(event, this._adjustActorPropertyBySpan.bind(this));
    });

    // Activate Item Filters
    const filterLists = html.find(".filter-list");
    filterLists.each(this._initializeFilterItemList.bind(this));
    filterLists.on("click", ".filter-item", this._onToggleFilter.bind(this));

    // Search boxes
    {
      const sb = html.find(".search-input");
      sb.on("keyup change", this._searchFilterChange.bind(this));
      sb.on("compositionstart compositionend", this._searchFilterCompositioning.bind(this)); // for IME
      this.searchRefresh = true;
      // Filter tabs on followup refreshes
      sb.each(function () {
        if (this.value.length > 0) $(this).change();
      });
      html.find(".clear-search").on("click", this._clearSearch.bind(this));
    }

    // Item summaries
    html.find(".item .item-name h4").click((event) => this._onItemSummary(event));

    // Click to change text input
    html.find('*[data-action="input-text"]').click((event) => this._onInputText(event));
    html
      .find('*[data-action="input-text"].wheel-change')
      .on("wheel", (event) => this._onInputText(event.originalEvent));

    // Everything below here is only needed if the sheet is editable
    if (!this.options.editable) return;

    // Trigger form submission from textarea elements.
    html.find("textarea").change(this._onSubmit.bind(this));

    // Show configureable fields
    html.find(".config .config-control").click(this._onConfigControl.bind(this));

    // Select the whole text on click
    html.find(".select-on-click").click(this._selectOnClick.bind(this));

    // Submit on blur
    html.find(".submit-on-blur").on("blur", async (ev) => {
      await this._onSubmit(ev, { preventRender: true });
      this.render();
    });

    /* -------------------------------------------- */
    /*  Abilities, Skills, Defenses and Traits
    /* -------------------------------------------- */

    // Submit hit points
    html.find('input[name="data.attributes.hp.value"]').keypress(this._onSubmitElement.bind(this));

    // Submit mana points
    html.find('input[name="data.attributes.mp.value"]').keypress(this._onSubmitElement.bind(this));

    // Ability Checks
    html.find(".ability-name").click(this._onRollAbilityTest.bind(this));

    // BAB Check
    html.find(".attribute.bab .rollable").click(this._onRollBAB.bind(this));

    // CMB Check
    html.find(".attribute.cmb .rollable").click(this._onRollCMB.bind(this));

    // Attack check
    html.find(".attribute.attack.melee .rollable").click(this._onRollMelee.bind(this));
    html.find(".attribute.attack.ranged .rollable").click(this._onRollRanged.bind(this));

    // Initiative Check
    html.find(".attribute.initiative .rollable").click(this._onRollInitiative.bind(this));

    // Saving Throw
    html.find(".saving-throw .rollable").click(this._onRollSavingThrow.bind(this));

    // Adjust skill rank
    html.find("span.text-box.skill-rank").on("click", (event) => {
      this._onSpanTextInput(event, this._adjustActorPropertyBySpan.bind(this));
    });

    // Add arbitrary skill
    html.find(".skill.arbitrary .skill-create").click((ev) => this._onArbitrarySkillCreate(ev));

    // Delete arbitrary skill
    html.find(".sub-skill > .skill-controls > .skill-delete").click((ev) => this._onArbitrarySkillDelete(ev));

    // Add custom skill
    html.find(".skill-controls.skills .skill-create").click((ev) => this._onSkillCreate(ev));

    // Delete custom skill
    html.find(".skill > .skill-controls > .skill-delete").click((ev) => this._onSkillDelete(ev));

    // Quick Item Action control
    html.find(".item-actions a").mouseup((ev) => this._quickItemActionControl(ev));

    // Roll Skill Checks
    html.find(".skill > .skill-name > .rollable").click(this._onRollSkillCheck.bind(this));
    html.find(".sub-skill > .skill-name > .rollable").click(this._onRollSubSkillCheck.bind(this));

    // Open skill compendium entry
    html.find("a.compendium-entry").click(this._onOpenCompendiumEntry.bind(this));

    // Trait Selector
    html.find(".trait-selector").click(this._onTraitSelector.bind(this));

    // Roll defenses
    html.find(".generic-defenses .rollable").click((ev) => {
      this.document.rollDefenses();
    });

    // Rest
    html.find(".rest").click(this._onRest.bind(this));

    // Race controls
    html.find(".race-container .item-control").click(this._onRaceControl.bind(this));

    // Point Buy Calculator
    html.find("button.pointbuy-calculator").click(this._onPointBuyCalculator.bind(this));

    // Alignment
    html.find(".control.alignment").click(this._onControlAlignment.bind(this));

    // Quick edit race item
    html.find(".race").each((i, el) => {
      if (el.closest(".item").dataset?.itemId) el.addEventListener("contextmenu", (ev) => this._onItemEdit(ev));
    });
    /* -------------------------------------------- */
    /*  Inventory
    /* -------------------------------------------- */

    // Owned Item management
    html.find(".item-create").click((ev) => this._onItemCreate(ev));
    html.find(".item-edit").click(this._onItemEdit.bind(this));
    html.find(".item-delete").click(this._onItemDelete.bind(this));
    html.find(".item-give").click(this._onItemGive.bind(this));

    // Quick edit item
    html.find(".item .item-name h4").contextmenu(this._onItemEdit.bind(this));

    // Item Rolling
    html.find(".item .item-image").click((event) => this._onItemRoll(event));

    // Quick add item quantity
    html.find("a.item-control.item-quantity-add").click((ev) => {
      this._quickChangeItemQuantity(ev, 1);
    });
    // Quick subtract item quantity
    html.find("a.item-control.item-quantity-subtract").click((ev) => {
      this._quickChangeItemQuantity(ev, -1);
    });

    // Quick (un)equip item
    html.find("a.item-control.item-equip").click((ev) => {
      this._quickEquipItem(ev);
    });

    // Quick carry item
    html.find("a.item-control.item-carry").click((ev) => {
      this._quickCarryItem(ev);
    });

    // Quick (un)identify item
    html.find("a.item-control.item-identify").click((ev) => {
      this._quickIdentifyItem(ev);
    });

    // Quick toggle item property
    html.find("a.item-control.item-toggle-data").click(this._itemToggleData.bind(this));

    // Duplicate item
    html.find("a.item-control.item-duplicate").click(this._duplicateItem.bind(this));

    // Quick Action
    html.find(".quick-actions li").click(this._quickAction.bind(this));

    // Convert currency
    html.find("a.convert-currency").click(this._convertCurrency.bind(this));

    // Set item charges
    html
      .find(".inventory-body .item-uses span.text-box.value")
      .on("wheel", this._setFeatUses.bind(this))
      .on("click", (event) => {
        this._onSpanTextInput(event, this._setFeatUses.bind(this));
      });

    // Set attack charges
    html
      .find(".attacks-body .item-uses span.text-box.value")
      .on("wheel", this._setFeatUses.bind(this))
      .on("click", (event) => {
        this._onSpanTextInput(event, this._setFeatUses.bind(this));
      });

    /* -------------------------------------------- */
    /*  Feats
    /* -------------------------------------------- */

    html
      .find(".feats-body .item-uses span.text-box.value")
      .on("wheel", this._setFeatUses.bind(this))
      .on("click", (event) => {
        this._onSpanTextInput(event, this._setFeatUses.bind(this));
      });

    /* -------------------------------------------- */
    /*  Classes
    /* -------------------------------------------- */

    // Level Up
    html.find(".level-up").click(this._onLevelUp.bind(this));

    /* -------------------------------------------- */
    /*  Spells
    /* -------------------------------------------- */

    // Set specific spell's (max) uses
    html
      .find(".item-list .spell-uses span.text-box[data-type='amount']")
      .on("wheel", this._setSpellUses.bind(this))
      .on("click", (event) => {
        this._onSpanTextInput(event, this._setSpellUses.bind(this));
      });
    html
      .find(".item-list .spell-uses span.text-box[data-type='max']")
      .on("wheel", this._setMaxSpellUses.bind(this))
      .on("click", (event) => {
        this._onSpanTextInput(event, this._setMaxSpellUses.bind(this));
      });

    // Set spell level uses for spontaneous spellbooks
    html
      .find(".spell-uses .spell-slots.spontaneous span.text-box")
      .on("wheel", this._adjustActorPropertyBySpan.bind(this))
      .on("click", (event) => {
        this._onSpanTextInput(event, this._adjustActorPropertyBySpan.bind(this));
      });
    // Set base amount of spell uses for a given spell level
    html.find(".spell-uses .spell-max span.text-box").on("click", (event) => {
      this._onSpanTextInput(event, this._onSubmit.bind(this));
    });

    // Set spell point amount
    html
      .find(".spell-points-current .value span.text-box")
      .on("wheel", this._adjustActorPropertyBySpan.bind(this))
      .on("click", (event) => {
        this._onSpanTextInput(event, this._adjustActorPropertyBySpan.bind(this));
      });

    html.find(".spellcasting-concentration .rollable").click(this._onRollConcentration.bind(this));

    html.find(".spellcasting-cl .rollable").click(this._onRollCL.bind(this));

    /* -------------------------------------------- */
    /*  Buffs
    /* -------------------------------------------- */

    html
      .find(".item-detail.item-active input[type='checkbox']")
      .off("change")
      .on("change", this._setItemActive.bind(this));

    html
      .find(".item-detail.item-level span.text-box")
      .on("wheel", this._setBuffLevel.bind(this))
      .on("click", (event) => {
        this._onSpanTextInput(event, this._setBuffLevel.bind(this));
      });

    html.find("a.hide-show").click(this._hideShowElement.bind(this));

    // Toggle condition
    html.find(".condition .checkbox").click(this._onToggleCondition.bind(this));

    /* -------------------------------------------- */
    /*  Skills
    /* -------------------------------------------- */

    html.find(".skill-lock-button").click(this._onToggleSkillLock.bind(this)).addClass("unlocked").click();

    /* -------------------------------------------- */
    /*  Links
    /* -------------------------------------------- */

    html.find('a[data-action="compendium"]').click(this._onOpenCompendium.bind(this));
  }

  createTabs(html) {
    const tabGroups = {
      primary: {
        subdetails: {},
        skillset: {},
        spellbooks: {},
      },
    };
    this._tabsAlt = createTabs.call(this, html, tabGroups, this._tabsAlt);
  }

  /* -------------------------------------------- */

  _onSpanTextInput(event, callback = null) {
    const el = event.currentTarget;
    const parent = el.parentElement;

    // Replace span element with an input (text) element
    const newEl = document.createElement(`INPUT`);
    newEl.type = "text";
    if (el.dataset?.dtype) newEl.dataset.dtype = el.dataset.dtype;

    // Set value of new input element
    let prevValue = el.innerText;
    if (el.classList.contains("placeholder")) prevValue = "";

    const name = el.getAttribute("name");
    let maxValue;
    if (name) {
      newEl.setAttribute("name", name);
      prevValue = getProperty(this.document.data, name);
      if (prevValue && typeof prevValue !== "string") prevValue = prevValue.toString();

      if (name.endsWith(".value")) {
        const maxName = name.replace(/\.value$/, ".max");
        maxValue = getProperty(this.document.data, maxName);
      }
    }
    newEl.value = prevValue;

    // Toggle classes
    const forbiddenClasses = ["placeholder", "direct", "allow-relative"];
    for (let cls of el.classList) {
      if (!forbiddenClasses.includes(cls)) newEl.classList.add(cls);
    }

    // Replace span with input element
    const allowRelative = el.classList.contains("allow-relative");
    parent.replaceChild(newEl, el);
    let changed = false;
    if (callback) {
      newEl.addEventListener("change", (...args) => {
        changed = true;
        if (allowRelative) {
          let number = adjustNumberByStringCommand(parseFloat(prevValue), newEl.value, maxValue);
          newEl.value = number;
        }

        if (newEl.value === prevValue) {
          this._render();
        } else {
          callback.call(this, ...args);
        }
      });
    }
    newEl.addEventListener("focusout", (event) => {
      if (!changed) {
        this._render();
      }
    });

    // Select text inside new element
    newEl.focus();
    newEl.select();
  }

  _moveTooltips(event) {
    const elem = $(event.currentTarget);
    const x = event.clientX;
    const y = event.clientY + 24;
    elem.find(".tooltip:hover .tooltipcontent").css("left", `${x}px`).css("top", `${y}px`);
  }

  _onDragSkillStart(event) {
    const elem = event.currentTarget;
    let skillElem = elem.closest(".sub-skill");
    let mainSkill = null;
    let subSkill = null;
    let isSubSkill = true;
    if (!skillElem) {
      skillElem = elem.closest(".skill");
      isSubSkill = false;
    }
    if (!skillElem) return;

    if (isSubSkill) {
      mainSkill = skillElem.dataset.mainSkill;
      subSkill = skillElem.dataset.skill;
    } else {
      mainSkill = skillElem.dataset.skill;
    }

    const result = {
      type: "skill",
      actor: this.document.id,
      skill: subSkill ? `${mainSkill}.subSkills.${subSkill}` : mainSkill,
    };
    if (this.document.isToken) {
      result.sceneId = canvas.scene.id;
      result.tokenId = this.document.token.id;
    }

    event.dataTransfer.setData("text/plain", JSON.stringify(result));
  }

  _onDragMiscStart(event, type) {
    const result = {
      type: type,
      actor: this.document.id,
    };
    if (this.document.isToken) {
      result.sceneId = canvas.scene.id;
      result.tokenId = this.document.token.id;
    }

    switch (type) {
      case "concentration":
      case "cl": {
        const elem = event.currentTarget.closest(".tab.spellbook-group");
        result.altType = elem.dataset.tab;
        break;
      }
    }

    event.dataTransfer.setData("text/plain", JSON.stringify(result));
  }

  _onDragSaveStart(event, type) {
    const result = {
      type: "save",
      altType: type,
      actor: this.document.id,
    };
    if (this.document.isToken) {
      result.sceneId = canvas.scene.id;
      result.tokenId = this.document.token.id;
    }

    event.dataTransfer.setData("text/plain", JSON.stringify(result));
  }

  /**
   * Initialize Item list filters by activating the set of filters which are currently applied
   *
   * @param i
   * @param ul
   * @private
   */
  _initializeFilterItemList(i, ul) {
    const set = this._filters[ul.dataset.filter];
    const filters = ul.querySelectorAll(".filter-item");
    for (let li of filters) {
      if (set.has(li.dataset.filter)) li.classList.add("active");
    }
  }

  /* -------------------------------------------- */
  /*  Event Listeners and Handlers                */
  /* -------------------------------------------- */

  _onRest(event) {
    event.preventDefault();
    const app = Object.values(this.document.apps).find((o) => {
      return o instanceof ActorRestDialog && o._element;
    });
    if (app) app.bringToTop();
    else new ActorRestDialog(this.document).render(true);
  }

  /* -------------------------------------------- */

  /**
   * Handle rolling of an item from the Actor sheet, obtaining the Item instance and dispatching to it's roll method
   *
   * @param event
   * @private
   */
  _onItemRoll(event) {
    event.preventDefault();
    const itemId = event.currentTarget.closest(".item").dataset.itemId;
    const item = this.document.items.get(itemId);

    if (item == null) return;
    return item.roll();
  }

  _mouseWheelAdd(event, el) {
    const isInput = el.tagName.toUpperCase() === "INPUT";

    if (event && event instanceof WheelEvent) {
      const value = (isInput ? parseFloat(el.value) : parseFloat(el.innerText)) || 0;
      if (Number.isNaN(value)) return;

      const increase = -Math.sign(event.deltaY);
      const amount = parseFloat(el.dataset.wheelStep) || 1;

      if (isInput) {
        el.value = value + amount * increase;
      } else {
        el.innerText = (value + amount * increase).toString();
      }
    }
  }

  _setFeatUses(event) {
    event.preventDefault();
    const el = event.currentTarget;
    const itemId = el.closest(".item").dataset.itemId;
    const item = this.document.items.get(itemId);

    this._mouseWheelAdd(event.originalEvent, el);

    const value = el.tagName.toUpperCase() === "INPUT" ? Number(el.value) : Number(el.innerText);
    this.setItemUpdate(item.id, "data.uses.value", value);

    // Update on lose focus
    if (event.originalEvent instanceof MouseEvent) {
      if (!this._submitQueued) {
        $(el).one("mouseleave", (event) => {
          this._updateItems();
        });
      }
    } else this._updateItems();
  }

  _setSpellUses(event) {
    event.preventDefault();
    const el = event.currentTarget;
    const itemId = event.currentTarget.closest(".item").dataset.itemId;
    const item = this.document.items.get(itemId);

    this._mouseWheelAdd(event.originalEvent, el);

    const prevValue = getProperty(item.data, "data.preparation.preparedAmount");
    const value = el.tagName.toUpperCase() === "INPUT" ? Number(el.value) : Number(el.innerText);
    this.setItemUpdate(item.id, "data.preparation.preparedAmount", value);
    if (prevValue < value) {
      this.setItemUpdate(item.id, "data.preparation.maxAmount", Math.max(prevValue, value));
    }

    // Update on lose focus
    if (event.originalEvent instanceof MouseEvent) {
      if (!this._submitQueued) {
        $(el).one("mouseleave", (event) => {
          this._updateItems();
        });
      }
    } else this._updateItems();
  }
  _setMaxSpellUses(event) {
    event.preventDefault();
    const el = event.currentTarget;
    const itemId = el.closest(".item").dataset.itemId;
    const item = this.document.items.get(itemId);

    this._mouseWheelAdd(event.originalEvent, el);

    const prevValue = getProperty(item.data, "data.preparation.maxAmount");
    const value = el.tagName.toUpperCase() === "INPUT" ? Number(el.value) : Number(el.innerText);
    this.setItemUpdate(item.id, "data.preparation.maxAmount", Math.max(0, value));
    if (prevValue > value) {
      this.setItemUpdate(item.id, "data.preparation.preparedAmount", Math.min(prevValue, value));
    }
    if (value < 0) {
      el.tagName.toUpperCase() === "INPUT" ? (el.value = 0) : (el.innerText = 0);
    }

    // Update on lose focus
    if (event.originalEvent instanceof MouseEvent) {
      if (!this._submitQueued) {
        $(el).one("mouseleave", (event) => {
          this._updateItems();
        });
      }
    } else this._updateItems();
  }

  _adjustActorPropertyBySpan(event) {
    event.preventDefault();
    const el = event.currentTarget;

    this._mouseWheelAdd(event.originalEvent, el);
    // Get base value
    let value = el.tagName.toUpperCase() === "INPUT" ? Number(el.value) : Number(el.innerText);
    if (el.dataset.dtype && el.dataset.dtype.toUpperCase() === "STRING") {
      value = el.tagName.toUpperCase() === "INPUT" ? el.value : el.innerText;
    }

    // Adjust value if needed
    const name = el.getAttribute("name");
    if (name.match(/data\.abilities\.([a-zA-Z0-9]+)\.value$/)) {
      if (Number.isNaN(parseInt(value))) value = null;
      else value = parseInt(value);
    }

    // Add pending update
    if (name) {
      this._pendingUpdates[name] = value;
    }

    // Update on lose focus
    if (event.originalEvent instanceof MouseEvent) {
      if (!this._submitQueued) {
        $(el).one("mouseleave", (event) => {
          this._onSubmit(event);
        });
      }
    } else this._onSubmit(event);
  }

  _setBuffLevel(event) {
    event.preventDefault();
    const el = event.currentTarget;
    const itemId = el.closest(".item").dataset.itemId;
    const item = this.document.items.get(itemId);

    this._mouseWheelAdd(event.originalEvent, el);
    const value = el.tagName.toUpperCase() === "INPUT" ? Number(el.value) : Number(el.innerText);
    const name = el.getAttribute("name");
    if (name) {
      this._pendingUpdates[name] = value;
    }

    this.setItemUpdate(item.id, "data.level", value);
    if (event.originalEvent instanceof MouseEvent) {
      if (!this._submitQueued) {
        $(el).one("mouseleave", (event) => {
          this._updateItems();
        });
      }
    } else this._updateItems();
  }

  _hideShowElement(event) {
    event.preventDefault();
    const a = event.currentTarget;
    const target = this.element.find(`.${a.dataset.for}`);

    if (target.hasClass("hidden")) {
      $(a).find("i").removeClass("fa-arrow-circle-down").addClass("fa-arrow-circle-up");
      target.removeClass("hidden");
      target.hide();
      target.slideDown(200);

      this._hiddenElems[a.dataset.for] = false;
    } else {
      $(a).find("i").removeClass("fa-arrow-circle-up").addClass("fa-arrow-circle-down");
      target.slideUp(200, () => target.addClass("hidden"));

      this._hiddenElems[a.dataset.for] = true;
    }
  }

  _onToggleCondition(event) {
    event.preventDefault();
    const a = event.currentTarget;
    const key = a.name;

    // Delete the stored condition status if setting to false
    const newStatus = !getProperty(this.actor.data, key);
    const deleteKey = key.replace(/(\w+)$/, (condition) => `-=${condition}`);
    const updateData = newStatus ? { [key]: true } : { [deleteKey]: null };
    this.actor.update(updateData);
  }

  _onToggleSkillLock(event) {
    event.preventDefault();
    const state = event.target.classList.toggle("unlocked");
    const tab = event.target.closest(".tab.skills");
    const rareInputs = $(tab).find(".skill-acp input,.skill-rt input, .skill-ability select");
    rareInputs.prop("disabled", !state);
    $(tab).find(".skill-controls .skill-delete").toggle();
  }

  _onOpenCompendium(event) {
    event.preventDefault();
    const a = event.currentTarget;
    const target = a.dataset.actionTarget;

    game.ffd20.compendiums[target].render(true);
  }

  _onRollConcentration(event) {
    event.preventDefault();

    const spellbookKey = $(event.currentTarget).closest(".spellbook-group").data("tab");
    this.document.rollConcentration(spellbookKey);
  }

  _onRollCL(event) {
    event.preventDefault();

    const spellbookKey = $(event.currentTarget).closest(".spellbook-group").data("tab");
    this.document.rollCL(spellbookKey);
  }

  _setItemActive(event) {
    event.preventDefault();
    const itemId = event.currentTarget.closest(".item").dataset.itemId;
    const item = this.document.items.get(itemId);

    const value = $(event.currentTarget).prop("checked");
    this.setItemUpdate(item.data._id, "data.active", value);
    this._updateItems();
  }

  _onLevelUp(event) {
    event.preventDefault;
    const itemId = event.currentTarget.closest(".item").dataset.itemId;
    const item = this.actor.items.get(itemId);

    const app = Object.values(this.actor.apps).find((o) => {
      return o instanceof LevelUpForm && o._element && o.object === item;
    });
    if (app) app.bringToTop();
    else new LevelUpForm(item).render(true);
  }

  /* -------------------------------------------- */

  /**
   * Handle rolling of an item from the Actor sheet, obtaining the Item instance and dispatching to it's roll method
   *
   * @param event
   * @private
   */
  _onItemSummary(event) {
    event.preventDefault();
    let li = $(event.currentTarget).parents(".item"),
      item = this.document.items.get(li.attr("data-item-id")),
      chatData = item.getChatData({ secrets: this.document.isOwner });

    // Toggle summary
    if (li.hasClass("expanded")) {
      let summary = li.children(".item-summary");
      summary.slideUp(200, () => summary.remove());
    } else {
      let div = $(`<div class="item-summary">${chatData.description.value}</div>`);
      let props = $(`<div class="item-properties"></div>`);
      chatData.properties.forEach((p) => props.append(`<span class="tag">${p}</span>`));
      div.append(props);
      li.append(div.hide());
      div.slideDown(200);
    }
    li.toggleClass("expanded");
  }

  /**
   * Makes a readonly text input editable, and focus it.
   *
   * @param event
   * @private
   */
  _onInputText(event) {
    event.preventDefault();
    const forStr = event.currentTarget.dataset.for;
    let elem;
    if (forStr.match(/CHILD-([0-9]+)/)) {
      const n = parseInt(RegExp.$1);
      elem = $(event.currentTarget.children[n]);
    } else {
      elem = this.element.find(event.currentTarget.dataset.for);
    }
    if (!elem || (elem && elem.attr("disabled"))) return;

    elem.prop("readonly", false);
    elem.attr("name", event.currentTarget.dataset.attrName);
    let value = getProperty(this.document.data, event.currentTarget.dataset.attrName);
    elem.attr("value", value);

    const wheelEvent = event && event instanceof WheelEvent;
    if (wheelEvent) {
      this._mouseWheelAdd(event, elem[0]);
    } else {
      elem.select();
    }

    const handler = (event) => {
      if (wheelEvent) elem[0].removeEventListener("mouseout", handler);
      else {
        elem[0].removeEventListener("focusout", handler);
        elem[0].removeEventListener("keydown", keyHandler);
      }
      elem[0].removeEventListener("click", handler);

      if (
        (typeof value === "string" && value !== elem[0].value) ||
        (typeof value === "number" && value !== parseInt(elem[0].value))
      ) {
        changed = true;
      }

      if (changed) {
        this._onSubmit(event);
      } else {
        this.render();
      }
    };
    const keyHandler = (event) => {
      if (event.key === "Enter") {
        changed = true;
        handler.call(this, event);
      }
    };

    let changed = false;
    if (wheelEvent) {
      elem[0].addEventListener("mouseout", handler);
      changed = true;
    } else {
      elem[0].addEventListener("focusout", handler);
      elem[0].addEventListener("keydown", keyHandler);
    }
    elem[0].addEventListener("click", handler);
  }

  /* -------------------------------------------- */

  _onArbitrarySkillCreate(event) {
    event.preventDefault();
    const skillId = $(event.currentTarget).parents(".skill").attr("data-skill");
    const mainSkillData = this.document.data.data.skills[skillId];
    const skillData = {
      name: "",
      ability: mainSkillData.ability,
      rank: 0,
      mod: 0,
      rt: mainSkillData.rt,
      cs: mainSkillData.cs,
      acp: mainSkillData.acp,
    };

    // Get tag
    let count = 1;
    let tag = `${skillId}${count}`;
    while (mainSkillData.subSkills[tag] != null) {
      count++;
      tag = `${skillId}${count}`;
    }

    const updateData = {};
    updateData[`data.skills.${skillId}.subSkills.${tag}`] = skillData;
    if (this.document.testUserPermission(game.user, "OWNER")) this.document.update(updateData);
  }

  _onSkillCreate(event) {
    event.preventDefault();
    const isBackground = $(event.currentTarget).parents(".skills-list").attr("data-background") === "true";
    const skillData = {
      name: "",
      ability: "int",
      rank: 0,
      mod: 0,
      rt: false,
      cs: false,
      acp: false,
      background: isBackground,
      custom: true,
    };

    let tag = createTag(skillData.name || "skill");
    let count = 1;
    while (this.document.data.data.skills[tag] != null) {
      count++;
      tag = createTag(skillData.name || "skill") + count.toString();
    }

    const updateData = {};
    updateData[`data.skills.${tag}`] = skillData;
    if (this.document.testUserPermission(game.user, "OWNER")) this.document.update(updateData);
  }

  _onArbitrarySkillDelete(event) {
    event.preventDefault();
    const mainSkillId = $(event.currentTarget).parents(".sub-skill").attr("data-main-skill");
    const subSkillId = $(event.currentTarget).parents(".sub-skill").attr("data-skill");

    const updateData = {};
    updateData[`data.skills.${mainSkillId}.subSkills.-=${subSkillId}`] = null;
    if (this.document.testUserPermission(game.user, "OWNER")) this.document.update(updateData);
  }

  _onSkillDelete(event) {
    event.preventDefault();
    const skillId = $(event.currentTarget).parents(".skill").attr("data-skill");

    const updateData = {};
    updateData[`data.skills.-=${skillId}`] = null;
    if (this.document.testUserPermission(game.user, "OWNER")) this.document.update(updateData);
  }

  async _onRaceControl(event) {
    event.preventDefault();
    const a = event.currentTarget;

    // Add race
    if (a.classList.contains("add")) {
      const itemData = {
        name: "New Race",
        type: "race",
      };
      this.document.createOwnedItem(itemData);
    }
    // Edit race
    else if (a.classList.contains("edit")) {
      this._onItemEdit(event);
    }
    // Delete race
    else if (a.classList.contains("delete")) {
      this._onItemDelete(event);
    }
  }

  async _onPointBuyCalculator(event) {
    event.preventDefault();

    const app = Object.values(this.document.apps).find((o) => {
      return o instanceof PointBuyCalculator && o._element;
    });
    if (app) app.bringToTop();
    else new PointBuyCalculator(this.document).render(true);
  }

  async _onControlAlignment(event) {
    event.preventDefault();
    const a = event.currentTarget;

    const items = Object.entries(CONFIG.FFD20.alignmentsShort).reduce((cur, o) => {
      cur.push({ value: o[0], label: game.i18n.localize(o[1]) });
      return cur;
    }, []);
    const w = new Widget_ItemPicker(
      (alignment) => {
        this.document.update({ "data.details.alignment": alignment });
      },
      { items: items, columns: 3 }
    );
    w.render($(a));
  }

  async _quickItemActionControl(event) {
    event.preventDefault();
    const a = event.currentTarget;
    const itemId = $(event.currentTarget).parents(".item").attr("data-item-id");
    const item = this.document.items.get(itemId);

    // Quick Attack
    if (a.classList.contains("item-attack")) {
      await item.use({ ev: event, skipDialog: getSkipActionPrompt() });
    }
  }

  async _quickChangeItemQuantity(event, add = 1) {
    event.preventDefault();
    const itemId = $(event.currentTarget).parents(".item").attr("data-item-id");
    const item = this.document.items.get(itemId);

    const curQuantity = getProperty(item.data, "data.quantity") || 0;
    let newQuantity = Math.max(0, curQuantity + add);

    if (item.type === "container") newQuantity = Math.min(newQuantity, 1);

    this.setItemUpdate(item.id, "data.quantity", newQuantity);
    this._updateItems();
  }

  async _quickEquipItem(event) {
    event.preventDefault();
    const itemId = $(event.currentTarget).parents(".item").attr("data-item-id");
    const item = this.document.items.get(itemId);

    if (hasProperty(item.data, "data.equipped")) {
      this.setItemUpdate(item.id, "data.equipped", !item.data.data.equipped);
      this._updateItems();
    }
  }

  async _quickCarryItem(event) {
    event.preventDefault();
    const itemId = $(event.currentTarget).parents(".item").attr("data-item-id");
    const item = this.document.items.get(itemId);

    if (hasProperty(item.data, "data.carried")) {
      item.update({ "data.carried": !item.data.data.carried });
    }
  }

  async _quickIdentifyItem(event) {
    event.preventDefault();
    if (!game.user.isGM) {
      const msg = game.i18n.localize("FFD20.ErrorCantIdentify");
      console.error(msg);
      return ui.notifications.error(msg);
    }
    // const itemId = $(event.currentTarget).parents(".item").attr("data-item-id");
    const itemId = event.currentTarget.closest(".item").dataset.itemId;
    const item = this.document.items.get(itemId);

    if (hasProperty(item.data, "data.identified")) {
      item.update({ "data.identified": !item.data.data.identified });
    }
  }

  async _itemToggleData(event) {
    event.preventDefault();
    const a = event.currentTarget;

    const itemId = $(a).parents(".item").attr("data-item-id");
    const item = this.document.items.get(itemId);
    const property = $(a).attr("name") || a.dataset.name;

    const updateData = {};
    updateData[property] = !getProperty(item.data, property);
    item.update(updateData);
  }

  async _duplicateItem(event) {
    event.preventDefault();
    const a = event.currentTarget;

    const itemId = $(a).parents(".item").attr("data-item-id");
    const item = this.document.items.get(itemId);
    const data = duplicate(item.data);

    delete data.id;
    data.name = `${data.name} (Copy)`;
    data.data.identifiedName = data.name;
    if (data.data.links) data.data.links = {};

    this.document.createOwnedItem(data);
  }

  _quickAction(event) {
    event.preventDefault();
    const a = event.currentTarget;
    const itemId = a.dataset.itemId;
    const item = this.document.items.find((o) => o.id === itemId);
    if (!item) return;

    game.ffd20.rollItemMacro(item.name, { itemId: item.id, itemType: item.type, actorId: this.document.id });
  }

  _convertCurrency(event) {
    event.preventDefault();
    const a = event.currentTarget;
    const currencyType = a.dataset.type;
    const category = a.dataset.category;

    this.document.convertCurrency(category, currencyType);
  }

  /**
   * Handle creating a new Owned Item for the actor using initial data defined in the HTML dataset
   *
   * @param event
   * @private
   */
  _onItemCreate(event) {
    event.preventDefault();
    const header = event.currentTarget;
    const type = header.dataset.type;
    const typeName = header.dataset.typeName || header.dataset.type;
    const baseName = `New ${typeName.capitalize()}`;
    const itemData = {
      name: baseName,
      type: type,
      data: duplicate(header.dataset),
    };
    delete itemData.data["type"];

    const getSubtype = (d) => getProperty(d, `data.${d.type}Type`);
    const subtype = getSubtype(itemData);
    const sameSubgroup = (oldItem) => {
      if (subtype) return subtype === getSubtype(oldItem.data);
      if (type === "spell") {
        return (
          itemData.data.spellbook === oldItem.data.data.spellbook && itemData.data.level === oldItem.data.data.level
        );
      }
      // Assume everything else is only categorized by main type
      return true;
    };

    // Get old items of same general category
    const oldItems = this.document.items
      .filter((i) => i.type === type && sameSubgroup(i))
      .sort((a, b) => a.data.sort - b.data.sort);

    if (oldItems.length) {
      // Ensure new item is at top of the list instead of seemingly random position
      itemData.sort = oldItems[0].data.sort - 10;

      // Ensure no duplicate names occur
      let i = 2;
      while (oldItems.find((i) => i.name === itemData.name)) {
        itemData.name = `${baseName} (${i++})`;
      }
    }

    return this.document.createOwnedItem(itemData);
  }

  /* -------------------------------------------- */

  /**
   * Handle editing an existing Owned Item for the Actor
   *
   * @param {Event} event   The originating click event
   * @private
   */
  _onItemEdit(event) {
    event.preventDefault();
    const li = event.currentTarget.closest(".item");
    const item = this.document.items.get(li.dataset.itemId);

    const app = Object.values(this.document.apps).find((o) => {
      return o instanceof ItemSheet && o.object === item && o._element;
    });
    if (app) app.bringToTop();
    else item.sheet.render(true);
  }

  /**
   * Handle deleting an existing Owned Item for the Actor
   *
   * @param {Event} event   The originating click event
   * @private
   */
  _onItemDelete(event) {
    event.preventDefault();

    const button = event.currentTarget;
    if (button.disabled) return;

    const li = event.currentTarget.closest(".item");
    const item = this.document.items.find((o) => o.id === li.dataset.itemId);

    if (keyboard.isDown("Shift")) {
      item.delete();
    } else {
      button.disabled = true;

      const msg = `<p>${game.i18n.localize("FFD20.DeleteItemConfirmation")}</p>`;
      Dialog.confirm({
        title: game.i18n.localize("FFD20.DeleteItemTitle").format(item.name),
        content: msg,
        yes: () => {
          item.delete();
          button.disabled = false;
        },
        no: () => (button.disabled = false),
        rejectClose: true,
      }).then(null, () => (button.disabled = false));
    }
  }

  async _onItemGive(event) {
    event.preventDefault();

    const itemId = event.currentTarget.closest(".item").dataset.itemId;
    const item = this.document.items.find((o) => o.id === itemId);

    const targets = game.actors.contents.filter((o) => o.testUserPermission(game.user, "OWNER") && o !== this.document);
    targets.push(...this.document.items.filter((o) => o.type === "container"));
    targets.push(
      ...game.items.contents.filter((o) => o.testUserPermission(game.user, "OWNER") && o.type === "container")
    );
    const targetData = await dialogGetActor(`Give item to actor`, targets);

    if (!targetData) return;
    let target;
    if (targetData.type === "actor") {
      target = game.actors.contents.find((o) => o.id === targetData.id);
    } else if (targetData.type === "item") {
      target = this.document.items.find((o) => o.id === targetData.id);
      if (!target) {
        target = game.items.contents.find((o) => o.id === targetData.id);
      }
    }

    if (target && target !== item) {
      const itemData = item.data;
      if (target instanceof Actor) {
        await target.createOwnedItem(itemData);
      } else if (target instanceof Item) {
        await target.createContainerContent(itemData);
      }
      await this.document.deleteOwnedItem(item.id);
    }
  }

  _onSubmitElement(event) {
    if (event.key === "Enter") {
      const elem = event.currentTarget;
      if (elem.name) {
        const attr = getProperty(this.document.data, elem.name);
        if (typeof attr === "number" && attr === parseFloat(elem.value)) {
          this._onSubmit(event);
        } else if (typeof attr === "string" && attr === elem.value) {
          this._onSubmit(event);
        }
      }
    }
  }

  /**
   * Handle rolling an Ability check, either a test or a saving throw
   *
   * @param {Event} event   The originating click event
   * @private
   */
  _onRollAbilityTest(event) {
    event.preventDefault();
    let ability = event.currentTarget.closest(".ability").dataset.ability;
    this.document.rollAbility(ability, { event: event });
  }

  _onRollBAB(event) {
    event.preventDefault();
    this.document.rollBAB({ event: event });
  }

  _onRollMelee(event) {
    event.preventDefault();
    this.document.rollAttack({ event: event, melee: true });
  }

  _onRollRanged(event) {
    event.preventDefault();
    this.document.rollAttack({ event: event, melee: false });
  }

  _onRollCMB(event) {
    event.preventDefault();
    this.document.rollCMB({ event: event });
  }

  _onRollInitiative(event) {
    event.preventDefault();
    this.document.rollInitiative({ createCombatants: true, rerollInitiative: game.user.isGM });
  }

  _onRollSavingThrow(event) {
    event.preventDefault();
    let savingThrow = event.currentTarget.parentElement.dataset.savingthrow;
    this.document.rollSavingThrow(savingThrow, { event: event, skipPrompt: getSkipActionPrompt() });
  }

  /* -------------------------------------------- */

  /**
   * Organize and classify Owned Items
   *
   * @param data
   * @private
   */
  _prepareItems(data) {
    // Set item tags
    for (let [key, res] of Object.entries(getProperty(data, "data.resources"))) {
      if (!res) continue;
      const id = res.id;
      if (!id) continue;
      const item = this.document.items.find((o) => o.id === id);
      if (!item) continue;
      item.data.tag = !item.data.data.useCustomTag ? key : item.data.data.tag;
    }

    // Categorize items as inventory, spellbook, features, and classes
    const inventory = {
      weapon: {
        label: game.i18n.localize("FFD20.InventoryWeapons"),
        canCreate: true,
        hasActions: false,
        items: [],
        canEquip: true,
        dataset: { type: "weapon" },
      },
      equipment: {
        label: game.i18n.localize("FFD20.InventoryArmorEquipment"),
        canCreate: true,
        hasActions: true,
        items: [],
        canEquip: true,
        dataset: { type: "equipment" },
        hasSlots: true,
      },
      consumable: {
        label: game.i18n.localize("FFD20.InventoryConsumables"),
        canCreate: true,
        hasActions: true,
        items: [],
        canEquip: false,
        dataset: { type: "consumable" },
      },
      gear: {
        label: CONFIG.FFD20.lootTypes["gear"],
        canCreate: true,
        hasActions: false,
        items: [],
        canEquip: true,
        dataset: { type: "loot", "type-name": game.i18n.localize("FFD20.LootTypeGearSingle"), "sub-type": "gear" },
      },
      ammo: {
        label: CONFIG.FFD20.lootTypes["ammo"],
        canCreate: true,
        hasActions: false,
        items: [],
        canEquip: false,
        dataset: { type: "loot", "type-name": game.i18n.localize("FFD20.LootTypeAmmoSingle"), "sub-type": "ammo" },
      },
      misc: {
        label: CONFIG.FFD20.lootTypes["misc"],
        canCreate: true,
        hasActions: false,
        items: [],
        canEquip: false,
        dataset: { type: "loot", "type-name": game.i18n.localize("FFD20.Misc"), "sub-type": "misc" },
      },
      tradeGoods: {
        label: CONFIG.FFD20.lootTypes["tradeGoods"],
        canCreate: true,
        hasActions: true,
        items: [],
        canEquip: false,
        dataset: {
          type: "loot",
          "type-name": game.i18n.localize("FFD20.LootTypeTradeGoodsSingle"),
          "sub-type": "tradeGoods",
        },
      },
      container: {
        label: game.i18n.localize("FFD20.InventoryContainers"),
        canCreate: true,
        hasActions: false,
        items: [],
        dataset: { type: "container" },
      },
    };

    // Partition items by category
    let [items, spells, feats, classes, attacks] = data.items.reduce(
      (arr, item) => {
        item.img = item.img || CONST.DEFAULT_TOKEN;
        item.isStack = item.data.quantity ? item.data.quantity > 1 : false;
        item.hasUses = item.data.uses && item.data.uses.max > 0;
        item.isCharged = ["day", "week", "charges"].includes(getProperty(item, "data.uses.per"));
        item.price = item.data.identified === false ? item.data.unidentified.price : item.data.price;

        const itemQuantity = getProperty(item, "data.quantity") != null ? getProperty(item, "data.quantity") : 1;
        const itemCharges = getProperty(item, "data.uses.value") != null ? getProperty(item, "data.uses.value") : 1;
        item.empty = itemQuantity <= 0 || (item.isCharged && itemCharges <= 0);
        if (item.type === "spell") arr[1].push(item);
        else if (item.type === "feat") arr[2].push(item);
        else if (item.type === "class") arr[3].push(item);
        else if (item.type === "attack") arr[4].push(item);
        else if (ItemFFD20.isInventoryItem(item.type)) arr[0].push(item);
        return arr;
      },
      [[], [], [], [], []]
    );

    // Apply active item filters
    items = this._filterItems(items, this._filters.inventory, this._filters.search.inventory);
    feats = this._filterItems(feats, this._filters.features);

    // Organize Spellbook
    let spellbookData = {};
    const spellbooks = data.data.attributes.spells.spellbooks;
    for (let [a, spellbook] of Object.entries(spellbooks)) {
      let spellbookSpells = spells.filter((obj) => {
        return obj.data.spellbook === a;
      });
      spellbookSpells = this._filterItems(spells, getProperty(this._filters, `spellbook-${a}`));
      spellbookData[a] = {
        data: this._prepareSpellbook(data, spellbookSpells, a),
        prepared: spellbookSpells.filter((obj) => {
          return obj.data.preparation.mode === "prepared" && obj.data.preparation.prepared;
        }).length,
        orig: spellbook,
      };
    }

    // Organize Inventory
    let usystem = game.settings.get("ffd20", "weightUnits"); // override
    if (usystem === "default") usystem = game.settings.get("ffd20", "units");

    for (let i of items) {
      const subType = i.type === "loot" ? i.data.subType || "gear" : i.data.subType;
      i.data.quantity = i.data.quantity || 0;
      i.data.weight = i.data.weight || 0;
      i.totalWeight = Math.round(convertWeight(i.data.quantity * i.data.weight) * 10) / 10;
      i.units = usystem === "metric" ? game.i18n.localize("FFD20.Kgs") : game.i18n.localize("FFD20.Lbs");
      if (inventory[i.type] != null) inventory[i.type].items.push(i);
      if (subType != null && inventory[subType] != null) inventory[subType].items.push(i);
    }

    // Organize Features
    const features = {};
    const featureDefaults = { items: [], canCreate: true, hasActions: true };
    const featData = this.constructor.featTypeData;
    for (const [featKey, featValue] of Object.entries(FFD20.featTypes)) {
      // Merge type specific data into common data template
      features[featKey] = mergeObject(
        featureDefaults,
        {
          // Fist generic data derived from the config object
          label: FFD20.featTypesPlurals[featKey] ?? featValue,
          dataset: { type: "feat", "type-name": game.i18n.localize(featValue), "feat-type": featKey },
          // Then any specific data explicitly set to override defaults
          ...featData[featKey],
        },
        { inplace: false }
      );
    }

    for (let f of feats) {
      let k = f.data.featType;
      if (f.data.abilityType && f.data.abilityType !== "none") {
        f.abilityType = game.i18n.localize(CONFIG.FFD20.abilityTypes[f.data.abilityType].long);
        f.abilityTypeShort = game.i18n.localize(CONFIG.FFD20.abilityTypes[f.data.abilityType].short);
      } else {
        f.abilityType = "";
        f.abilityTypeShort = "";
      }
      features[k]?.items?.push(f);
    }
    classes.sort((a, b) => b.level - a.level);
    classes.forEach((item) => {
      if (item.data.classType !== "mythic") item.canLevelUp = true;
    });

    // Buffs
    let buffs = data.items.filter((obj) => {
      return obj.type === "buff";
    });
    buffs = this._filterItems(buffs, this._filters.buffs);
    const buffSections = {
      temp: {
        label: game.i18n.localize("FFD20.Temporary"),
        items: [],
        hasActions: false,
        dataset: { type: "buff", "buff-type": "temp" },
      },
      perm: {
        label: game.i18n.localize("FFD20.Permanent"),
        items: [],
        hasActions: false,
        dataset: { type: "buff", "buff-type": "perm" },
      },
      item: {
        label: game.i18n.localize("FFD20.Item"),
        items: [],
        hasActions: false,
        dataset: { type: "buff", "buff-type": "item" },
      },
      misc: {
        label: game.i18n.localize("FFD20.Misc"),
        items: [],
        hasActions: false,
        dataset: { type: "buff", "buff-type": "misc" },
      },
    };

    for (let b of buffs) {
      let s = b.data.buffType;
      if (!buffSections[s]) continue;
      buffSections[s].items.push(b);
    }

    // Attacks
    attacks = this._filterItems(attacks, this._filters.attacks);
    const attackSections = {
      weapon: {
        label: game.i18n.localize("FFD20.AttackTypeWeaponPlural"),
        items: [],
        canCreate: true,
        initial: false,
        showTypes: false,
        dataset: { type: "attack", "attack-type": "weapon" },
      },
      natural: {
        label: game.i18n.localize("FFD20.AttackTypeNaturalPlural"),
        items: [],
        canCreate: true,
        initial: false,
        showTypes: false,
        dataset: { type: "attack", "attack-type": "natural" },
      },
      ability: {
        label: game.i18n.localize("FFD20.AttackTypeAbilityPlural"),
        items: [],
        canCreate: true,
        initial: false,
        showTypes: false,
        dataset: { type: "attack", "attack-type": "ability" },
      },
      racialAbility: {
        label: game.i18n.localize("FFD20.AttackTypeRacialPlural"),
        items: [],
        canCreate: true,
        initial: false,
        showTypes: false,
        dataset: { type: "attack", "attack-type": "racialAbility" },
      },
      item: {
        label: game.i18n.localize("FFD20.Items"),
        items: [],
        canCreate: true,
        initial: false,
        showTypes: false,
        dataset: { type: "attack", "attack-type": "item" },
      },
      misc: {
        label: game.i18n.localize("FFD20.Misc"),
        items: [],
        canCreate: true,
        initial: false,
        showTypes: false,
        dataset: { type: "attack", "attack-type": "misc" },
      },
    };

    for (let a of attacks) {
      let s = a.data.attackType;
      if (!attackSections[s]) continue;
      attackSections[s].items.push(a);
    }

    // Apply type filters
    {
      let sections = [
        { key: "inventory", section: inventory },
        { key: "features", section: features },
        { key: "buffs", section: buffSections },
        { key: "attacks", section: attackSections },
      ];
      for (let [k, sb] of Object.entries(spellbookData)) {
        sections.push({ key: `spellbook-${k}`, section: sb.data });
      }

      for (let section of sections) {
        for (let [k, s] of Object.entries(section.section)) {
          const typeFilterCount = this._typeFilterCount(this._filters[section.key]);
          if (typeFilterCount > 0 && s.items.length === 0) {
            s._hidden = true;
          }
          if (typeFilterCount === 1 && this._filters[section.key].has(`type-${k}`)) {
            s._hidden = false;
          }
        }
      }
    }

    // Assign and return
    data.inventory = inventory;
    data.spellbookData = spellbookData;
    data.features = features;
    data.buffs = buffSections;
    data.attacks = attackSections;
    data.classes = classes;
    data.quickActions = this.document.getQuickActions();
  }

  /**
   * Handle rolling a Skill check
   *
   * @param {Event} event   The originating click event
   * @private
   */
  _onRollSkillCheck(event) {
    event.preventDefault();
    const skill = event.currentTarget.parentElement.parentElement.dataset.skill;
    this.document.rollSkill(skill, { event: event, skipDialog: getSkipActionPrompt() });
  }

  _onRollSubSkillCheck(event) {
    event.preventDefault();
    const mainSkill = event.currentTarget.parentElement.parentElement.dataset.mainSkill;
    const skill = event.currentTarget.parentElement.parentElement.dataset.skill;
    this.document.rollSkill(`${mainSkill}.subSkills.${skill}`, { event: event, skipDialog: getSkipActionPrompt() });
  }

  /**
   * Handle opening a skill's compendium entry
   *
   * @param {Event} event   The originating click event
   * @private
   */
  async _onOpenCompendiumEntry(event) {
    const entryKey = event.currentTarget.dataset.compendiumEntry;
    const parts = entryKey.split(".");
    const packKey = parts.slice(0, 2).join(".");
    const entryId = parts.slice(-1)[0];
    const pack = game.packs.get(packKey);
    const entry = await pack.getDocument(entryId);
    entry.sheet.render(true);
  }

  /* -------------------------------------------- */

  /**
   * Handle toggling of filters to display a different set of owned items
   *
   * @param {Event} event     The click event which triggered the toggle
   * @private
   */
  _onToggleFilter(event) {
    event.preventDefault();

    const li = event.currentTarget;
    const set = this._filters[li.parentElement.dataset.filter];
    const filter = li.dataset.filter;
    const typeFilterCount = this._typeFilterCount(set);

    const tabLikeFilters = game.settings.get("ffd20", "invertSectionFilterShiftBehaviour")
      ? !event.shiftKey
      : event.shiftKey;
    if (tabLikeFilters) {
      for (let f of Array.from(set)) {
        if (f.startsWith("type-") && (f !== filter || typeFilterCount > 1)) {
          set.delete(f);
        }
      }
    }

    if (set.has(filter)) set.delete(filter);
    else set.add(filter);
    this.render();
  }

  _searchFilterCommit(event) {
    const actor = this.actor;
    const search = this._filters.search[event.target.dataset.category].toLowerCase();
    const category = event.target.dataset.category;

    // TODO: Do not refresh if same search term, unless the sheet has updated.
    if (this.effectiveSearch[category] === search && !this.searchRefresh) return;
    this.effectiveSearch[category] = search;
    this.searchRefresh = false;

    const matchSearch = (name) => name.toLowerCase().includes(search); // MKAhvi: Bad method for i18n support.

    $(event.target)
      .closest(".tab")
      .find(".item-list .item")
      .each(function () {
        const jq = $(this);
        if (search?.length > 0) {
          const item = actor.items.get(this.dataset.itemId);
          if (matchSearch(item.name)) jq.show();
          else jq.hide();
        } else jq.show();
      });
  }

  _clearSearch(event) {
    const sb = $(event.target).prev(".search-input");
    this._filters.search[sb.get(0).dataset.category] = "";
    sb.val("").change();
  }

  // IME related
  _searchFilterCompositioning(event) {
    this.searchCompositioning = event.type === "compositionstart";
  }

  _searchFilterChange(event) {
    event.preventDefault();
    this._onSubmit(event, { preventRender: true }); // prevent sheet refresh

    // Accept input only while not compositioning

    const search = event.target.value;
    const category = event.target.dataset.category;
    const changed = this._filters.search[category] !== search;

    if (this.searchCompositioning || changed) clearTimeout(this.searchDelayEvent); // reset
    if (this.searchCompositioning) return;

    //if (unchanged) return; // nothing changed
    this._filters.search[category] = search;

    if (event.type === "keyup") {
      // Delay search
      if (changed) this.searchDelayEvent = setTimeout(() => this._searchFilterCommit(event), this.searchDelay);
    } else {
      this._searchFilterCommit(event);
    }
  }

  /* -------------------------------------------- */

  /**
   * Handle spawning the ActorTraitSelector application which allows a checkbox of multiple trait options
   *
   * @param {Event} event   The click event which originated the selection
   * @private
   */
  _onTraitSelector(event) {
    event.preventDefault();
    const a = event.currentTarget;
    const label = a.parentElement.querySelector("label");
    const options = {
      name: label.getAttribute("for"),
      title: label.innerText,
      choices: CONFIG.FFD20[a.dataset.options],
    };

    const app = Object.values(this.document.apps).find((o) => {
      return o instanceof ActorTraitSelector && o.options.name === options.name && o._element;
    });
    if (app) app.bringToTop();
    else new ActorTraitSelector(this.document, options).render(true);
  }

  setItemUpdate(id, key, value) {
    let obj = this._itemUpdates.filter((o) => {
      return o._id === id;
    })[0];
    if (obj == null) {
      obj = { _id: id };
      this._itemUpdates.push(obj);
    }

    obj[key] = value;
  }

  async _render(...args) {
    // Trick to avoid error on elements with changing name
    let focus = this.element.find(":focus");
    focus = focus.length ? focus[0] : null;
    if (focus && focus.name.match(/^data\.skills\.(?:[a-zA-Z0-9]*)\.name$/)) focus.blur();

    const result = await super._render(...args);

    // Create placeholders
    this._createPlaceholders(this.element);

    // Apply accessibility settings
    applyAccessibilitySettings(this, this.element, {}, game.settings.get("ffd20", "accessibilityConfig"));

    return result;
  }

  async _onSubmit(event, { updateData = null, preventClose = false, preventRender = false } = {}) {
    event.preventDefault();

    this._submitQueued = false;

    await super._onSubmit(event, { updateData, preventClose, preventRender });

    // Update items
    await this._updateItems();
  }

  async _updateItems() {

    const updates = this._itemUpdates;
    this._itemUpdates = [];

    // Memorize variables in document
    for (let d of updates) {
      const item = this.document.items.find((o) => o.id === d._id);
      item?.memorizeVariables();
      delete d._id;
      await item.update(d);
    }
  }

  async _onDropCurrency(event, data) {
    let sourceActor = data.tokenId ? game.actors.tokens[data.tokenId] : data.actorId;
    return new CurrencyTransfer(
      { actor: sourceActor, container: data.containerId, alt: data.alt },
      { actor: this.actor, amount: Object.fromEntries([[data.currency, parseInt(data.amount)]]) }
    ).render(true);
  }

  /**
   * @override
   */
  async _onDropItem(event, data) {
    if (!this.document.isOwner) return false;

    const item = await ItemFFD20.implementation.fromDropData(data);
    const itemData = item.toJSON();

    // Handle item sorting within the same actor
    let sameActor =
      (data.actorId === this.actor.id || (this.actor.isToken && data.tokenId === this.actor.token.id)) &&
      !data.containerId;
    if (sameActor) {
      const dropTarget = event.target.closest("li[data-item-id]");
      if (dropTarget?.dataset?.itemId === item.id) return; // item dropped onto itself
      return this._onSortItem(event, itemData);
    }

    // Remove from container
    if (data.containerId) {
      const container = this.actor.allItems.find((o) => o.id === data.containerId);

      if (container) container.deleteContainerContent(itemData._id);
    }

    // Create the owned item
    this._alterDropItemData(itemData);
    return this._onDropItemCreate(itemData);
  }

  _alterDropItemData(data) {
    if (data.type === "spell") {
      data.data.spellbook = this.currentSpellbookKey;
    }
  }

  /**
   * @override
   */
  _getSortSiblings(source) {
    return this.document.items.filter((i) => {
      if (ItemFFD20.isInventoryItem(source.data.type)) return ItemFFD20.isInventoryItem(i.data.type);
      return i.data.type === source.data.type && i.data.id !== source.data.id;
    });
  }

  async _onDropItemCreate(itemData) {
    // Import spell as consumable
    if (itemData.type === "spell" && this.currentPrimaryTab !== "spellbook") {
      let resultData = await createConsumableSpellDialog(itemData);
      if (resultData === "spell") ; else if (resultData) return this.document.createEmbeddedDocuments("Item", [resultData]);
      else return false;
    }
    // Choose how to import class
    if (
      itemData.type === "class" &&
      getProperty(itemData, "data.classType") !== "mythic" &&
      !(event && event.shiftKey)
    ) {
      let doReturn = await new Promise((resolve) => {
        new Dialog(
          {
            title: game.i18n.localize("FFD20.AddClass"),
            content: `<div class="ffd20"><p>${game.i18n.localize(
              "FFD20.Info.AddClassDialog_Desc"
            )}</p><div class="help-text"><i class="fas fa-info-circle"></i> ${game.i18n.localize(
              "FFD20.Info.AddClassDialog"
            )}</div></div>`,
            buttons: {
              normal: {
                icon: '<i class="fas fa-hat-wizard"></i>',
                label: game.i18n.localize("FFD20.Normal"),
                callback: () => {
                  LevelUpForm.addClassWizard(this.actor, itemData).then(() => {
                    resolve(true);
                  });
                },
              },
              raw: {
                icon: '<i class="fas fa-file"></i>',
                label: game.i18n.localize("FFD20.Raw"),
                callback: () => {
                  resolve(false);
                },
              },
            },
            close: () => {
              resolve(true);
            },
          },
          {
            classes: ["dialog", "ffd20", "add-character-class"],
          }
        ).render(true);
      });
      if (doReturn) return false;
    }

    if (itemData.id) delete itemData.id;
    let actorRef = this.document;
    return this.document.createEmbeddedDocuments("Item", [itemData]).then((createdItem) => {
      let fullItem = actorRef.items.get(createdItem.id);
      return fullItem;
    });
  }

  _onDragStart(event) {
    const elem = event.target;
    if (elem.classList.contains("denomination")) {
      if (this.actor.permission < 3) return;
      const dragData = {
        actorId: this.actor.id,
        sceneId: this.actor.isToken ? canvas.scene?.id : null,
        tokenId: this.actor.isToken ? this.actor.token.id : null,
        type: "Currency",
        alt: elem.classList.contains("alt-currency"),
        currency: [...elem.classList].find((o) => /[pgsc]p/.test(o)),
        amount: parseInt(elem.nextElementSibling.textContent || elem.nextElementSibling.value),
      };
      event.dataTransfer.setData("text/plain", JSON.stringify(dragData));
    } else if (elem.dataset?.skill) {
      this._onDragSkillStart(event);
    } else if (elem.dataset?.attribute) {
      this._onDragMiscStart(event, elem.dataset.attribute);
    } else if (elem.dataset?.drag) {
      this._onDragMiscStart(event, elem.dataset.drag);
    } else if (elem.dataset?.savingthrow) {
      this._onDragSaveStart(event, elem.dataset.savingthrow);
    } else super._onDragStart(event);
  }

  async _onConfigControl(event) {
    event.preventDefault();
    const a = event.currentTarget;
    const f = $(a).attr("for");
    const html = this.element;

    $(a).css("display", "none");

    // Show CR field
    if (f === "cr") {
      const elem = html.find('input[for="data.details.cr"]');
      elem.attr("value", CR.fromNumber(this.document.data.data.details.cr.base));
      elem.attr("name", "data.details.cr.base");
      elem.prop("disabled", false);
      elem.focus();
      elem.select();
    }

    // Show base Spell Slots field
    else if (f === "spellSlots") {
      const elem = $(a).closest(".spell-uses").find(".base");
      elem.css("display", "block");
      elem.focus();
      elem.select();
    }
  }

  _selectOnClick(event) {
    event.preventDefault();
    const el = event.currentTarget;
    el.select();
  }

  _updateObject(event, formData) {
    // Translate CR
    const cr = formData["data.details.cr.base"];
    if (typeof cr === "string") formData["data.details.cr.base"] = CR.fromString(cr);

    // Update from elements with 'data-name'
    {
      const elems = this.element.find("*[data-name]");
      let changedData = {};
      for (const el of elems) {
        const name = el.dataset.name;
        let value;
        if (el.nodeName === "INPUT") value = el.value;
        else if (el.nodeName === "SELECT") value = el.options[el.selectedIndex].value;

        if (el.dataset.dtype === "Number") value = Number(value);
        else if (el.dataset.dtype === "Boolean") value = Boolean(value);

        if (getProperty(this.document.data, name) !== value) {
          changedData[name] = value;
        }
      }

      for (let [k, v] of Object.entries(changedData)) {
        formData[k] = v;
      }
    }

    // Add pending updates
    for (let [k, v] of Object.entries(this._pendingUpdates)) {
      formData[k] = v;
    }
    this._pendingUpdates = {};

    this.searchRefresh = true;

    return super._updateObject(event, formData);
  }

  calculateTotalItemValue() {
    const items = this.document.items.filter((o) => o.data.data.price != null);
    return items.reduce((cur, i) => {
      return cur + i.getValue({ sellValue: 1 });
    }, 0);
  }

  calculateSellItemValue() {
    const items = this.document.items.filter((o) => o.data.data.price != null);
    const sellMultiplier = this.document.getFlag("ffd20", "sellMultiplier") || 0.5;
    return items.reduce((cur, i) => {
      return cur + i.getValue({ sellValue: sellMultiplier });
    }, 0);
  }

  _createPlaceholders(html) {
    const elems = html.find("span[data-placeholder]");
    for (let el of elems) {
      if (!el.innerText) {
        el.classList.add("placeholder");
        el.innerText = el.dataset.placeholder;
      }
    }
  }
}

/**
 * An Actor sheet for player character type actors in the FFD20 system.
 * Extends the base ActorSheetFFD20 class.
 *
 * @type {ActorSheetFFD20}
 */
class ActorSheetFFD20Character extends ActorSheetFFD20 {
  /**
   * Define default rendering options for the NPC sheet
   *
   * @returns {Object}
   */
  static get defaultOptions() {
    return mergeObject(super.defaultOptions, {
      classes: ["ffd20", "sheet", "actor", "character"],
      width: 800,
      height: 840,
    });
  }

  /* -------------------------------------------- */
  /*  Rendering                                   */
  /* -------------------------------------------- */

  /**
   * Get the correct HTML template path to use for rendering this particular sheet
   *
   * @type {string}
   */
  get template() {
    if (!game.user.isGM && this.actor.limited) return "systems/ffd20/templates/actors/limited-sheet.hbs";
    return "systems/ffd20/templates/actors/character-sheet.hbs";
  }

  /* -------------------------------------------- */

  /**
   * Add some extra data when rendering the sheet to reduce the amount of logic required within the template.
   */
  async getData() {
    const data = await super.getData();
    const xpSettings = game.settings.get("ffd20", "experienceConfig");

    // Experience Tracking
    data["disableExperience"] = xpSettings.disableExperienceTracking;

    data.hasClasses = this.actor.items.filter((o) => o.type === "class").length > 0;

    const hpSettings = game.settings.get("ffd20", "healthConfig");
    data["woundThresholds"] = hpSettings.variants.pc;

    // BAB iteratives
    const iteratives = game.settings.get("ffd20", "displayIteratives");
    const bab = data.data.attributes.bab.total;
    if (iteratives) {
      let iters = [bab];
      for (let i = bab - 5; i > 0; i -= 5) iters.push(i);
      data["iteratives"] = `+${iters.join(" / +")}`;
    }

    // Add level up buttons to classes
    if (
      this.actor.data.type === "character" &&
      game.settings.get("ffd20", "experienceConfig").disableExperienceTracking !== true &&
      data.hasClasses
    ) {
      const xp = getProperty(this.actor.data, "data.details.xp");
      if (xp && xp.value >= xp.max) {
        data.levelUp = true;
      }
    } else {
      data.levelUp = true;
    }

    // Return data for rendering
    return data;
  }

  /* -------------------------------------------- */
  /*  Event Listeners and Handlers
  /* -------------------------------------------- */

  /**
   * Activate event listeners using the prepared sheet HTML
   *
   * @param html {HTML}   The prepared HTML object ready to be rendered into the DOM
   */
  activateListeners(html) {
    super.activateListeners(html);
    if (!this.options.editable) return;

    // Inventory Functions
    html.find(".currency-convert").click(this._onConvertCurrency.bind(this));

    // Spell Preparation
    html.find(".toggle-prepared").click(this._onPrepareItem.bind(this));
  }

  /* -------------------------------------------- */

  /**
   * Handle toggling the prepared status of an Owned Item within the Actor
   *
   * @param {Event} event   The triggering click event
   * @private
   */
  _onPrepareItem(event) {
    event.preventDefault();
    const itemId = event.currentTarget.closest(".item").dataset.itemId;
    const item = this.actor.getOwnedItem(itemId);
    return item.update({ "data.preparation.prepared": !item.data.data.preparation.prepared });
  }

  _onLevelUp(event) {
    event.preventDefault;
    const itemId = event.currentTarget.closest(".item").dataset.itemId;
    const item = this.actor.items.get(itemId);

    const app = Object.values(this.actor.apps).find((o) => {
      return o instanceof LevelUpForm && o._element;
    });
    if (app) app.bringToTop();
    else new LevelUpForm(item).render(true);
  }

  /* -------------------------------------------- */

  async _onConvertCurrency(event) {
    event.preventDefault();
    const curr = duplicate(this.actor.data.data.currency);
    const convert = {
      cgil: { into: "sgil", each: 10 },
      sgil: { into: "gil", each: 10 },
      gil: { into: "pgil", each: 10 },
    };
    for (let [c, t] of Object.entries(convert)) {
      let change = Math.floor(curr[c] / t.each);
      curr[c] -= change * t.each;
      curr[t.into] += change;
    }
    return this.actor.update({ "data.currency": curr });
  }
}

/**
 * An Actor sheet for NPC type characters in the game system.
 * Extends the base ActorSheetFFD20 class.
 *
 * @type {ActorSheetFFD20}
 */
class ActorSheetFFD20NPC extends ActorSheetFFD20 {
  /**
   * Define default rendering options for the NPC sheet
   *
   * @returns {Object}
   */
  static get defaultOptions() {
    return mergeObject(super.defaultOptions, {
      classes: ["ffd20", "sheet", "actor", "npc"],
      width: 800,
      height: 840,
    });
  }

  /* -------------------------------------------- */
  /*  Rendering                                   */
  /* -------------------------------------------- */

  /**
   * Get the correct HTML template path to use for rendering this particular sheet
   *
   * @type {string}
   */
  get template() {
    if (!game.user.isGM && this.actor.limited) return "systems/ffd20/templates/actors/limited-sheet.hbs";
    return "systems/ffd20/templates/actors/npc-sheet.hbs";
  }

  // static get name() {
  //   return game.i18n.localize("FFD20.ActorSheetFFD20NPC");
  // }

  /* -------------------------------------------- */

  /**
   * Add some extra data when rendering the sheet to reduce the amount of logic required within the template.
   */
  async getData() {
    const data = await super.getData();

    // Challenge Rating
    try {
      data.labels.cr = CR.fromNumber(getProperty(this.actor.data, "data.details.cr.total"));
    } catch (e) {
      try {
        data.labels.cr = CR.fromNumber(getProperty(this.actor.data, "data.details.cr"));
      } catch (e) {
        data.labels.cr = CR.fromNumber(1);
      }
    }

    const hpSettings = game.settings.get("ffd20", "healthConfig");
    data["woundThresholds"] = hpSettings.variants.npc;

    data.levelUp = true;

    return data;
  }

  /* -------------------------------------------- */
  /*  Object Updates                              */
  /* -------------------------------------------- */

  /* -------------------------------------------- */
  /*  Event Listeners and Handlers                */
  /* -------------------------------------------- */

  /**
   * Activate event listeners using the prepared sheet HTML
   *
   * @param html {HTML}   The prepared HTML object ready to be rendered into the DOM
   */
  activateListeners(html) {
    super.activateListeners(html);

    // Rollable Health Formula
    html.find(".health .rollable").click(this._onRollHealthFormula.bind(this));

    // Adjust CR
    html.find("span.text-box.cr-input").on("click", (event) => {
      this._onSpanTextInput(event, this._adjustCR.bind(this));
    });
  }

  /* -------------------------------------------- */

  _adjustCR(event) {
    event.preventDefault();
    const el = event.currentTarget;

    const value = CR.fromString(el.tagName.toUpperCase() === "INPUT" ? el.value : el.innerText);
    const name = el.getAttribute("name");
    if (name) {
      this._pendingUpdates[name] = value;
    }

    // Update on lose focus
    if (event.originalEvent instanceof MouseEvent) {
      if (!this._submitQueued) {
        $(el).one("mouseleave", (event) => {
          this._onSubmit(event);
        });
      }
    } else this._onSubmit(event);
  }

  /**
   * Handle rolling NPC health values using the provided formula
   *
   * @param {Event} event     The original click event
   * @private
   */
  _onRollHealthFormula(event) {
    event.preventDefault();
    const formula = this.actor.data.data.attributes.hp.formula;
    if (!formula) return;
    const hp = RollFFD20.safeRoll(formula).total;
    AudioHelper.play({ src: CONFIG.sounds.dice });
    this.actor.update({ "data.attributes.hp.value": hp, "data.attributes.hp.max": hp });
  }
}

class ActorSheetFFD20NPCLite extends ActorSheetFFD20NPC {
  /**
   * Define default rendering options for the NPC sheet
   *
   * @returns {object}
   */
  static get defaultOptions() {
    return mergeObject(super.defaultOptions, {
      classes: ["ffd20", "sheet", "actor", "npc", "lite"],
      width: 440,
      height: 640,
      tabs: [{ navSelector: ".tabs", contentSelector: "primary", initial: "summary" }],
    });
  }

  get template() {
    if (!game.user.isGM && this.actor.limited) return "systems/ffd20/templates/actors/limited-sheet.hbs";
    return "systems/ffd20/templates/actors/npc-sheet-lite.hbs";
  }

  _prepareItems(data) {
    const [attacks] = data.items.reduce(
      (arr, item) => {
        item.img = item.img || foundry.data.ItemData.DEFAULT_ICON;
        item.hasUses = item.data.uses && item.data.uses.max > 0;
        item.isCharged = ["day", "week", "charges"].includes(getProperty(item, "data.uses.per"));

        getProperty(item, "data.uses.value") != null ? getProperty(item, "data.uses.value") : 1;

        if (item.type === "attack") arr[0].push(item);
        return arr;
      },
      [[]]
    );

    const attackSections = {
      all: {
        label: game.i18n.localize("FFD20.ActionPlural"),
        items: [],
        canCreate: true,
        initial: true,
        showTypes: true,
        dataset: { type: "attack", "attack-type": "weapon" },
      },
    };

    for (let a of attacks) {
      attackSections.all.items.push(a);
    }

    data.attacks = attackSections;
  }
}

class ActorSheetFFD20NPCLoot extends ActorSheetFFD20NPC {
  /**
   * Define default rendering options for the NPC sheet
   *
   * @returns {object}
   */
  static get defaultOptions() {
    return mergeObject(super.defaultOptions, {
      classes: ["ffd20", "sheet", "actor", "npc", "loot"],
      width: 620,
      height: 420,
    });
  }

  get template() {
    return "systems/ffd20/templates/actors/npc-sheet-loot.hbs";
  }

  get currentPrimaryTab() {
    return "inventory";
  }

  async getData() {
    const data = await super.getData();

    data.isLootSheet = true;
    data.sellMultiplier = this.actor.getFlag("ffd20", "sellMultiplier");

    // Get total value
    const gilValue = this.calculateTotalItemValue() + this.actor.mergeCurrency();
    const sellValue = this.calculateSellItemValue() + this.actor.mergeCurrency();
    data.totalValue = {
      gil: Math.max(0, Math.floor(gilValue)),
      sgil: Math.max(0, Math.floor(gilValue * 10 - Math.floor(gilValue) * 10)),
      cgil: Math.max(
        0,
        Math.floor(
          Math.floor(gilValue * 100 - Math.floor(gilValue) * 100) -
            Math.floor(gilValue * 10 - Math.floor(gilValue) * 10) * 10
        )
      ),
    };
    data.sellValue = {
      gil: Math.max(0, Math.floor(sellValue)),
      sgil: Math.max(0, Math.floor(sellValue * 10 - Math.floor(sellValue) * 10)),
      cgil: Math.max(
        0,
        Math.floor(
          Math.floor(sellValue * 100 - Math.floor(sellValue) * 100) -
            Math.floor(sellValue * 10 - Math.floor(sellValue) * 10) * 10
        )
      ),
    };

    // Set labels
    if (!data.labels) data.labels = {};
    data.labels.totalValue = game.i18n
      .localize("FFD20.ItemContainerTotalValue")
      .format(data.totalValue.gil, data.totalValue.sgil, data.totalValue.cgil);
    data.labels.sellValue = game.i18n
      .localize("FFD20.ItemContainerSellValue")
      .format(data.sellValue.gil, data.sellValue.sgil, data.sellValue.cgil);

    // Alter inventory columns
    for (let inv of Object.values(data.inventory)) {
      inv.hasActions = false;
      inv.canEquip = false;
      inv.showValue = true;
    }

    return data;
  }

  createTabs(html) {
    const tabGroups = {
      primary: {
        inventory: {},
      },
    };
    this._tabsAlt = createTabs.call(this, html, tabGroups, this._tabsAlt);
  }
}

class TokenDocumentFFD20 extends TokenDocument {
  async update(data, options) {
    // Resize token with actor size change
    const sizeKey = getProperty(data, "actorData.data.traits.size");
    if (sizeKey) {
      const size = CONFIG.FFD20.tokenSizes[sizeKey];
      setProperty(data, "width", size.w);
      setProperty(data, "height", size.h);
      setProperty(data, "scale", size.scale);
    }

    return super.update(data, options);
  }
}

class EntrySelector extends FormApplication {
  constructor(...args) {
    super(...args);

    this.entries = duplicate(getProperty(this.object.data, this.attribute) || []);
  }

  static get defaultOptions() {
    return mergeObject(super.defaultOptions, {
      id: "entry-selector",
      classes: ["ffd20", "entry"],
      title: "Entry Selector",
      template: "systems/ffd20/templates/apps/entry-selector.hbs",
      width: 320,
      height: "auto",
      closeOnSubmit: false,
      submitOnClose: false,
    });
  }

  get attribute() {
    return this.options.name;
  }

  get fields() {
    return this.options.fields.split(";");
  }

  get dtypes() {
    return this.options.dtypes.split(";");
  }

  get dataCount() {
    return this.fields.length;
  }

  getData() {
    const entries = this.entries.map((o) => {
      return o.map((o2, a) => {
        return [o2, this.dtypes[a]];
      });
    });

    return {
      entries: entries,
      fields: this.fields,
    };
  }

  activateListeners(html) {
    html.find(".entry-control").click(this._onEntryControl.bind(this));

    html.find('tr td input[type="text"]').change(this._onEntryChange.bind(this));

    html.find('button[type="submit"]').click(this._submitAndClose.bind(this));
  }

  async _updateObject(event, formData) {
    const updateData = {};

    updateData[this.attribute] = this.entries;

    return this.object.update(updateData);
  }

  async _onEntryControl(event) {
    event.preventDefault();
    const a = event.currentTarget;

    if (a.classList.contains("add-entry")) {
      let obj = [];
      for (let a = 0; a < this.dataCount; a++) {
        let dataType = this.dtypes[a];
        if (dataType === "Number") obj.push(0);
        else obj.push("");
      }
      this.entries.push(obj);
      this._render(false);
    }

    if (a.classList.contains("delete-entry")) {
      const tr = a.closest("tr");
      const index = parseInt(tr.dataset.index);
      this.entries.splice(index, 1);
      this._render(false);
    }
  }

  async _onEntryChange(event) {
    const a = event.currentTarget;

    const tr = a.closest("tr.entry");
    const index = parseInt(tr.dataset.index);
    const index2 = parseInt(a.dataset.index);
    const value = a.value;

    if (a.dataset.dtype === "Number") {
      let v = parseFloat(value);
      if (isNaN(v)) v = 0;
      this.entries[index][index2] = Math.floor(v * 100) / 100;
    } else this.entries[index][index2] = value;
  }

  async _submitAndClose(event) {
    event.preventDefault();
    await this._onSubmit(event);
    this.close();
  }
}

// deals with compendium versioning
const NEED_NEW_VERSION = {
  spells: "0.1.25",
  items: "0.1.25",
  bestiary: "0.1.25",
  feats: "0.1.25",
  classes: "0.1.25",
  races: "0.1.25",
  buffs: "0.1.25",
};

const COMPENDIUM_TYPES = {
  spells: "Item",
  items: "Item",
  bestiary: "Actor",
  feats: "Item",
  classes: "Item",
  races: "Item",
  buffs: "Item",
};

//adds filters to the compendium
class CompendiumBrowser extends Application {
  constructor(...args) {
    super(...args);

    this.items = [];

    this.filters = [];

    this.activeFilters = {};

    this._data = {
      loaded: false,
      data: {},
      promise: null,
      progress: null,
    };

    /**
     * The bottom scroll treshold (in pixels) at which the browser should start lazy loading some more items.
     *
     * @type {number}
     * @property
     */
    this.lazyLoadTreshold = 80;
    /**
     * The maximum number of items initially visible in regards to lazy loading.
     *
     * @type {number}
     * @property
     */
    this.lazyStart = 80;
    /**
     * The current amount of items visible in regards to lazy loading.
     *
     * @type {number}
     * @property
     */
    this.lazyIndex = 0;
    /**
     * The amount of new items to lazy load when triggered.
     *
     * @type {number}
     * @property
     */
    this.lazyAdd = 20;

    /**
     * A list of packs used, for filtering purposes.
     *
     * @type {Compendium{}}
     * @property
     */
    this.packs = {};

    /**
     * The RegExp to filter item names by.
     *
     * @type {RegExp}
     * @property
     */
    this.filterQuery = /.*/;
    this.searchString = "";

    /**
     * Load cached items
     */
    {
      this._savedItems = [];
      const cacheVersions = game.settings.get("ffd20", "compendiumSaveVersions");
      const thisVersion = SemanticVersion.fromString(cacheVersions[this.type] || "0.0.1");
      const needVersion = SemanticVersion.fromString(NEED_NEW_VERSION[this.type]);
      if (needVersion.isHigherThan(thisVersion)) {
        game.settings.set(
          "ffd20",
          "compendiumSaveVersions",
          mergeObject(cacheVersions, { [this.type]: game.system.data.version })
        );
      } else {
        const settings = game.settings.get("ffd20", "compendiumItems");
        if (settings[this.type]) {
          this._savedItems = settings[this.type];
        }
      }
    }
  }

  static get defaultOptions() {
    return mergeObject(super.defaultOptions, {
      template: "systems/ffd20/templates/apps/compendium-browser.hbs",
      classes: ["ffd20", "app"],
      width: 720,
      height: window.innerHeight - 60,
      top: 30,
      left: 40,
    });
  }

  shouldForceRefresh() {
    let result = false;

    if (!this._currentCompendiums) {
      this.updateForceRefreshData();
    }

    const forceRefreshData = game.settings.get("ffd20", "compendiumForceRefresh");
    const diff = getProperty(forceRefreshData, `diff.${this.type}`);

    // Determine difference in used compendiums
    if (!diff) {
      result = true;
    } else {
      let diffCompendiums = [];
      for (let o of [...this._currentCompendiums, ...diff]) {
        if (!diff.includes(o) || !this._currentCompendiums.includes(o)) diffCompendiums.push(o);
      }
      if (diffCompendiums.length > 0) result = true;
    }

    return result;
  }

  updateForceRefreshData(options = { save: false, refresh: true }) {
    // Generate list of usable compendiums
    if (options.refresh) {
      this._currentCompendiums = game.packs
        .filter((o) => {
          if (o.metadata.entity !== this.entityType) return false;

          if (this.shouldSkip(o)) return false;

          return true;
        })
        .map((o) => {
          return `${o.metadata.package}.${o.metadata.name}`;
        });
    }

    // Save results
    if (options.save) {
      const forceRefreshData = duplicate(game.settings.get("ffd20", "compendiumForceRefresh"));
      setProperty(forceRefreshData, `diff.${this.type}`, this._currentCompendiums);
      return game.settings.set("ffd20", "compendiumForceRefresh", forceRefreshData);
    }
  }

  async _createInitialElements() {
    let items = [];
    for (let a = 0; items.length < this.lazyLoadTreshold && a < this.items.length; a++) {
      const item = this.items[a];
      if (this._passesFilters(item.item)) {
        items.push(item);
      }
      this.lazyIndex = a + 1;
    }

    for (let item of items) {
      await this._addEntryElement(item);
    }
  }
  async _addEntryElement(item) {
    const elem = $(await renderTemplate("systems/ffd20/templates/internal/compendium-browser_entry.hbs", item));
    const rootElem = this.element.find(".directory-list");
    rootElem.append(elem);
    this.activateEntryListeners(elem);

    return elem;
  }
  _clearEntryElements() {
    this.element.find(".directory-list").empty();
  }

  activateEntryListeners(elem) {
    // Open sheet
    elem.find(".entry-name").click((ev) => {
      let li = ev.currentTarget.parentElement;
      this._onEntry(li.getAttribute("data-collection"), li.getAttribute("data-entry-id"));
    });

    // Make compendium item draggable
    elem[0].setAttribute("draggable", true);
    elem[0].addEventListener("dragstart", this._onDragStart, false);
  }

  async _initLazyLoad() {
    await this._createInitialElements();
    const rootElem = this.element.find(".directory-list");

    // Create function for lazy loading
    const lazyLoad = async () => {
      let createdItems = 0;
      for (let a = this.lazyIndex; a < this.items.length && createdItems < this.lazyAdd; a++) {
        const item = this.items[a];
        if (this._passesFilters(item.item)) {
          createdItems++;
          const elem = await this._addEntryElement(item);
          $(elem).fadeIn(500);
        }
        this.lazyIndex++;
      }
    };

    // Create callback for lazy loading
    $(rootElem).on("scroll", () => {
      const top = rootElem.scrollTop() + rootElem.height();
      const bottom = rootElem[0].scrollHeight - this.lazyLoadTreshold;
      if (top >= bottom) {
        lazyLoad();
      }
    });
  }

  async loadData() {
    return new Promise((resolve) => {
      let promise = this._data.promise;
      if (promise == null) {
        promise = this._gatherData();
        this._data.promise = promise;
      }

      promise.then(async () => {
        this._data.loaded = true;
        this._data.promise = null;
        try {
          await this.saveEntries();
        } catch (err) {
          console.error(err);
          await this.clearEntries();
        }
        resolve(this._data.data);
      });
    });
  }

  async _gatherData() {
    try {
      await this._fetchMetadata();
    } catch (err) {
      console.warn(err);
      this._savedItems = [];
      await this._fetchMetadata();
    }

    this._data.data = {
      filters: this.filters,
      collection: this.items.reduce((cur, o) => {
        cur[o.item._id] = o;
        return cur;
      }, {}),
      labels: {
        itemCount: game.i18n.localize("FFD20.TotalItems").format(this.items.length),
      },
    };
  }

  get typeName() {
    switch (this.type) {
      case "spells":
        return game.i18n.localize("FFD20.Spells");
      case "items":
        return game.i18n.localize("FFD20.Items");
      case "feats":
        return game.i18n.localize("FFD20.Features");
      case "bestiary":
        return game.i18n.localize("FFD20.Creatures");
      case "classes":
        return game.i18n.localize("FFD20.Classes");
      case "races":
        return game.i18n.localize("FFD20.Races");
      case "buffs":
        return game.i18n.localize("FFD20.Buffs");
    }
    return this.type;
  }

  get type() {
    return this.options.type;
  }

  get title() {
    return [this.typeName, "Browser"].join(" ");
  }

  get entityType() {
    return COMPENDIUM_TYPES[this.type];
  }

  getBasicFilters() {
    switch (this.type) {
      case "spells":
        return [{ type: "spell" }];
      case "items":
        return [
          { type: "equipment" },
          { type: "weapon" },
          { type: "consumable" },
          { type: "loot" },
          { type: "container" },
        ];
      case "feats":
        return [{ type: "feat" }];
      case "classes":
        return [{ type: "class" }];
      case "races":
        return [{ type: "race" }];
      case "buffs":
        return [{ type: "buff" }];
    }
    return [null];
  }

  /**
   * @param {Compendium} p - The compendium in question.
   * @returns {boolean} Whether the compendium should be skipped.
   */
  shouldSkip(p) {
    // Check disabled status
    const config = game.settings.get("core", "compendiumConfiguration")[p.collection];
    const disabled = getProperty(config, "ffd20.disabled") === true;
    if (disabled) return true;

    // Skip if set to private and the user is not a GM
    if (p.private && !game.user.isGM) return true;

    // Don't skip the compendium
    return false;
  }

  _onProgress(progress) {
    progress.loaded++;
    progress.pct = Math.round((progress.loaded * 10) / progress.total) * 10;
    SceneNavigation._onLoadProgress(progress.message, progress.pct);
  }

  async loadCompendium(p, filters = [null]) {
    const progress = this._data.progress;

    if (p.metadata.system != "ffd20") {
      console.warn(p.metadata.label + " is incompatible with this browser and has been skipped.");
      this._onProgress(progress);
      return;
    }

    // Retrieve compendium contents
    let items = [];
    for (let filter of filters) {
      items.push(...(await p.getDocuments(filter)));
    }

    if (p.translated) {
      items = items.map((item) => p.translate(item));
    }

    // Flush full compendium contents from memory
    p.clear();

    for (let i of items) {
      if (!this._filterItems(i)) continue;
      this.packs[p.collection] = p;
      this.items.push(this._mapEntry(p, i.data));
    }
    this._onProgress(progress);
  }

  async _fetchMetadata() {
    this.items = [];

    if (this.shouldForceRefresh() || this._savedItems.length === 0) {
      // Initialize progress bar
      let packs = [];
      const progress = { pct: 0, message: game.i18n.localize("FFD20.LoadingCompendiumBrowser"), loaded: -1, total: 0 };
      for (let p of game.packs.values()) {
        if (p.documentClass.documentName === this.entityType && !this.shouldSkip(p)) {
          progress.total++;
          packs.push(p);
        } else {
          if (Object.hasOwnProperty.call(this.packs, p.collection)) {
            delete this.packs[p.collection];
          }
        }
      }

      // Clear filters without applicable packs
      if (packs.length === 0) {
        this.filters = [];
        return;
      }

      this._data.progress = progress;
      this._onProgress(progress);

      // Load compendiums
      for (let p of packs) {
        await this.loadCompendium(p, this.getBasicFilters());
      }

      // Sort items
      this.items = naturalSort(this.items, "item.name");

      // Return if no appropriate items were found
      if (this.items.length === 0) {
        return;
      }
    } else {
      for (let i of this._savedItems) {
        const p = game.packs.get(i.collection._id);
        if (p) {
          this.items.push(this._mapEntry(p, i.item));
          this.packs[i.collection._id] = p;
        }
      }
      this._savedItems = [];
    }

    // Gather filter data
    this._fetchGeneralFilters();
    switch (this.type) {
      case "spells":
        this._fetchSpellFilters();
        break;
      case "items":
        this._fetchItemFilters();
        break;
      case "bestiary":
        this._fetchBestiaryFilters();
        break;
      case "feats":
        this._fetchFeatFilters();
        break;
      case "classes":
        this._fetchClassFilters();
        break;
      case "races":
        this._fetchRaceFilters();
        break;
      case "buffs":
        this._fetchBuffFilters();
        break;
    }

    // Create an empty active filters object
    this.activeFilters = this.filters.reduce((cur, f) => {
      cur[f.path] = [];
      return cur;
    }, {});

    // Merge active filters object with stored settings
    const filterSettings =
      getProperty(game.settings.get("ffd20", "compendiumFilters") || {}, `${this.type}.activeFilters`) || {};
    for (let [k, v] of Object.entries(filterSettings)) {
      if (!this.activeFilters[k]) continue;
      this.activeFilters[k] = v;
    }

    // Apply active filters to template
    for (let k of Object.keys(this.activeFilters)) {
      const filter = this.filters.find((o) => o.path === k);
      if (!filter) continue;
      for (let k2 of this.activeFilters[k]) {
        filter.active = filter.active || {};
        filter.active[k2] = true;
      }
    }
  }

  _filterItems(item) {
    if (this.type === "spells" && item.type !== "spell") return false;
    if (this.type === "items" && !ItemFFD20.isInventoryItem(item.type)) return false;
    if (this.type === "feats" && item.type !== "feat") return false;
    if (this.type === "classes" && item.type !== "class") return false;
    if (this.type === "races" && item.type !== "race") return false;
    if (this.type === "buffs" && item.type !== "buff") return false;
    return true;
  }

  /* ------------------------------------- */
  /*  Mapping Functions                    */
  /* ------------------------------------- */
  _mapFeats(result, item) {
    this.extraFilters = this.extraFilters || {
      tags: {},
      associations: {
        class: {},
      },
    };

    result.item.tags = (item.data.tags || []).reduce((cur, o) => {
      this.extraFilters.tags[o[0]] = true;
      cur.push(o[0]);
      return cur;
    }, []);

    result.item.assocations = {
      class: (item.data.featType === "classFeat" ? getProperty(item.data, "associations.classes") || [] : []).reduce(
        (cur, o) => {
          this.extraFilters.associations.class[o[0]] = true;
          cur.push(o[0]);
          return cur;
        },
        []
      ),
    };
  }

  _mapBestiary(result, item) {
    this.extraFilters = this.extraFilters || {
      "data.details.cr.total": {},
      subTypes: {},
    };
    result.item.creatureType = "";
    result.item.subTypes = [];

    // Add CR filters
    if (item.type === "npc") {
      const cr = getProperty(item, "data.details.cr.total");
      if (cr && !this.extraFilters["data.details.cr.total"][cr]) this.extraFilters["data.details.cr.total"][cr] = true;
    }
    // Get creature (sub)type
    if (item.items) {
      const race = item.items.filter((o) => o.type === "race")[0];
      if (race != null) {
        result.item.creatureType = race.data.data.creatureType;
        result.item.subTypes = race.data.data.subTypes?.map((o) => {
          this.extraFilters.subTypes[o[0]] = true;
          return o[0];
        });
      }
    } else {
      item.subTypes?.forEach((o) => {
        this.extraFilters.subTypes[o] = true;
      });
      result.item.creatureType = item.creatureType;
      result.item.subTypes = item.subTypes;
    }
  }

  _mapItems(result, item) {
    this.extraFilters = this.extraFilters || {};

    result.item.weaponProps = Object.entries(getProperty(item.data, "data.properties") || []).reduce((cur, o) => {
      if (o[1]) cur.push(o[0]);
      return cur;
    }, []);
  }

  _mapSpells(result, item) {
    this.extraFilters = this.extraFilters || {
      "learnedAt.class": [],
      "learnedAt.domain": [],
      "learnedAt.subDomain": [],
      "learnedAt.elementalSchool": [],
      "learnedAt.bloodline": [],
      "data.subschool": [],
      spellTypes: [],
    };

    result.item.allSpellLevels = [];

    // Add class/domain/etc filters
    result.item.learnedAt = {
      class: (getProperty(item, "data.learnedAt.class") || []).reduce((cur, o) => {
        this.extraFilters["learnedAt.class"][o[0]] = true;
        if (!result.item.allSpellLevels.includes(o[1])) result.item.allSpellLevels.push(o[1]);
        cur.push(o[0]);
        return cur;
      }, []),
      domain: (getProperty(item, "data.learnedAt.domain") || []).reduce((cur, o) => {
        this.extraFilters["learnedAt.domain"][o[0]] = true;
        if (!result.item.allSpellLevels.includes(o[1])) result.item.allSpellLevels.push(o[1]);
        cur.push(o[0]);
        return cur;
      }, []),
      subDomain: (getProperty(item, "data.learnedAt.subDomain") || []).reduce((cur, o) => {
        this.extraFilters["learnedAt.subDomain"][o[0]] = true;
        if (!result.item.allSpellLevels.includes(o[1])) result.item.allSpellLevels.push(o[1]);
        cur.push(o[0]);
        return cur;
      }, []),
      elementalSchool: (getProperty(item, "data.learnedAt.elementalSchool") || []).reduce((cur, o) => {
        this.extraFilters["learnedAt.elementalSchool"][o[0]] = true;
        if (!result.item.allSpellLevels.includes(o[1])) result.item.allSpellLevels.push(o[1]);
        cur.push(o[0]);
        return cur;
      }, []),
      bloodline: (getProperty(item, "data.learnedAt.bloodline") || []).reduce((cur, o) => {
        this.extraFilters["learnedAt.bloodline"][o[0]] = true;
        if (!result.item.allSpellLevels.includes(o[1])) result.item.allSpellLevels.push(o[1]);
        cur.push(o[0]);
        return cur;
      }, []),
      spellLevel: {
        class: (getProperty(item, "data.learnedAt.class") || []).reduce((cur, o) => {
          cur[o[0]] = o[1];
          return cur;
        }, {}),
        domain: (getProperty(item, "data.learnedAt.domain") || []).reduce((cur, o) => {
          cur[o[0]] = o[1];
          return cur;
        }, {}),
        subDomain: (getProperty(item, "data.learnedAt.subDomain") || []).reduce((cur, o) => {
          cur[o[0]] = o[1];
          return cur;
        }, {}),
        // "elementalSchool": (getProperty(item, "data.learnedAt.elementalSchool") || []).reduce((cur, o) => {
        //   cur[o[0]] = o[1];
        //   return cur;
        // }, {}),
        bloodline: (getProperty(item, "data.learnedAt.bloodline") || []).reduce((cur, o) => {
          cur[o[0]] = o[1];
          return cur;
        }, {}),
      },
    };

    // Add subschools
    {
      const subschool = item.data.subschool;
      if (subschool) this.extraFilters["data.subschool"][subschool] = true;
    }
    // Add spell types
    {
      const spellTypes = item.data.types ? item.data.types.split(CONFIG.FFD20.re.traitSeparator) : [];
      result.item.spellTypes = spellTypes;
      for (let st of spellTypes) {
        this.extraFilters["spellTypes"][st] = true;
      }
    }
  }

  _mapClasses(result, item) {
    this.extraFilters = this.extraFilters || {
      "data.hd": {},
      "data.skillsPerLevel": {},
      "data.parentClass": {},
    };

    // Add HD
    {
      const hd = item.data.hd;
      if (hd) this.extraFilters["data.hd"][hd] = true;
    }
    // Add skills per level
    {
      const s = item.data.skillsPerLevel;
      if (s) this.extraFilters["data.skillsPerLevel"][s] = true;
    }
    // Add parent classes
    {
      const s = item.data.parentClass;
      if (s) this.extraFilters["data.parentClass"][s] = true;
    }
  }

  _mapRaces(result, item) {
    this.extraFilters = this.extraFilters || {
      subTypes: {},
    };
    result.item.subTypes = [];

    // Get subtypes
    result.item.subTypes = item.data.subTypes.map((o) => {
      this.extraFilters.subTypes[o[0]] = true;
      return o[0];
    });
  }

  _mapBuffs(result, item) {
    this.extraFilters = this.extraFilters || {
      types: {},
    };

    // Get types
    this.extraFilters.types[item.data.buffType] = true;
  }

  _mapEntry(pack, item) {
    const result = {
      collection: {
        _id: pack.collection,
        label: pack.metadata.label,
      },
      item: {
        _id: item._id,
        name: item.name,
        type: item.type,
        img: item.img,
        data: item.data,
        pack: pack.collection,
      },
    };

    switch (this.type) {
      case "feats":
        this._mapFeats(result, item);
        break;
      case "bestiary":
        this._mapBestiary(result, item);
        break;
      case "items":
        this._mapItems(result, item);
        break;
      case "spells":
        this._mapSpells(result, item);
        break;
      case "classes":
        this._mapClasses(result, item);
        break;
      case "races":
        this._mapRaces(result, item);
        break;
      case "buffs":
        this._mapBuffs(result, item);
        break;
    }

    return result;
  }

  async getData() {
    this.updateForceRefreshData();
    if (this.shouldForceRefresh() || !this._data.loaded) await this.loadData();
    await this.updateForceRefreshData({ save: true, refresh: false });

    const data = duplicate(this._data.data);
    data.searchString = this.searchString;

    return data;
  }

  async refresh() {
    await this.loadData();
    this.render(false);
  }

  _fetchGeneralFilters() {
    this.filters = [
      {
        path: "pack",
        label: game.i18n.localize("FFD20.Compendium"),
        items: naturalSort(
          Object.entries(this.packs).reduce((cur, o) => {
            cur.push({ key: o[0], name: o[1].metadata.label });
            return cur;
          }, []),
          "name"
        ),
      },
    ];
  }

  _fetchSpellFilters() {
    this.filters.push(
      ...[
        {
          path: "data.school",
          label: game.i18n.localize("FFD20.SpellSchool"),
          items: naturalSort(
            Object.entries(CONFIG.FFD20.spellSchools).reduce((cur, o) => {
              cur.push({ key: o[0], name: o[1] });
              return cur;
            }, []),
            "name"
          ),
        },
        {
          path: "data.multischool",
          label: game.i18n.localize("FFD20.multiSchool"),
          items: naturalSort(
            Object.entries(CONFIG.FFD20.multiSchools).reduce((cur, o) => {
              cur.push({ key: o[0], name: o[1] });
              return cur;
            }, []),
            "name"
          ),
        },
        {
          path: "data.subschool",
          label: game.i18n.localize("FFD20.SubSchool"),
          items: naturalSort(
            Object.keys(this.extraFilters["data.subschool"]).reduce((cur, o) => {
              cur.push({ key: o, name: o });
              return cur;
            }, []),
            "name"
          ),
        },
        {
          path: "spellTypes",
          label: game.i18n.localize("FFD20.TypePlural"),
          items: naturalSort(
            Object.keys(this.extraFilters["spellTypes"]).reduce((cur, o) => {
              cur.push({ key: o, name: o });
              return cur;
            }, []),
            "name"
          ),
        },
        {
          path: "learnedAt.class",
          label: game.i18n.localize("FFD20.ClassPlural"),
          items: naturalSort(
            Object.keys(this.extraFilters["learnedAt.class"]).reduce((cur, o) => {
              cur.push({ key: o, name: o });
              return cur;
            }, []),
            "name"
          ),
        },
        {
          path: "learnedAt.domain",
          label: game.i18n.localize("FFD20.Domain"),
          items: naturalSort(
            Object.keys(this.extraFilters["learnedAt.domain"]).reduce((cur, o) => {
              cur.push({ key: o, name: o });
              return cur;
            }, []),
            "name"
          ),
        },
        {
          path: "learnedAt.subDomain",
          label: game.i18n.localize("FFD20.SubDomain"),
          items: naturalSort(
            Object.keys(this.extraFilters["learnedAt.subDomain"]).reduce((cur, o) => {
              cur.push({ key: o, name: o });
              return cur;
            }, []),
            "name"
          ),
        },
        // {
        //   path: "learnedAt.elementalSchool",
        //   label: game.i18n.localize("FFD20.ElementalSchool"),
        //   items: this.extraFilters["learnedAt.elementalSchool"].reduce((cur, o) => {
        //     cur.push({ key: o, name: o });
        //     return cur;
        //   }, []),
        // },
        {
          path: "learnedAt.bloodline",
          label: game.i18n.localize("FFD20.Bloodline"),
          items: naturalSort(
            Object.keys(this.extraFilters["learnedAt.bloodline"]).reduce((cur, o) => {
              cur.push({ key: o, name: o });
              return cur;
            }, []),
            "name"
          ),
        },
        {
          path: "_spellLevel",
          label: game.i18n.localize("FFD20.SpellLevel"),
          items: Object.entries(CONFIG.FFD20.spellLevels).reduce((cur, o) => {
            cur.push({ key: o[0], name: o[1] });
            return cur;
          }, []),
        },
      ]
    );
  }

  _fetchItemFilters() {
    this.filters.push(
      ...[
        {
          path: "type",
          label: game.i18n.localize("FFD20.Type"),
          items: [
            { key: "weapon", name: game.i18n.localize("FFD20.ItemTypeWeapon") },
            { key: "equipment", name: game.i18n.localize("FFD20.ItemTypeEquipment") },
            { key: "consumable", name: game.i18n.localize("FFD20.ItemTypeConsumable") },
            { key: "loot", name: game.i18n.localize("FFD20.Misc") },
          ],
        },
        {
          path: "data.weaponType",
          label: game.i18n.localize("FFD20.WeaponType"),
          items: Object.entries(CONFIG.FFD20.weaponTypes).reduce((cur, o) => {
            cur.push({ key: o[0], name: o[1]._label });
            return cur;
          }, []),
        },
        {
          path: "data.weaponSubtype",
          label: game.i18n.localize("FFD20.WeaponSubtype"),
          items: Object.values(CONFIG.FFD20.weaponTypes).reduce((cur, o) => {
            cur = cur.concat(
              Object.entries(o)
                .filter((i) => !i[0].startsWith("_"))
                .reduce((arr, i) => {
                  if (!cur.filter((a) => a.key === i[0]).length) {
                    arr.push({ key: i[0], name: i[1] });
                  }
                  return arr;
                }, [])
            );
            return cur;
          }, []),
        },
        {
          path: "weaponProps",
          label: game.i18n.localize("FFD20.WeaponProperties"),
          items: Object.entries(CONFIG.FFD20.weaponProperties).reduce((cur, o) => {
            cur.push({ key: o[0], name: o[1] });
            return cur;
          }, []),
        },
        {
          path: "data.equipmentType",
          label: game.i18n.localize("FFD20.EquipmentType"),
          items: Object.entries(CONFIG.FFD20.equipmentTypes).reduce((cur, o) => {
            cur.push({ key: o[0], name: o[1]._label });
            return cur;
          }, []),
        },
        {
          path: "data.equipmentSubtype",
          label: game.i18n.localize("FFD20.EquipmentSubtype"),
          items: Object.values(CONFIG.FFD20.equipmentTypes).reduce((cur, o) => {
            cur = cur.concat(
              Object.entries(o)
                .filter((i) => !i[0].startsWith("_"))
                .reduce((arr, i) => {
                  if (!cur.filter((a) => a.key === i[0]).length) {
                    arr.push({ key: i[0], name: i[1] });
                  }
                  return arr;
                }, [])
            );
            return cur;
          }, []),
        },
        {
          path: "data.slot",
          label: game.i18n.localize("FFD20.Slot"),
          items: Object.values(CONFIG.FFD20.equipmentSlots).reduce((cur, o) => {
            cur = cur.concat(
              Object.entries(o)
                .filter((i) => !i[0].startsWith("_"))
                .reduce((arr, i) => {
                  if (!cur.filter((a) => a.key === i[0]).length) {
                    arr.push({ key: i[0], name: i[1] });
                  }
                  return arr;
                }, [])
            );
            return cur;
          }, []),
        },
        {
          path: "data.consumableType",
          label: game.i18n.localize("FFD20.ConsumableType"),
          items: Object.entries(CONFIG.FFD20.consumableTypes).reduce((cur, o) => {
            cur.push({ key: o[0], name: o[1] });
            return cur;
          }, []),
        },
        {
          path: "data.subType",
          label: game.i18n.localize("FFD20.Misc"),
          items: Object.entries(CONFIG.FFD20.lootTypes).reduce((cur, o) => {
            cur.push({ key: o[0], name: o[1] });
            return cur;
          }, []),
        },
      ]
    );
  }

  _fetchBestiaryFilters() {
    this.filters.push(
      ...[
        {
          path: "data.details.cr.total",
          label: "CR",
          items: naturalSort(
            Object.keys(this.extraFilters["data.details.cr.total"]).reduce((cur, o) => {
              cur.push({ key: o, name: CR.fromNumber(o) });
              return cur;
            }, []),
            "name"
          ),
        },
        {
          path: "creatureType",
          label: game.i18n.localize("FFD20.CreatureType"),
          items: naturalSort(
            Object.entries(CONFIG.FFD20.creatureTypes).reduce((cur, o) => {
              cur.push({ key: o[0], name: o[1] });
              return cur;
            }, []),
            "name"
          ),
        },
        {
          path: "subTypes",
          label: game.i18n.localize("FFD20.RaceSubtypePlural"),
          items: naturalSort(
            Object.keys(this.extraFilters["subTypes"]).reduce((cur, o) => {
              cur.push({ key: o, name: o });
              return cur;
            }, []),
            "name"
          ),
        },
      ]
    );
  }

  _fetchFeatFilters() {
    this.filters.push(
      ...[
        {
          path: "data.featType",
          label: game.i18n.localize("FFD20.Type"),
          items: Object.entries(CONFIG.FFD20.featTypes).reduce((cur, o) => {
            cur.push({ key: o[0], name: o[1] });
            return cur;
          }, []),
        },
        {
          path: "tags",
          label: game.i18n.localize("FFD20.Tags"),
          items: naturalSort(
            Object.keys(this.extraFilters.tags).reduce((cur, o) => {
              cur.push({ key: o, name: o });
              return cur;
            }, []),
            "name"
          ),
        },
        {
          path: "assocations.class",
          label: game.i18n.localize("FFD20.ClassPlural"),
          items: naturalSort(
            Object.keys(this.extraFilters.associations["class"]).reduce((cur, o) => {
              cur.push({ key: o, name: o });
              return cur;
            }, []),
            "name"
          ),
        },
      ]
    );
  }

  // add other class features
  _fetchClassFilters() {
    this.filters.push(
      ...[
        {
          path: "data.classType",
          label: game.i18n.localize("FFD20.ClassType"),
          items: Object.entries(CONFIG.FFD20.classTypes).reduce((cur, o) => {
            cur.push({ key: o[0], name: o[1] });
            return cur;
          }, []),
        },
        // TODO class catagory
        {
          path: "data.classSubType",
          label: game.i18n.localize("FFD20.ClassSubType"),
          items: Object.entries(CONFIG.FFD20.classSubTypes).reduce((cur, o) => {
            cur.push({ key: o[0], name: o[1] });
            return cur;
          }, []),
        },
        // TODO Parent class
        {
          path: "data.parentClass",
          label: game.i18n.localize("FFD20.ParentClass"),
          items: Object.keys(this.extraFilters["data.parentClass"]).reduce((cur, o) => {
            cur.push({ key: o.toString(), name: o.toString() });
            return cur;
          }, []),
        },
        {
          path: "data.hd",
          label: game.i18n.localize("FFD20.HitDie"),
          items: Object.keys(this.extraFilters["data.hd"]).reduce((cur, o) => {
            cur.push({ key: o.toString(), name: o.toString() });
            return cur;
          }, []),
        },
        // TODO MP type
        {
          path: "data.classBaseMPTypes",
          label: game.i18n.localize("FFD20.ClassMPType"),
          items: Object.entries(CONFIG.FFD20.classBaseMPTypes).reduce((cur, o) => {
            cur.push({ key: o[0], name: o[1] });
            return cur;
          }, []),
        },
        //  TODO Casting stat
        {
          path: "data.classCastingStat",
          label: game.i18n.localize("FFD20.SpellcastingAbility"),
          items: Object.entries(CONFIG.FFD20.classCastingStats).reduce((cur, o) => {
            cur.push({ key: o[0], name: o[1] });
            return cur;
          }, []),
        },
        {
          path: "data.bab",
          label: game.i18n.localize("FFD20.BAB"),
          items: Object.entries(CONFIG.FFD20.classBAB).reduce((cur, o) => {
            cur.push({ key: o[0], name: o[1] });
            return cur;
          }, []),
        },
        {
          path: "data.skillsPerLevel",
          label: game.i18n.localize("FFD20.SkillsPerLevel"),
          items: Object.keys(this.extraFilters["data.skillsPerLevel"]).reduce((cur, o) => {
            cur.push({ key: o.toString(), name: o.toString() });
            return cur;
          }, []),
        },
        {
          path: "data.savingThrows.fort.value",
          label: game.i18n.localize("FFD20.SavingThrowFort"),
          items: Object.entries(CONFIG.FFD20.classSavingThrows).reduce((cur, o) => {
            cur.push({ key: o[0], name: o[1] });
            return cur;
          }, []),
        },
        {
          path: "data.savingThrows.ref.value",
          label: game.i18n.localize("FFD20.SavingThrowRef"),
          items: Object.entries(CONFIG.FFD20.classSavingThrows).reduce((cur, o) => {
            cur.push({ key: o[0], name: o[1] });
            return cur;
          }, []),
        },
        {
          path: "data.savingThrows.will.value",
          label: game.i18n.localize("FFD20.SavingThrowWill"),
          items: Object.entries(CONFIG.FFD20.classSavingThrows).reduce((cur, o) => {
            cur.push({ key: o[0], name: o[1] });
            return cur;
          }, []),
        },
      ]
    );
  }

  _fetchRaceFilters() {
    this.filters.push(
      ...[
        {
          path: "data.creatureType",
          label: game.i18n.localize("FFD20.CreatureType"),
          items: naturalSort(
            Object.entries(CONFIG.FFD20.creatureTypes).reduce((cur, o) => {
              cur.push({ key: o[0], name: o[1] });
              return cur;
            }, []),
            "name"
          ),
        },
        {
          path: "subTypes",
          label: game.i18n.localize("FFD20.RaceSubtypePlural"),
          items: naturalSort(
            Object.keys(this.extraFilters["subTypes"]).reduce((cur, o) => {
              cur.push({ key: o, name: o });
              return cur;
            }, []),
            "name"
          ),
        },
      ]
    );
  }

  _fetchBuffFilters() {
    this.filters.push(
      ...[
        {
          path: "data.buffType",
          label: game.i18n.localize("FFD20.Type"),
          items: naturalSort(
            Object.entries(CONFIG.FFD20.buffTypes).reduce((cur, o) => {
              cur.push({ key: o[0], name: o[1] });
              return cur;
            }, []),
            "name"
          ),
        },
      ]
    );
  }

  async _render(force, ...args) {
    await super._render(force, ...args);

    // Collapse filter displays
    {
      const elems = this.element.find(".filter-content");
      for (const e of elems) {
        const pE = e.closest(".filter");
        const path = pE.dataset.path;
        if (this.activeFilters[path].length === 0) {
          $(e).css("display", "none");
        }
      }
    }

    // Determine filtered item count
    this._determineFilteredItemCount();
  }

  activateListeners(html) {
    super.activateListeners(html);

    html.find('input[name="search"]').keyup(this._onFilterResults.bind(this));

    html.find('.filter input[type="checkbox"]').change(this._onActivateBooleanFilter.bind(this));

    html.find(".filter h3").click(this._toggleFilterVisibility.bind(this));

    html.find("button.refresh").click(this.refresh.bind(this));

    // Lazy load
    this._initLazyLoad();
  }

  /**
   * Handle opening a single compendium entry by invoking the configured entity class and its sheet
   *
   * @param collectionKey
   * @param entryId
   * @private
   */
  async _onEntry(collectionKey, entryId) {
    const pack = game.packs.find((o) => o.collection === collectionKey);
    const entity = await pack.getDocument(entryId);
    entity.sheet.render(true);
  }

  /**
   * Handle a new drag event from the compendium, create a placeholder token for dropping the item
   *
   * @param event
   * @private
   */
  _onDragStart(event) {
    const li = this,
      packName = li.getAttribute("data-collection"),
      pack = game.packs.find((p) => p.collection === packName);

    // Get the pack
    if (!pack) {
      event.preventDefault();
      return false;
    }

    // Set the transfer data
    event.dataTransfer.setData(
      "text/plain",
      JSON.stringify({
        type: pack.documentClass.documentName,
        pack: pack.collection,
        id: li.getAttribute("data-entry-id"),
      })
    );
  }

  _toggleFilterVisibility(event) {
    event.preventDefault();
    const title = event.currentTarget;
    const content = $(title).siblings(".filter-content")[0];

    if (content.style.display === "none") content.style.display = "block";
    else content.style.display = "none";
  }

  _onFilterResults(event) {
    event.preventDefault();
    let input = event.currentTarget;

    // Define filtering function
    let filter = async (query) => {
      this.filterQuery = query;
      await this._filterResults();
    };

    // Filter if we are done entering keys
    let query = new RegExp(RegExp.escape(input.value), "i");
    this.searchString = input.value;
    if (this._filterTimeout) {
      clearTimeout(this._filterTimeout);
      this._filterTimeout = null;
    }
    this._filterTimeout = setTimeout(() => filter(query), 100);
  }

  _onActivateBooleanFilter(event) {
    event.preventDefault();
    let input = event.currentTarget;
    const path = input.closest(".filter").dataset.path;
    const key = input.name;
    const value = input.checked;

    const filter = this._data.data.filters.find((o) => o.path === path);
    if (filter) {
      if (!filter.active) filter.active = {};
    }

    if (value) {
      let index = this.activeFilters[path].indexOf(key);
      if (index < 0) {
        this.activeFilters[path].push(key);
        filter.active[key] = true;
      }
    } else {
      let index = this.activeFilters[path].indexOf(key);
      if (index >= 0) {
        this.activeFilters[path].splice(index, 1);
        if (filter.active[key] != null) delete filter.active[key];
      }
    }

    // Save filter settings
    {
      const settings = game.settings.get("ffd20", "compendiumFilters");
      setProperty(settings, `${this.type}.activeFilters`, this.activeFilters);
      game.settings.set("ffd20", "compendiumFilters", settings);
    }

    return this._filterResults();
  }

  async _filterResults() {
    this.lazyIndex = 0;
    // Clear entry elements
    this._clearEntryElements();

    // Scroll up
    const rootElem = this.element.find(".directory-list")[0];
    rootElem.scrollTop = 0;

    // Create new elements
    await this._createInitialElements();

    // Determine filtered item count
    this._determineFilteredItemCount();
  }

  _determineFilteredItemCount() {
    let itemCount = 0;
    for (let item of this.items) {
      if (this._passesFilters(item.item)) {
        itemCount++;
      }
    }
    this.element
      .find('span[data-type="filterItemCount"]')
      .text(game.i18n.localize("FFD20.FilteredItems").format(itemCount));
  }

  _passesFilters(item) {
    if (!this.filterQuery.test(item.name)) return false;

    for (let [path, filter] of Object.entries(this.activeFilters)) {
      if (filter.length === 0) continue;

      // Handle special cases
      // Handle Spell Level
      {
        let result = null;
        if (this.type === "spells" && path === "_spellLevel") {
          result = false;
          let hasActiveFilter = false;
          const spellLevels = this.activeFilters[path];
          const checks = [
            { path: "learnedAt.class", type: "class" },
            { path: "learnedAt.domain", type: "domain" },
            { path: "learnedAt.subDomain", type: "subDomain" },
            { path: "learnedAt.elementalSchool", type: "elementalSchool" },
            { path: "learnedAt.bloodline", type: "bloodline" },
          ];
          for (let c of checks) {
            const f = this.activeFilters[c.path];
            if (!f || !f.length) continue;
            hasActiveFilter = true;
            for (let fi of f) {
              const p = getProperty(item, `learnedAt.spellLevel.${c.type}`);
              for (let sl of spellLevels) {
                if (p[fi] === parseInt(sl)) result = true;
              }
            }
          }
          if (!hasActiveFilter) {
            for (let sl of spellLevels) {
              if (item.allSpellLevels.includes(parseInt(sl))) result = true;
            }
          }
        }
        if (result === false) return false;
        else if (result === true) continue;
      }

      // Handle the rest
      const prop = getProperty(item, path);
      if (prop == null) return false;
      if (typeof prop === "number") {
        filter = filter.map((o) => parseFloat(o)).filter((o) => !isNaN(o));
      }
      if (prop instanceof Array) {
        if (!filter.every((o) => prop.includes(o))) return false;
        continue;
      }
      if (!filter.includes(prop)) return false;
    }

    return true;
  }

  getSaveEntries() {
    let result = [];

    let propKeys = ["_id", "name", "img"];

    switch (this.type) {
      case "spells":
        propKeys.push(
          "data.learnedAt.class",
          "data.learnedAt.domain",
          "data.learnedAt.subDomain",
          "data.learnedAt.elementalSchool",
          "data.learnedAt.bloodline",
          "data.school",
          "data.multischool",
          "data.subschool",
          "data.types"
        );
        break;
      case "items":
        propKeys.push(
          "type",
          "data.properties",
          "data.weaponType",
          "data.weaponSubtype",
          "data.equipmentType",
          "data.equipmentSubtype",
          "data.slot",
          "data.consumableType",
          "data.subType"
        );
        break;
      case "feats":
        propKeys.push("data.featType", "data.associations.classes", "data.tags");
        break;
      case "bestiary":
        propKeys.push("data.details.cr.total");
        break;
      case "classes":
        propKeys.push(
          "data.classType",
          "data.classSubTypes",
          "data.parentClass",
          "data.bab",
          "data.hd",
          "data.classBaseMPTypes",
          "data.classCastingStat",
          "data.skillsPerLevel",
          "data.savingThrows.fort.value",
          "data.savingThrows.ref.value",
          "data.savingThrows.will.value"
        );
        break;
      case "races":
        propKeys.push("data.creatureType", "data.subTypes");
        break;
    }

    for (let i of this.items) {
      let resultObj = {
        collection: i.collection,
        item: {},
      };

      // Copy parsed properties
      for (let k of Object.keys(i.item)) {
        if (k !== "data") {
          resultObj.item[k] = i.item[k];
        }
      }

      // Copy specific data properties
      for (let k of propKeys) {
        if (hasProperty(i.item, k)) {
          setProperty(resultObj, `item.${k}`, getProperty(i.item, k));
        }
      }

      result.push(resultObj);
    }

    return result;
  }

  saveEntries() {
    const entries = this.getSaveEntries();

    const settings = game.settings.get("ffd20", "compendiumItems") || {};
    settings[this.type] = entries;

    return game.settings.set("ffd20", "compendiumItems", settings);
  }

  clearEntries() {
    const settings = game.settings.get("ffd20", "compendiumItems") || {};
    settings[this.type] = [];

    return game.settings.set("ffd20", "compendiumItems", settings);
  }
}

class SidebarFFD20 extends Sidebar {
  constructor(...args) {
    super(...args);

    this.compendiums = {
      spells: new CompendiumBrowser({ type: "spells", entityType: "Item" }),
      items: new CompendiumBrowser({ type: "items", entityType: "Item" }),
      bestiary: new CompendiumBrowser({ type: "bestiary", entityType: "Actor" }),
    };
  }

  async _render(...args) {
    await super._render(...args);

    const parent = this.element.find("#compendium .directory-footer");
    const child = await renderTemplate("systems/ffd20/templates/sidebar/compendiums-footer.hbs", {});
    parent.append(child);
    this.activateExtraListeners(parent);
  }

  activateExtraListeners(html) {
    html.find(".compendium-footer .compendium.spells").click((e) => this._onBrowseCompendium(e, "spells"));
    html.find(".compendium-footer .compendium.items").click((e) => this._onBrowseCompendium(e, "items"));
    html.find(".compendium-footer .compendium.bestiary").click((e) => this._onBrowseCompendium(e, "bestiary"));
  }

  _onBrowseCompendium(event, type) {
    event.preventDefault();

    this.compendiums[type]._render(true);
  }
}

class ExperienceDistributor extends FormApplication {
  constructor(...args) {
    super(...args);

    this.combatants = this.getCombatants();
    this.bonusXP = 0;
  }

  static get defaultOptions() {
    return mergeObject(super.defaultOptions, {
      classes: ["ffd20", "xp-distributor"],
      title: game.i18n.localize("FFD20.Application.XPDistributor.Title"),
      template: "systems/ffd20/templates/apps/xp-distributor.hbs",
      width: 430,
      height: 794,
      resizable: true,
      scrollY: [".selectors"],
    });
  }

  getData() {
    const result = super.getData();

    // Add associated combat data
    result.combat = this.object.data;

    // Add combatants
    result.combatants = {
      characters: this.getCharacters(),
      npcs: this.getNPCs(),
    };

    // Add labels
    result.labels = {
      xp: {
        total: `+ ${this.getTotalExperience().toLocaleString()}`,
        split: `+ ${this.getSplitExperience().toLocaleString()}`,
      },
    };

    result.bonusXP = this.bonusXP;

    return result;
  }

  getCombatants() {
    return this.object.combatants.map((o) => this.constructor.getCombatantData(o));
  }

  getCharacters() {
    return this.combatants.filter((o) => o.actorData.type === "character");
  }

  getNPCs() {
    return this.combatants.filter((o) => o.actorData.type === "npc");
  }

  activateListeners(html) {
    if (jQuery != null && html instanceof jQuery) html = html[0];
    const addListener = (query, ev, callback) =>
      html.querySelectorAll(query).forEach((elem) => elem.addEventListener(ev, callback));

    addListener(".character-selector .actor, .npc-selector .actor", "click", this._onClickActor.bind(this));

    addListener(".bonus-xp input", "change", (event) => {
      event.preventDefault();

      this.bonusXP = parseInt(event.currentTarget.value);
      if (isNaN(this.bonusXP)) this.bonusXP = 0;

      this.render();
    });

    addListener('button[name="split-evenly"], button[name="give-to-all"]', "click", this._onSubmit.bind(this));
    addListener('button[name="cancel"]', "click", this._onCancel.bind(this));
  }

  _onClickActor(event) {
    event.preventDefault();

    const a = event.currentTarget;
    const combatantID = event.currentTarget.dataset.id;
    const combatant = this.combatants.find((o) => o.id === combatantID);

    if (!combatant) return;

    if (combatant.toggled) {
      combatant.toggled = false;
      a.classList.remove("toggled");
    } else {
      combatant.toggled = true;
      a.classList.add("toggled");
    }

    this.render();
  }

  async _onSubmit(event) {
    event.preventDefault();

    const type = event.currentTarget.name;

    const value = type === "split-evenly" ? this.getSplitExperience() : this.getTotalExperience();

    if (value > 0) {
      for (let combatant of this.getCharacters()) {
        const combatantActive = combatant.toggled;
        const combatantHasActor = combatant.actor != null;

        if (combatantActive && combatantHasActor) {
          await combatant.actor.update({
            "data.details.xp.value": getProperty(combatant.actor.data, "data.details.xp.value") + value,
          });
        }
      }
    }

    this.close();
  }

  _onCancel(event) {
    event.preventDefault();

    this.close();
  }

  getTotalExperience() {
    const npcs = this.getNPCs().filter((o) => o.toggled);

    return npcs.reduce((cur, o) => {
      return cur + o.xp;
    }, this.bonusXP);
  }

  getSplitExperience() {
    const characters = this.getCharacters().filter((o) => o.toggled);
    const xp = this.getTotalExperience();

    const hasAnyCharacters = characters.length > 0;

    if (hasAnyCharacters) return Math.floor(xp / characters.length);
    return 0;
  }

  static getCombatantData(combatant) {
    const type = combatant.actor?.type;
    const xp = type === "npc" ? combatant.actor?.data.data.details.xp.value ?? 0 : 0;

    return {
      id: combatant.id,
      data: combatant.data,
      actor: combatant.actor,
      actorData: combatant.actor?.data ?? {},
      toggled: this.shouldCombatantBeToggled(combatant),
      xp,
      xpString: xp.toLocaleString(),
    };
  }

  static shouldCombatantBeToggled(combatant) {
    const isPC = combatant.actor?.type === "character";
    const isDefeated = combatant.data.defeated === true || combatant.actor?.data.data.attributes.hp.value < 0;

    if (!isPC && !isDefeated) return false;

    return true;
  }
}

class ActiveEffectFFD20 extends ActiveEffect {
  async create(data, context) {
    const statusId = this.data["flags.core.statusId"],
      origin = this.data.origin,
      updates = {};
    if (statusId && this.parent?.data.data.attributes.conditions[statusId] === false) {
      updates[`data.attributes.conditions.${statusId}`] = true;
      await this.parent.update(updates);
      let created = this.parent.effects.find((e) => e.getFlag("core", "statusId") === statusId);
      if (created) return created;
    }
    if (origin) {
      let buffItem = this.parent.items.get(origin.split(".")[3]);
      if (buffItem && !buffItem.data.data.active) await buffItem.update({ "data.active": true });
    }
    return super.create(data, context);
  }

  async delete(context) {
    const statusId = this.getFlag("core", "statusId"),
      origin = this.data.origin?.split(".")?.[3] ?? null,
      parentActor = this.parent,
      returnVal = await super.delete(context),
      updates = {};
    if (statusId && parentActor.data.data.attributes.conditions[statusId]) {
      updates[`data.attributes.conditions.${statusId}`] = false;
      parentActor.update(updates);
    } else if (origin && parentActor.items.get(origin)) parentActor.items.get(origin).update({ "data.active": false });
    return returnVal;
  }

  get isTemporary() {
    const duration = this.data.duration.seconds ?? (this.data.duration.rounds || this.data.duration.turns) ?? 0;
    return duration > 0 || this.getFlag("core", "statusId") || this.getFlag("ffd20", "show");
  }
}

class Widget_CategorizedItemPicker extends Application {
  constructor(options, categories, callback, selected) {
    super(options);

    /**
     * @typedef {object} Widget_CategorizedItemPicker~Item
     * @property {string} key - The key of the item.
     * @property {string} [label] - The label of the item.
     * @property {string} [icon] - The icon of the item.
     */
    /**
     * @typedef {object} Widget_CategorizedItemPicker~Category
     * @property {string} key - The key of the category.
     * @property {string} label - The label of the category.
     * @property {Widget_CategorizedItemPicker~Item[]} items - All the items associated with this category.
     */
    /**
     * Objects containing category and item data.
     *
     * @type {Widget_CategorizedItemPicker~Category[]}
     */
    this.categories = categories;

    /**
     * Previously selected category and item
     *
     * @type {object}
     * @property {string} category Selected category.
     * @property {string} item Selected item in that category.
     */
    this.selected = selected;

    /**
     * Callback fired when an item has been selected.
     *
     * @type {Function}
     */
    this.callback = callback;

    /**
     * Track hidden elements of the sheet.
     *
     * @property
     * @type {object.<string, string>}
     */
    this._hiddenElems = {};
  }

  get template() {
    return "systems/ffd20/templates/widgets/categorized-item-picker.hbs";
  }

  getData(options) {
    const data = super.getData(options);

    data.categories = [];
    data.items = [];

    for (let cat of this.categories) {
      data.categories.push({
        key: cat.key,
        label: cat.label,
      });

      for (let item of cat.items) {
        data.items.push(
          mergeObject(
            {
              category: cat.key,
            },
            item
          )
        );
      }
    }

    return data;
  }

  activateListeners(html) {
    // Click an item
    html.find(".item").click(this._onClickItem.bind(this));

    // Expand/minimize category
    html.find(".category a").click(this._onClickCategory.bind(this));

    // Pre-select old category
    if (this.selected?.category) {
      html.find(`.category a[data-category="${this.selected.category}"]`).click();
      if (this.selected?.item) {
        html
          .find(`.item[data-category="${this.selected.category}"][data-value="${this.selected.item}"]`)
          .first()
          .addClass("pre-select");
      }
    }

    // Cancel widget
    window.setTimeout(() => {
      if (this._cancelCallback) document.removeEventListener("click", this._cancelCallback);
      this._cancelCallback = this._onCancel.bind(this);
      document.addEventListener("click", this._cancelCallback);
    }, 10);
  }

  static get defaultOptions() {
    return mergeObject(super.defaultOptions, {
      width: 480,
      height: 480,
    });
  }

  _onClickItem(event) {
    event.preventDefault();
    const a = event.currentTarget;

    const result = a.dataset.value;
    this.callback(result);
    this.close();
  }

  _onClickCategory(event) {
    event.preventDefault();
    const a = event.currentTarget;
    const html = $(this.element);

    // Deactivate all categories
    html.find(".item-picker-categories").children().removeClass("active");

    // Activate clicked category
    $(a).closest(".category").addClass("active");

    // Hide all items
    html.find(".item-picker-items").children().hide();

    // Show items
    html.find(`.item-picker-items .item[data-category="${a.dataset.category}"]`).show();
  }

  _onCancel(event) {
    event.preventDefault();

    // Don't cancel if this widget was clicked
    let node = event.target;
    if (node === this.element[0]) return;
    while (node.parentNode) {
      if (node === this.element[0]) return;
      node = node.parentNode;
    }

    this.close();
  }

  async close(...args) {
    document.removeEventListener("click", this._cancelCallback);
    return super.close(...args);
  }
}

Hooks.on("renderWidget_CategorizedItemPicker", (app, html, data) => {
  html.find(".pre-select")[0]?.scrollIntoView({ block: "nearest" });
});

class FFD20_HelpBrowser extends Application {
  constructor(...args) {
    super(...args);

    /**
     * @property
     * @type String
     * The HTML content of the current page.
     */
    this.pageContent = "";

    /**
     * @property
     * @type Number
     * Maximum number of pages to track in history.
     */
    this.maxHistory = 20;

    /**
     * @property
     * @type Array
     * History list.
     */
    this.history = [];

    /**
     * @property
     * @type Number
     * @private
     * The current index in history.
     */
    this._historyIndex = 0;

    /**
     * @property
     * @type Number
     * @private
     * The scroll index of the nav element.
     */
    this._navScroll = 0;

    /**
     * @property
     * @type String
     * @Private
     * The URL of the current page.
     */
    this._currentURL = "";
  }

  static get defaultOptions() {
    return mergeObject(super.defaultOptions, {
      classes: ["ffd20", "help-browser"],
      template: "systems/ffd20/templates/apps/help-browser.hbs",
      minWidth: 800,
      minHeight: 450,
      width: 960,
      height: 600,
      resizable: true,
    });
  }

  get title() {
    return game.i18n.localize("FFD20.Help.Label");
  }

  get currentURL() {
    return this.history[this._historyIndex].url;
  }

  async getData() {
    const data = await super.getData();

    data.pageContent = this.pageContent;

    data.hasHistoryBack = this.history.length > this._historyIndex + 1;
    data.hasHistoryForward = this._historyIndex > 0;

    data.nav = await renderTemplate("systems/ffd20/help/nav.hbs", data);

    return data;
  }

  async openURL(url, { addToHistory = true, header = "" } = {}) {
    // Alter URL
    url = this.fixURL(url);

    if (url !== this._currentURL) {
      // Add new page to history
      if (addToHistory) {
        this.addHistory(url);
        this._historyIndex = 0;
      }

      // Render new page
      this.pageContent = await renderTemplate(url, this.getData());
      await this._render(true);
    }
    this._currentURL = url;

    // Scroll to specified header
    const baseElem = this.element.find(".content")[0];
    if (header) {
      const elem = baseElem.querySelector(`.${header}`);
      if (elem) {
        window.setTimeout(() => {
          baseElem.scrollTop = elem.offsetTop;
        }, 25);
      }
    } else {
      baseElem.scrollTop = 0;
    }
  }

  async _render(...args) {
    await super._render(...args);

    const el = this.element[0];
    el.style.minWidth = `${this.options.minWidth}px`;
    el.style.minHeight = `${this.options.minHeight}px`;
  }

  addHistory(url) {
    const elem = this.element.find(".content")[0];
    const scrollTop = elem ? elem.scrollTop : 0;
    const obj = {
      url: url,
      scrollTop: scrollTop,
    };

    this.history = this.history.slice(this._historyIndex);

    this.history.unshift(obj);
    if (this.history.length > this.maxHistory) {
      this.history.splice(20, this.history.length - this.maxHistory);
    }
  }

  /**
   * @param {number} index - The specific index in history to go to. Larger values are further down history.
   */
  async goToHistory(index) {
    if (this.history[this._historyIndex]) {
      const elem = this.element.find(".content")[0];
      this.history[this._historyIndex].scrollTop = elem ? elem.scrollTop : 0;
    }

    this._historyIndex = index;
    await this.openURL(this.currentURL, { addToHistory: false });

    window.setTimeout(() => {
      this.element.find(".content")[0].scrollTop = this.history[index].scrollTop || 0;
    }, 25);
  }

  backInHistory() {
    if (this._historyIndex < this.maxHistory) {
      this.goToHistory(this._historyIndex + 1);
    }
  }

  forwardInHistory() {
    if (this._historyIndex > 0) {
      this.goToHistory(this._historyIndex - 1);
    }
  }

  fixURL(url) {
    let result = url;

    if (url.match(/^.+?:\/\/.+\//)) {
      const arr = url.split("/");
      result = arr.slice(3).join("/");
    }

    return result;
  }

  activateListeners(html) {
    // Translate links
    {
      const links = html.find("a[href]");
      for (let l of links) {
        const href = l.href;
        l.removeAttribute("href");
        l.addEventListener("click", () => {
          const header = l.dataset?.header || "";
          this.openURL(href, { header: header });
        });
      }
    }

    // History buttons
    html.find(".history-back").click(this.backInHistory.bind(this));
    html.find(".history-forward").click(this.forwardInHistory.bind(this));

    html.find("nav").on("scroll", (event) => {
      console.log(event, event.currentTarget);
    });
  }
}

/**
 * Override and extend the core ItemSheet implementation to handle game system specific item types
 *
 * @type {ItemSheet}
 */
class ItemSheetFFD20 extends ItemSheet {
  constructor(...args) {
    super(...args);

    /**
     * Track the set of item filters which are applied
     *
     * @type {Set}
     */
    this._filters = {
      search: "",
    };

    /** Item search */
    this.searchCompositioning = false; // for IME
    this.searchRefresh = true; // Lock out same term search unless sheet also refreshes
    this.searchDelay = 250; // arbitrary ?ms for arbitrarily decent reactivity; MMke this configurable?
    this.searchDelayEvent = null; // setTimeout id
    this.effectiveSearch = ""; // prevent searching the same thing

    this.items = [];

    /**
     * Tracks the application IDs associated with this sheet.
     *
     * @type {Application[]}
     */
    this._openApplications = [];
  }

  /* -------------------------------------------- */

  static get defaultOptions() {
    return mergeObject(super.defaultOptions, {
      width: 580,
      classes: ["ffd20", "sheet", "item"],
      scrollY: [".tab.details", ".buff-flags", '.tab[data-tab="changes"]'],
      dragDrop: [
        {
          dragSelector: "li.conditional",
          dropSelector: 'div[data-tab="conditionals"]',
        },
      ],
    });
  }

  /* -------------------------------------------- */

  /**
   * Return a dynamic reference to the HTML template path used to render this Item Sheet
   *
   * @returns {string}
   */
  get template() {
    const path = "systems/ffd20/templates/items/";
    return `${path}/${this.item.data.type}.hbs`;
  }

  get actor() {
    let actor = this.item.actor;
    let p = this.parentItem;
    while (!actor && p) {
      actor = p.actor;
      p = p.parentItem;
    }

    return actor;
  }

  /* -------------------------------------------- */

  /**
   * Prepare item sheet data
   * Start with the base item data and extending with additional properties for rendering.
   */
  async getData() {
    const data = await super.getData();
    data.data = data.data.data;
    const rollData = this.item.getRollData();
    data.labels = this.item.labels;

    // Include sub-items
    data.items = [];
    if (this.item.items != null) {
      data.items = this.item.items.map((i) => {
        i.data.labels = i.labels;
        return i.data;
      });
    }

    // Include CONFIG values
    data.config = CONFIG.FFD20;

    // Item Type, Status, and Details
    data.itemType = this._getItemType(data.item);
    data.itemStatus = this._getItemStatus(data.item);
    data.itemProperties = this._getItemProperties(data.item);
    data.itemName = data.item.name;
    data.isPhysical = hasProperty(data.item.data, "data.quantity");
    data.isSpell = this.item.type === "spell";
    data.owned = this.item.actor != null;
    data.parentOwned = this.actor != null;
    data.owner = this.item.isOwner;
    data.isGM = game.user.isGM;
    data.showIdentifyDescription = data.isGM && data.isPhysical;
    data.isMateria = data.item.data.data.equipmentType === "materia";
    data.showUnidentifiedData = this.item.showUnidentifiedData;
    data.unchainedActionEconomy = game.settings.get("ffd20", "unchainedActionEconomy");
    data.hasActivationType =
      (game.settings.get("ffd20", "unchainedActionEconomy") &&
        getProperty(data.item.data, "data.unchainedAction.activation.type")) ||
      (!game.settings.get("ffd20", "unchainedActionEconomy") && getProperty(data.item.data, "data.activation.type"));
    if (rollData.item.auraStrength != null) {
      const auraStrength = rollData.item.auraStrength;
      data.auraStrength = auraStrength;

      if (CONFIG.FFD20.auraStrengths[auraStrength] != null) {
        const auraStrength_name = CONFIG.FFD20.auraStrengths[auraStrength];
        data.auraStrength_name = auraStrength_name;

        data.labels.identify = game.i18n.localize("FFD20.IdentifyDCNumber").format(15 + rollData.item.cl);
        // const auraSchool = CONFIG.FFD20.spellSchools[rollData.item.aura.school];
        // data.labels.aura = `${auraStrength_name} ${auraSchool}`;
      }
    }

    // Unidentified data
    if (this.item.showUnidentifiedData) {
      data.itemName =
        getProperty(this.item.data, "data.unidentified.name") ||
        getProperty(this.item.data, "data.identifiedName") ||
        this.item.name;
    } else {
      data.itemName = getProperty(this.item.data, "data.identifiedName") || this.item.name;
    }

    // Action Details
    data.hasAttackRoll = this.item.hasAttack;
    data.isHealing = data.item.data.actionType === "heal";
    data.isCombatManeuver = ["mcman", "rcman"].includes(data.item.data.actionType);

    data.isCharged = false;
    if (data.item.data.data.uses != null) {
      data.isCharged = ["day", "week", "charges"].includes(data.item.data.data.uses.per);
    }
    if (data.item.data.data.range != null) {
      data.canInputRange = ["ft", "mi", "spec"].includes(data.item.data.data.range.units);
      data.canInputMinRange = ["ft", "mi", "spec"].includes(data.item.data.data.range.minUnits);
    }
    if (data.item.data.data.duration != null) {
      data.canInputDuration = !["", "inst", "perm", "seeText"].includes(data.item.data.data.duration.units);
    }

    // Show additional ranged properties
    data.showMaxRangeIncrements = getProperty(this.item.data, "data.range.units") === "ft";

    // Prepare feat specific stuff
    if (data.item.type === "feat") {
      data.isClassFeature = getProperty(this.item.data, "data.featType") === "classFeat";
      data.isTemplate = getProperty(this.item.data, "data.featType") === "template";
    }

    // Prepare weapon specific stuff
    if (data.item.type === "weapon") {
      data.isRanged = data.item.data.data.weaponSubtype === "ranged" || data.item.data.data.properties["thr"] === true;

      // Prepare categories for weapons
      data.weaponCategories = { types: {}, subTypes: {} };
      for (let [k, v] of Object.entries(CONFIG.FFD20.weaponTypes)) {
        if (typeof v === "object") data.weaponCategories.types[k] = v._label;
      }
      const type = data.item.data.data.weaponType;
      if (hasProperty(CONFIG.FFD20.weaponTypes, type)) {
        for (let [k, v] of Object.entries(CONFIG.FFD20.weaponTypes[type])) {
          // Add static targets
          if (!k.startsWith("_")) data.weaponCategories.subTypes[k] = v;
        }
      }
    }

    // Prepare equipment specific stuff
    if (data.item.type === "equipment") {
      // Prepare categories for equipment
      data.equipmentCategories = { types: {}, subTypes: {} };
      for (let [k, v] of Object.entries(CONFIG.FFD20.equipmentTypes)) {
        if (typeof v === "object") data.equipmentCategories.types[k] = v._label;
      }
      const type = data.item.data.data.equipmentType;
      if (hasProperty(CONFIG.FFD20.equipmentTypes, type)) {
        for (let [k, v] of Object.entries(CONFIG.FFD20.equipmentTypes[type])) {
          // Add static targets
          if (!k.startsWith("_")) data.equipmentCategories.subTypes[k] = v;
        }
      }

      // Prepare slots for equipment
      data.equipmentSlots = CONFIG.FFD20.equipmentSlots[type];

      // Whether the equipment should show armor data
      data.showArmorData = ["armor", "shield"].includes(type);

      // Whether the current equipment type has multiple slots
      data.hasMultipleSlots = Object.keys(data.equipmentSlots).length > 1;
    }

    // Prepare attack specific stuff
    if (data.item.type === "attack") {
      data.isWeaponAttack = data.item.data.data.attackType === "weapon";
      data.isNaturalAttack = data.item.data.data.attackType === "natural";
    }

    // Prepare spell specific stuff
    if (data.item.type === "spell") {
      let spellbook = null;
      if (this.actor != null) {
        spellbook = getProperty(this.actor.data, `data.attributes.spells.spellbooks.${this.item.data.data.spellbook}`);
      }

      data.isPreparedSpell = spellbook != null ? !spellbook.spontaneous : false;
      data.isAtWill = data.item.data.atWill;
      data.spellbooks = {};
      if (this.actor) {
        data.spellbooks = duplicate(this.actor.data.data.attributes.spells.spellbooks);
      }

      // Enrich description
      data.description = TextEditor.enrichHTML(data.data.description.value, { rollData: this.item.getRollData() });
      if (data.data.shortDescription != null) {
        data.shortDescription = TextEditor.enrichHTML(data.data.shortDescription, {
          rollData: this.item.getRollData(),
        });
      }
    }

    // Prepare class specific stuff
    if (data.item.type === "class") {
      data.isMythicPath = data.data.classType === "mythic";

      for (let [a, s] of Object.entries(data.data.savingThrows)) {
        s.label = CONFIG.FFD20.savingThrows[a];
      }
      for (let [a, s] of Object.entries(data.data.fc)) {
        s.label = CONFIG.FFD20.favouredClassBonuses[a];
      }

      data.isBaseClass = data.data.classType === "base";
      data.isRacialHD = data.data.classType === "racial";

      if (this.actor != null) {
        let healthConfig = game.settings.get("ffd20", "healthConfig");
        data.healthConfig = data.isRacialHD
          ? healthConfig.hitdice.Racial
          : this.actor.data.type === "character"
          ? healthConfig.hitdice.PC
          : healthConfig.hitdice.NPC;
      } else data.healthConfig = { auto: false };

      // Add skill list
      if (!this.actor) {
        data.skills = Object.entries(CONFIG.FFD20.skills).reduce((cur, o) => {
          cur[o[0]] = { name: o[1], classSkill: getProperty(this.item.data, `data.classSkills.${o[0]}`) === true };
          return cur;
        }, {});
      } else {
        // Get sorted skill list from config, custom skills get appended to bottom of list
        const skills = mergeObject(duplicate(CONFIG.FFD20.skills), this.actor.data.data.skills);
        data.skills = Object.entries(skills).reduce((cur, o) => {
          const key = o[0];
          const name = CONFIG.FFD20.skills[key] != null ? CONFIG.FFD20.skills[key] : o[1].name;
          cur[o[0]] = { name: name, classSkill: getProperty(this.item.data, `data.classSkills.${o[0]}`) === true };
          return cur;
        }, {});
      }
    }

    // Prepare proficiencies
    const profs = {
      languages: CONFIG.FFD20.languages,
      armorProf: CONFIG.FFD20.armorProf,
      weaponProf: CONFIG.FFD20.weaponProf,
    };
    for (let [t, choices] of Object.entries(profs)) {
      if (hasProperty(data.item.data.data, t)) {
        const trait = data.data[t];
        if (!trait) continue;
        let values = [];
        if (trait.value) {
          values = trait.value instanceof Array ? trait.value : [trait.value];
        }
        trait.selected = values.reduce((obj, t) => {
          obj[t] = choices[t];
          return obj;
        }, {});

        // Add custom entry
        if (trait.custom) {
          trait.custom
            .split(CONFIG.FFD20.re.traitSeparator)
            .forEach((c, i) => (trait.selected[`custom${i + 1}`] = c.trim()));
        }
        trait.cssClass = !isObjectEmpty(trait.selected) ? "" : "inactive";
      }
    }

    // Prepare stuff for active effects on items
    if (this.item.changes) {
      data.changeGlobals = {
        targets: {},
        modifiers: CONFIG.FFD20.bonusModifiers,
      };
      for (let [k, v] of Object.entries(CONFIG.FFD20.buffTargets)) {
        if (typeof v === "object") data.changeGlobals.targets[k] = v._label;
      }

      const buffTargets = getBuffTargets(this.item.actor);
      data.changes = data.item.data.data.changes.reduce((cur, o) => {
        const obj = { data: o };

        obj.subTargetLabel = buffTargets[o.subTarget]?.label;
        obj.isScript = obj.data.operator === "script";

        cur.push(obj);
        return cur;
      }, []);
    }

    // Prepare stuff for attacks with conditionals
    if (data.data.conditionals) {
      data.conditionals = { targets: {}, conditionalModifierTypes: {} };
      for (const conditional of data.data.conditionals) {
        for (const modifier of conditional.modifiers) {
          modifier.targets = this.item.getConditionalTargets();
          modifier.subTargets = this.item.getConditionalSubTargets(modifier.target);
          modifier.conditionalModifierTypes = this.item.getConditionalModifierTypes(modifier.target);
          modifier.conditionalCritical = this.item.getConditionalCritical(modifier.target);
          modifier.isAttack = modifier.target === "attack";
          modifier.isDamage = modifier.target === "damage";
          modifier.isSize = modifier.target === "size";
          modifier.isSpell = modifier.target === "spell";
        }
      }
    }

    // Prepare stuff for items with context notes
    if (data.item.data.data.contextNotes) {
      data.contextNotes = duplicate(data.item.data.data.contextNotes);
      const noteTargets = getBuffTargets(this.item.actor, "contextNotes");
      data.contextNotes.forEach((o) => {
        o.label = noteTargets[o.subTarget]?.label;
      });
    }

    // Add distance units
    data.distanceUnits = duplicate(CONFIG.FFD20.distanceUnits);
    if (this.item.type !== "spell") {
      for (let d of ["close", "medium", "long"]) {
        delete data.distanceUnits[d];
      }
    }

    // Parse notes
    if (data.item.data.data.attackNotes) {
      const value = data.item.data.data.attackNotes;
      setProperty(data, "notes.attack", value);
    }

    // Add item flags
    this._prepareItemFlags(data);

    // Add script calls
    await this._prepareScriptCalls(data);

    // Add links
    await this._prepareLinks(data);

    return data;
  }

  async _prepareLinks(data) {
    data.links = {
      list: [],
    };

    // Add children link type
    data.links.list.push({
      id: "children",
      label: game.i18n.localize("FFD20.LinkTypeChildren"),
      help: game.i18n.localize("FFD20.LinkHelpChildren"),
      items: [],
    });

    // Add charges link type
    if (["feat", "consumable", "attack", "equipment"].includes(this.item.type)) {
      data.links.list.push({
        id: "charges",
        label: game.i18n.localize("FFD20.LinkTypeCharges"),
        help: game.i18n.localize("FFD20.LinkHelpCharges"),
        items: [],
      });
    }

    // Add class associations
    if (this.item.type === "class") {
      data.links.list.push({
        id: "classAssociations",
        label: game.i18n.localize("FFD20.LinkTypeClassAssociations"),
        help: game.i18n.localize("FFD20.LinkHelpClassAssociations"),
        fields: {
          level: {
            type: "Number",
            label: game.i18n.localize("FFD20.Level"),
          },
        },
        items: [],
      });
    }

    // Add ammunition links
    if (this.item.type === "attack") {
      data.links.list.push({
        id: "ammunition",
        label: game.i18n.localize("FFD20.LinkTypeAmmunition"),
        help: game.i18n.localize("FFD20.LinkHelpAmmunition"),
        fields: {
          recoverChance: {
            type: "Number",
            label: game.i18n.localize("FFD20.RecoverChancePercentage"),
          },
        },
        items: [],
      });
    }

    // Post process data
    for (let l of data.links.list) {
      const items = getProperty(this.item.data, `data.links.${l.id}`) || [];
      for (let a = 0; a < items.length; a++) {
        const i = items[a];
        i._index = a;

        // Add item to stack
        l.items.push(i);
      }

      // Sort items
      if (l.id === "classAssociations") {
        l.items = l.items.sort((a, b) => {
          return a.level - b.level;
        });
      }
    }

    await this.item.updateLinkItems();
  }

  _prepareItemFlags(data) {
    // Add boolean flags
    {
      const flags = getProperty(data.item.data, "data.flags.boolean") || [];
      setProperty(data, "flags.boolean", flags);
    }

    // Add dictionary flags
    {
      const flags = getProperty(data.item.data, "data.flags.dictionary") || [];
      let result = [];
      for (let [k, v] of flags) {
        result.push({ key: k, value: v });
      }
      setProperty(data, "flags.dictionary", result);
    }
  }

  async _prepareScriptCalls(data) {
    const categories = game.ffd20.registry.getItemScriptCategories().filter((o) => {
      if (!o.itemTypes.includes(this.document.type)) return false;
      if (o.hidden === true && !game.user.isGM) return false;
      return true;
    });
    // Don't show the Script Calls section if there are no categories for this item type
    if (!categories.length) {
      data.scriptCalls = null;
      return;
    }
    // Don't show the Script Calls section if players are not allowed to edit script macros
    if (!game.user.can("MACRO_SCRIPT")) {
      data.scriptCalls = null;
      return;
    }

    data.scriptCalls = {};

    // Prepare data to add
    const checkYes = '<i class="fas fa-check"></i>';
    const checkNo = '<i class="fas fa-times"></i>';

    // Iterate over all script calls, and adjust data
    let scriptCalls = Object.hasOwnProperty.call(this.document, "scriptCalls")
      ? duplicate(Array.from(this.document.scriptCalls).map((o) => o.data))
      : [];
    {
      let promises = [];
      for (let o of scriptCalls) {
        promises.push(
          (async () => {
            // Obtain macro info
            if (o.type === "macro") {
              const m = await fromUuid(o.value);
              o.name = m.data.name;
              o.img = m.data.img;
            }

            // Add data
            o.hiddenIcon = o.hidden ? checkYes : checkNo;
            o.hide = o.hidden && !game.user.isGM;
          })()
        );
      }
      await Promise.all(promises);
    }

    // Create categories, and assign items to them
    for (const c of categories) {
      data.scriptCalls[c.key] = {
        name: game.i18n.localize(c.name),
        info: c.info ? game.i18n.localize(c.info) : null,
        items: scriptCalls.filter((o) => o.category === c.key),
        dataset: {
          category: c.key,
        },
      };
    }
  }

  /* -------------------------------------------- */

  /**
   * Get the text item type which is shown in the top-right corner of the sheet
   *
   * @param item
   * @returns {string}
   * @private
   */
  _getItemType(item) {
    let typeKeys = Object.keys(CONFIG.FFD20.itemTypes);
    let itemType = item.type;
    if (!typeKeys.includes(itemType)) itemType = typeKeys[0];
    return game.i18n.localize(CONFIG.FFD20.itemTypes[itemType]);
  }

  /**
   * Get the text item status which is shown beneath the Item type in the top-right corner of the sheet
   *
   * @param item
   * @returns {string}
   * @private
   */
  _getItemStatus(item) {
    if (item.type === "spell") {
      const spellbook = this.item.spellbook;
      if (item.data.data.preparation.mode === "prepared") {
        if (item.data.data.preparation.preparedAmount > 0) {
          if (spellbook != null && spellbook.spontaneous) {
            return game.i18n.localize("FFD20.SpellPrepPrepared");
          } else {
            return game.i18n.localize("FFD20.AmountPrepared").format(item.data.data.preparation.preparedAmount);
          }
        }
        return game.i18n.localize("FFD20.Unprepared");
      } else if (item.data.data.preparation.mode) {
        return item.data.data.preparation.mode.titleCase();
      } else return "";
    } else if (
      ["weapon", "equipment"].includes(item.type) ||
      (item.type === "loot" && item.data.data.subType === "gear")
    ) {
      return item.data.data.equipped ? game.i18n.localize("FFD20.Equipped") : game.i18n.localize("FFD20.NotEquipped");
    }
  }

  /* -------------------------------------------- */

  /**
   * Get the Array of item properties which are used in the small sidebar of the description tab
   *
   * @param item
   * @returns {Array}
   * @private
   */
  _getItemProperties(item) {
    const props = [];
    const labels = this.item.labels;

    if (item.type === "weapon") {
      props.push(
        ...Object.entries(item.data.data.properties)
          .filter((e) => e[1] === true)
          .map((e) => CONFIG.FFD20.weaponProperties[e[0]])
      );
    } else if (item.type === "spell") {
      props.push(labels.components, labels.materials);
    } else if (item.type === "equipment") {
      props.push(CONFIG.FFD20.equipmentTypes[item.data.data.equipmentType][item.data.data.equipmentSubtype]);
      props.push(labels.armor);
    } else if (item.type === "feat") {
      props.push(labels.featType);
    }

    // Action type
    if (item.data.actionType) {
      props.push(CONFIG.FFD20.itemActionTypes[item.data.data.actionType]);
    }

    // Action usage
    if (item.type !== "weapon" && item.data.data.activation && !isObjectEmpty(item.data.data.activation)) {
      props.push(labels.activation, labels.range, labels.target, labels.duration);
    }

    // Tags
    if (getProperty(item.data, "data.tags") != null) {
      props.push(
        ...getProperty(item.data, "data.tags").map((o) => {
          return o[0];
        })
      );
    }

    return props.filter((p) => !!p);
  }

  /* -------------------------------------------- */

  setPosition(position = {}) {
    // if ( this._sheetTab === "details" ) position.height = "auto";
    return super.setPosition(position);
  }

  /* -------------------------------------------- */
  /*  Form Submission                             */
  /* -------------------------------------------- */

  /**
   * Extend the parent class _updateObject method to ensure that damage ends up in an Array
   *
   * @param event
   * @param formData
   * @private
   */
  async _updateObject(event, formData) {
    // Handle conditionals array
    let conditionals = Object.entries(formData).filter((e) => e[0].startsWith("data.conditionals"));
    formData["data.conditionals"] = conditionals.reduce((arr, entry) => {
      let [i, j, k] = entry[0].split(".").slice(2);
      if (!arr[i]) arr[i] = ItemFFD20.defaultConditional;
      if (k) {
        formData[`data.conditionals.${i}.${j}.target`];
        if (!arr[i].modifiers[j]) arr[i].modifiers[j] = ItemFFD20.defaultConditionalModifier;
        arr[i].modifiers[j][k] = entry[1];
        // Target dependent keys
        if (["subTarget", "critical", "type"].includes(k)) {
          const target = (conditionals.find((o) => o[0] === `data.conditionals.${i}.${j}.target`) || [])[1];
          const val = entry[1];
          if (typeof target === "string") {
            let keys;
            switch (k) {
              case "subTarget":
                keys = Object.keys(this.item.getConditionalSubTargets(target));
                break;
              case "type":
                keys = Object.keys(this.item.getConditionalModifierTypes(target));
                break;
              case "critical":
                keys = Object.keys(this.item.getConditionalCritical(target));
                break;
            }
            // Reset subTarget, non-damage type, and critical if necessary
            if (!keys.includes(val) && target !== "damage" && k !== "type") arr[i].modifiers[j][k] = keys[0];
          }
        }
      } else {
        arr[i][j] = entry[1];
      }
      return arr;
    }, []);

    // Handle links arrays
    let links = Object.entries(formData).filter((e) => e[0].startsWith("data.links"));
    for (let e of links) {
      const path = e[0].split(".");
      const linkType = path[2];
      const index = path[3];
      const subPath = path.slice(4).join(".");
      const value = e[1];

      // Non-indexed formData is presumed to have been handled already
      if (index == null) continue;

      delete formData[e[0]];

      if (!formData[`data.links.${linkType}`])
        formData[`data.links.${linkType}`] = duplicate(getProperty(this.item.data, `data.links.${linkType}`));

      setProperty(formData[`data.links.${linkType}`][index], subPath, value);
    }

    // Change relative values
    const relativeKeys = ["data.currency.pgil", "data.currency.gil", "data.currency.sgil", "data.currency.cgil"];
    for (let [k, v] of Object.entries(formData)) {
      if (typeof v !== "string") continue;
      // Add or subtract values
      if (relativeKeys.includes(k)) {
        const originalValue = getProperty(this.item.data, k);
        let max = null;
        const maxKey = k.replace(/\.value$/, ".max");
        if (maxKey !== k) {
          max = getProperty(this.item.data, maxKey);
        }

        if (v.match(/(\+|--?)([0-9]+)/)) {
          const operator = RegExp.$1;
          let value = parseInt(RegExp.$2);
          if (operator === "--") {
            formData[k] = -value;
          } else {
            if (operator === "-") value = -value;
            formData[k] = originalValue + value;
            if (max) formData[k] = Math.min(formData[k], max);
          }
        } else if (v.match(/^[0-9]+$/)) {
          formData[k] = parseInt(v);
          if (max) formData[k] = Math.min(formData[k], max);
        } else if (v === "") {
          formData[k] = 0;
        } else formData[k] = 0; // @TODO: definition?
      }
    }

    // Update the Item
    return super._updateObject(event, formData);
  }

  /* -------------------------------------------- */

  /**
   * Activate listeners for interactive item sheet events
   *
   * @param html
   */
  activateListeners(html) {
    super.activateListeners(html);

    // Activate tabs
    const tabGroups = {
      primary: {
        description: {},
        links: {},
      },
    };
    this._tabsAlt = createTabs.call(this, html, tabGroups, this._tabsAlt);

    // Tooltips
    html.mousemove((ev) => this._moveTooltips(ev));

    // Everything below here is only needed if the sheet is editable
    if (!this.options.editable) return;

    // Trigger form submission from textarea elements.
    html.find("textarea").change(this._onSubmit.bind(this));

    // Add drop handler to textareas
    html.find("textarea, .notes input[type='text']").on("drop", this._onTextAreaDrop.bind(this));

    // Open help browser
    html.find("a.help-browser[data-url]").click(this._openHelpBrowser.bind(this));

    // Modify attack formula
    html.find(".attack-control").click(this._onAttackControl.bind(this));

    // Modify damage formula
    html.find(".damage-control").click(this._onDamageControl.bind(this));

    // Modify buff changes
    html.find(".change-control").click(this._onBuffControl.bind(this));
    html.find(".change .change-target").click(this._onChangeTargetControl.bind(this));

    // Modify note changes
    html.find(".context-note-control").click(this._onNoteControl.bind(this));
    html.find(".context-note .context-note-target").click(this._onNoteTargetControl.bind(this));

    // Create attack
    if (["weapon"].includes(this.item.data.type)) {
      html.find("button[name='create-attack']").click(this._createAttack.bind(this));
    }

    // Modify conditionals
    html.find(".conditional-control").click(this._onConditionalControl.bind(this));

    // Listen to field entries
    html.find(".entry-selector").click(this._onEntrySelector.bind(this));

    html.find(".entry-control a").click(this._onEntryControl.bind(this));

    // Add drop handler to link tabs
    html.find('div[data-group="links"],a.item[data-tab="links"]').on("drop", this._onLinksDrop.bind(this));

    html.find(".link-control").click(this._onLinkControl.bind(this));

    // Handle alternative file picker
    html.find(".file-picker-alt").click(this._onFilePickerAlt.bind(this));

    // Click to change text input
    html.find('*[data-action="input-text"]').click((event) => this._onInputText(event));

    // Select the whole text on click
    html.find(".select-on-click").click(this._selectOnClick.bind(this));

    // Edit change script contents
    html.find(".edit-change-contents").on("click", this._onEditChangeScriptContents.bind(this));

    // Trait Selector
    html.find(".trait-selector").click(this._onTraitSelector.bind(this));

    // Search box
    if (["container"].includes(this.item.data.type)) {
      const sb = html.find(".search-input");
      sb.on("keyup change", this._searchFilterChange.bind(this));
      sb.on("compositionstart compositionend", this._searchFilterCompositioning.bind(this)); // for IME
      this.searchRefresh = true;
      // Filter tabs on followup refreshes
      sb.each(function () {
        if (this.value.length > 0) $(this).change();
      });
      html.find(".clear-search").on("click", this._clearSearch.bind(this));
    }

    /* -------------------------------------------- */
    /*  Links
    /* -------------------------------------------- */

    html.find('a[data-action="compendium"]').click(this._onOpenCompendium.bind(this));

    /* -------------------------------------------- */
    /*  Script Calls
    /* -------------------------------------------- */

    html.find(".script-calls .item-control").click(this._onScriptCallControl.bind(this));

    html.find(".script-calls .items-list .item").contextmenu(this._onScriptCallEdit.bind(this));

    html.find(".script-calls .inventory-list[data-category]").on("drop", this._onScriptCallDrop.bind(this));
  }

  /* -------------------------------------------- */

  _onOpenCompendium(event) {
    event.preventDefault();
    const a = event.currentTarget;
    const target = a.dataset.actionTarget;

    game.ffd20.compendiums[target].render(true);
  }

  _onScriptCallControl(event) {
    event.preventDefault();
    const a = event.currentTarget;
    const item = this.document.scriptCalls ? this.document.scriptCalls.get(a.closest(".item")?.dataset.itemId) : null;
    const group = a.closest(".inventory-list");
    const category = group.dataset.category;

    // Create item
    if (a.classList.contains("item-create")) {
      const list = this.document.data.data.scriptCalls || [];
      const item = ItemScriptCall.create({}, null);
      item.data.category = category;
      item.data.type = "script";
      return this._onSubmit(event, { updateData: { "data.scriptCalls": list.concat(item.data) } });
    }
    // Delete item
    else if (item && a.classList.contains("item-delete")) {
      const list = (this.document.data.data.scriptCalls || []).filter((o) => o._id !== item.id);
      return this._onSubmit(event, { updateData: { "data.scriptCalls": list } });
    }
    // Edit item
    else if (item && a.classList.contains("item-edit")) {
      item.edit();
    }
    // Toggle hidden
    else if (item && a.classList.contains("item-hide")) {
      item.update({
        hidden: !item.data.hidden,
      });
    }
  }

  _onScriptCallEdit(event) {
    event.preventDefault();
    const a = event.currentTarget;
    const item = this.document.scriptCalls ? this.document.scriptCalls.get(a.dataset.itemId) : null;

    if (item) {
      item.edit();
    }
  }

  _moveTooltips(event) {
    const elem = $(event.currentTarget);
    const x = event.clientX;
    const y = event.clientY + 24;
    elem.find(".tooltip:hover .tooltipcontent").css("left", `${x}px`).css("top", `${y}px`);
  }

  async _onTextAreaDrop(event) {
    event.preventDefault();
    const data = JSON.parse(event.originalEvent.dataTransfer.getData("text/plain"));
    if (!data) return;

    const elem = event.currentTarget;
    let link;

    // Case 1 - Entity from Compendium Pack
    if (data.pack) {
      const pack = game.packs.get(data.pack);
      if (!pack) return;
      const entity = await pack.getDocument(data.id);
      link = `@Compendium[${data.pack}.${data.id}]{${entity.name}}`;
    }

    // Case 2 - Entity from World
    else {
      const config = CONFIG[data.type];
      if (!config) return false;
      const entity = config.collection.instance.get(data.id);
      if (!entity) return false;
      link = `@${data.type}[${entity._id}]{${entity.name}}`;
    }

    // Insert link
    if (link) {
      elem.value = !elem.value ? link : elem.value + "\n" + link;
    }
    return this._onSubmit(event);
  }

  async _onScriptCallDrop(event) {
    event.preventDefault();
    const data = JSON.parse(event.originalEvent.dataTransfer.getData("text/plain"));
    if (!data) return;

    const elem = event.currentTarget;
    const category = elem.dataset.category;

    if (data.type === "Macro") {
      let uuid;
      // Get from compendium
      if (data.pack) {
        const pack = game.packs.get(data.pack);
        const document = await pack.getDocument(data.id);
        uuid = document.uuid;
      }
      // Get from world
      else if (data.id) {
        const document = game.macros.get(data.id);
        uuid = document.uuid;
      }

      // Submit data
      if (uuid) {
        const list = this.document.data.data.scriptCalls ?? [];
        const item = ItemScriptCall.create({ type: "macro", value: uuid, category });
        return this._onSubmit(event, { updateData: { "data.scriptCalls": list.concat(item.data) } });
      }
    }
  }

  _openHelpBrowser(event) {
    event.preventDefault();
    const a = event.currentTarget;

    let browser = null;
    for (let w of Object.values(ui.windows)) {
      if (w instanceof FFD20_HelpBrowser) {
        browser = w;
        browser.bringToTop();
        break;
      }
    }
    if (!browser) browser = new FFD20_HelpBrowser();

    browser.openURL(a.dataset.url);
  }

  async _onLinksDrop(event) {
    const elem = event.currentTarget;
    var linkType = elem.dataset.tab;

    // Default selection for dropping on tab instead of body
    if (linkType === "links") linkType = "children";

    // Try to extract the data
    let data;
    try {
      data = JSON.parse(event.originalEvent.dataTransfer.getData("text/plain"));
      if (data.type !== "Item") return;
    } catch (err) {
      return false;
    }

    let targetItem;
    let dataType = "";
    let itemLink = "";

    // Case 1 - Import from a Compendium pack
    if (data.pack) {
      dataType = "compendium";
      const pack = game.packs.find((p) => p.collection === data.pack);
      const packItem = await pack.getDocument(data.id);
      if (packItem != null) {
        targetItem = packItem;
        itemLink = `${pack.collection}.${packItem._id}`;
      }
    }

    // Case 2 - Data explicitly provided; check same actor for item
    else if (data.data) {
      dataType = "data";
      if (this.item && this.item.actor) {
        targetItem = this.item.actor.items.find((o) => o.id === data.data._id);
      }
      itemLink = data.data._id;
    }

    // Case 3 - Import from World entity
    else {
      dataType = "world";
      targetItem = game.items.get(data.id);
      itemLink = `world.${data.id}`;
    }

    await this.item.createItemLink(linkType, dataType, targetItem, itemLink);
  }

  /**
   * By default, returns true only for GM
   *
   * @override
   */
  _canDragStart(selector) {
    return true;
  }

  _onDragStart(event) {
    const elem = event.currentTarget;
    if (elem.dataset?.conditional) {
      const conditional = this.object.data.data.conditionals[elem.dataset?.conditional];
      event.dataTransfer.setData("text/plain", JSON.stringify(conditional));
    }
  }

  async _onDrop(event) {
    event.preventDefault();
    event.stopPropagation();

    let data;
    try {
      data = JSON.parse(event.dataTransfer.getData("text/plain"));
      // Surface-level check for conditional
      if (!(data.default != null && typeof data.name === "string" && Array.isArray(data.modifiers))) return;
    } catch (e) {
      return false;
    }

    const item = this.object;
    // Check targets and other fields for valid values, reset if necessary
    for (let modifier of data.modifiers) {
      if (!Object.keys(item.getConditionalTargets()).includes(modifier.target)) modifier.target = "";
      let keys;
      for (let [k, v] of Object.entries(modifier)) {
        switch (k) {
          case "subTarget":
            keys = Object.keys(item.getConditionalSubTargets(modifier.target));
            break;
          case "type":
            keys = Object.keys(item.getConditionalModifierTypes(modifier.target));
            break;
          case "critical":
            keys = Object.keys(item.getConditionalCritical(modifier.target));
            break;
        }
        if (!keys?.includes(v)) v = keys?.[0] ?? "";
      }
    }

    const conditionals = item.data.data.conditionals || [];
    await this.object.update({ "data.conditionals": conditionals.concat([data]) });
  }

  async _onEditChangeScriptContents(event) {
    const elem = event.currentTarget;
    const changeID = elem.closest(".change").dataset.change;
    const change = this.item.changes.find((o) => o._id === changeID);

    if (!change) return;

    const scriptEditor = new ScriptEditor({ command: change.formula }).render(true);
    const result = await scriptEditor.awaitResult();
    if (typeof result.command === "string") {
      return change.update({ formula: result.command });
    }
  }

  /**
   * Handle spawning the ActorTraitSelector application which allows a checkbox of multiple trait options
   *
   * @param {Event} event   The click event which originated the selection
   * @private
   */
  _onTraitSelector(event) {
    event.preventDefault();
    const a = event.currentTarget;
    const label = a.parentElement.querySelector("label");
    const options = {
      name: label.getAttribute("for"),
      title: label.innerText,
      choices: CONFIG.FFD20[a.dataset.options],
    };
    new ActorTraitSelector(this.object, options).render(true);
  }

  /**
   * @param {string} linkType - The type of link.
   * @param {string} dataType - Either "compendium", "data" or "world".
   * @param {object} itemData - The (new) item's data.
   * @param {string} itemLink - The link identifier for the item.
   * @param {object} [data] - The raw data from a drop event.
   * @returns {boolean} Whether a link to the item is possible here.
   */
  canCreateLink(linkType, dataType, itemData, itemLink, data = null) {
    const actor = this.item.actor;
    const sameActor = actor != null && data != null && data.actorId === actor._id;

    // Don't create link to self
    const itemId = itemLink.split(".").slice(-1)[0];
    if (itemId === this.item._id) return false;

    // Don't create existing links
    const links = getProperty(this.item.data, `data.links.${linkType}`) || [];
    if (links.filter((o) => o.id === itemLink).length) return false;

    if (["children", "charges", "ammunition"].includes(linkType) && sameActor) return true;

    if (linkType === "classAssociations" && dataType === "compendium") return true;

    return false;
  }

  /**
   * @param {string} linkType - The type of link.
   * @param {string} dataType - Either "compendium", "data" or "world".
   * @param {object} itemData - The (new) item's data.
   * @param {string} itemLink - The link identifier for the item.
   * @param {object} [data] - The raw data from a drop event.
   * @returns {Array} An array to insert into this item's link data.
   */
  generateInitialLinkData(linkType, dataType, itemData, itemLink, data = null) {
    const result = {
      id: itemLink,
      dataType: dataType,
      name: itemData.name,
      img: itemData.img,
      hiddenLinks: {},
    };

    if (linkType === "classAssociations") {
      result.level = 1;
    }

    if (linkType === "ammunition") {
      result.recoverChance = 50;
    }

    return result;
  }

  /**
   * Add or remove a damage part from the damage formula
   *
   * @param {Event} event     The original click event
   * @returns {Promise}
   * @private
   */
  async _onDamageControl(event) {
    event.preventDefault();
    const a = event.currentTarget;
    const list = a.closest(".damage");
    const k = list.dataset.key || "data.damage.parts";
    const k2 = k.split(".").slice(0, -1).join(".");
    const k3 = k.split(".").slice(-1).join(".");

    // Add new damage component
    if (a.classList.contains("add-damage")) {
      // Get initial data
      const initialData = ["", ""];

      // Add data
      const damage = getProperty(this.item.data, k2);
      const updateData = {};
      updateData[k] = getProperty(damage, k3).concat([initialData]);
      return this._onSubmit(event, { updateData });
    }

    // Remove a damage component
    if (a.classList.contains("delete-damage")) {
      const li = a.closest(".damage-part");
      const damage = duplicate(getProperty(this.item.data, k2));
      getProperty(damage, k3).splice(Number(li.dataset.damagePart), 1);
      const updateData = {};
      updateData[k] = getProperty(damage, k3);
      return this._onSubmit(event, { updateData });
    }
  }

  async _onAttackControl(event) {
    event.preventDefault();
    const a = event.currentTarget;

    // Add new attack component
    if (a.classList.contains("add-attack")) {
      const attackParts = this.item.data.data.attackParts;
      return this._onSubmit(event, { updateData: { "data.attackParts": attackParts.concat([["", ""]]) } });
    }

    // Remove an attack component
    if (a.classList.contains("delete-attack")) {
      const li = a.closest(".attack-part");
      const attackParts = duplicate(this.item.data.data.attackParts);
      attackParts.splice(Number(li.dataset.attackPart), 1);
      return this._onSubmit(event, { updateData: { "data.attackParts": attackParts } });
    }
  }

  async _onBuffControl(event) {
    event.preventDefault();
    const a = event.currentTarget;

    // Add new change
    if (a.classList.contains("add-change")) {
      const changes = this.item.data.data.changes || [];
      const change = ItemChange.create({}, null);
      return this._onSubmit(event, { updateData: { "data.changes": changes.concat(change.data) } });
    }

    // Remove a change
    if (a.classList.contains("delete-change")) {
      const li = a.closest(".change");
      const changes = duplicate(this.item.data.data.changes);
      const change = changes.find((o) => o._id === li.dataset.change);
      changes.splice(changes.indexOf(change), 1);
      return this._onSubmit(event, { updateData: { "data.changes": changes } });
    }
  }
  _onChangeTargetControl(event) {
    event.preventDefault();
    const a = event.currentTarget;

    // Prepare categories and changes to display
    const change = this.item.changes.get(a.closest(".change").dataset.change);
    const categories = getBuffTargetDictionary(this.item.actor);

    const part1 = change?.subTarget?.split(".")[0];
    const category = CONFIG.FFD20.buffTargets[part1]?.category ?? part1;

    // Show widget
    const w = new Widget_CategorizedItemPicker(
      { title: "FFD20.Application.ChangeTargetSelector.Title" },
      categories,
      (key) => {
        if (key) {
          change.update({ subTarget: key });
        }
      },
      { category, item: change?.subTarget }
    );
    this._openApplications.push(w.appId);
    w.render(true);
  }

  async _onConditionalControl(event) {
    event.preventDefault();
    const a = event.currentTarget;

    // Add new conditional
    if (a.classList.contains("add-conditional")) {
      await this._onSubmit(event); // Submit any unsaved changes
      const conditionals = this.item.data.data.conditionals || [];
      return this.item.update({ "data.conditionals": conditionals.concat([ItemFFD20.defaultConditional]) });
    }

    // Remove a conditional
    if (a.classList.contains("delete-conditional")) {
      await this._onSubmit(event); // Submit any unsaved changes
      const li = a.closest(".conditional");
      const conditionals = duplicate(this.item.data.data.conditionals);
      conditionals.splice(Number(li.dataset.conditional), 1);
      return this.item.update({ "data.conditionals": conditionals });
    }

    // Add a new conditional modifier
    if (a.classList.contains("add-conditional-modifier")) {
      await this._onSubmit(event);
      const li = a.closest(".conditional");
      const conditionals = this.item.data.data.conditionals;
      conditionals[Number(li.dataset.conditional)].modifiers.push(ItemFFD20.defaultConditionalModifier);
      // duplicate object to ensure update
      return this.item.update({ "data.conditionals": duplicate(conditionals) });
    }

    // Remove a conditional modifier
    if (a.classList.contains("delete-conditional-modifier")) {
      await this._onSubmit(event);
      const li = a.closest(".conditional-modifier");
      const conditionals = duplicate(this.item.data.data.conditionals);
      conditionals[Number(li.dataset.conditional)].modifiers.splice(Number(li.dataset.modifier), 1);
      return this.item.update({ "data.conditionals": conditionals });
    }
  }

  async _onNoteControl(event) {
    event.preventDefault();
    const a = event.currentTarget;

    // Add new note
    if (a.classList.contains("add-note")) {
      const contextNotes = this.item.data.data.contextNotes || [];
      await this._onSubmit(event, {
        updateData: { "data.contextNotes": contextNotes.concat([ItemFFD20.defaultContextNote]) },
      });
    }

    // Remove a note
    if (a.classList.contains("delete-note")) {
      const li = a.closest(".context-note");
      const contextNotes = duplicate(this.item.data.data.contextNotes);
      contextNotes.splice(Number(li.dataset.note), 1);
      await this._onSubmit(event, {
        updateData: { "data.contextNotes": contextNotes },
      });
    }
  }

  _onNoteTargetControl(event) {
    event.preventDefault();
    const a = event.currentTarget;

    // Prepare categories and changes to display
    const li = a.closest(".context-note");
    const noteIndex = Number(li.dataset.note);
    const note = this.item.data.data.contextNotes[noteIndex];
    const categories = getBuffTargetDictionary(this.item.actor, "contextNotes");

    const part1 = note?.subTarget?.split(".")[0];
    const category = CONFIG.FFD20.contextNoteTargets[part1]?.category ?? part1;

    // Show widget
    const w = new Widget_CategorizedItemPicker(
      { title: "FFD20.Application.ContextNoteTargetSelector.Title" },
      categories,
      (key) => {
        if (key) {
          const updateData = {};
          updateData[`data.contextNotes.${noteIndex}.subTarget`] = key;
          this.item.update(updateData);
        }
      },
      { category, item: note?.subTarget }
    );
    this._openApplications.push(w.appId);
    w.render(true);
  }

  async _onLinkControl(event) {
    event.preventDefault();
    const a = event.currentTarget;

    // Delete link
    if (a.classList.contains("delete-link")) {
      const li = a.closest(".links-item");
      const group = a.closest('div[data-group="links"]');
      let links = duplicate(getProperty(this.item.data, `data.links.${group.dataset.tab}`) || []);
      const link = links.find((o) => o.id === li.dataset.link);
      links = links.filter((o) => o !== link);

      const updateData = {};
      updateData[`data.links.${group.dataset.tab}`] = links;

      // Call hook for deleting a link
      Hooks.callAll("deleteItemLink", this.item, link, group.dataset.tab);

      await this._onSubmit(event, { updateData });

      // Clean link
      this.item._cleanLink(link, group.dataset.tab);
      game.socket.emit("system.ffd20", {
        eventType: "cleanItemLink",
        actorUUID: this.item.actor.uuid,
        itemUUID: this.item.uuid,
        link: link,
        linkType: group.dataset.tab,
      });
    }
  }

  async _onFilePickerAlt(event) {
    const button = event.currentTarget;
    const attr = button.dataset.for;
    const current = getProperty(this.item.data, attr);
    const form = button.form;
    const targetField = form[attr];
    if (!targetField) return;

    const fp = new FilePicker({
      type: button.dataset.type,
      current: current,
      callback: (path) => {
        targetField.value = path;
        if (this.options.submitOnChange) {
          this._onSubmit(event);
        }
      },
      top: this.position.top + 40,
      left: this.position.left + 10,
    });
    fp.browse(current);
  }

  /**
   * Makes a readonly text input editable, and focus it.
   *
   * @param event
   * @private
   */
  _onInputText(event) {
    event.preventDefault();
    const elem = this.element.find(event.currentTarget.dataset.for);

    elem.removeAttr("readonly");
    elem.attr("name", event.currentTarget.dataset.attrName);
    let value = getProperty(this.item.data, event.currentTarget.dataset.attrName);
    elem.attr("value", value);
    elem.select();

    elem.focusout((event) => {
      if (typeof value === "number") value = value.toString();
      if (value !== elem.attr("value")) {
        this._onSubmit(event);
      } else {
        this.render();
      }
    });
  }

  async _createAttack(event) {
    if (this.item.actor == null) throw new Error(game.i18n.localize("FFD20.ErrorItemNoOwner"));

    await this._onSubmit(event);

    await this.item.actor.createAttackFromWeapon(this.item);
  }

  _onEntrySelector(event) {
    event.preventDefault();
    const a = event.currentTarget;
    const options = {
      name: a.getAttribute("for"),
      title: a.innerText,
      fields: a.dataset.fields,
      dtypes: a.dataset.dtypes,
    };
    new EntrySelector(this.item, options).render(true);
  }

  _onEntryControl(event) {
    event.preventDefault();
    const a = event.currentTarget;
    const key = a.closest(".notes").dataset.name;

    if (a.classList.contains("add-entry")) {
      let notes = getProperty(this.document.data, key);
      const updateData = {};
      updateData[key] = notes.concat("");
      return this._onSubmit(event, { updateData });
    } else if (a.classList.contains("delete-entry")) {
      const index = a.closest(".entry").dataset.index;
      let notes = duplicate(getProperty(this.document.data, key));
      notes.splice(index, 1);

      const updateData = {};
      updateData[key] = notes;
      return this._onSubmit(event, { updateData });
    }
  }

  _selectOnClick(event) {
    event.preventDefault();
    const el = event.currentTarget;
    el.select();
  }

  /** Item Search */

  _searchFilterCommit(event) {
    const container = this.item;
    const search = this._filters.search.toLowerCase();

    // TODO: Do not refresh if same search term, unless the sheet has updated.
    if (this.effectiveSearch === search && !this.searchRefresh) {
      console.log(this.effectiveSearch, "===", search, this.searchRefresh);
      return;
    }
    this.effectiveSearch = search;
    this.searchRefresh = false;

    const matchSearch = (name) => name.toLowerCase().includes(search); // MKAhvi: Bad method for i18n support.

    $(event.target)
      .closest(".tab")
      .find(".item-list .item")
      .each(function () {
        const jq = $(this);
        if (search?.length > 0) {
          const item = container.items.get(this.dataset.itemId);
          if (matchSearch(item.name)) jq.show();
          else jq.hide();
        } else jq.show();
      });
  }

  _clearSearch(event) {
    this._filters.search = "";
    $(event.target).prev(".search-input").val("").change();
  }

  // IME related
  _searchFilterCompositioning(event) {
    this.searchCompositioning = event.type === "compositionstart";
  }

  _searchFilterChange(event) {
    event.preventDefault();
    this._onSubmit(event, { preventRender: true }); // prevent sheet refresh

    // Accept input only while not compositioning

    const search = event.target.value;
    const changed = this._filters.search !== search;

    if (this.searchCompositioning || changed) clearTimeout(this.searchDelayEvent); // reset
    if (this.searchCompositioning) return;

    //if (unchanged) return; // nothing changed
    this._filters.search = search;

    if (event.type === "keyup") {
      // Delay search
      if (changed) this.searchDelayEvent = setTimeout(() => this._searchFilterCommit(event), this.searchDelay);
    } else this._searchFilterCommit(event);
  }
}

class ItemSheetFFD20_Container extends ItemSheetFFD20 {
  constructor(...args) {
    super(...args);

    /**
     * Track item updates from the actor sheet.
     *
     * @type {object[]}
     */
    this._itemUpdates = [];
  }

  static get defaultOptions() {
    return mergeObject(super.defaultOptions, {
      width: 800,
      classes: ["ffd20", "sheet", "item"],
      scrollY: ["section.inventory-body"],
      dragDrop: [
        { dragSelector: "li.item[data-item-id]", dropSelector: '.tab[data-tab="contents"]' },
        { dragSelector: "label.denomination" },
      ],
    });
  }

  /**
   * Return a dynamic reference to the HTML template path used to render this Item Sheet
   *
   * @returns {string}
   */
  get template() {
    return "systems/ffd20/templates/items/container.hbs";
  }

  /* -------------------------------------------- */

  /**
   * Prepare item sheet data
   * Start with the base item data and extending with additional properties for rendering.
   */
  async getData() {
    const data = await super.getData();

    // The item's items
    data.items = this.item.items.map((i) => {
      i.data.labels = i.labels;
      i.data.hasAttack = i.hasAttack;
      i.data.hasMultiAttack = i.hasMultiAttack;
      i.data.hasDamage = i.hasDamage;
      i.data.hasRange = i.hasRange;
      i.data.hasEffect = i.hasEffect;
      i.data.hasAction = i.hasAction || i.isCharged;
      i.data.showUnidentifiedData = i.showUnidentifiedData;
      if (i.showUnidentifiedData)
        i.data.name =
          getProperty(i.data, "data.unidentified.name") || getProperty(i.data, "data.identifiedName") || i.data.name;
      else i.data.name = getProperty(i.data, "data.identifiedName") || i.data.name;
      return i.data;
    });
    data.items.sort((a, b) => (a.sort || 0) - (b.sort || 0));

    // Prepare inventory
    this._prepareContents(data);

    // Override description attributes
    {
      data.descriptionAttributes = [];

      // Add weight
      data.descriptionAttributes.push({
        isNumber: true,
        name: "data.baseWeight",
        fakeName: true,
        label: game.i18n.localize("FFD20.Weight"),
        value: data.item.data.data.weightConverted,
        id: "data-baseWeight",
      });

      // Add price
      if (data.showIdentifyDescription) {
        data.descriptionAttributes.push(
          {
            isNumber: true,
            name: "data.basePrice",
            fakeName: true,
            label: game.i18n.localize("FFD20.Price"),
            value: data.item.data.data.price,
            id: "data-basePrice",
          },
          {
            isNumber: true,
            name: "data.unidentified.basePrice",
            fakeName: true,
            label: game.i18n.localize("FFD20.UnidentifiedPriceShort"),
            value: getProperty(data.item.data, "data.unidentified.price"),
            id: "data-unidentifiedBasePrice",
          }
        );
      } else {
        if (data.showUnidentifiedData) {
          data.descriptionAttributes.push({
            isNumber: true,
            name: "data.unidentified.basePrice",
            fakeName: true,
            label: game.i18n.localize("FFD20.Price"),
            value: getProperty(data.item, "data.unidentified.price"),
            id: "data-basePrice",
          });
        } else {
          data.descriptionAttributes.push({
            isNumber: true,
            name: "data.basePrice",
            fakeName: true,
            label: game.i18n.localize("FFD20.Price"),
            value: data.item.data.price,
            id: "data-basePrice",
          });
        }
      }

      // Add hit points
      data.descriptionAttributes.push({
        isRange: true,
        label: game.i18n.localize("FFD20.HPShort"),
        value: {
          name: "data.hp.value",
          value: getProperty(data.item.data, "data.hp.value"),
        },
        max: {
          name: "data.hp.max",
          value: getProperty(data.item.data, "data.hp.max"),
        },
      });

      // Add hardness
      data.descriptionAttributes.push({
        isNumber: true,
        label: game.i18n.localize("FFD20.Hardness"),
        name: "data.hardness",
        value: getProperty(data.item.data, "data.hardness"),
      });

      // Add carried flag
      data.descriptionAttributes.push({
        isBoolean: true,
        name: "data.carried",
        label: game.i18n.localize("FFD20.Carried"),
        value: data.item.data.data.carried,
      });
    }

    // Get contents weight
    data.contentsWeight = this.item.items.reduce((cur, o) => {
      return cur + o.data.data.weight * o.data.data.quantity;
    }, 0);
    data.contentsWeight += this.item._calculateCoinWeight(this.item.data);
    data.contentsWeight = Math.round(convertWeight(data.contentsWeight) * 10) / 10;
    let usystem = game.settings.get("ffd20", "weightUnits"); // override
    if (usystem === "default") usystem = game.settings.get("ffd20", "units");
    data.weightUnits = usystem === "metric" ? game.i18n.localize("FFD20.Kgs") : game.i18n.localize("FFD20.Lbs");

    // Get contents value
    const gilValue = this.item.getValue({ sellValue: 1 }) - this.item.getValue({ recursive: false, sellValue: 1 });
    const sellValue = this.item.getValue() - this.item.getValue({ recursive: false });
    data.totalValue = {
      gil: Math.max(0, Math.floor(gilValue)),
      sgil: Math.max(0, Math.floor(gilValue * 10 - Math.floor(gilValue) * 10)),
      cgil: Math.max(
        0,
        Math.floor(
          Math.floor(gilValue * 100 - Math.floor(gilValue) * 100) -
            Math.floor(gilValue * 10 - Math.floor(gilValue) * 10) * 10
        )
      ),
    };
    data.sellValue = {
      gil: Math.max(0, Math.floor(sellValue)),
      sgil: Math.max(0, Math.floor(sellValue * 10 - Math.floor(sellValue) * 10)),
      cgil: Math.max(
        0,
        Math.floor(
          Math.floor(sellValue * 100 - Math.floor(sellValue) * 100) -
            Math.floor(sellValue * 10 - Math.floor(sellValue) * 10) * 10
        )
      ),
    };

    // Set labels
    if (!data.labels) data.labels = {};
    data.labels.totalValue = game.i18n
      .localize("FFD20.ItemContainerTotalValue")
      .format(data.totalValue.gil, data.totalValue.sgil, data.totalValue.cgil);
    data.labels.sellValue = game.i18n
      .localize("FFD20.ItemContainerSellValue")
      .format(data.sellValue.gil, data.sellValue.sgil, data.sellValue.cgil);

    return data;
  }

  _prepareContents(data) {
    // Categorize items as inventory, spellbook, features, and classes
    const inventory = {
      weapon: {
        label: game.i18n.localize("FFD20.InventoryWeapons"),
        canCreate: true,
        hasActions: false,
        items: [],
        canEquip: false,
        dataset: { type: "weapon" },
      },
      equipment: {
        label: game.i18n.localize("FFD20.InventoryArmorEquipment"),
        canCreate: true,
        hasActions: true,
        items: [],
        canEquip: false,
        dataset: { type: "equipment" },
        hasSlots: true,
      },
      consumable: {
        label: game.i18n.localize("FFD20.InventoryConsumables"),
        canCreate: true,
        hasActions: true,
        items: [],
        canEquip: false,
        dataset: { type: "consumable" },
      },
      gear: {
        label: CONFIG.FFD20.lootTypes["gear"],
        canCreate: true,
        hasActions: false,
        items: [],
        canEquip: false,
        dataset: { type: "loot", "type-name": game.i18n.localize("FFD20.LootTypeGearSingle"), "sub-type": "gear" },
      },
      ammo: {
        label: CONFIG.FFD20.lootTypes["ammo"],
        canCreate: true,
        hasActions: false,
        items: [],
        canEquip: false,
        dataset: { type: "loot", "type-name": game.i18n.localize("FFD20.LootTypeAmmoSingle"), "sub-type": "ammo" },
      },
      misc: {
        label: CONFIG.FFD20.lootTypes["misc"],
        canCreate: true,
        hasActions: false,
        items: [],
        canEquip: false,
        dataset: { type: "loot", "type-name": game.i18n.localize("FFD20.Misc"), "sub-type": "misc" },
      },
      tradeGoods: {
        label: CONFIG.FFD20.lootTypes["tradeGoods"],
        canCreate: true,
        hasActions: true,
        items: [],
        canEquip: false,
        dataset: {
          type: "loot",
          "type-name": game.i18n.localize("FFD20.LootTypeTradeGoodsSingle"),
          "sub-type": "tradeGoods",
        },
      },
      container: {
        label: game.i18n.localize("FFD20.InventoryContainers"),
        canCreate: true,
        hasActions: false,
        items: [],
        dataset: { type: "container" },
      },
    };

    // Partition items by category
    let items = data.items.reduce((arr, item) => {
      item.img = item.img || DEFAULT_TOKEN;
      item.isStack = item.data.quantity ? item.data.quantity > 1 : false;
      item.hasUses = item.data.uses && item.data.uses.max > 0;
      item.isCharged = ["day", "week", "charges"].includes(getProperty(item, "data.uses.per"));
      item.price = item.data.identified === false ? item.data.unidentified.price : item.data.price;

      const itemQuantity = getProperty(item, "data.quantity") != null ? getProperty(item, "data.quantity") : 1;
      const itemCharges = getProperty(item, "data.uses.value") != null ? getProperty(item, "data.uses.value") : 1;
      item.empty = itemQuantity <= 0 || (item.isCharged && itemCharges <= 0);
      arr.push(item);
      return arr;
    }, []);

    // Organize Inventory
    for (let i of items) {
      const subType = i.type === "loot" ? i.data.subType || "gear" : i.data.subType;
      i.data.quantity = i.data.quantity || 0;
      i.data.weight = i.data.weight || 0;
      i.totalWeight = Math.round(convertWeight(i.data.quantity * i.data.weight) * 10) / 10;
      let usystem = game.settings.get("ffd20", "weightUnits"); // override
      if (usystem === "default") usystem = game.settings.get("ffd20", "units");
      i.units = usystem === "metric" ? game.i18n.localize("FFD20.Kgs") : game.i18n.localize("FFD20.Lbs");
      if (inventory[i.type] != null) inventory[i.type].items.push(i);
      if (subType != null && inventory[subType] != null) inventory[subType].items.push(i);
    }

    data.inventory = Object.values(inventory);
  }

  activateListeners(html) {
    super.activateListeners(html);

    /* -------------------------------------------- */
    /*  Inventory
    /* -------------------------------------------- */

    // Owned Item management
    html.find(".item-create").click((ev) => this._onItemCreate(ev));
    html.find(".item-edit").click(this._onItemEdit.bind(this));
    html.find(".item-delete").click(this._onItemDelete.bind(this));
    html.find(".item-take").click(this._onItemTake.bind(this));

    // Item summaries
    html.find(".item .item-name h4").click((event) => this._onItemSummary(event));

    // Quick edit item
    html.find(".item .item-name h4").contextmenu(this._onItemEdit.bind(this));

    // Quick (un)identify item
    html.find("a.item-control.item-identify").click((ev) => {
      this._quickIdentifyItem(ev);
    });

    // Duplicate item
    html.find("a.item-control.item-duplicate").click(this._duplicateItem.bind(this));

    // Quick add item quantity
    html.find("a.item-control.item-quantity-add").click((ev) => {
      this._quickChangeItemQuantity(ev, 1);
    });
    // Quick subtract item quantity
    html.find("a.item-control.item-quantity-subtract").click((ev) => {
      this._quickChangeItemQuantity(ev, -1);
    });

    // Quick Item Action control
    html.find(".item-actions a").click((ev) => this._quickItemActionControl(ev));

    // Set item uses
    html
      .find(".item-detail.item-uses input[type='text']:not(:disabled)")
      .off("change")
      .change(this._setItemUses.bind(this))
      .on("wheel", this._setItemUses.bind(this));

    // Convert currency
    html.find("a.convert-currency").click(this._convertCurrency.bind(this));

    // Item Rolling
    html.find(".item .item-image").click((event) => this._onItemRoll(event));
  }

  _onItemCreate(event) {
    event.preventDefault();
    const header = event.currentTarget;
    const type = header.dataset.type;
    const typeName = header.dataset.typeName || header.dataset.type;
    const itemData = {
      name: `New ${typeName.capitalize()}`,
      type: type,
      data: duplicate(header.dataset),
    };
    delete itemData.data["type"];
    return this.item.createContainerContent(itemData);
  }

  _onItemEdit(event) {
    event.preventDefault();
    const li = event.currentTarget.closest(".item");
    const item = this.item.getContainerContent(li.dataset.itemId);
    item.sheet.render(true);
  }

  _onItemDelete(event) {
    event.preventDefault();

    const button = event.currentTarget;
    if (button.disabled) return;

    const li = event.currentTarget.closest(".item");
    if (keyboard.isDown("Shift")) {
      this.item.deleteContainerContent(li.dataset.itemId);
    } else {
      button.disabled = true;

      const item = this.document.items.get(li.dataset.itemId);

      const msg = `<p>${game.i18n.localize("FFD20.DeleteItemConfirmation")}</p>`;
      Dialog.confirm({
        title: game.i18n.localize("FFD20.DeleteItemTitle").format(item.name),
        content: msg,
        yes: () => {
          this.item.deleteContainerContent(li.dataset.itemId);
          button.disabled = false;
        },
        no: () => (button.disabled = false),
        rejectClose: true,
      }).then(null, () => (button.disabled = false));
    }
  }

  async _onItemTake(event) {
    event.preventDefault();

    const li = event.currentTarget.closest(".item");
    const item = this.item.getContainerContent(li.dataset.itemId);

    if (this.actor) {
      await this.actor.createOwnedItem(item.data);
      await this.item.deleteContainerContent(item._id);
    }
  }

  _onDragStart(event) {
    // Skip entity links, since they should be handled differently
    if (event.target.classList.contains("entity-link")) return;

    // Create drag data for an owned item
    const elem = event.currentTarget;
    let dragData;
    if (elem.classList.contains("denomination")) {
      if (!this.item.testUserPermission(game.user, 3)) return;
      dragData = {
        type: "Currency",
        alt: elem.classList.contains("alt-currency"),
        currency: [...elem.classList].find((o) => /[pgsc]p/.test(o)),
        containerId: this.item.id,
        amount: parseInt(elem.nextElementSibling.textContent || elem.nextElementSibling.value),
      };
    } else {
      const item = this.item.getContainerContent(elem.dataset.itemId);
      dragData = {
        type: "Item",
        data: item.data,
        containerId: this.item.id,
      };
    }

    // Add actor to drag data
    const actor = this.item.parentActor;
    if (actor) {
      dragData.actorId = actor.id;
      dragData.sceneId = actor.isToken ? canvas.scene?.id : null;
      dragData.tokenId = actor.isToken ? actor.token.id : null;
    }

    // Set data transfer
    event.dataTransfer.setData("text/plain", JSON.stringify(dragData));
  }

  _onDrop(event) {
    event.preventDefault();
    event.stopPropagation();

    // Try to extract the data
    let data;
    try {
      data = JSON.parse(event.dataTransfer.getData("text/plain"));
    } catch (err) {
      return false;
    }
    const item = this.item;

    // Handle the drop with a Hooked function
    const allowed = Hooks.call("dropContainerSheetData", item, this, data);
    if (allowed === false) return;

    // Handle different data types
    switch (data.type) {
      case "Item":
        return this._onDropItem(event, data);
      case "Currency": {
        return this._onDropCurrency(event, data);
      }
    }
  }

  async _onDropCurrency(event, data) {
    let sourceActor = data.tokenId ? game.actors.tokens[data.tokenId] : data.actorId;
    return new CurrencyTransfer(
      { actor: sourceActor, container: data.containerId, alt: data.alt },
      {
        actor: this.actor,
        container: this.item.id,
        amount: Object.fromEntries([[data.currency, parseInt(data.amount)]]),
      }
    ).render(true);
  }

  async _onDropItem(event, data) {
    if (!this.item.isOwner) return false;

    let actor;
    if (data.tokenId) {
      actor = game.actors.tokens[data.tokenId];
    } else if (data.actorId) {
      actor = game.actors.contents.find((o) => o.id === data.actorId);
    }

    const item = await ItemFFD20.fromDropData(data);
    const itemData = duplicate(item.data);

    // Sort item
    if (data.containerId === this.item.id) return this._onSortItem(event, itemData);

    // Create consumable from spell
    if (itemData.type === "spell") {
      let resultData = await createConsumableSpellDialog(itemData, { allowSpell: false });
      if (resultData) return this.item.createContainerContent(resultData);
      else return false;
    }

    // Create or transfer item
    if (ItemFFD20.isInventoryItem(item.data.type)) {
      await this.item.createContainerContent(itemData);

      if (actor && actor === this.item.parentActor) {
        if (actor.items.get(data.data._id)) {
          await actor.deleteEmbeddedDocuments("Item", [data.data._id]);
        } else {
          const containerItem = actor.containerItems.find((i) => i.id === data.data._id);
          if (containerItem) {
            await containerItem.parentItem.deleteContainerContent(data.data._id);
          }
        }
      }
    }
  }

  async _quickIdentifyItem(event) {
    event.preventDefault();
    if (!game.user.isGM) {
      const msg = game.i18n.localize("FFD20.ErrorCantIdentify");
      console.error(msg);
      return ui.notifications.error(msg);
    }
    const itemId = $(event.currentTarget).parents(".item").attr("data-item-id");
    const item = this.item.getContainerContent(itemId);

    if (hasProperty(item.data, "data.identified")) {
      return item.update({ "data.identified": !item.data.data.identified });
    }
  }

  async _duplicateItem(event) {
    event.preventDefault();
    const a = event.currentTarget;

    const itemId = $(a).parents(".item").attr("data-item-id");
    const item = this.item.getContainerContent(itemId);
    const data = duplicate(item.data);

    delete data._id;
    data.name = `${data.name} (Copy)`;
    if (data.data.links) data.data.links = {};

    return this.item.createContainerContent(data);
  }

  async _quickChangeItemQuantity(event, add = 1) {
    event.preventDefault();
    const itemId = $(event.currentTarget).parents(".item").attr("data-item-id");
    const item = this.item.getContainerContent(itemId);

    const curQuantity = getProperty(item.data, "data.quantity") || 0;
    const newQuantity = Math.max(0, curQuantity + add);
    return item.update({ "data.quantity": newQuantity });
  }

  /**
   * Handle rolling of an item from the Actor sheet, obtaining the Item instance and dispatching to it's roll method
   *
   * @param event
   * @private
   */
  _onItemSummary(event) {
    event.preventDefault();
    let li = $(event.currentTarget).closest(".item"),
      item = this.item.getContainerContent(li.attr("data-item-id")),
      chatData = item.getChatData({ secrets: this.actor ? this.actor.owner : this.owner });

    // Toggle summary
    if (li.hasClass("expanded")) {
      let summary = li.children(".item-summary");
      summary.slideUp(200, () => summary.remove());
    } else {
      let div = $(`<div class="item-summary">${chatData.description.value}</div>`);
      let props = $(`<div class="item-properties"></div>`);
      chatData.properties.forEach((p) => props.append(`<span class="tag">${p}</span>`));
      div.append(props);
      li.append(div.hide());
      div.slideDown(200);
    }
    li.toggleClass("expanded");
  }

  async _quickItemActionControl(event) {
    event.preventDefault();
    const a = event.currentTarget;
    const itemId = $(event.currentTarget).closest(".item").attr("data-item-id");
    const item = this.item.getContainerContent(itemId);

    // Quick Attack
    if (a.classList.contains("item-attack")) {
      await item.use({ ev: event, skipDialog: getSkipActionPrompt() });
    }
  }

  async _setItemUses(event) {
    event.preventDefault();
    const el = event.currentTarget;
    const itemId = el.closest(".item").dataset.itemId;
    const item = this.item.getContainerContent(itemId);

    this._mouseWheelAdd(event.originalEvent, el);

    const value = Number(el.value);
    this.setItemUpdate(item._id, "data.uses.value", value);

    // Update on lose focus
    if (event.originalEvent instanceof MouseEvent) {
      if (!this._submitQueued) {
        $(el).one("mouseleave", (event) => {
          this._updateItems();
        });
      }
    } else this._updateItems();
  }

  async _updateItems() {
    let promises = [];

    const updates = duplicate(this._itemUpdates);
    this._itemUpdates = [];

    for (const data of updates) {
      const item = this.item.items.filter((o) => {
        return o._id === data._id;
      })[0];
      if (item == null) continue;

      delete data._id;
      if (item.testUserPermission(game.user, "OWNER")) promises.push(item.update(data));
    }

    return Promise.all(promises);
  }

  setItemUpdate(id, key, value) {
    let obj = this._itemUpdates.filter((o) => {
      return o._id === id;
    })[0];
    if (obj == null) {
      obj = { _id: id };
      this._itemUpdates.push(obj);
    }

    obj[key] = value;
  }

  _mouseWheelAdd(event, el) {
    if (event && event instanceof WheelEvent) {
      const value = parseFloat(el.value);
      if (Number.isNaN(value)) return;

      const increase = -Math.sign(event.deltaY);
      const amount = parseFloat(el.dataset.wheelStep) || 1;
      el.value = value + amount * increase;
    }
  }

  _convertCurrency(event) {
    event.preventDefault();
    const a = event.currentTarget;
    const currencyType = a.dataset.type;

    this.item.convertCurrency(currencyType);
  }

  /**
   * @override
   */
  _onSortItem(event, itemData) {
    // Get the drag source and its siblings
    const source = this.item.getContainerContent(itemData._id);
    const siblings = this._getSortSiblings(source);

    // Get the drop target
    const dropTarget = event.target.closest(".item");
    const targetId = dropTarget ? dropTarget.dataset.itemId : null;
    const target = siblings.find((s) => s.data._id === targetId);

    // Perform the sort
    const sortUpdates = SortingHelpers.performIntegerSort(source, { target: target, siblings });
    const updateData = sortUpdates.map((u) => {
      const update = u.update;
      update._id = u.target.data._id;
      return update;
    });

    // Perform the update
    return this.item.updateContainerContents(updateData);
  }

  /**
   * @override
   */
  _getSortSiblings(source) {
    return this.item.items.filter((i) => {
      if (ItemFFD20.isInventoryItem(source.data.type)) return ItemFFD20.isInventoryItem(i.data.type);
      return i.data.type === source.data.type && i.data._id !== source.data._id;
    });
  }

  /**
   * Handle rolling of an item from the Actor sheet, obtaining the Item instance and dispatching to it's roll method
   *
   * @param event
   * @private
   */
  _onItemRoll(event) {
    event.preventDefault();
    const itemId = event.currentTarget.closest(".item").dataset.itemId;
    const item = this.item.getContainerContent(itemId);

    if (item == null) return;
    return item.roll();
  }
}

class CompendiumDirectoryFFD20 extends CompendiumDirectory {
  static get defaultOptions() {
    return mergeObject(super.defaultOptions, {
      template: "systems/ffd20/templates/sidebar/compendium.hbs",
    });
  }

  getData(options) {
    let data = super.getData(options);

    for (let p of Object.values(data.packs)) {
      for (let pack of p.packs) {
        const config = game.settings.get("core", "compendiumConfiguration")[pack.collection];
        const disabled = getProperty(config, "ffd20.disabled") === true;
        setProperty(pack, "ffd20.disabled", disabled);
      }
    }

    return data;
  }

  activateListeners(html) {
    super.activateListeners(html);

    html.find(".compendium-footer .compendium.spells").click((e) => this._onBrowseCompendium(e, "spells"));
    html.find(".compendium-footer .compendium.items").click((e) => this._onBrowseCompendium(e, "items"));
    html.find(".compendium-footer .compendium.bestiary").click((e) => this._onBrowseCompendium(e, "bestiary"));
    html.find(".compendium-footer .compendium.feats").click((e) => this._onBrowseCompendium(e, "feats"));
    html.find(".compendium-footer .compendium.classes").click((e) => this._onBrowseCompendium(e, "classes"));
    html.find(".compendium-footer .compendium.races").click((e) => this._onBrowseCompendium(e, "races"));
    html.find(".compendium-footer .compendium.buffs").click((e) => this._onBrowseCompendium(e, "buffs"));
  }

  _onBrowseCompendium(event, type) {
    event.preventDefault();

    if (game.ffd20.isMigrating) return ui.notifications.warn(game.i18n.localize("FFD20.Migration.Ongoing"));

    game.ffd20.compendiums[type]._render(true);
  }
}

/**
 * Apply patches to Core Foundry to implement Pathfinder's Low-Light Vision rules
 */
function patchLowLightVision() {
  // Patch Token's sheet template
  Object.defineProperties(Token.prototype, {
    actorVision: {
      get() {
        return {
          lowLight: getProperty(this.data, "flags.ffd20.lowLightVision"),
          lowLightMultiplier: getProperty(this.data, "flags.ffd20.lowLightVisionMultiplier"),
          lowLightMultiplierBright: getProperty(this.data, "flags.ffd20.lowLightVisionMultiplierBright"),
        };
      },
    },
    disableLowLight: {
      get: function () {
        return getProperty(this.data, "flags.ffd20.disableLowLight") === true;
      },
    },
  });

  SightLayer.prototype.hasLowLight = function () {
    console.warn("SightLayer#hasLowLight is deprecated in favor of SightLayer#lowLightMultiplier");

    const relevantTokens = canvas.tokens.placeables.filter((o) => {
      return o.actor && o.actor.testUserPermission(game.user, "OBSERVER");
    });
    const lowLightTokens = relevantTokens.filter((o) => getProperty(o, "actorVision.lowLight"));
    if (game.user.isGM) {
      return lowLightTokens.filter((o) => o._controlled).length > 0;
    }
    if (game.settings.get("ffd20", "lowLightVisionMode")) {
      return lowLightTokens.filter((o) => o._controlled).length > 0;
    }

    const hasControlledTokens = relevantTokens.filter((o) => o._controlled).length > 0;
    const hasControlledLowLightTokens = lowLightTokens.filter((o) => o._controlled).length > 0;
    const hasLowLightTokens = lowLightTokens.length > 0;
    return (!hasControlledTokens && hasLowLightTokens) || hasControlledLowLightTokens;
  };

  SightLayer.prototype.lowLightMultiplier = function () {
    let result = {
      dim: 1,
      bright: 1,
    };

    const relevantTokens = canvas.tokens.placeables.filter((o) => {
      return o.actor && o.actor.testUserPermission(game.user, "OBSERVER");
    });
    const lowLightTokens = relevantTokens.filter((o) => getProperty(o, "actorVision.lowLight"));

    if (game.user.isGM || game.settings.get("ffd20", "lowLightVisionMode")) {
      for (let t of lowLightTokens.filter((o) => o._controlled)) {
        const multiplier = getProperty(t, "actorVision.lowLightMultiplier") || 2;
        const multiplierBright = getProperty(t, "actorVision.lowLightMultiplierBright") || 2;
        result.dim = Math.max(result.dim, multiplier);
        result.bright = Math.max(result.bright, multiplierBright);
      }
    } else {
      const hasControlledTokens = relevantTokens.filter((o) => o._controlled).length > 0;
      const hasControlledLowLightTokens = lowLightTokens.filter((o) => o._controlled).length > 0;
      const hasLowLightTokens = lowLightTokens.length > 0;
      if ((!hasControlledTokens && hasLowLightTokens) || hasControlledLowLightTokens) {
        for (let t of lowLightTokens) {
          const multiplier = getProperty(t, "actorVision.lowLightMultiplier") || 2;
          const multiplierBright = getProperty(t, "actorVision.lowLightMultiplierBright") || 2;
          result.dim = Math.max(result.dim, multiplier);
          result.bright = Math.max(result.bright, multiplierBright);
        }
      }
    }

    return result;
  };

  Token.prototype.updateSource = function ({ defer = false, deleted = false, noUpdateFog = false } = {}) {
    if (CONFIG.debug.sight) {
      SightLayer._performance = { start: performance.now(), tests: 0, rays: 0 };
    }

    // Prepare some common data
    const origin = this.getSightOrigin();
    const sourceId = this.sourceId;
    const d = canvas.dimensions;
    const maxR = canvas.lighting.globalLight ? Math.hypot(d.sceneWidth, d.sceneHeight) : null;
    const lowLightMultiplier = canvas.sight.lowLightMultiplier();

    // Update light source
    const isLightSource = this.emitsLight && !this.data.hidden;
    if (isLightSource && !deleted) {
      const bright =
        this.getLightRadius(this.data.brightLight) * (!this.disableLowLight ? lowLightMultiplier.bright : 1);
      const dim = this.getLightRadius(this.data.dimLight) * (!this.disableLowLight ? lowLightMultiplier.dim : 1);
      this.light.initialize({
        x: origin.x,
        y: origin.y,
        dim: dim,
        bright: bright,
        angle: this.data.lightAngle,
        rotation: this.data.rotation,
        color: this.data.lightColor,
        alpha: this.data.lightAlpha,
        animation: this.data.lightAnimation,
      });
      canvas.lighting.sources.set(sourceId, this.light);
      if (!defer) {
        this.light.drawLight();
        this.light.drawColor();
      }
    } else {
      canvas.lighting.sources.delete(sourceId);
      if (isLightSource && !defer) canvas.lighting.refresh();
    }

    // Update vision source
    const isVisionSource = this._isVisionSource();
    if (isVisionSource && !deleted) {
      //-Override token vision sources to not receive low-light bonus-
      let dim = maxR ?? this.getLightRadius(this.data.dimSight);
      let bright = this.getLightRadius(this.data.brightSight);
      dim = dim / (canvas.sight.lowLightMultiplier().dim || 1);
      bright = bright / (canvas.sight.lowLightMultiplier().bright || 1);
      //-End change-
      if (dim === 0 && bright === 0) dim = d.size * 0.6;
      this.vision.initialize({
        x: origin.x,
        y: origin.y,
        dim: dim,
        bright: bright,
        angle: this.data.sightAngle,
        rotation: this.data.rotation,
      });
      canvas.sight.sources.set(sourceId, this.vision);
      if (!defer) {
        this.vision.drawLight();
        canvas.sight.refresh({ noUpdateFog });
      }
    } else {
      canvas.sight.sources.delete(sourceId);
      if (isVisionSource && !defer) canvas.sight.refresh();
    }
  };

  Object.defineProperty(AmbientLight.prototype, "disableLowLight", {
    get: function () {
      return getProperty(this.data, "flags.ffd20.disableLowLight") === true;
    },
  });

  const AmbientLight__get__dimRadius = Object.getOwnPropertyDescriptor(AmbientLight.prototype, "dimRadius").get;
  Object.defineProperty(AmbientLight.prototype, "dimRadius", {
    get: function () {
      let result = AmbientLight__get__dimRadius.call(this);
      if (!this.disableLowLight) return result * canvas.sight.lowLightMultiplier().dim;
      return result;
    },
  });

  const AmbientLight__get__brightRadius = Object.getOwnPropertyDescriptor(AmbientLight.prototype, "brightRadius").get;
  Object.defineProperty(AmbientLight.prototype, "brightRadius", {
    get: function () {
      let result = AmbientLight__get__brightRadius.call(this);
      if (!this.disableLowLight) return result * canvas.sight.lowLightMultiplier().bright;
      return result;
    },
  });

  const Token__onUpdate = Token.prototype._onUpdate;
  Token.prototype._onUpdate = async function (data, options, ...args) {
    await Token__onUpdate.call(this, data, options, ...args);

    if (
      hasProperty(data, "flags.ffd20.disableLowLight") ||
      hasProperty(data, "flags.ffd20.lowLightVision") ||
      hasProperty(data, "flags.ffd20.lowLightVisionMultiplier") ||
      hasProperty(data, "flags.ffd20.lowLightVisionMultiplierBright")
    ) {
      canvas.lighting.initializeSources();
      canvas.perception.initialize();
    }
  };
}

/**
 * Add a checkbox to enable/disable low-light vision effects to a light's configuration
 *
 * @param {FormApplication} app - The LightConfig app
 * @param {jQuery} html - The jQuery of the inner html
 */
const addLowLightVisionToLightConfig = function (app, html) {
  const obj = app.object;

  // Create checkbox HTML element
  let checkboxStr = `<div class="form-group"><label>${game.i18n.localize(
    "FFD20.DisableLightLowLightVision"
  )}</label><div class="form-group">`;
  checkboxStr += '<input type="checkbox" name="flags.ffd20.disableLowLight" data-dtype="Boolean"';
  if (getProperty(obj.data, "flags.ffd20.disableLowLight")) checkboxStr += " checked";
  checkboxStr += "/></div></div>";
  const checkbox = $(checkboxStr);

  // Insert new checkbox
  checkbox.insertBefore(html.find('button[type="submit"]'));
};

/**
 * Add a checkbox to enable/disable low-light vision to a token's configuration
 *
 * @param {FormApplication} app - The TokenConfig app
 * @param {jQuery} html - The jQuery of the inner html
 */
const addLowLightVisionToTokenConfig = function (app, html) {
  const obj = app.object;

  // Create checkbox HTML element
  let checkboxStr = `<div class="form-group"><label>${game.i18n.localize(
    "FFD20.DisableLightLowLightVision"
  )}</label><div class="form-group">`;
  checkboxStr += '<input type="checkbox" name="flags.ffd20.disableLowLight" data-dtype="Boolean"';
  if (getProperty(obj.data, "flags.ffd20.disableLowLight")) checkboxStr += " checked";
  checkboxStr += "/></div></div>";
  const checkbox = $(checkboxStr);

  // Insert new checkbox
  html.find('.tab[data-tab="vision"]').append(checkbox);
};

/**
 * Applies patches to core functions to integrate Pathfinder specific measurements.
 */
function patchMeasureTools() {
  // Use 90 degrees cone in FFD20 style
  const TemplateLayer__onDragLeftStart = TemplateLayer.prototype._onDragLeftStart;
  TemplateLayer.prototype._onDragLeftStart = function (event) {
    if (!game.settings.get("ffd20", "measureStyle")) return TemplateLayer__onDragLeftStart.call(this, event);

    PlaceablesLayer.prototype._onDragLeftStart.call(this, event);

    // Create the new preview template
    const tool = game.activeTool;
    const origin = event.data.origin;
    let pos;
    if (["cone", "circle"].includes(tool)) {
      pos = canvas.grid.getSnappedPosition(origin.x, origin.y, 2);
    } else pos = canvas.grid.getSnappedPosition(origin.x, origin.y, 2);
    origin.x = pos.x;
    origin.y = pos.y;

    // Create the template
    const data = {
      user: game.user.id,
      t: tool,
      x: pos.x,
      y: pos.y,
      distance: 5,
      direction: 0,
      fillColor: game.user.data.color || "#FF0000",
    };
    if (tool === "cone") data["angle"] = 90;
    else if (tool === "ray") data["width"] = 5;

    // Assign the template
    const doc = new MeasuredTemplateDocument(data, { parent: canvas.scene });
    const template = new MeasuredTemplate(doc);
    event.data.preview = this.preview.addChild(template);
    template.draw();
  };

  const TemplateLayer__onDragLeftMove = TemplateLayer.prototype._onDragLeftMove;
  TemplateLayer.prototype._onDragLeftMove = function (event) {
    if (!game.settings.get("ffd20", "measureStyle")) return TemplateLayer__onDragLeftMove.call(this, event);

    PlaceablesLayer.prototype._onDragLeftMove.call(this, event);
    if (event.data.createState >= 1) {
      // Snap the destination to the grid
      let dest = event.data.destination;
      let { x, y } = canvas.grid.getSnappedPosition(dest.x, dest.y, 2);
      dest.x = x;
      dest.y = y;

      // Compute the ray
      let template = event.data.preview,
        ray = new Ray(event.data.origin, event.data.destination),
        ratio = canvas.dimensions.size / canvas.dimensions.distance;

      // Update the shape data
      if (["cone", "circle"].includes(template.data.t)) {
        const direction = ray.angle;
        template.data.direction = Math.toDegrees(
          Math.floor((direction + Math.PI * 0.125) / (Math.PI * 0.25)) * (Math.PI * 0.25)
        );
        const distance = ray.distance / ratio;
        template.data.distance = Math.floor(distance / canvas.dimensions.distance) * canvas.dimensions.distance;
      } else {
        template.data.direction = Math.toDegrees(ray.angle);
        if (template.data.t === "ray") {
          template.data.distance = Math.floor(ray.distance / ratio / 2.5) * 2.5;
        } else {
          template.data.distance = ray.distance / ratio;
        }
      }

      // Draw the pending shape
      template.refresh();
      event.data.createState = 2;
    }
  };

  // Highlight grid in FFD20 style
  const MeasuredTemplate_highlightGrid = MeasuredTemplate.prototype.highlightGrid;
  MeasuredTemplate.prototype.highlightGrid = function () {
    if (!game.settings.get("ffd20", "measureStyle") || !["circle", "cone"].includes(this.data.t))
      return MeasuredTemplate_highlightGrid.call(this);

    const grid = canvas.grid,
      d = canvas.dimensions,
      bc = this.borderColor,
      fc = this.fillColor;

    // Only highlight for objects which have a defined shape
    if (!this.id || !this.shape) return;

    // Clear existing highlight
    const hl = grid.getHighlightLayer(`Template.${this.id}`);
    hl.clear();

    // Get number of rows and columns
    let nr = Math.ceil((this.data.distance * 1.5) / d.distance / (d.size / grid.h)),
      nc = Math.ceil((this.data.distance * 1.5) / d.distance / (d.size / grid.w));

    // Get the center of the grid position occupied by the template
    let x = this.data.x,
      y = this.data.y;

    let [cx, cy] = grid.getCenter(x, y),
      [col0, row0] = grid.grid.getGridPositionFromPixels(cx, cy),
      minAngle = (360 + ((this.data.direction - this.data.angle * 0.5) % 360)) % 360,
      maxAngle = (360 + ((this.data.direction + this.data.angle * 0.5) % 360)) % 360;

    const within_angle = function (min, max, value) {
      min = (360 + (min % 360)) % 360;
      max = (360 + (max % 360)) % 360;
      value = (360 + (value % 360)) % 360;

      if (min < max) return value >= min && value <= max;
      return value >= min || value <= max;
    };

    const measureDistance = function (p0, p1) {
      let gs = canvas.dimensions.size,
        ray = new Ray(p0, p1),
        // How many squares do we travel across to get there? If 2.3, we should count that as 3 instead of 2; hence, Math.ceil
        nx = Math.ceil(Math.abs(ray.dx / gs)),
        ny = Math.ceil(Math.abs(ray.dy / gs));

      // Get the number of straight and diagonal moves
      let nDiagonal = Math.min(nx, ny),
        nStraight = Math.abs(ny - nx);

      // Diagonals in FFD20 pretty much count as 1.5 times a straight
      let distance = Math.floor(nDiagonal * 1.5 + nStraight);
      let distanceOnGrid = distance * canvas.dimensions.distance;
      return distanceOnGrid;
    };

    let originOffset = { x: 0, y: 0 };
    // Offset measurement for cones
    // Offset is to ensure that cones only start measuring from cell borders, as in https://www.d20pfsrd.com/magic/#Aiming_a_Spell
    if (this.data.t === "cone") {
      // Degrees anticlockwise from pointing right. In 45-degree increments from 0 to 360
      const dir = (this.data.direction >= 0 ? 360 - this.data.direction : -this.data.direction) % 360;
      // If we're not on a border for X, offset by 0.5 or -0.5 to the border of the cell in the direction we're looking on X axis
      let xOffset =
        this.data.x % d.size != 0
          ? Math.sign((1 * Math.round(Math.cos(degtorad(dir)) * 100)) / 100) / 2 // /2 turns from 1/0/-1 to 0.5/0/-0.5
          : 0;
      // Same for Y, but cos Y goes down on screens, we invert
      let yOffset =
        this.data.y % d.size != 0 ? -Math.sign((1 * Math.round(Math.sin(degtorad(dir)) * 100)) / 100) / 2 : 0;
      originOffset.x = xOffset;
      originOffset.y = yOffset;
    }

    for (let a = -nc; a < nc; a++) {
      for (let b = -nr; b < nr; b++) {
        // Position of cell's top-left corner, in pixels
        let [gx, gy] = canvas.grid.grid.getPixelsFromGridPosition(col0 + a, row0 + b);
        // Position of cell's center, in pixels
        let [cellCenterX, cellCenterY] = [gx + d.size * 0.5, gy + d.size * 0.5];

        // Determine point of origin
        let origin = { x: this.data.x, y: this.data.y };
        origin.x += originOffset.x * d.size;
        origin.y += originOffset.y * d.size;

        let ray = new Ray(origin, { x: cellCenterX, y: cellCenterY });

        let rayAngle = (360 + ((ray.angle / (Math.PI / 180)) % 360)) % 360;
        if (this.data.t === "cone" && ray.distance > 0 && !within_angle(minAngle, maxAngle, rayAngle)) {
          continue;
        }

        // Determine point we're measuring the distance to - always in the center of a grid square
        let destination = { x: cellCenterX, y: cellCenterY };

        let distance = measureDistance(destination, origin);
        if (distance <= this.data.distance) {
          grid.grid.highlightGridPosition(hl, { x: gx, y: gy, color: fc, border: bc });
        }
      }
    }
  };
}

/**
 *
 */
async function PatchCore() {
  // Patch getTemplate to prevent unwanted indentation in things things like <textarea> elements.
  /**
   * @param path
   */
  async function FFD20_getTemplate(path) {
    if (!Object.prototype.hasOwnProperty.call(_templateCache, path) || CONFIG.debug.template) {
      await new Promise((resolve) => {
        game.socket.emit("template", path, (resp) => {
          const compiled = Handlebars.compile(resp.html, { preventIndent: true });
          Handlebars.registerPartial(path, compiled);
          _templateCache[path] = compiled;
          console.log(`Foundry VTT | Retrieved and compiled template ${path}`);
          resolve(compiled);
        });
      });
    }
    return _templateCache[path];
  }

  // Token patch for shared vision
  Token.prototype._isVisionSource;
  Token.prototype._isVisionSource = function () {
    if (!canvas.sight.tokenVision || !this.hasSight) return false;

    // Only display hidden tokens for the GM
    const isGM = game.user.isGM;
    if (this.data.hidden && !isGM) return false;

    // Always display controlled tokens which have vision
    if (this._controlled) return true;

    // Otherwise vision is ignored for GM users
    if (isGM) return false;

    // If a non-GM user controls no other tokens with sight, display sight anyways
    const canObserve = this.actor && hasTokenVision(this);
    if (!canObserve) return false;
    const others = this.layer.controlled.filter((t) => !t.data.hidden && t.hasSight);
    return !others.length || game.settings.get("ffd20", "sharedVisionMode") === "1";
  };

  // Token#observer patch to make use of vision permission settings
  Object.defineProperty(Token.prototype, "observer", {
    get() {
      return game.user.isGM || hasTokenVision(this);
    },
  });

  // Add Vision Permission sheet to ActorDirectory context options
  const ActorDirectory__getEntryContextOptions = ActorDirectory.prototype._getEntryContextOptions;
  ActorDirectory.prototype._getEntryContextOptions = function () {
    return ActorDirectory__getEntryContextOptions.call(this).concat([
      {
        name: "FFD20.Vision",
        icon: '<i class="fas fa-eye"></i>',
        condition: (li) => {
          return game.user.isGM;
        },
        callback: (li) => {
          const entity = this.constructor.collection.get(li.data("entityId"));
          if (entity) {
            const sheet = entity.visionPermissionSheet;
            if (sheet.rendered) {
              if (sheet._minimized) sheet.maximize();
              else sheet.close();
            } else sheet.render(true);
          }
        },
      },
    ]);
  };

  // Add combat tracker context menu options
  {
    const origFunc = CombatTracker.prototype._getEntryContextOptions;
    CombatTracker.prototype._getEntryContextOptions = function () {
      let result = origFunc.call(this);
      addCombatTrackerContextOptions.call(this, result);
      return result;
    };
  }

  // Add inline support for extra /commands
  {
    const origParse = ChatLog.parse;
    ChatLog.parse = function (message) {
      const match = message.match(/^\/(\w+)(?: +([^#]+))(?:#(.+))?/),
        type = match?.[1];
      if (["HEAL", "H", "DAMAGE", "D"].includes(type?.toUpperCase())) {
        match[2] = match[0].slice(1);
        return ["custom", match];
      } else return origParse.call(this, message);
    };

    const origClick = TextEditor._onClickInlineRoll;
    TextEditor._onClickInlineRoll = function (event) {
      event.preventDefault();
      const a = event.currentTarget;
      if (!a.classList.contains("custom")) return origClick.call(this, event);

      const chatMessage = `/${a.dataset.formula}`;
      const cMsg = CONFIG.ChatMessage.entityClass;
      const speaker = cMsg.getSpeaker();
      let actor = cMsg.getSpeakerActor(speaker);
      let rollData = actor ? actor.getRollData() : {};

      const sheet = a.closest(".sheet");
      if (sheet) {
        const app = ui.windows[sheet.dataset.appid];
        if (["Actor", "Item"].includes(app?.object?.entity)) rollData = app.object.getRollData();
      }
      return customRolls(chatMessage, speaker, rollData);
    };

    // Fix for race condition
    if ($._data($("body").get(0), "events")?.click?.find((o) => o.selector === "a.inline-roll")) {
      $("body").off("click", "a.inline-roll", origClick);
      $("body").on("click", "a.inline-roll", TextEditor._onClickInlineRoll);
    }
  }

  // Change tooltip showing on alt
  {
    const fn = KeyboardManager.prototype._onAlt;
    KeyboardManager.prototype._onAlt = function (event, up, modifiers) {
      if (!up) game.ffd20.tooltip.lock.new = true;
      fn.call(this, event, up, modifiers);
      if (!up) game.ffd20.tooltip.lock.new = false;
    };
  }

  // Patch, patch, patch
  Combat.prototype._getInitiativeFormula = _getInitiativeFormula;
  Combat.prototype.rollInitiative = _rollInitiative;
  window.getTemplate = FFD20_getTemplate;

  // Apply low light vision patches
  patchLowLightVision();

  // Apply measurement patches
  patchMeasureTools();

  // Patch StringTerm
  StringTerm.prototype.evaluate = function (options = {}) {
    const result = parseRollStringVariable(this.term);
    if (typeof result === "string") {
      const src = `with (sandbox) { return ${this.term}; }`;
      try {
        const evalFn = new Function("sandbox", src);
        this._total = evalFn(RollFFD20.MATH_PROXY);
      } catch (err) {
        err.message = `Failed to evaluate: '${this.term}'\n${err.message}`;
        throw err;
      }
    } else {
      this._total = result;
    }
  };

  // Patch NumericTerm
  NumericTerm.prototype.getTooltipData = function () {
    return {
      formula: this.expression,
      total: this.total,
      flavor: this.flavor,
    };
  };

  // Patch ParentheticalTerm and allowed operators
  ParentheticalTerm.CLOSE_REGEXP = new RegExp(`\\)${RollTerm.FLAVOR_REGEXP_STRING}?`, "g");
  OperatorTerm.REGEXP = /(?:&&|\|\||\*\*|\+|-|\*|\/|\\%|\||:|\?)|(?<![a-z])[!=<>]+/g;
  OperatorTerm.OPERATORS.push("\\%", "!", "?", ":", "=", "<", ">", "==", "===", "<=", ">=", "??", "||", "&&", "**");

  // Add secondary indexing to compendium collections
  {
    const origFunc = CompendiumCollection.prototype.getIndex;
    CompendiumCollection.prototype.getIndex = async function ({ fields } = {}) {
      let index = await origFunc.call(this, { fields });
      this.fuzzyIndex = sortArrayByName([...index]);
      return this.index;
    };
  }

  // Entity link attribute stuffing
  {
    const origFunc = TextEditor._createContentLink;
    TextEditor._createContentLink = function (match, type, target, name) {
      let a = origFunc.call(this, match, type, target, name);
      if (name?.indexOf("::") > -1) {
        let args = name.split("::"),
          label = args.pop();
        if (args.length) {
          args.forEach((o) => {
            let [key, value] = o.split(/(?<!\\):/);
            if (!(key && value)) {
              value = key;
              key = "extra";
            }
            switch (key) {
              case "icon":
                a.firstChild.className = "fas fa-" + value;
                break;
              case "class":
                a.classList.add(...value.split(" "));
                break;
              default:
                a.setAttribute("data-" + key, value);
            }
          });
          a.lastChild.textContent = label;
        }
      }
      return a;
    };
  }

  // Todo: Declare this in TokenDocumentFFD20 when/ if TokenDocument.getData calls the constructor's method
  {
    const origFunc = TokenDocument.getTrackedAttributes;
    TokenDocument.getTrackedAttributes = function (data, _path = []) {
      let attr = origFunc.call(this, data, _path);
      if (_path.length === 0) attr.value.push(["attributes", "hp", "temp"], ["attributes", "hp", "nonlethal"]);
      return attr;
    };
  }
}

const rangeColor = {
  fill: color("#ff0000"),
  border: color("#ff0000").darken(0.1),
};
const reachColor = {
  fill: color("#ffff00"),
  border: color("#ffff00").darken(0.1),
};

class SquareHighlight {
  constructor(origin, fillColor = 0x00ff00, borderColor = 0x000000) {
    this.origin = origin;
    this.borderColor = borderColor;
    this.fillColor = fillColor;
    this._squares = [];

    this._id = randomID();

    canvas.grid.addHighlightLayer(`AttackHighlight.${this._id}`);
  }

  addSquare(x, y) {
    this._squares.push({ x: x, y: y });
  }

  clear(permanent = false) {
    const hl = canvas.grid.getHighlightLayer(`AttackHighlight.${this._id}`);
    if (!hl) return;
    hl.clear();

    if (permanent) canvas.grid.destroyHighlightLayer(`AttackHighlight.${this._id}`);
  }

  render() {
    const grid = canvas.grid;
    const gridSize = grid.size;
    const hl = canvas.grid.getHighlightLayer(`AttackHighlight.${this._id}`);

    this.clear();

    // Highlight squares
    for (let s of this._squares) {
      const x = Math.floor(this.origin.x - s.x) * gridSize;
      const y = Math.floor(this.origin.y - s.y) * gridSize;
      grid.grid.highlightGridPosition(hl, { x: x, y: y, border: this.borderColor, color: this.fillColor });
    }
  }
}

/**
 * Highlights the reach of an attack for a token.
 *
 * @param {Token} token
 * @param {ItemFFD20} attack
 * @returns SquareHighlight
 */
const showAttackReach = function (token, attack) {
  const grid = canvas.grid;
  const gridSize = grid.size;
  const tw = token.data.width;
  const th = token.data.height;
  const origin = {
    x: Math.floor((token.x + tw * gridSize - 0.5 * gridSize) / gridSize),
    y: Math.floor((token.y + th * gridSize - 0.5 * gridSize) / gridSize),
  };

  const rollData = attack.getRollData();

  // Determine whether reach
  const rangeKey = getProperty(attack.data, "data.range.units");
  if (!["melee", "touch", "reach", "ft", "close", "medium"].includes(rangeKey)) return;
  const isReach = rangeKey === "reach";
  const range = rollData.range;

  // Determine minimum range
  const minRangeKey = getProperty(attack.data, "data.range.minUnits");
  let minRange = null;
  if (["melee", "touch"].includes(minRangeKey)) minRange = range.melee;
  if (minRangeKey === "reach") minRange = range.reach;
  if (minRangeKey === "ft") {
    minRange = RollFFD20.safeRoll(getProperty(attack.data, "data.range.minValue") || "0", rollData).total;
  }

  let squares = {
    normal: [],
    reach: [],
    extra: [],
  };
  const useReachRule = game.settings.get("ffd20", "alternativeReachCornerRule") !== true;

  if (["melee", "touch", "reach"].includes(rangeKey)) {
    squares.normal = getReachSquares(token, range.melee, minRange, null, { useReachRule });
    squares.reach = getReachSquares(token, range.reach, range.melee, null, { useReachRule });
  } else if (rangeKey === "ft") {
    const r = RollFFD20.safeRoll(getProperty(attack.data, "data.range.value") || "0", rollData).total;
    squares.normal = getReachSquares(token, r, minRange, null, { useReachRule: true });

    // Add range increments
    const maxSquareRange = Math.min(
      400,
      Math.max(
        (canvas.dimensions.width / canvas.dimensions.size) * canvas.dimensions.distance,
        (canvas.dimensions.height / canvas.dimensions.size) * canvas.dimensions.distance
      ) + convertDistance(r)[0]
    );
    const rangeIncrements = getProperty(attack.data, "data.range.maxIncrements") || 1;
    for (let a = 1; a < rangeIncrements; a++) {
      if ((a + 1) * convertDistance(r)[0] <= maxSquareRange) {
        squares.extra.push(getReachSquares(token, (a + 1) * r, a * r, null, { useReachRule }));
      }
    }
  } else if (["close", "medium"].includes(rangeKey) && attack.type === "spell") {
    let r;
    switch (rangeKey) {
      case "close":
        r = RollFFD20.safeRoll("25 + floor(@cl / 2) * 5", rollData).total;
        break;
      case "medium":
        r = RollFFD20.safeRoll("100 + @cl * 10", rollData).total;
        break;
    }
    squares.normal = getReachSquares(token, r, minRange, null, { useReachRule });
  }

  const result = {
    normal: new SquareHighlight(origin, colorToInt(rangeColor.fill), colorToInt(rangeColor.border)),
    reach: new SquareHighlight(origin, colorToInt(reachColor.fill), colorToInt(reachColor.border)),
    extra: [],
  };
  for (let s of squares.normal) {
    result.normal.addSquare(s[0], s[1]);
  }
  if (isReach) {
    for (let s of squares.reach) {
      result.reach.addSquare(s[0], s[1]);
    }
  }

  // Add extra range squares
  {
    for (let a = 0; a < squares.extra.length; a++) {
      let squaresExtra = squares.extra[a];

      const color = {
        fill: a % 2 === 1 ? rangeColor.fill : reachColor.fill,
        border: a % 2 === 1 ? rangeColor.border : reachColor.border,
      };

      const hl = new SquareHighlight(origin, colorToInt(color.fill), colorToInt(color.border));
      for (let s of squaresExtra) {
        hl.addSquare(s[0], s[1]);
      }
      result.extra.push(hl);
    }
  }

  return result;
};

const addReachCallback = async function (data, html) {
  let results = [];

  // Don't do anything under certain circumstances
  const itemId = getProperty(data, "flags.ffd20.metadata.item");
  if (!itemId) return results;

  const tokenUuid = html.find(".chat-card")[0]?.dataset?.tokenUuid;
  let token;
  if (tokenUuid) {
    token = (await fromUuid(tokenUuid))?.object;
  }
  if (!token || !token.actor) return results;

  const item = token.actor.items.find((o) => o.id === itemId);
  if (!item) return results;

  let highlight;
  // Add mouse enter callback
  const mouseEnterCallback = function () {
    if (token._destroyed) return;
    if (!game.settings.get("ffd20", "hideReachMeasurements")) highlight = showAttackReach(token, item);

    if (!highlight) return;

    highlight.normal.render();
    highlight.reach.render();
    highlight.extra.forEach((hl) => {
      hl.render();
    });
  };
  const rangeElems = html.find(".card-range");
  rangeElems.on("mouseenter", mouseEnterCallback);

  // Add mouse leave callback
  const mouseLeaveCallback = function () {
    if (token._destroyed) return;
    if (!highlight) return;

    highlight.normal.clear(true);
    highlight.reach.clear(true);
    highlight.extra.forEach((hl) => {
      hl.clear(true);
    });
  };
  rangeElems.on("mouseleave", mouseLeaveCallback);
  // Add 'click' event as a safeguard to remove highlights
  // html.on("click", mouseLeaveCallback);

  // Clear highlights when chat messages are rendered
  Hooks.on("renderChatMessage", () => {
    if (!highlight) return;

    highlight.normal.clear(true);
    highlight.reach.clear(true);
    highlight.extra.forEach((hl) => {
      hl.clear(true);
    });
  });

  // Add results
  results.push(
    {
      event: "mouseenter",
      callback: mouseEnterCallback,
      elem: html,
    },
    {
      event: "mouseleave",
      callback: mouseLeaveCallback,
      elem: html,
    },
    {
      event: "click",
      callback: mouseLeaveCallback,
      elem: html,
    }
  );

  return results;
};

const getReachSquares = function (token, range, minRange = 0, addSquareFunction = null, options) {
  range = convertDistance(range)[0];
  if (typeof minRange === "number") minRange = convertDistance(minRange)[0];

  let result = [];

  if (canvas.grid.type !== CONST.GRID_TYPES.SQUARE) return result;
  if (!addSquareFunction) addSquareFunction = shouldAddReachSquare;

  // Initialize variables
  const gridDist = canvas.scene.data.gridDistance;
  const gridSize = canvas.grid.size;

  // Determine token squares
  let tokenSquares = [];
  for (let a = 0; a < Math.floor(token.w / gridSize); a++) {
    for (let b = 0; b < Math.floor(token.h / gridSize); b++) {
      const x = Math.floor((token.x + gridSize * 0.5) / gridSize + a);
      const y = Math.floor((token.y + gridSize * 0.5) / gridSize + b);
      tokenSquares.push([x, y]);
    }
  }

  // Determine token-based variables
  let tokenRect = [
    Math.floor((token.x + gridSize * 0.5) / gridSize),
    Math.floor((token.y + gridSize * 0.5) / gridSize),
    Math.floor(token.w / gridSize),
    Math.floor(token.h / gridSize),
  ];

  // Create function to determine closest token square
  const getClosestTokenSquare = function (pos) {
    const lowest = { square: null, dist: null };
    for (let s of tokenSquares) {
      const dist = Math.sqrt((s[0] - pos[0]) ** 2 + (s[1] - pos[1]) ** 2);
      if (lowest.dist == null || dist < lowest.dist) {
        lowest.square = s;
        lowest.dist = dist;
      }
    }

    return lowest.square;
  };

  // Gather potential squares
  const squareRange = Math.round(range / gridDist);
  const wMax = squareRange * 2 + tokenRect[2];
  const hMax = squareRange * 2 + tokenRect[3];
  const tl = [tokenRect[0] - squareRange, tokenRect[1] - squareRange];
  for (let a = tl[0]; a < tl[0] + wMax; a++) {
    for (let b = tl[1]; b < tl[1] + hMax; b++) {
      const closestSquare = getClosestTokenSquare([a, b]);

      const offset = [a - tokenRect[0], b - tokenRect[1]];
      if (
        !(
          a >= tokenRect[0] &&
          a < tokenRect[0] + tokenRect[2] &&
          b >= tokenRect[1] &&
          b < tokenRect[1] + tokenRect[2] &&
          minRange != null
        )
      ) {
        if (addSquareFunction(token, [a, b], closestSquare, range, minRange, tokenRect, options)) {
          result.push(offset);
        }
      }
    }
  }

  return result;
};

const shouldAddReachSquare = function (
  token,
  pos,
  closestTokenSquare,
  range,
  minRange,
  tokenRect,
  options = { useReachRule: false }
) {
  canvas.scene.data.gridDistance;
  const gridSize = canvas.grid.size;
  const p0 = { x: closestTokenSquare[0] * gridSize, y: closestTokenSquare[1] * gridSize };
  const p1 = { x: pos[0] * gridSize, y: pos[1] * gridSize };

  const dist = measureReachDistance(p0, p1);
  const dist2 = measureReachDistance(p0, p1, true);
  const reachRuleRange = convertDistance(10)[0];
  if (dist > range) {
    // Special rule for 10-ft. reach
    if (!(options.useReachRule && range === reachRuleRange)) {
      return false;
    }
  }

  if (minRange != null && dist <= minRange) {
    return false;
  }

  // Special rule for minimum ranges >= 10-ft.
  if (options.useReachRule && minRange >= reachRuleRange && dist2 <= reachRuleRange) {
    return false;
  }

  return true;
};

const measureReachDistance = function (p0, p1, alt = false) {
  let gs = canvas.dimensions.size,
    ray = new Ray(p0, p1),
    nx = Math.abs(Math.ceil(ray.dx / gs)),
    ny = Math.abs(Math.ceil(ray.dy / gs));

  // Get the number of straight and diagonal moves
  let nDiagonal = Math.min(nx, ny),
    nStraight = Math.abs(ny - nx);

  // Return distance
  if (!alt) {
    let nd10 = Math.floor(nDiagonal / 2);
    let spaces = nd10 * 2 + (nDiagonal - nd10) + nStraight;
    return spaces * canvas.dimensions.distance;
  }

  return (nStraight + nDiagonal) * canvas.scene.data.gridDistance;
};

class TokenQuickActions {
  static async addTop3Attacks(app, html, data) {
    const token = canvas.tokens.placeables.find((o) => o.id === data._id);
    const actor = token.actor;

    if (actor == null) return;

    const actualChargeCost = (i) => Math.floor(i.charges / i.chargeCost),
      actualMaxCharge = (i) => Math.floor(i.maxCharges / i.chargeCost);
    const chargeDisplay = (item) => {
      let r = "<charges>";
      const max = item.isCharged ? actualMaxCharge(item) : 0;
      const recharging = item.isCharged && item.chargeCost < 0;
      const uses = item.isCharged
        ? !recharging
          ? actualChargeCost(item)
          : -item.chargeCost
        : item.data.data.links?.ammunition
            ?.flatMap((l) => actor.items.get(l.id) ?? [])
            .reduce((a, b) => a + actualChargeCost(b), 0) ?? 0;
      if (!recharging) r += `<span class='remaining'>${uses}</span >`;
      else r += `<span class='recharge'>+${uses}</span>`;
      if (!recharging && max !== 0) r += `<span class='delimiter' >/</span ><span class='max'>${max}</span>`;
      r += "</charges>";
      return r;
    };

    let quickActions = '<div class="col actions"><div class="below">';
    let items = actor.getQuickActions();
    items.forEach(function (i) {
      const item = i.item;
      const icon = item.img ?? CONST.DEFAULT_TOKEN;
      let title = "";
      if (item.type === "attack") title = game.i18n.localize("FFD20.AttackWith").format(item.name);
      else if (item.type === "spell") title = game.i18n.localize("FFD20.AttackWithSpell").format(item.name);
      else if (item.type === "feat") title = game.i18n.localize("FFD20.AttackWithFeat").format(item.name);
      const type = item.type;
      quickActions +=
        `<div id="${type}-${item.id}" class="control-icon token-quick-action" style="border: 2px solid ${i.color1};">` +
        `<img src="${icon}" width="36" height="36" title="${title}">`;
      if (item.isCharged || item.data.data.links?.ammunition?.length > 0) quickActions += chargeDisplay(item);
      quickActions += "</div >";
    });

    html.find(".col.middle").after(quickActions + "</div></div>");

    items.forEach(function (i) {
      const item = actor.items.find((o) => o.id === i.item.id);
      const type = item.type;
      const elem = html.find(`#${type}-${item.id}`);

      // Add click handler
      elem.on("click", (event) => {
        if (!event.ctrlKey) {
          return item.use({ skipDialog: getSkipActionPrompt() });
        }
        return item.roll();
      });

      // Add mouse enter handler
      let highlight;
      elem.on("mouseenter", (event) => {
        if (!game.settings.get("ffd20", "hideReachMeasurements")) highlight = showAttackReach(token, item);

        if (!highlight) return;

        highlight.normal.render();
        highlight.reach.render();
        highlight.extra.forEach((hl) => {
          hl.render();
        });
      });

      // Add mouse leave callback
      elem.on("mouseleave", (event) => {
        if (!highlight) return;

        highlight.normal.clear(true);
        highlight.reach.clear(true);
        highlight.extra.forEach((hl) => {
          hl.clear(true);
        });
      });
    });
  }
}

/**
 *
 */
function initializeSocket() {
  game.socket.on("system.ffd20", async (args) => {
    const isFirstGM = game.user === game.users.find((u) => u.isGM && u.active);
    try {
      switch (args.eventType) {
        case "cleanItemLink": {
          // Get actor
          const actor = await fromUuid(args.actorUUID);
          // Get item
          const parentItemData = await fromUuid(args.itemUUID);
          const parentItem = actor.items.find((o) => o._id === parentItemData._id);
          // Get link data
          const link = args.link;
          const linkType = args.linkType;
          // Clean item links
          parentItem._cleanLink(link, linkType);
          break;
        }
        case "redrawCanvas":
          canvas.draw();
          break;
        case "currencyTransfer": {
          if (!isFirstGM) return;
          let source = await fromUuid(args.data.sourceActor);
          let dest = await fromUuid(args.data.destActor);

          if (args.data.sourceContainer) source = source.items.get(args.data.sourceContainer);
          if (args.data.destContainer) dest = dest.items.get(args.data.destContainer);
          const amount = args.data.amount;

          game.ffd20.applications.CurrencyTransfer.transfer(
            source,
            dest,
            amount,
            args.data.sourceAlt,
            args.data.destAlt,
            false
          );
          break;
        }
      }
    } catch (err) {
      console.log("FFD20 | Socket Error: ", err);
    }
  });
}

const runUnitTests = async function () {
  const actorName = "Testy";
  const actor = game.actors.contents.find((o) => o.name === actorName);
  if (!actor) {
    const msg = game.i18n.localize("FFD20.ErrorCouldNotFindActorByName").format(actorName);
    console.error(msg);
    return ui.notifications.error(msg);
  }

  console.log("Running unit tests...");
  let tests = [];

  // tests.push(...(await runSkillTests(actor)));
  // tests.push(...(await runAttackTests(actor)));
  // tests.push(...(await runMiscActorTests(actor)));
  tests.push(...(await runSizeRollTests()));

  // Finish unit tests
  const successes = tests.filter((o) => !o.failure);
  const failures = tests.filter((o) => o.failure);
  console.log(`Unit tests done. ${successes.length}/${tests.length} succeeded.`);
  if (failures.length) {
    console.log("Failures:", failures);
  }
};

class UnitTestResult {
  constructor(name) {
    this.name = name;
    this.failure = false;
    this.error = null;
    this.chatMessages = [];
  }

  fail(error) {
    this.failure = true;
    if (error) this.error = error;
    console.log(`${this.name} failed!`, this.error);
  }

  succeed() {
    this.failure = false;
    this.error = null;
    console.log(`${this.name} succeeded!`);
  }
}

const runSizeRollTests = async function () {
  let result = [];

  await _addSizeRollTest("1d6", "1d6", result);
  await _addSizeRollTest("1d4", "1d6", result, { targetSize: 5 });
  await _addSizeRollTest("1d6", "1d8", result, { targetSize: 5 });
  await _addSizeRollTest("1d8", "1d6", result, { targetSize: 3 });
  await _addSizeRollTest("1d6", "1d4", result, { targetSize: 3 });
  await _addSizeRollTest("2d4", "2d6", result, { targetSize: 5 });
  await _addSizeRollTest("2d6", "6d6", result, { targetSize: 7 });
  await _addSizeRollTest("6d8", "2d8", result, { targetSize: 4, initialSize: 7 });
  await _addSizeRollTest("6d8", "3d8", result, { targetSize: 2, initialSize: 5 });
  await _addSizeRollTest("2d10", "4d8", result, { targetSize: 5 });
  await _addSizeRollTest("2d10", "2d8", result, { targetSize: 3 });
  await _addSizeRollTest("4d10", "8d8", result, { targetSize: 5 });

  return result;
};

const _addSizeRollTest = async function (
  formula,
  expectedFormula,
  resultArr,
  options = { targetSize: 4, initialSize: 4 }
) {
  options = mergeObject({ targetSize: 4, initialSize: 4 }, options);
  const label = `Size roll: ${formula}, going from size ${options.initialSize} to ${options.targetSize}`;
  const test = new UnitTestResult(label);

  const re = /^([0-9]+)d([0-9]+)$/;
  if (!formula.match(re)) {
    throw new Error(`Unit test (size roll): incorrect input formula: '${formula}'`);
  }
  const baseDie = [parseInt(RegExp.$1), parseInt(RegExp.$2)];
  if (!expectedFormula.match(re)) {
    throw new Error(`Unit test (size roll): incorrect expected formula: '${expectedFormula}'`);
  }
  const expectedDie = [parseInt(RegExp.$1), parseInt(RegExp.$2)];
  resultArr.push(test);

  try {
    const roll = RollFFD20.safeRoll(
      `sizeRoll(${baseDie[0]}, ${baseDie[1]}, ${options.targetSize}, ${options.initialSize})`
    );
    if (roll.err) throw roll.err;
    const term = roll.terms[0];
    if (term.number !== expectedDie[0] || term.faces !== expectedDie[1])
      throw new Error(
        `Incorrect result die. Expected: ${expectedDie[0]}d${expectedDie[1]}, got: ${term.number}d${term.faces}`
      );
    test.succeed();
  } catch (err) {
    test.fail(err);
  }
};

var Aacute = "Á";
var aacute = "á";
var Abreve = "Ă";
var abreve = "ă";
var ac = "∾";
var acd = "∿";
var acE = "∾̳";
var Acirc = "Â";
var acirc = "â";
var acute = "´";
var Acy = "А";
var acy = "а";
var AElig = "Æ";
var aelig = "æ";
var af = "⁡";
var Afr = "𝔄";
var afr = "𝔞";
var Agrave = "À";
var agrave = "à";
var alefsym = "ℵ";
var aleph = "ℵ";
var Alpha = "Α";
var alpha = "α";
var Amacr = "Ā";
var amacr = "ā";
var amalg = "⨿";
var amp = "&";
var AMP = "&";
var andand = "⩕";
var And = "⩓";
var and = "∧";
var andd = "⩜";
var andslope = "⩘";
var andv = "⩚";
var ang = "∠";
var ange = "⦤";
var angle = "∠";
var angmsdaa = "⦨";
var angmsdab = "⦩";
var angmsdac = "⦪";
var angmsdad = "⦫";
var angmsdae = "⦬";
var angmsdaf = "⦭";
var angmsdag = "⦮";
var angmsdah = "⦯";
var angmsd = "∡";
var angrt = "∟";
var angrtvb = "⊾";
var angrtvbd = "⦝";
var angsph = "∢";
var angst = "Å";
var angzarr = "⍼";
var Aogon = "Ą";
var aogon = "ą";
var Aopf = "𝔸";
var aopf = "𝕒";
var apacir = "⩯";
var ap = "≈";
var apE = "⩰";
var ape = "≊";
var apid = "≋";
var apos = "'";
var ApplyFunction = "⁡";
var approx = "≈";
var approxeq = "≊";
var Aring = "Å";
var aring = "å";
var Ascr = "𝒜";
var ascr = "𝒶";
var Assign = "≔";
var ast = "*";
var asymp = "≈";
var asympeq = "≍";
var Atilde = "Ã";
var atilde = "ã";
var Auml = "Ä";
var auml = "ä";
var awconint = "∳";
var awint = "⨑";
var backcong = "≌";
var backepsilon = "϶";
var backprime = "‵";
var backsim = "∽";
var backsimeq = "⋍";
var Backslash = "∖";
var Barv = "⫧";
var barvee = "⊽";
var barwed = "⌅";
var Barwed = "⌆";
var barwedge = "⌅";
var bbrk = "⎵";
var bbrktbrk = "⎶";
var bcong = "≌";
var Bcy = "Б";
var bcy = "б";
var bdquo = "„";
var becaus = "∵";
var because = "∵";
var Because = "∵";
var bemptyv = "⦰";
var bepsi = "϶";
var bernou = "ℬ";
var Bernoullis = "ℬ";
var Beta = "Β";
var beta = "β";
var beth = "ℶ";
var between = "≬";
var Bfr = "𝔅";
var bfr = "𝔟";
var bigcap = "⋂";
var bigcirc = "◯";
var bigcup = "⋃";
var bigodot = "⨀";
var bigoplus = "⨁";
var bigotimes = "⨂";
var bigsqcup = "⨆";
var bigstar = "★";
var bigtriangledown = "▽";
var bigtriangleup = "△";
var biguplus = "⨄";
var bigvee = "⋁";
var bigwedge = "⋀";
var bkarow = "⤍";
var blacklozenge = "⧫";
var blacksquare = "▪";
var blacktriangle = "▴";
var blacktriangledown = "▾";
var blacktriangleleft = "◂";
var blacktriangleright = "▸";
var blank = "␣";
var blk12 = "▒";
var blk14 = "░";
var blk34 = "▓";
var block$1 = "█";
var bne = "=⃥";
var bnequiv = "≡⃥";
var bNot = "⫭";
var bnot = "⌐";
var Bopf = "𝔹";
var bopf = "𝕓";
var bot = "⊥";
var bottom = "⊥";
var bowtie = "⋈";
var boxbox = "⧉";
var boxdl = "┐";
var boxdL = "╕";
var boxDl = "╖";
var boxDL = "╗";
var boxdr = "┌";
var boxdR = "╒";
var boxDr = "╓";
var boxDR = "╔";
var boxh = "─";
var boxH = "═";
var boxhd = "┬";
var boxHd = "╤";
var boxhD = "╥";
var boxHD = "╦";
var boxhu = "┴";
var boxHu = "╧";
var boxhU = "╨";
var boxHU = "╩";
var boxminus = "⊟";
var boxplus = "⊞";
var boxtimes = "⊠";
var boxul = "┘";
var boxuL = "╛";
var boxUl = "╜";
var boxUL = "╝";
var boxur = "└";
var boxuR = "╘";
var boxUr = "╙";
var boxUR = "╚";
var boxv = "│";
var boxV = "║";
var boxvh = "┼";
var boxvH = "╪";
var boxVh = "╫";
var boxVH = "╬";
var boxvl = "┤";
var boxvL = "╡";
var boxVl = "╢";
var boxVL = "╣";
var boxvr = "├";
var boxvR = "╞";
var boxVr = "╟";
var boxVR = "╠";
var bprime = "‵";
var breve = "˘";
var Breve = "˘";
var brvbar = "¦";
var bscr = "𝒷";
var Bscr = "ℬ";
var bsemi = "⁏";
var bsim = "∽";
var bsime = "⋍";
var bsolb = "⧅";
var bsol = "\\";
var bsolhsub = "⟈";
var bull = "•";
var bullet = "•";
var bump = "≎";
var bumpE = "⪮";
var bumpe = "≏";
var Bumpeq = "≎";
var bumpeq = "≏";
var Cacute = "Ć";
var cacute = "ć";
var capand = "⩄";
var capbrcup = "⩉";
var capcap = "⩋";
var cap = "∩";
var Cap = "⋒";
var capcup = "⩇";
var capdot = "⩀";
var CapitalDifferentialD = "ⅅ";
var caps = "∩︀";
var caret = "⁁";
var caron = "ˇ";
var Cayleys = "ℭ";
var ccaps = "⩍";
var Ccaron = "Č";
var ccaron = "č";
var Ccedil = "Ç";
var ccedil = "ç";
var Ccirc = "Ĉ";
var ccirc = "ĉ";
var Cconint = "∰";
var ccups = "⩌";
var ccupssm = "⩐";
var Cdot = "Ċ";
var cdot = "ċ";
var cedil = "¸";
var Cedilla = "¸";
var cemptyv = "⦲";
var cent = "¢";
var centerdot = "·";
var CenterDot = "·";
var cfr = "𝔠";
var Cfr = "ℭ";
var CHcy = "Ч";
var chcy = "ч";
var check = "✓";
var checkmark = "✓";
var Chi = "Χ";
var chi = "χ";
var circ = "ˆ";
var circeq = "≗";
var circlearrowleft = "↺";
var circlearrowright = "↻";
var circledast = "⊛";
var circledcirc = "⊚";
var circleddash = "⊝";
var CircleDot = "⊙";
var circledR = "®";
var circledS = "Ⓢ";
var CircleMinus = "⊖";
var CirclePlus = "⊕";
var CircleTimes = "⊗";
var cir = "○";
var cirE = "⧃";
var cire = "≗";
var cirfnint = "⨐";
var cirmid = "⫯";
var cirscir = "⧂";
var ClockwiseContourIntegral = "∲";
var CloseCurlyDoubleQuote = "”";
var CloseCurlyQuote = "’";
var clubs = "♣";
var clubsuit = "♣";
var colon = ":";
var Colon = "∷";
var Colone = "⩴";
var colone = "≔";
var coloneq = "≔";
var comma = ",";
var commat = "@";
var comp = "∁";
var compfn = "∘";
var complement = "∁";
var complexes = "ℂ";
var cong = "≅";
var congdot = "⩭";
var Congruent = "≡";
var conint = "∮";
var Conint = "∯";
var ContourIntegral = "∮";
var copf = "𝕔";
var Copf = "ℂ";
var coprod = "∐";
var Coproduct = "∐";
var copy = "©";
var COPY = "©";
var copysr = "℗";
var CounterClockwiseContourIntegral = "∳";
var crarr = "↵";
var cross = "✗";
var Cross = "⨯";
var Cscr = "𝒞";
var cscr = "𝒸";
var csub = "⫏";
var csube = "⫑";
var csup = "⫐";
var csupe = "⫒";
var ctdot = "⋯";
var cudarrl = "⤸";
var cudarrr = "⤵";
var cuepr = "⋞";
var cuesc = "⋟";
var cularr = "↶";
var cularrp = "⤽";
var cupbrcap = "⩈";
var cupcap = "⩆";
var CupCap = "≍";
var cup = "∪";
var Cup = "⋓";
var cupcup = "⩊";
var cupdot = "⊍";
var cupor = "⩅";
var cups = "∪︀";
var curarr = "↷";
var curarrm = "⤼";
var curlyeqprec = "⋞";
var curlyeqsucc = "⋟";
var curlyvee = "⋎";
var curlywedge = "⋏";
var curren = "¤";
var curvearrowleft = "↶";
var curvearrowright = "↷";
var cuvee = "⋎";
var cuwed = "⋏";
var cwconint = "∲";
var cwint = "∱";
var cylcty = "⌭";
var dagger = "†";
var Dagger = "‡";
var daleth = "ℸ";
var darr = "↓";
var Darr = "↡";
var dArr = "⇓";
var dash = "‐";
var Dashv = "⫤";
var dashv = "⊣";
var dbkarow = "⤏";
var dblac = "˝";
var Dcaron = "Ď";
var dcaron = "ď";
var Dcy = "Д";
var dcy = "д";
var ddagger = "‡";
var ddarr = "⇊";
var DD = "ⅅ";
var dd = "ⅆ";
var DDotrahd = "⤑";
var ddotseq = "⩷";
var deg = "°";
var Del = "∇";
var Delta = "Δ";
var delta = "δ";
var demptyv = "⦱";
var dfisht = "⥿";
var Dfr = "𝔇";
var dfr = "𝔡";
var dHar = "⥥";
var dharl = "⇃";
var dharr = "⇂";
var DiacriticalAcute = "´";
var DiacriticalDot = "˙";
var DiacriticalDoubleAcute = "˝";
var DiacriticalGrave = "`";
var DiacriticalTilde = "˜";
var diam = "⋄";
var diamond = "⋄";
var Diamond = "⋄";
var diamondsuit = "♦";
var diams = "♦";
var die = "¨";
var DifferentialD = "ⅆ";
var digamma = "ϝ";
var disin = "⋲";
var div = "÷";
var divide = "÷";
var divideontimes = "⋇";
var divonx = "⋇";
var DJcy = "Ђ";
var djcy = "ђ";
var dlcorn = "⌞";
var dlcrop = "⌍";
var dollar = "$";
var Dopf = "𝔻";
var dopf = "𝕕";
var Dot = "¨";
var dot = "˙";
var DotDot = "⃜";
var doteq = "≐";
var doteqdot = "≑";
var DotEqual = "≐";
var dotminus = "∸";
var dotplus = "∔";
var dotsquare = "⊡";
var doublebarwedge = "⌆";
var DoubleContourIntegral = "∯";
var DoubleDot = "¨";
var DoubleDownArrow = "⇓";
var DoubleLeftArrow = "⇐";
var DoubleLeftRightArrow = "⇔";
var DoubleLeftTee = "⫤";
var DoubleLongLeftArrow = "⟸";
var DoubleLongLeftRightArrow = "⟺";
var DoubleLongRightArrow = "⟹";
var DoubleRightArrow = "⇒";
var DoubleRightTee = "⊨";
var DoubleUpArrow = "⇑";
var DoubleUpDownArrow = "⇕";
var DoubleVerticalBar = "∥";
var DownArrowBar = "⤓";
var downarrow = "↓";
var DownArrow = "↓";
var Downarrow = "⇓";
var DownArrowUpArrow = "⇵";
var DownBreve = "̑";
var downdownarrows = "⇊";
var downharpoonleft = "⇃";
var downharpoonright = "⇂";
var DownLeftRightVector = "⥐";
var DownLeftTeeVector = "⥞";
var DownLeftVectorBar = "⥖";
var DownLeftVector = "↽";
var DownRightTeeVector = "⥟";
var DownRightVectorBar = "⥗";
var DownRightVector = "⇁";
var DownTeeArrow = "↧";
var DownTee = "⊤";
var drbkarow = "⤐";
var drcorn = "⌟";
var drcrop = "⌌";
var Dscr = "𝒟";
var dscr = "𝒹";
var DScy = "Ѕ";
var dscy = "ѕ";
var dsol = "⧶";
var Dstrok = "Đ";
var dstrok = "đ";
var dtdot = "⋱";
var dtri = "▿";
var dtrif = "▾";
var duarr = "⇵";
var duhar = "⥯";
var dwangle = "⦦";
var DZcy = "Џ";
var dzcy = "џ";
var dzigrarr = "⟿";
var Eacute = "É";
var eacute = "é";
var easter = "⩮";
var Ecaron = "Ě";
var ecaron = "ě";
var Ecirc = "Ê";
var ecirc = "ê";
var ecir = "≖";
var ecolon = "≕";
var Ecy = "Э";
var ecy = "э";
var eDDot = "⩷";
var Edot = "Ė";
var edot = "ė";
var eDot = "≑";
var ee = "ⅇ";
var efDot = "≒";
var Efr = "𝔈";
var efr = "𝔢";
var eg = "⪚";
var Egrave = "È";
var egrave = "è";
var egs = "⪖";
var egsdot = "⪘";
var el = "⪙";
var Element = "∈";
var elinters = "⏧";
var ell = "ℓ";
var els = "⪕";
var elsdot = "⪗";
var Emacr = "Ē";
var emacr = "ē";
var empty = "∅";
var emptyset = "∅";
var EmptySmallSquare = "◻";
var emptyv = "∅";
var EmptyVerySmallSquare = "▫";
var emsp13 = " ";
var emsp14 = " ";
var emsp = " ";
var ENG = "Ŋ";
var eng = "ŋ";
var ensp = " ";
var Eogon = "Ę";
var eogon = "ę";
var Eopf = "𝔼";
var eopf = "𝕖";
var epar = "⋕";
var eparsl = "⧣";
var eplus = "⩱";
var epsi = "ε";
var Epsilon = "Ε";
var epsilon = "ε";
var epsiv = "ϵ";
var eqcirc = "≖";
var eqcolon = "≕";
var eqsim = "≂";
var eqslantgtr = "⪖";
var eqslantless = "⪕";
var Equal = "⩵";
var equals = "=";
var EqualTilde = "≂";
var equest = "≟";
var Equilibrium = "⇌";
var equiv = "≡";
var equivDD = "⩸";
var eqvparsl = "⧥";
var erarr = "⥱";
var erDot = "≓";
var escr = "ℯ";
var Escr = "ℰ";
var esdot = "≐";
var Esim = "⩳";
var esim = "≂";
var Eta = "Η";
var eta = "η";
var ETH = "Ð";
var eth = "ð";
var Euml = "Ë";
var euml = "ë";
var euro = "€";
var excl = "!";
var exist = "∃";
var Exists = "∃";
var expectation = "ℰ";
var exponentiale = "ⅇ";
var ExponentialE = "ⅇ";
var fallingdotseq = "≒";
var Fcy = "Ф";
var fcy = "ф";
var female = "♀";
var ffilig = "ﬃ";
var fflig = "ﬀ";
var ffllig = "ﬄ";
var Ffr = "𝔉";
var ffr = "𝔣";
var filig = "ﬁ";
var FilledSmallSquare = "◼";
var FilledVerySmallSquare = "▪";
var fjlig = "fj";
var flat = "♭";
var fllig = "ﬂ";
var fltns = "▱";
var fnof = "ƒ";
var Fopf = "𝔽";
var fopf = "𝕗";
var forall = "∀";
var ForAll = "∀";
var fork = "⋔";
var forkv = "⫙";
var Fouriertrf = "ℱ";
var fpartint = "⨍";
var frac12 = "½";
var frac13 = "⅓";
var frac14 = "¼";
var frac15 = "⅕";
var frac16 = "⅙";
var frac18 = "⅛";
var frac23 = "⅔";
var frac25 = "⅖";
var frac34 = "¾";
var frac35 = "⅗";
var frac38 = "⅜";
var frac45 = "⅘";
var frac56 = "⅚";
var frac58 = "⅝";
var frac78 = "⅞";
var frasl = "⁄";
var frown = "⌢";
var fscr = "𝒻";
var Fscr = "ℱ";
var gacute = "ǵ";
var Gamma = "Γ";
var gamma = "γ";
var Gammad = "Ϝ";
var gammad = "ϝ";
var gap = "⪆";
var Gbreve = "Ğ";
var gbreve = "ğ";
var Gcedil = "Ģ";
var Gcirc = "Ĝ";
var gcirc = "ĝ";
var Gcy = "Г";
var gcy = "г";
var Gdot = "Ġ";
var gdot = "ġ";
var ge = "≥";
var gE = "≧";
var gEl = "⪌";
var gel = "⋛";
var geq = "≥";
var geqq = "≧";
var geqslant = "⩾";
var gescc = "⪩";
var ges = "⩾";
var gesdot = "⪀";
var gesdoto = "⪂";
var gesdotol = "⪄";
var gesl = "⋛︀";
var gesles = "⪔";
var Gfr = "𝔊";
var gfr = "𝔤";
var gg = "≫";
var Gg = "⋙";
var ggg = "⋙";
var gimel = "ℷ";
var GJcy = "Ѓ";
var gjcy = "ѓ";
var gla = "⪥";
var gl = "≷";
var glE = "⪒";
var glj = "⪤";
var gnap = "⪊";
var gnapprox = "⪊";
var gne = "⪈";
var gnE = "≩";
var gneq = "⪈";
var gneqq = "≩";
var gnsim = "⋧";
var Gopf = "𝔾";
var gopf = "𝕘";
var grave = "`";
var GreaterEqual = "≥";
var GreaterEqualLess = "⋛";
var GreaterFullEqual = "≧";
var GreaterGreater = "⪢";
var GreaterLess = "≷";
var GreaterSlantEqual = "⩾";
var GreaterTilde = "≳";
var Gscr = "𝒢";
var gscr = "ℊ";
var gsim = "≳";
var gsime = "⪎";
var gsiml = "⪐";
var gtcc = "⪧";
var gtcir = "⩺";
var gt = ">";
var GT = ">";
var Gt = "≫";
var gtdot = "⋗";
var gtlPar = "⦕";
var gtquest = "⩼";
var gtrapprox = "⪆";
var gtrarr = "⥸";
var gtrdot = "⋗";
var gtreqless = "⋛";
var gtreqqless = "⪌";
var gtrless = "≷";
var gtrsim = "≳";
var gvertneqq = "≩︀";
var gvnE = "≩︀";
var Hacek = "ˇ";
var hairsp = " ";
var half = "½";
var hamilt = "ℋ";
var HARDcy = "Ъ";
var hardcy = "ъ";
var harrcir = "⥈";
var harr = "↔";
var hArr = "⇔";
var harrw = "↭";
var Hat = "^";
var hbar = "ℏ";
var Hcirc = "Ĥ";
var hcirc = "ĥ";
var hearts = "♥";
var heartsuit = "♥";
var hellip = "…";
var hercon = "⊹";
var hfr = "𝔥";
var Hfr = "ℌ";
var HilbertSpace = "ℋ";
var hksearow = "⤥";
var hkswarow = "⤦";
var hoarr = "⇿";
var homtht = "∻";
var hookleftarrow = "↩";
var hookrightarrow = "↪";
var hopf = "𝕙";
var Hopf = "ℍ";
var horbar = "―";
var HorizontalLine = "─";
var hscr = "𝒽";
var Hscr = "ℋ";
var hslash = "ℏ";
var Hstrok = "Ħ";
var hstrok = "ħ";
var HumpDownHump = "≎";
var HumpEqual = "≏";
var hybull = "⁃";
var hyphen = "‐";
var Iacute = "Í";
var iacute = "í";
var ic = "⁣";
var Icirc = "Î";
var icirc = "î";
var Icy = "И";
var icy = "и";
var Idot = "İ";
var IEcy = "Е";
var iecy = "е";
var iexcl = "¡";
var iff = "⇔";
var ifr = "𝔦";
var Ifr = "ℑ";
var Igrave = "Ì";
var igrave = "ì";
var ii = "ⅈ";
var iiiint = "⨌";
var iiint = "∭";
var iinfin = "⧜";
var iiota = "℩";
var IJlig = "Ĳ";
var ijlig = "ĳ";
var Imacr = "Ī";
var imacr = "ī";
var image$1 = "ℑ";
var ImaginaryI = "ⅈ";
var imagline = "ℐ";
var imagpart = "ℑ";
var imath = "ı";
var Im = "ℑ";
var imof = "⊷";
var imped = "Ƶ";
var Implies = "⇒";
var incare = "℅";
var infin = "∞";
var infintie = "⧝";
var inodot = "ı";
var intcal = "⊺";
var int = "∫";
var Int = "∬";
var integers = "ℤ";
var Integral = "∫";
var intercal = "⊺";
var Intersection = "⋂";
var intlarhk = "⨗";
var intprod = "⨼";
var InvisibleComma = "⁣";
var InvisibleTimes = "⁢";
var IOcy = "Ё";
var iocy = "ё";
var Iogon = "Į";
var iogon = "į";
var Iopf = "𝕀";
var iopf = "𝕚";
var Iota = "Ι";
var iota = "ι";
var iprod = "⨼";
var iquest = "¿";
var iscr = "𝒾";
var Iscr = "ℐ";
var isin = "∈";
var isindot = "⋵";
var isinE = "⋹";
var isins = "⋴";
var isinsv = "⋳";
var isinv = "∈";
var it = "⁢";
var Itilde = "Ĩ";
var itilde = "ĩ";
var Iukcy = "І";
var iukcy = "і";
var Iuml = "Ï";
var iuml = "ï";
var Jcirc = "Ĵ";
var jcirc = "ĵ";
var Jcy = "Й";
var jcy = "й";
var Jfr = "𝔍";
var jfr = "𝔧";
var jmath = "ȷ";
var Jopf = "𝕁";
var jopf = "𝕛";
var Jscr = "𝒥";
var jscr = "𝒿";
var Jsercy = "Ј";
var jsercy = "ј";
var Jukcy = "Є";
var jukcy = "є";
var Kappa = "Κ";
var kappa = "κ";
var kappav = "ϰ";
var Kcedil = "Ķ";
var kcedil = "ķ";
var Kcy = "К";
var kcy = "к";
var Kfr = "𝔎";
var kfr = "𝔨";
var kgreen = "ĸ";
var KHcy = "Х";
var khcy = "х";
var KJcy = "Ќ";
var kjcy = "ќ";
var Kopf = "𝕂";
var kopf = "𝕜";
var Kscr = "𝒦";
var kscr = "𝓀";
var lAarr = "⇚";
var Lacute = "Ĺ";
var lacute = "ĺ";
var laemptyv = "⦴";
var lagran = "ℒ";
var Lambda = "Λ";
var lambda = "λ";
var lang = "⟨";
var Lang = "⟪";
var langd = "⦑";
var langle = "⟨";
var lap = "⪅";
var Laplacetrf = "ℒ";
var laquo = "«";
var larrb = "⇤";
var larrbfs = "⤟";
var larr = "←";
var Larr = "↞";
var lArr = "⇐";
var larrfs = "⤝";
var larrhk = "↩";
var larrlp = "↫";
var larrpl = "⤹";
var larrsim = "⥳";
var larrtl = "↢";
var latail = "⤙";
var lAtail = "⤛";
var lat = "⪫";
var late = "⪭";
var lates = "⪭︀";
var lbarr = "⤌";
var lBarr = "⤎";
var lbbrk = "❲";
var lbrace = "{";
var lbrack = "[";
var lbrke = "⦋";
var lbrksld = "⦏";
var lbrkslu = "⦍";
var Lcaron = "Ľ";
var lcaron = "ľ";
var Lcedil = "Ļ";
var lcedil = "ļ";
var lceil = "⌈";
var lcub = "{";
var Lcy = "Л";
var lcy = "л";
var ldca = "⤶";
var ldquo = "“";
var ldquor = "„";
var ldrdhar = "⥧";
var ldrushar = "⥋";
var ldsh = "↲";
var le = "≤";
var lE = "≦";
var LeftAngleBracket = "⟨";
var LeftArrowBar = "⇤";
var leftarrow = "←";
var LeftArrow = "←";
var Leftarrow = "⇐";
var LeftArrowRightArrow = "⇆";
var leftarrowtail = "↢";
var LeftCeiling = "⌈";
var LeftDoubleBracket = "⟦";
var LeftDownTeeVector = "⥡";
var LeftDownVectorBar = "⥙";
var LeftDownVector = "⇃";
var LeftFloor = "⌊";
var leftharpoondown = "↽";
var leftharpoonup = "↼";
var leftleftarrows = "⇇";
var leftrightarrow = "↔";
var LeftRightArrow = "↔";
var Leftrightarrow = "⇔";
var leftrightarrows = "⇆";
var leftrightharpoons = "⇋";
var leftrightsquigarrow = "↭";
var LeftRightVector = "⥎";
var LeftTeeArrow = "↤";
var LeftTee = "⊣";
var LeftTeeVector = "⥚";
var leftthreetimes = "⋋";
var LeftTriangleBar = "⧏";
var LeftTriangle = "⊲";
var LeftTriangleEqual = "⊴";
var LeftUpDownVector = "⥑";
var LeftUpTeeVector = "⥠";
var LeftUpVectorBar = "⥘";
var LeftUpVector = "↿";
var LeftVectorBar = "⥒";
var LeftVector = "↼";
var lEg = "⪋";
var leg = "⋚";
var leq = "≤";
var leqq = "≦";
var leqslant = "⩽";
var lescc = "⪨";
var les = "⩽";
var lesdot = "⩿";
var lesdoto = "⪁";
var lesdotor = "⪃";
var lesg = "⋚︀";
var lesges = "⪓";
var lessapprox = "⪅";
var lessdot = "⋖";
var lesseqgtr = "⋚";
var lesseqqgtr = "⪋";
var LessEqualGreater = "⋚";
var LessFullEqual = "≦";
var LessGreater = "≶";
var lessgtr = "≶";
var LessLess = "⪡";
var lesssim = "≲";
var LessSlantEqual = "⩽";
var LessTilde = "≲";
var lfisht = "⥼";
var lfloor = "⌊";
var Lfr = "𝔏";
var lfr = "𝔩";
var lg = "≶";
var lgE = "⪑";
var lHar = "⥢";
var lhard = "↽";
var lharu = "↼";
var lharul = "⥪";
var lhblk = "▄";
var LJcy = "Љ";
var ljcy = "љ";
var llarr = "⇇";
var ll = "≪";
var Ll = "⋘";
var llcorner = "⌞";
var Lleftarrow = "⇚";
var llhard = "⥫";
var lltri = "◺";
var Lmidot = "Ŀ";
var lmidot = "ŀ";
var lmoustache = "⎰";
var lmoust = "⎰";
var lnap = "⪉";
var lnapprox = "⪉";
var lne = "⪇";
var lnE = "≨";
var lneq = "⪇";
var lneqq = "≨";
var lnsim = "⋦";
var loang = "⟬";
var loarr = "⇽";
var lobrk = "⟦";
var longleftarrow = "⟵";
var LongLeftArrow = "⟵";
var Longleftarrow = "⟸";
var longleftrightarrow = "⟷";
var LongLeftRightArrow = "⟷";
var Longleftrightarrow = "⟺";
var longmapsto = "⟼";
var longrightarrow = "⟶";
var LongRightArrow = "⟶";
var Longrightarrow = "⟹";
var looparrowleft = "↫";
var looparrowright = "↬";
var lopar = "⦅";
var Lopf = "𝕃";
var lopf = "𝕝";
var loplus = "⨭";
var lotimes = "⨴";
var lowast = "∗";
var lowbar = "_";
var LowerLeftArrow = "↙";
var LowerRightArrow = "↘";
var loz = "◊";
var lozenge = "◊";
var lozf = "⧫";
var lpar = "(";
var lparlt = "⦓";
var lrarr = "⇆";
var lrcorner = "⌟";
var lrhar = "⇋";
var lrhard = "⥭";
var lrm = "‎";
var lrtri = "⊿";
var lsaquo = "‹";
var lscr = "𝓁";
var Lscr = "ℒ";
var lsh = "↰";
var Lsh = "↰";
var lsim = "≲";
var lsime = "⪍";
var lsimg = "⪏";
var lsqb = "[";
var lsquo = "‘";
var lsquor = "‚";
var Lstrok = "Ł";
var lstrok = "ł";
var ltcc = "⪦";
var ltcir = "⩹";
var lt = "<";
var LT = "<";
var Lt = "≪";
var ltdot = "⋖";
var lthree = "⋋";
var ltimes = "⋉";
var ltlarr = "⥶";
var ltquest = "⩻";
var ltri = "◃";
var ltrie = "⊴";
var ltrif = "◂";
var ltrPar = "⦖";
var lurdshar = "⥊";
var luruhar = "⥦";
var lvertneqq = "≨︀";
var lvnE = "≨︀";
var macr = "¯";
var male = "♂";
var malt = "✠";
var maltese = "✠";
var map$1 = "↦";
var mapsto = "↦";
var mapstodown = "↧";
var mapstoleft = "↤";
var mapstoup = "↥";
var marker = "▮";
var mcomma = "⨩";
var Mcy = "М";
var mcy = "м";
var mdash = "—";
var mDDot = "∺";
var measuredangle = "∡";
var MediumSpace = " ";
var Mellintrf = "ℳ";
var Mfr = "𝔐";
var mfr = "𝔪";
var mho = "℧";
var micro = "µ";
var midast = "*";
var midcir = "⫰";
var mid = "∣";
var middot = "·";
var minusb = "⊟";
var minus = "−";
var minusd = "∸";
var minusdu = "⨪";
var MinusPlus = "∓";
var mlcp = "⫛";
var mldr = "…";
var mnplus = "∓";
var models = "⊧";
var Mopf = "𝕄";
var mopf = "𝕞";
var mp = "∓";
var mscr = "𝓂";
var Mscr = "ℳ";
var mstpos = "∾";
var Mu = "Μ";
var mu = "μ";
var multimap = "⊸";
var mumap = "⊸";
var nabla = "∇";
var Nacute = "Ń";
var nacute = "ń";
var nang = "∠⃒";
var nap = "≉";
var napE = "⩰̸";
var napid = "≋̸";
var napos = "ŉ";
var napprox = "≉";
var natural = "♮";
var naturals = "ℕ";
var natur = "♮";
var nbsp = " ";
var nbump = "≎̸";
var nbumpe = "≏̸";
var ncap = "⩃";
var Ncaron = "Ň";
var ncaron = "ň";
var Ncedil = "Ņ";
var ncedil = "ņ";
var ncong = "≇";
var ncongdot = "⩭̸";
var ncup = "⩂";
var Ncy = "Н";
var ncy = "н";
var ndash = "–";
var nearhk = "⤤";
var nearr = "↗";
var neArr = "⇗";
var nearrow = "↗";
var ne = "≠";
var nedot = "≐̸";
var NegativeMediumSpace = "​";
var NegativeThickSpace = "​";
var NegativeThinSpace = "​";
var NegativeVeryThinSpace = "​";
var nequiv = "≢";
var nesear = "⤨";
var nesim = "≂̸";
var NestedGreaterGreater = "≫";
var NestedLessLess = "≪";
var NewLine = "\n";
var nexist = "∄";
var nexists = "∄";
var Nfr = "𝔑";
var nfr = "𝔫";
var ngE = "≧̸";
var nge = "≱";
var ngeq = "≱";
var ngeqq = "≧̸";
var ngeqslant = "⩾̸";
var nges = "⩾̸";
var nGg = "⋙̸";
var ngsim = "≵";
var nGt = "≫⃒";
var ngt = "≯";
var ngtr = "≯";
var nGtv = "≫̸";
var nharr = "↮";
var nhArr = "⇎";
var nhpar = "⫲";
var ni = "∋";
var nis = "⋼";
var nisd = "⋺";
var niv = "∋";
var NJcy = "Њ";
var njcy = "њ";
var nlarr = "↚";
var nlArr = "⇍";
var nldr = "‥";
var nlE = "≦̸";
var nle = "≰";
var nleftarrow = "↚";
var nLeftarrow = "⇍";
var nleftrightarrow = "↮";
var nLeftrightarrow = "⇎";
var nleq = "≰";
var nleqq = "≦̸";
var nleqslant = "⩽̸";
var nles = "⩽̸";
var nless = "≮";
var nLl = "⋘̸";
var nlsim = "≴";
var nLt = "≪⃒";
var nlt = "≮";
var nltri = "⋪";
var nltrie = "⋬";
var nLtv = "≪̸";
var nmid = "∤";
var NoBreak = "⁠";
var NonBreakingSpace = " ";
var nopf = "𝕟";
var Nopf = "ℕ";
var Not = "⫬";
var not = "¬";
var NotCongruent = "≢";
var NotCupCap = "≭";
var NotDoubleVerticalBar = "∦";
var NotElement = "∉";
var NotEqual = "≠";
var NotEqualTilde = "≂̸";
var NotExists = "∄";
var NotGreater = "≯";
var NotGreaterEqual = "≱";
var NotGreaterFullEqual = "≧̸";
var NotGreaterGreater = "≫̸";
var NotGreaterLess = "≹";
var NotGreaterSlantEqual = "⩾̸";
var NotGreaterTilde = "≵";
var NotHumpDownHump = "≎̸";
var NotHumpEqual = "≏̸";
var notin = "∉";
var notindot = "⋵̸";
var notinE = "⋹̸";
var notinva = "∉";
var notinvb = "⋷";
var notinvc = "⋶";
var NotLeftTriangleBar = "⧏̸";
var NotLeftTriangle = "⋪";
var NotLeftTriangleEqual = "⋬";
var NotLess = "≮";
var NotLessEqual = "≰";
var NotLessGreater = "≸";
var NotLessLess = "≪̸";
var NotLessSlantEqual = "⩽̸";
var NotLessTilde = "≴";
var NotNestedGreaterGreater = "⪢̸";
var NotNestedLessLess = "⪡̸";
var notni = "∌";
var notniva = "∌";
var notnivb = "⋾";
var notnivc = "⋽";
var NotPrecedes = "⊀";
var NotPrecedesEqual = "⪯̸";
var NotPrecedesSlantEqual = "⋠";
var NotReverseElement = "∌";
var NotRightTriangleBar = "⧐̸";
var NotRightTriangle = "⋫";
var NotRightTriangleEqual = "⋭";
var NotSquareSubset = "⊏̸";
var NotSquareSubsetEqual = "⋢";
var NotSquareSuperset = "⊐̸";
var NotSquareSupersetEqual = "⋣";
var NotSubset = "⊂⃒";
var NotSubsetEqual = "⊈";
var NotSucceeds = "⊁";
var NotSucceedsEqual = "⪰̸";
var NotSucceedsSlantEqual = "⋡";
var NotSucceedsTilde = "≿̸";
var NotSuperset = "⊃⃒";
var NotSupersetEqual = "⊉";
var NotTilde = "≁";
var NotTildeEqual = "≄";
var NotTildeFullEqual = "≇";
var NotTildeTilde = "≉";
var NotVerticalBar = "∤";
var nparallel = "∦";
var npar = "∦";
var nparsl = "⫽⃥";
var npart = "∂̸";
var npolint = "⨔";
var npr = "⊀";
var nprcue = "⋠";
var nprec = "⊀";
var npreceq = "⪯̸";
var npre = "⪯̸";
var nrarrc = "⤳̸";
var nrarr = "↛";
var nrArr = "⇏";
var nrarrw = "↝̸";
var nrightarrow = "↛";
var nRightarrow = "⇏";
var nrtri = "⋫";
var nrtrie = "⋭";
var nsc = "⊁";
var nsccue = "⋡";
var nsce = "⪰̸";
var Nscr = "𝒩";
var nscr = "𝓃";
var nshortmid = "∤";
var nshortparallel = "∦";
var nsim = "≁";
var nsime = "≄";
var nsimeq = "≄";
var nsmid = "∤";
var nspar = "∦";
var nsqsube = "⋢";
var nsqsupe = "⋣";
var nsub = "⊄";
var nsubE = "⫅̸";
var nsube = "⊈";
var nsubset = "⊂⃒";
var nsubseteq = "⊈";
var nsubseteqq = "⫅̸";
var nsucc = "⊁";
var nsucceq = "⪰̸";
var nsup = "⊅";
var nsupE = "⫆̸";
var nsupe = "⊉";
var nsupset = "⊃⃒";
var nsupseteq = "⊉";
var nsupseteqq = "⫆̸";
var ntgl = "≹";
var Ntilde = "Ñ";
var ntilde = "ñ";
var ntlg = "≸";
var ntriangleleft = "⋪";
var ntrianglelefteq = "⋬";
var ntriangleright = "⋫";
var ntrianglerighteq = "⋭";
var Nu = "Ν";
var nu = "ν";
var num = "#";
var numero = "№";
var numsp = " ";
var nvap = "≍⃒";
var nvdash = "⊬";
var nvDash = "⊭";
var nVdash = "⊮";
var nVDash = "⊯";
var nvge = "≥⃒";
var nvgt = ">⃒";
var nvHarr = "⤄";
var nvinfin = "⧞";
var nvlArr = "⤂";
var nvle = "≤⃒";
var nvlt = "<⃒";
var nvltrie = "⊴⃒";
var nvrArr = "⤃";
var nvrtrie = "⊵⃒";
var nvsim = "∼⃒";
var nwarhk = "⤣";
var nwarr = "↖";
var nwArr = "⇖";
var nwarrow = "↖";
var nwnear = "⤧";
var Oacute = "Ó";
var oacute = "ó";
var oast = "⊛";
var Ocirc = "Ô";
var ocirc = "ô";
var ocir = "⊚";
var Ocy = "О";
var ocy = "о";
var odash = "⊝";
var Odblac = "Ő";
var odblac = "ő";
var odiv = "⨸";
var odot = "⊙";
var odsold = "⦼";
var OElig = "Œ";
var oelig = "œ";
var ofcir = "⦿";
var Ofr = "𝔒";
var ofr = "𝔬";
var ogon = "˛";
var Ograve = "Ò";
var ograve = "ò";
var ogt = "⧁";
var ohbar = "⦵";
var ohm = "Ω";
var oint = "∮";
var olarr = "↺";
var olcir = "⦾";
var olcross = "⦻";
var oline = "‾";
var olt = "⧀";
var Omacr = "Ō";
var omacr = "ō";
var Omega = "Ω";
var omega = "ω";
var Omicron = "Ο";
var omicron = "ο";
var omid = "⦶";
var ominus = "⊖";
var Oopf = "𝕆";
var oopf = "𝕠";
var opar = "⦷";
var OpenCurlyDoubleQuote = "“";
var OpenCurlyQuote = "‘";
var operp = "⦹";
var oplus = "⊕";
var orarr = "↻";
var Or = "⩔";
var or = "∨";
var ord = "⩝";
var order = "ℴ";
var orderof = "ℴ";
var ordf = "ª";
var ordm = "º";
var origof = "⊶";
var oror = "⩖";
var orslope = "⩗";
var orv = "⩛";
var oS = "Ⓢ";
var Oscr = "𝒪";
var oscr = "ℴ";
var Oslash = "Ø";
var oslash = "ø";
var osol = "⊘";
var Otilde = "Õ";
var otilde = "õ";
var otimesas = "⨶";
var Otimes = "⨷";
var otimes = "⊗";
var Ouml = "Ö";
var ouml = "ö";
var ovbar = "⌽";
var OverBar = "‾";
var OverBrace = "⏞";
var OverBracket = "⎴";
var OverParenthesis = "⏜";
var para = "¶";
var parallel = "∥";
var par = "∥";
var parsim = "⫳";
var parsl = "⫽";
var part = "∂";
var PartialD = "∂";
var Pcy = "П";
var pcy = "п";
var percnt = "%";
var period = ".";
var permil = "‰";
var perp = "⊥";
var pertenk = "‱";
var Pfr = "𝔓";
var pfr = "𝔭";
var Phi = "Φ";
var phi = "φ";
var phiv = "ϕ";
var phmmat = "ℳ";
var phone = "☎";
var Pi = "Π";
var pi = "π";
var pitchfork = "⋔";
var piv = "ϖ";
var planck = "ℏ";
var planckh = "ℎ";
var plankv = "ℏ";
var plusacir = "⨣";
var plusb = "⊞";
var pluscir = "⨢";
var plus = "+";
var plusdo = "∔";
var plusdu = "⨥";
var pluse = "⩲";
var PlusMinus = "±";
var plusmn = "±";
var plussim = "⨦";
var plustwo = "⨧";
var pm = "±";
var Poincareplane = "ℌ";
var pointint = "⨕";
var popf = "𝕡";
var Popf = "ℙ";
var pound = "£";
var prap = "⪷";
var Pr = "⪻";
var pr = "≺";
var prcue = "≼";
var precapprox = "⪷";
var prec = "≺";
var preccurlyeq = "≼";
var Precedes = "≺";
var PrecedesEqual = "⪯";
var PrecedesSlantEqual = "≼";
var PrecedesTilde = "≾";
var preceq = "⪯";
var precnapprox = "⪹";
var precneqq = "⪵";
var precnsim = "⋨";
var pre = "⪯";
var prE = "⪳";
var precsim = "≾";
var prime = "′";
var Prime = "″";
var primes = "ℙ";
var prnap = "⪹";
var prnE = "⪵";
var prnsim = "⋨";
var prod = "∏";
var Product = "∏";
var profalar = "⌮";
var profline = "⌒";
var profsurf = "⌓";
var prop = "∝";
var Proportional = "∝";
var Proportion = "∷";
var propto = "∝";
var prsim = "≾";
var prurel = "⊰";
var Pscr = "𝒫";
var pscr = "𝓅";
var Psi = "Ψ";
var psi = "ψ";
var puncsp = " ";
var Qfr = "𝔔";
var qfr = "𝔮";
var qint = "⨌";
var qopf = "𝕢";
var Qopf = "ℚ";
var qprime = "⁗";
var Qscr = "𝒬";
var qscr = "𝓆";
var quaternions = "ℍ";
var quatint = "⨖";
var quest = "?";
var questeq = "≟";
var quot = "\"";
var QUOT = "\"";
var rAarr = "⇛";
var race = "∽̱";
var Racute = "Ŕ";
var racute = "ŕ";
var radic = "√";
var raemptyv = "⦳";
var rang = "⟩";
var Rang = "⟫";
var rangd = "⦒";
var range = "⦥";
var rangle = "⟩";
var raquo = "»";
var rarrap = "⥵";
var rarrb = "⇥";
var rarrbfs = "⤠";
var rarrc = "⤳";
var rarr = "→";
var Rarr = "↠";
var rArr = "⇒";
var rarrfs = "⤞";
var rarrhk = "↪";
var rarrlp = "↬";
var rarrpl = "⥅";
var rarrsim = "⥴";
var Rarrtl = "⤖";
var rarrtl = "↣";
var rarrw = "↝";
var ratail = "⤚";
var rAtail = "⤜";
var ratio = "∶";
var rationals = "ℚ";
var rbarr = "⤍";
var rBarr = "⤏";
var RBarr = "⤐";
var rbbrk = "❳";
var rbrace = "}";
var rbrack = "]";
var rbrke = "⦌";
var rbrksld = "⦎";
var rbrkslu = "⦐";
var Rcaron = "Ř";
var rcaron = "ř";
var Rcedil = "Ŗ";
var rcedil = "ŗ";
var rceil = "⌉";
var rcub = "}";
var Rcy = "Р";
var rcy = "р";
var rdca = "⤷";
var rdldhar = "⥩";
var rdquo = "”";
var rdquor = "”";
var rdsh = "↳";
var real = "ℜ";
var realine = "ℛ";
var realpart = "ℜ";
var reals = "ℝ";
var Re = "ℜ";
var rect = "▭";
var reg = "®";
var REG = "®";
var ReverseElement = "∋";
var ReverseEquilibrium = "⇋";
var ReverseUpEquilibrium = "⥯";
var rfisht = "⥽";
var rfloor = "⌋";
var rfr = "𝔯";
var Rfr = "ℜ";
var rHar = "⥤";
var rhard = "⇁";
var rharu = "⇀";
var rharul = "⥬";
var Rho = "Ρ";
var rho = "ρ";
var rhov = "ϱ";
var RightAngleBracket = "⟩";
var RightArrowBar = "⇥";
var rightarrow = "→";
var RightArrow = "→";
var Rightarrow = "⇒";
var RightArrowLeftArrow = "⇄";
var rightarrowtail = "↣";
var RightCeiling = "⌉";
var RightDoubleBracket = "⟧";
var RightDownTeeVector = "⥝";
var RightDownVectorBar = "⥕";
var RightDownVector = "⇂";
var RightFloor = "⌋";
var rightharpoondown = "⇁";
var rightharpoonup = "⇀";
var rightleftarrows = "⇄";
var rightleftharpoons = "⇌";
var rightrightarrows = "⇉";
var rightsquigarrow = "↝";
var RightTeeArrow = "↦";
var RightTee = "⊢";
var RightTeeVector = "⥛";
var rightthreetimes = "⋌";
var RightTriangleBar = "⧐";
var RightTriangle = "⊳";
var RightTriangleEqual = "⊵";
var RightUpDownVector = "⥏";
var RightUpTeeVector = "⥜";
var RightUpVectorBar = "⥔";
var RightUpVector = "↾";
var RightVectorBar = "⥓";
var RightVector = "⇀";
var ring = "˚";
var risingdotseq = "≓";
var rlarr = "⇄";
var rlhar = "⇌";
var rlm = "‏";
var rmoustache = "⎱";
var rmoust = "⎱";
var rnmid = "⫮";
var roang = "⟭";
var roarr = "⇾";
var robrk = "⟧";
var ropar = "⦆";
var ropf = "𝕣";
var Ropf = "ℝ";
var roplus = "⨮";
var rotimes = "⨵";
var RoundImplies = "⥰";
var rpar = ")";
var rpargt = "⦔";
var rppolint = "⨒";
var rrarr = "⇉";
var Rrightarrow = "⇛";
var rsaquo = "›";
var rscr = "𝓇";
var Rscr = "ℛ";
var rsh = "↱";
var Rsh = "↱";
var rsqb = "]";
var rsquo = "’";
var rsquor = "’";
var rthree = "⋌";
var rtimes = "⋊";
var rtri = "▹";
var rtrie = "⊵";
var rtrif = "▸";
var rtriltri = "⧎";
var RuleDelayed = "⧴";
var ruluhar = "⥨";
var rx = "℞";
var Sacute = "Ś";
var sacute = "ś";
var sbquo = "‚";
var scap = "⪸";
var Scaron = "Š";
var scaron = "š";
var Sc = "⪼";
var sc = "≻";
var sccue = "≽";
var sce = "⪰";
var scE = "⪴";
var Scedil = "Ş";
var scedil = "ş";
var Scirc = "Ŝ";
var scirc = "ŝ";
var scnap = "⪺";
var scnE = "⪶";
var scnsim = "⋩";
var scpolint = "⨓";
var scsim = "≿";
var Scy = "С";
var scy = "с";
var sdotb = "⊡";
var sdot = "⋅";
var sdote = "⩦";
var searhk = "⤥";
var searr = "↘";
var seArr = "⇘";
var searrow = "↘";
var sect = "§";
var semi = ";";
var seswar = "⤩";
var setminus = "∖";
var setmn = "∖";
var sext = "✶";
var Sfr = "𝔖";
var sfr = "𝔰";
var sfrown = "⌢";
var sharp = "♯";
var SHCHcy = "Щ";
var shchcy = "щ";
var SHcy = "Ш";
var shcy = "ш";
var ShortDownArrow = "↓";
var ShortLeftArrow = "←";
var shortmid = "∣";
var shortparallel = "∥";
var ShortRightArrow = "→";
var ShortUpArrow = "↑";
var shy = "­";
var Sigma = "Σ";
var sigma = "σ";
var sigmaf = "ς";
var sigmav = "ς";
var sim = "∼";
var simdot = "⩪";
var sime = "≃";
var simeq = "≃";
var simg = "⪞";
var simgE = "⪠";
var siml = "⪝";
var simlE = "⪟";
var simne = "≆";
var simplus = "⨤";
var simrarr = "⥲";
var slarr = "←";
var SmallCircle = "∘";
var smallsetminus = "∖";
var smashp = "⨳";
var smeparsl = "⧤";
var smid = "∣";
var smile = "⌣";
var smt = "⪪";
var smte = "⪬";
var smtes = "⪬︀";
var SOFTcy = "Ь";
var softcy = "ь";
var solbar = "⌿";
var solb = "⧄";
var sol = "/";
var Sopf = "𝕊";
var sopf = "𝕤";
var spades = "♠";
var spadesuit = "♠";
var spar = "∥";
var sqcap = "⊓";
var sqcaps = "⊓︀";
var sqcup = "⊔";
var sqcups = "⊔︀";
var Sqrt = "√";
var sqsub = "⊏";
var sqsube = "⊑";
var sqsubset = "⊏";
var sqsubseteq = "⊑";
var sqsup = "⊐";
var sqsupe = "⊒";
var sqsupset = "⊐";
var sqsupseteq = "⊒";
var square = "□";
var Square = "□";
var SquareIntersection = "⊓";
var SquareSubset = "⊏";
var SquareSubsetEqual = "⊑";
var SquareSuperset = "⊐";
var SquareSupersetEqual = "⊒";
var SquareUnion = "⊔";
var squarf = "▪";
var squ = "□";
var squf = "▪";
var srarr = "→";
var Sscr = "𝒮";
var sscr = "𝓈";
var ssetmn = "∖";
var ssmile = "⌣";
var sstarf = "⋆";
var Star = "⋆";
var star = "☆";
var starf = "★";
var straightepsilon = "ϵ";
var straightphi = "ϕ";
var strns = "¯";
var sub = "⊂";
var Sub = "⋐";
var subdot = "⪽";
var subE = "⫅";
var sube = "⊆";
var subedot = "⫃";
var submult = "⫁";
var subnE = "⫋";
var subne = "⊊";
var subplus = "⪿";
var subrarr = "⥹";
var subset = "⊂";
var Subset = "⋐";
var subseteq = "⊆";
var subseteqq = "⫅";
var SubsetEqual = "⊆";
var subsetneq = "⊊";
var subsetneqq = "⫋";
var subsim = "⫇";
var subsub = "⫕";
var subsup = "⫓";
var succapprox = "⪸";
var succ = "≻";
var succcurlyeq = "≽";
var Succeeds = "≻";
var SucceedsEqual = "⪰";
var SucceedsSlantEqual = "≽";
var SucceedsTilde = "≿";
var succeq = "⪰";
var succnapprox = "⪺";
var succneqq = "⪶";
var succnsim = "⋩";
var succsim = "≿";
var SuchThat = "∋";
var sum = "∑";
var Sum = "∑";
var sung = "♪";
var sup1 = "¹";
var sup2 = "²";
var sup3 = "³";
var sup = "⊃";
var Sup = "⋑";
var supdot = "⪾";
var supdsub = "⫘";
var supE = "⫆";
var supe = "⊇";
var supedot = "⫄";
var Superset = "⊃";
var SupersetEqual = "⊇";
var suphsol = "⟉";
var suphsub = "⫗";
var suplarr = "⥻";
var supmult = "⫂";
var supnE = "⫌";
var supne = "⊋";
var supplus = "⫀";
var supset = "⊃";
var Supset = "⋑";
var supseteq = "⊇";
var supseteqq = "⫆";
var supsetneq = "⊋";
var supsetneqq = "⫌";
var supsim = "⫈";
var supsub = "⫔";
var supsup = "⫖";
var swarhk = "⤦";
var swarr = "↙";
var swArr = "⇙";
var swarrow = "↙";
var swnwar = "⤪";
var szlig = "ß";
var Tab = "\t";
var target = "⌖";
var Tau = "Τ";
var tau = "τ";
var tbrk = "⎴";
var Tcaron = "Ť";
var tcaron = "ť";
var Tcedil = "Ţ";
var tcedil = "ţ";
var Tcy = "Т";
var tcy = "т";
var tdot = "⃛";
var telrec = "⌕";
var Tfr = "𝔗";
var tfr = "𝔱";
var there4 = "∴";
var therefore = "∴";
var Therefore = "∴";
var Theta = "Θ";
var theta = "θ";
var thetasym = "ϑ";
var thetav = "ϑ";
var thickapprox = "≈";
var thicksim = "∼";
var ThickSpace = "  ";
var ThinSpace = " ";
var thinsp = " ";
var thkap = "≈";
var thksim = "∼";
var THORN = "Þ";
var thorn = "þ";
var tilde = "˜";
var Tilde = "∼";
var TildeEqual = "≃";
var TildeFullEqual = "≅";
var TildeTilde = "≈";
var timesbar = "⨱";
var timesb = "⊠";
var times = "×";
var timesd = "⨰";
var tint = "∭";
var toea = "⤨";
var topbot = "⌶";
var topcir = "⫱";
var top = "⊤";
var Topf = "𝕋";
var topf = "𝕥";
var topfork = "⫚";
var tosa = "⤩";
var tprime = "‴";
var trade = "™";
var TRADE = "™";
var triangle = "▵";
var triangledown = "▿";
var triangleleft = "◃";
var trianglelefteq = "⊴";
var triangleq = "≜";
var triangleright = "▹";
var trianglerighteq = "⊵";
var tridot = "◬";
var trie = "≜";
var triminus = "⨺";
var TripleDot = "⃛";
var triplus = "⨹";
var trisb = "⧍";
var tritime = "⨻";
var trpezium = "⏢";
var Tscr = "𝒯";
var tscr = "𝓉";
var TScy = "Ц";
var tscy = "ц";
var TSHcy = "Ћ";
var tshcy = "ћ";
var Tstrok = "Ŧ";
var tstrok = "ŧ";
var twixt = "≬";
var twoheadleftarrow = "↞";
var twoheadrightarrow = "↠";
var Uacute = "Ú";
var uacute = "ú";
var uarr = "↑";
var Uarr = "↟";
var uArr = "⇑";
var Uarrocir = "⥉";
var Ubrcy = "Ў";
var ubrcy = "ў";
var Ubreve = "Ŭ";
var ubreve = "ŭ";
var Ucirc = "Û";
var ucirc = "û";
var Ucy = "У";
var ucy = "у";
var udarr = "⇅";
var Udblac = "Ű";
var udblac = "ű";
var udhar = "⥮";
var ufisht = "⥾";
var Ufr = "𝔘";
var ufr = "𝔲";
var Ugrave = "Ù";
var ugrave = "ù";
var uHar = "⥣";
var uharl = "↿";
var uharr = "↾";
var uhblk = "▀";
var ulcorn = "⌜";
var ulcorner = "⌜";
var ulcrop = "⌏";
var ultri = "◸";
var Umacr = "Ū";
var umacr = "ū";
var uml = "¨";
var UnderBar = "_";
var UnderBrace = "⏟";
var UnderBracket = "⎵";
var UnderParenthesis = "⏝";
var Union = "⋃";
var UnionPlus = "⊎";
var Uogon = "Ų";
var uogon = "ų";
var Uopf = "𝕌";
var uopf = "𝕦";
var UpArrowBar = "⤒";
var uparrow = "↑";
var UpArrow = "↑";
var Uparrow = "⇑";
var UpArrowDownArrow = "⇅";
var updownarrow = "↕";
var UpDownArrow = "↕";
var Updownarrow = "⇕";
var UpEquilibrium = "⥮";
var upharpoonleft = "↿";
var upharpoonright = "↾";
var uplus = "⊎";
var UpperLeftArrow = "↖";
var UpperRightArrow = "↗";
var upsi = "υ";
var Upsi = "ϒ";
var upsih = "ϒ";
var Upsilon = "Υ";
var upsilon = "υ";
var UpTeeArrow = "↥";
var UpTee = "⊥";
var upuparrows = "⇈";
var urcorn = "⌝";
var urcorner = "⌝";
var urcrop = "⌎";
var Uring = "Ů";
var uring = "ů";
var urtri = "◹";
var Uscr = "𝒰";
var uscr = "𝓊";
var utdot = "⋰";
var Utilde = "Ũ";
var utilde = "ũ";
var utri = "▵";
var utrif = "▴";
var uuarr = "⇈";
var Uuml = "Ü";
var uuml = "ü";
var uwangle = "⦧";
var vangrt = "⦜";
var varepsilon = "ϵ";
var varkappa = "ϰ";
var varnothing = "∅";
var varphi = "ϕ";
var varpi = "ϖ";
var varpropto = "∝";
var varr = "↕";
var vArr = "⇕";
var varrho = "ϱ";
var varsigma = "ς";
var varsubsetneq = "⊊︀";
var varsubsetneqq = "⫋︀";
var varsupsetneq = "⊋︀";
var varsupsetneqq = "⫌︀";
var vartheta = "ϑ";
var vartriangleleft = "⊲";
var vartriangleright = "⊳";
var vBar = "⫨";
var Vbar = "⫫";
var vBarv = "⫩";
var Vcy = "В";
var vcy = "в";
var vdash = "⊢";
var vDash = "⊨";
var Vdash = "⊩";
var VDash = "⊫";
var Vdashl = "⫦";
var veebar = "⊻";
var vee = "∨";
var Vee = "⋁";
var veeeq = "≚";
var vellip = "⋮";
var verbar = "|";
var Verbar = "‖";
var vert = "|";
var Vert = "‖";
var VerticalBar = "∣";
var VerticalLine = "|";
var VerticalSeparator = "❘";
var VerticalTilde = "≀";
var VeryThinSpace = " ";
var Vfr = "𝔙";
var vfr = "𝔳";
var vltri = "⊲";
var vnsub = "⊂⃒";
var vnsup = "⊃⃒";
var Vopf = "𝕍";
var vopf = "𝕧";
var vprop = "∝";
var vrtri = "⊳";
var Vscr = "𝒱";
var vscr = "𝓋";
var vsubnE = "⫋︀";
var vsubne = "⊊︀";
var vsupnE = "⫌︀";
var vsupne = "⊋︀";
var Vvdash = "⊪";
var vzigzag = "⦚";
var Wcirc = "Ŵ";
var wcirc = "ŵ";
var wedbar = "⩟";
var wedge = "∧";
var Wedge = "⋀";
var wedgeq = "≙";
var weierp = "℘";
var Wfr = "𝔚";
var wfr = "𝔴";
var Wopf = "𝕎";
var wopf = "𝕨";
var wp = "℘";
var wr = "≀";
var wreath = "≀";
var Wscr = "𝒲";
var wscr = "𝓌";
var xcap = "⋂";
var xcirc = "◯";
var xcup = "⋃";
var xdtri = "▽";
var Xfr = "𝔛";
var xfr = "𝔵";
var xharr = "⟷";
var xhArr = "⟺";
var Xi = "Ξ";
var xi = "ξ";
var xlarr = "⟵";
var xlArr = "⟸";
var xmap = "⟼";
var xnis = "⋻";
var xodot = "⨀";
var Xopf = "𝕏";
var xopf = "𝕩";
var xoplus = "⨁";
var xotime = "⨂";
var xrarr = "⟶";
var xrArr = "⟹";
var Xscr = "𝒳";
var xscr = "𝓍";
var xsqcup = "⨆";
var xuplus = "⨄";
var xutri = "△";
var xvee = "⋁";
var xwedge = "⋀";
var Yacute = "Ý";
var yacute = "ý";
var YAcy = "Я";
var yacy = "я";
var Ycirc = "Ŷ";
var ycirc = "ŷ";
var Ycy = "Ы";
var ycy = "ы";
var yen = "¥";
var Yfr = "𝔜";
var yfr = "𝔶";
var YIcy = "Ї";
var yicy = "ї";
var Yopf = "𝕐";
var yopf = "𝕪";
var Yscr = "𝒴";
var yscr = "𝓎";
var YUcy = "Ю";
var yucy = "ю";
var yuml = "ÿ";
var Yuml = "Ÿ";
var Zacute = "Ź";
var zacute = "ź";
var Zcaron = "Ž";
var zcaron = "ž";
var Zcy = "З";
var zcy = "з";
var Zdot = "Ż";
var zdot = "ż";
var zeetrf = "ℨ";
var ZeroWidthSpace = "​";
var Zeta = "Ζ";
var zeta = "ζ";
var zfr = "𝔷";
var Zfr = "ℨ";
var ZHcy = "Ж";
var zhcy = "ж";
var zigrarr = "⇝";
var zopf = "𝕫";
var Zopf = "ℤ";
var Zscr = "𝒵";
var zscr = "𝓏";
var zwj = "‍";
var zwnj = "‌";
const require$$0 = {
	Aacute: Aacute,
	aacute: aacute,
	Abreve: Abreve,
	abreve: abreve,
	ac: ac,
	acd: acd,
	acE: acE,
	Acirc: Acirc,
	acirc: acirc,
	acute: acute,
	Acy: Acy,
	acy: acy,
	AElig: AElig,
	aelig: aelig,
	af: af,
	Afr: Afr,
	afr: afr,
	Agrave: Agrave,
	agrave: agrave,
	alefsym: alefsym,
	aleph: aleph,
	Alpha: Alpha,
	alpha: alpha,
	Amacr: Amacr,
	amacr: amacr,
	amalg: amalg,
	amp: amp,
	AMP: AMP,
	andand: andand,
	And: And,
	and: and,
	andd: andd,
	andslope: andslope,
	andv: andv,
	ang: ang,
	ange: ange,
	angle: angle,
	angmsdaa: angmsdaa,
	angmsdab: angmsdab,
	angmsdac: angmsdac,
	angmsdad: angmsdad,
	angmsdae: angmsdae,
	angmsdaf: angmsdaf,
	angmsdag: angmsdag,
	angmsdah: angmsdah,
	angmsd: angmsd,
	angrt: angrt,
	angrtvb: angrtvb,
	angrtvbd: angrtvbd,
	angsph: angsph,
	angst: angst,
	angzarr: angzarr,
	Aogon: Aogon,
	aogon: aogon,
	Aopf: Aopf,
	aopf: aopf,
	apacir: apacir,
	ap: ap,
	apE: apE,
	ape: ape,
	apid: apid,
	apos: apos,
	ApplyFunction: ApplyFunction,
	approx: approx,
	approxeq: approxeq,
	Aring: Aring,
	aring: aring,
	Ascr: Ascr,
	ascr: ascr,
	Assign: Assign,
	ast: ast,
	asymp: asymp,
	asympeq: asympeq,
	Atilde: Atilde,
	atilde: atilde,
	Auml: Auml,
	auml: auml,
	awconint: awconint,
	awint: awint,
	backcong: backcong,
	backepsilon: backepsilon,
	backprime: backprime,
	backsim: backsim,
	backsimeq: backsimeq,
	Backslash: Backslash,
	Barv: Barv,
	barvee: barvee,
	barwed: barwed,
	Barwed: Barwed,
	barwedge: barwedge,
	bbrk: bbrk,
	bbrktbrk: bbrktbrk,
	bcong: bcong,
	Bcy: Bcy,
	bcy: bcy,
	bdquo: bdquo,
	becaus: becaus,
	because: because,
	Because: Because,
	bemptyv: bemptyv,
	bepsi: bepsi,
	bernou: bernou,
	Bernoullis: Bernoullis,
	Beta: Beta,
	beta: beta,
	beth: beth,
	between: between,
	Bfr: Bfr,
	bfr: bfr,
	bigcap: bigcap,
	bigcirc: bigcirc,
	bigcup: bigcup,
	bigodot: bigodot,
	bigoplus: bigoplus,
	bigotimes: bigotimes,
	bigsqcup: bigsqcup,
	bigstar: bigstar,
	bigtriangledown: bigtriangledown,
	bigtriangleup: bigtriangleup,
	biguplus: biguplus,
	bigvee: bigvee,
	bigwedge: bigwedge,
	bkarow: bkarow,
	blacklozenge: blacklozenge,
	blacksquare: blacksquare,
	blacktriangle: blacktriangle,
	blacktriangledown: blacktriangledown,
	blacktriangleleft: blacktriangleleft,
	blacktriangleright: blacktriangleright,
	blank: blank,
	blk12: blk12,
	blk14: blk14,
	blk34: blk34,
	block: block$1,
	bne: bne,
	bnequiv: bnequiv,
	bNot: bNot,
	bnot: bnot,
	Bopf: Bopf,
	bopf: bopf,
	bot: bot,
	bottom: bottom,
	bowtie: bowtie,
	boxbox: boxbox,
	boxdl: boxdl,
	boxdL: boxdL,
	boxDl: boxDl,
	boxDL: boxDL,
	boxdr: boxdr,
	boxdR: boxdR,
	boxDr: boxDr,
	boxDR: boxDR,
	boxh: boxh,
	boxH: boxH,
	boxhd: boxhd,
	boxHd: boxHd,
	boxhD: boxhD,
	boxHD: boxHD,
	boxhu: boxhu,
	boxHu: boxHu,
	boxhU: boxhU,
	boxHU: boxHU,
	boxminus: boxminus,
	boxplus: boxplus,
	boxtimes: boxtimes,
	boxul: boxul,
	boxuL: boxuL,
	boxUl: boxUl,
	boxUL: boxUL,
	boxur: boxur,
	boxuR: boxuR,
	boxUr: boxUr,
	boxUR: boxUR,
	boxv: boxv,
	boxV: boxV,
	boxvh: boxvh,
	boxvH: boxvH,
	boxVh: boxVh,
	boxVH: boxVH,
	boxvl: boxvl,
	boxvL: boxvL,
	boxVl: boxVl,
	boxVL: boxVL,
	boxvr: boxvr,
	boxvR: boxvR,
	boxVr: boxVr,
	boxVR: boxVR,
	bprime: bprime,
	breve: breve,
	Breve: Breve,
	brvbar: brvbar,
	bscr: bscr,
	Bscr: Bscr,
	bsemi: bsemi,
	bsim: bsim,
	bsime: bsime,
	bsolb: bsolb,
	bsol: bsol,
	bsolhsub: bsolhsub,
	bull: bull,
	bullet: bullet,
	bump: bump,
	bumpE: bumpE,
	bumpe: bumpe,
	Bumpeq: Bumpeq,
	bumpeq: bumpeq,
	Cacute: Cacute,
	cacute: cacute,
	capand: capand,
	capbrcup: capbrcup,
	capcap: capcap,
	cap: cap,
	Cap: Cap,
	capcup: capcup,
	capdot: capdot,
	CapitalDifferentialD: CapitalDifferentialD,
	caps: caps,
	caret: caret,
	caron: caron,
	Cayleys: Cayleys,
	ccaps: ccaps,
	Ccaron: Ccaron,
	ccaron: ccaron,
	Ccedil: Ccedil,
	ccedil: ccedil,
	Ccirc: Ccirc,
	ccirc: ccirc,
	Cconint: Cconint,
	ccups: ccups,
	ccupssm: ccupssm,
	Cdot: Cdot,
	cdot: cdot,
	cedil: cedil,
	Cedilla: Cedilla,
	cemptyv: cemptyv,
	cent: cent,
	centerdot: centerdot,
	CenterDot: CenterDot,
	cfr: cfr,
	Cfr: Cfr,
	CHcy: CHcy,
	chcy: chcy,
	check: check,
	checkmark: checkmark,
	Chi: Chi,
	chi: chi,
	circ: circ,
	circeq: circeq,
	circlearrowleft: circlearrowleft,
	circlearrowright: circlearrowright,
	circledast: circledast,
	circledcirc: circledcirc,
	circleddash: circleddash,
	CircleDot: CircleDot,
	circledR: circledR,
	circledS: circledS,
	CircleMinus: CircleMinus,
	CirclePlus: CirclePlus,
	CircleTimes: CircleTimes,
	cir: cir,
	cirE: cirE,
	cire: cire,
	cirfnint: cirfnint,
	cirmid: cirmid,
	cirscir: cirscir,
	ClockwiseContourIntegral: ClockwiseContourIntegral,
	CloseCurlyDoubleQuote: CloseCurlyDoubleQuote,
	CloseCurlyQuote: CloseCurlyQuote,
	clubs: clubs,
	clubsuit: clubsuit,
	colon: colon,
	Colon: Colon,
	Colone: Colone,
	colone: colone,
	coloneq: coloneq,
	comma: comma,
	commat: commat,
	comp: comp,
	compfn: compfn,
	complement: complement,
	complexes: complexes,
	cong: cong,
	congdot: congdot,
	Congruent: Congruent,
	conint: conint,
	Conint: Conint,
	ContourIntegral: ContourIntegral,
	copf: copf,
	Copf: Copf,
	coprod: coprod,
	Coproduct: Coproduct,
	copy: copy,
	COPY: COPY,
	copysr: copysr,
	CounterClockwiseContourIntegral: CounterClockwiseContourIntegral,
	crarr: crarr,
	cross: cross,
	Cross: Cross,
	Cscr: Cscr,
	cscr: cscr,
	csub: csub,
	csube: csube,
	csup: csup,
	csupe: csupe,
	ctdot: ctdot,
	cudarrl: cudarrl,
	cudarrr: cudarrr,
	cuepr: cuepr,
	cuesc: cuesc,
	cularr: cularr,
	cularrp: cularrp,
	cupbrcap: cupbrcap,
	cupcap: cupcap,
	CupCap: CupCap,
	cup: cup,
	Cup: Cup,
	cupcup: cupcup,
	cupdot: cupdot,
	cupor: cupor,
	cups: cups,
	curarr: curarr,
	curarrm: curarrm,
	curlyeqprec: curlyeqprec,
	curlyeqsucc: curlyeqsucc,
	curlyvee: curlyvee,
	curlywedge: curlywedge,
	curren: curren,
	curvearrowleft: curvearrowleft,
	curvearrowright: curvearrowright,
	cuvee: cuvee,
	cuwed: cuwed,
	cwconint: cwconint,
	cwint: cwint,
	cylcty: cylcty,
	dagger: dagger,
	Dagger: Dagger,
	daleth: daleth,
	darr: darr,
	Darr: Darr,
	dArr: dArr,
	dash: dash,
	Dashv: Dashv,
	dashv: dashv,
	dbkarow: dbkarow,
	dblac: dblac,
	Dcaron: Dcaron,
	dcaron: dcaron,
	Dcy: Dcy,
	dcy: dcy,
	ddagger: ddagger,
	ddarr: ddarr,
	DD: DD,
	dd: dd,
	DDotrahd: DDotrahd,
	ddotseq: ddotseq,
	deg: deg,
	Del: Del,
	Delta: Delta,
	delta: delta,
	demptyv: demptyv,
	dfisht: dfisht,
	Dfr: Dfr,
	dfr: dfr,
	dHar: dHar,
	dharl: dharl,
	dharr: dharr,
	DiacriticalAcute: DiacriticalAcute,
	DiacriticalDot: DiacriticalDot,
	DiacriticalDoubleAcute: DiacriticalDoubleAcute,
	DiacriticalGrave: DiacriticalGrave,
	DiacriticalTilde: DiacriticalTilde,
	diam: diam,
	diamond: diamond,
	Diamond: Diamond,
	diamondsuit: diamondsuit,
	diams: diams,
	die: die,
	DifferentialD: DifferentialD,
	digamma: digamma,
	disin: disin,
	div: div,
	divide: divide,
	divideontimes: divideontimes,
	divonx: divonx,
	DJcy: DJcy,
	djcy: djcy,
	dlcorn: dlcorn,
	dlcrop: dlcrop,
	dollar: dollar,
	Dopf: Dopf,
	dopf: dopf,
	Dot: Dot,
	dot: dot,
	DotDot: DotDot,
	doteq: doteq,
	doteqdot: doteqdot,
	DotEqual: DotEqual,
	dotminus: dotminus,
	dotplus: dotplus,
	dotsquare: dotsquare,
	doublebarwedge: doublebarwedge,
	DoubleContourIntegral: DoubleContourIntegral,
	DoubleDot: DoubleDot,
	DoubleDownArrow: DoubleDownArrow,
	DoubleLeftArrow: DoubleLeftArrow,
	DoubleLeftRightArrow: DoubleLeftRightArrow,
	DoubleLeftTee: DoubleLeftTee,
	DoubleLongLeftArrow: DoubleLongLeftArrow,
	DoubleLongLeftRightArrow: DoubleLongLeftRightArrow,
	DoubleLongRightArrow: DoubleLongRightArrow,
	DoubleRightArrow: DoubleRightArrow,
	DoubleRightTee: DoubleRightTee,
	DoubleUpArrow: DoubleUpArrow,
	DoubleUpDownArrow: DoubleUpDownArrow,
	DoubleVerticalBar: DoubleVerticalBar,
	DownArrowBar: DownArrowBar,
	downarrow: downarrow,
	DownArrow: DownArrow,
	Downarrow: Downarrow,
	DownArrowUpArrow: DownArrowUpArrow,
	DownBreve: DownBreve,
	downdownarrows: downdownarrows,
	downharpoonleft: downharpoonleft,
	downharpoonright: downharpoonright,
	DownLeftRightVector: DownLeftRightVector,
	DownLeftTeeVector: DownLeftTeeVector,
	DownLeftVectorBar: DownLeftVectorBar,
	DownLeftVector: DownLeftVector,
	DownRightTeeVector: DownRightTeeVector,
	DownRightVectorBar: DownRightVectorBar,
	DownRightVector: DownRightVector,
	DownTeeArrow: DownTeeArrow,
	DownTee: DownTee,
	drbkarow: drbkarow,
	drcorn: drcorn,
	drcrop: drcrop,
	Dscr: Dscr,
	dscr: dscr,
	DScy: DScy,
	dscy: dscy,
	dsol: dsol,
	Dstrok: Dstrok,
	dstrok: dstrok,
	dtdot: dtdot,
	dtri: dtri,
	dtrif: dtrif,
	duarr: duarr,
	duhar: duhar,
	dwangle: dwangle,
	DZcy: DZcy,
	dzcy: dzcy,
	dzigrarr: dzigrarr,
	Eacute: Eacute,
	eacute: eacute,
	easter: easter,
	Ecaron: Ecaron,
	ecaron: ecaron,
	Ecirc: Ecirc,
	ecirc: ecirc,
	ecir: ecir,
	ecolon: ecolon,
	Ecy: Ecy,
	ecy: ecy,
	eDDot: eDDot,
	Edot: Edot,
	edot: edot,
	eDot: eDot,
	ee: ee,
	efDot: efDot,
	Efr: Efr,
	efr: efr,
	eg: eg,
	Egrave: Egrave,
	egrave: egrave,
	egs: egs,
	egsdot: egsdot,
	el: el,
	Element: Element,
	elinters: elinters,
	ell: ell,
	els: els,
	elsdot: elsdot,
	Emacr: Emacr,
	emacr: emacr,
	empty: empty,
	emptyset: emptyset,
	EmptySmallSquare: EmptySmallSquare,
	emptyv: emptyv,
	EmptyVerySmallSquare: EmptyVerySmallSquare,
	emsp13: emsp13,
	emsp14: emsp14,
	emsp: emsp,
	ENG: ENG,
	eng: eng,
	ensp: ensp,
	Eogon: Eogon,
	eogon: eogon,
	Eopf: Eopf,
	eopf: eopf,
	epar: epar,
	eparsl: eparsl,
	eplus: eplus,
	epsi: epsi,
	Epsilon: Epsilon,
	epsilon: epsilon,
	epsiv: epsiv,
	eqcirc: eqcirc,
	eqcolon: eqcolon,
	eqsim: eqsim,
	eqslantgtr: eqslantgtr,
	eqslantless: eqslantless,
	Equal: Equal,
	equals: equals,
	EqualTilde: EqualTilde,
	equest: equest,
	Equilibrium: Equilibrium,
	equiv: equiv,
	equivDD: equivDD,
	eqvparsl: eqvparsl,
	erarr: erarr,
	erDot: erDot,
	escr: escr,
	Escr: Escr,
	esdot: esdot,
	Esim: Esim,
	esim: esim,
	Eta: Eta,
	eta: eta,
	ETH: ETH,
	eth: eth,
	Euml: Euml,
	euml: euml,
	euro: euro,
	excl: excl,
	exist: exist,
	Exists: Exists,
	expectation: expectation,
	exponentiale: exponentiale,
	ExponentialE: ExponentialE,
	fallingdotseq: fallingdotseq,
	Fcy: Fcy,
	fcy: fcy,
	female: female,
	ffilig: ffilig,
	fflig: fflig,
	ffllig: ffllig,
	Ffr: Ffr,
	ffr: ffr,
	filig: filig,
	FilledSmallSquare: FilledSmallSquare,
	FilledVerySmallSquare: FilledVerySmallSquare,
	fjlig: fjlig,
	flat: flat,
	fllig: fllig,
	fltns: fltns,
	fnof: fnof,
	Fopf: Fopf,
	fopf: fopf,
	forall: forall,
	ForAll: ForAll,
	fork: fork,
	forkv: forkv,
	Fouriertrf: Fouriertrf,
	fpartint: fpartint,
	frac12: frac12,
	frac13: frac13,
	frac14: frac14,
	frac15: frac15,
	frac16: frac16,
	frac18: frac18,
	frac23: frac23,
	frac25: frac25,
	frac34: frac34,
	frac35: frac35,
	frac38: frac38,
	frac45: frac45,
	frac56: frac56,
	frac58: frac58,
	frac78: frac78,
	frasl: frasl,
	frown: frown,
	fscr: fscr,
	Fscr: Fscr,
	gacute: gacute,
	Gamma: Gamma,
	gamma: gamma,
	Gammad: Gammad,
	gammad: gammad,
	gap: gap,
	Gbreve: Gbreve,
	gbreve: gbreve,
	Gcedil: Gcedil,
	Gcirc: Gcirc,
	gcirc: gcirc,
	Gcy: Gcy,
	gcy: gcy,
	Gdot: Gdot,
	gdot: gdot,
	ge: ge,
	gE: gE,
	gEl: gEl,
	gel: gel,
	geq: geq,
	geqq: geqq,
	geqslant: geqslant,
	gescc: gescc,
	ges: ges,
	gesdot: gesdot,
	gesdoto: gesdoto,
	gesdotol: gesdotol,
	gesl: gesl,
	gesles: gesles,
	Gfr: Gfr,
	gfr: gfr,
	gg: gg,
	Gg: Gg,
	ggg: ggg,
	gimel: gimel,
	GJcy: GJcy,
	gjcy: gjcy,
	gla: gla,
	gl: gl,
	glE: glE,
	glj: glj,
	gnap: gnap,
	gnapprox: gnapprox,
	gne: gne,
	gnE: gnE,
	gneq: gneq,
	gneqq: gneqq,
	gnsim: gnsim,
	Gopf: Gopf,
	gopf: gopf,
	grave: grave,
	GreaterEqual: GreaterEqual,
	GreaterEqualLess: GreaterEqualLess,
	GreaterFullEqual: GreaterFullEqual,
	GreaterGreater: GreaterGreater,
	GreaterLess: GreaterLess,
	GreaterSlantEqual: GreaterSlantEqual,
	GreaterTilde: GreaterTilde,
	Gscr: Gscr,
	gscr: gscr,
	gsim: gsim,
	gsime: gsime,
	gsiml: gsiml,
	gtcc: gtcc,
	gtcir: gtcir,
	gt: gt,
	GT: GT,
	Gt: Gt,
	gtdot: gtdot,
	gtlPar: gtlPar,
	gtquest: gtquest,
	gtrapprox: gtrapprox,
	gtrarr: gtrarr,
	gtrdot: gtrdot,
	gtreqless: gtreqless,
	gtreqqless: gtreqqless,
	gtrless: gtrless,
	gtrsim: gtrsim,
	gvertneqq: gvertneqq,
	gvnE: gvnE,
	Hacek: Hacek,
	hairsp: hairsp,
	half: half,
	hamilt: hamilt,
	HARDcy: HARDcy,
	hardcy: hardcy,
	harrcir: harrcir,
	harr: harr,
	hArr: hArr,
	harrw: harrw,
	Hat: Hat,
	hbar: hbar,
	Hcirc: Hcirc,
	hcirc: hcirc,
	hearts: hearts,
	heartsuit: heartsuit,
	hellip: hellip,
	hercon: hercon,
	hfr: hfr,
	Hfr: Hfr,
	HilbertSpace: HilbertSpace,
	hksearow: hksearow,
	hkswarow: hkswarow,
	hoarr: hoarr,
	homtht: homtht,
	hookleftarrow: hookleftarrow,
	hookrightarrow: hookrightarrow,
	hopf: hopf,
	Hopf: Hopf,
	horbar: horbar,
	HorizontalLine: HorizontalLine,
	hscr: hscr,
	Hscr: Hscr,
	hslash: hslash,
	Hstrok: Hstrok,
	hstrok: hstrok,
	HumpDownHump: HumpDownHump,
	HumpEqual: HumpEqual,
	hybull: hybull,
	hyphen: hyphen,
	Iacute: Iacute,
	iacute: iacute,
	ic: ic,
	Icirc: Icirc,
	icirc: icirc,
	Icy: Icy,
	icy: icy,
	Idot: Idot,
	IEcy: IEcy,
	iecy: iecy,
	iexcl: iexcl,
	iff: iff,
	ifr: ifr,
	Ifr: Ifr,
	Igrave: Igrave,
	igrave: igrave,
	ii: ii,
	iiiint: iiiint,
	iiint: iiint,
	iinfin: iinfin,
	iiota: iiota,
	IJlig: IJlig,
	ijlig: ijlig,
	Imacr: Imacr,
	imacr: imacr,
	image: image$1,
	ImaginaryI: ImaginaryI,
	imagline: imagline,
	imagpart: imagpart,
	imath: imath,
	Im: Im,
	imof: imof,
	imped: imped,
	Implies: Implies,
	incare: incare,
	"in": "∈",
	infin: infin,
	infintie: infintie,
	inodot: inodot,
	intcal: intcal,
	int: int,
	Int: Int,
	integers: integers,
	Integral: Integral,
	intercal: intercal,
	Intersection: Intersection,
	intlarhk: intlarhk,
	intprod: intprod,
	InvisibleComma: InvisibleComma,
	InvisibleTimes: InvisibleTimes,
	IOcy: IOcy,
	iocy: iocy,
	Iogon: Iogon,
	iogon: iogon,
	Iopf: Iopf,
	iopf: iopf,
	Iota: Iota,
	iota: iota,
	iprod: iprod,
	iquest: iquest,
	iscr: iscr,
	Iscr: Iscr,
	isin: isin,
	isindot: isindot,
	isinE: isinE,
	isins: isins,
	isinsv: isinsv,
	isinv: isinv,
	it: it,
	Itilde: Itilde,
	itilde: itilde,
	Iukcy: Iukcy,
	iukcy: iukcy,
	Iuml: Iuml,
	iuml: iuml,
	Jcirc: Jcirc,
	jcirc: jcirc,
	Jcy: Jcy,
	jcy: jcy,
	Jfr: Jfr,
	jfr: jfr,
	jmath: jmath,
	Jopf: Jopf,
	jopf: jopf,
	Jscr: Jscr,
	jscr: jscr,
	Jsercy: Jsercy,
	jsercy: jsercy,
	Jukcy: Jukcy,
	jukcy: jukcy,
	Kappa: Kappa,
	kappa: kappa,
	kappav: kappav,
	Kcedil: Kcedil,
	kcedil: kcedil,
	Kcy: Kcy,
	kcy: kcy,
	Kfr: Kfr,
	kfr: kfr,
	kgreen: kgreen,
	KHcy: KHcy,
	khcy: khcy,
	KJcy: KJcy,
	kjcy: kjcy,
	Kopf: Kopf,
	kopf: kopf,
	Kscr: Kscr,
	kscr: kscr,
	lAarr: lAarr,
	Lacute: Lacute,
	lacute: lacute,
	laemptyv: laemptyv,
	lagran: lagran,
	Lambda: Lambda,
	lambda: lambda,
	lang: lang,
	Lang: Lang,
	langd: langd,
	langle: langle,
	lap: lap,
	Laplacetrf: Laplacetrf,
	laquo: laquo,
	larrb: larrb,
	larrbfs: larrbfs,
	larr: larr,
	Larr: Larr,
	lArr: lArr,
	larrfs: larrfs,
	larrhk: larrhk,
	larrlp: larrlp,
	larrpl: larrpl,
	larrsim: larrsim,
	larrtl: larrtl,
	latail: latail,
	lAtail: lAtail,
	lat: lat,
	late: late,
	lates: lates,
	lbarr: lbarr,
	lBarr: lBarr,
	lbbrk: lbbrk,
	lbrace: lbrace,
	lbrack: lbrack,
	lbrke: lbrke,
	lbrksld: lbrksld,
	lbrkslu: lbrkslu,
	Lcaron: Lcaron,
	lcaron: lcaron,
	Lcedil: Lcedil,
	lcedil: lcedil,
	lceil: lceil,
	lcub: lcub,
	Lcy: Lcy,
	lcy: lcy,
	ldca: ldca,
	ldquo: ldquo,
	ldquor: ldquor,
	ldrdhar: ldrdhar,
	ldrushar: ldrushar,
	ldsh: ldsh,
	le: le,
	lE: lE,
	LeftAngleBracket: LeftAngleBracket,
	LeftArrowBar: LeftArrowBar,
	leftarrow: leftarrow,
	LeftArrow: LeftArrow,
	Leftarrow: Leftarrow,
	LeftArrowRightArrow: LeftArrowRightArrow,
	leftarrowtail: leftarrowtail,
	LeftCeiling: LeftCeiling,
	LeftDoubleBracket: LeftDoubleBracket,
	LeftDownTeeVector: LeftDownTeeVector,
	LeftDownVectorBar: LeftDownVectorBar,
	LeftDownVector: LeftDownVector,
	LeftFloor: LeftFloor,
	leftharpoondown: leftharpoondown,
	leftharpoonup: leftharpoonup,
	leftleftarrows: leftleftarrows,
	leftrightarrow: leftrightarrow,
	LeftRightArrow: LeftRightArrow,
	Leftrightarrow: Leftrightarrow,
	leftrightarrows: leftrightarrows,
	leftrightharpoons: leftrightharpoons,
	leftrightsquigarrow: leftrightsquigarrow,
	LeftRightVector: LeftRightVector,
	LeftTeeArrow: LeftTeeArrow,
	LeftTee: LeftTee,
	LeftTeeVector: LeftTeeVector,
	leftthreetimes: leftthreetimes,
	LeftTriangleBar: LeftTriangleBar,
	LeftTriangle: LeftTriangle,
	LeftTriangleEqual: LeftTriangleEqual,
	LeftUpDownVector: LeftUpDownVector,
	LeftUpTeeVector: LeftUpTeeVector,
	LeftUpVectorBar: LeftUpVectorBar,
	LeftUpVector: LeftUpVector,
	LeftVectorBar: LeftVectorBar,
	LeftVector: LeftVector,
	lEg: lEg,
	leg: leg,
	leq: leq,
	leqq: leqq,
	leqslant: leqslant,
	lescc: lescc,
	les: les,
	lesdot: lesdot,
	lesdoto: lesdoto,
	lesdotor: lesdotor,
	lesg: lesg,
	lesges: lesges,
	lessapprox: lessapprox,
	lessdot: lessdot,
	lesseqgtr: lesseqgtr,
	lesseqqgtr: lesseqqgtr,
	LessEqualGreater: LessEqualGreater,
	LessFullEqual: LessFullEqual,
	LessGreater: LessGreater,
	lessgtr: lessgtr,
	LessLess: LessLess,
	lesssim: lesssim,
	LessSlantEqual: LessSlantEqual,
	LessTilde: LessTilde,
	lfisht: lfisht,
	lfloor: lfloor,
	Lfr: Lfr,
	lfr: lfr,
	lg: lg,
	lgE: lgE,
	lHar: lHar,
	lhard: lhard,
	lharu: lharu,
	lharul: lharul,
	lhblk: lhblk,
	LJcy: LJcy,
	ljcy: ljcy,
	llarr: llarr,
	ll: ll,
	Ll: Ll,
	llcorner: llcorner,
	Lleftarrow: Lleftarrow,
	llhard: llhard,
	lltri: lltri,
	Lmidot: Lmidot,
	lmidot: lmidot,
	lmoustache: lmoustache,
	lmoust: lmoust,
	lnap: lnap,
	lnapprox: lnapprox,
	lne: lne,
	lnE: lnE,
	lneq: lneq,
	lneqq: lneqq,
	lnsim: lnsim,
	loang: loang,
	loarr: loarr,
	lobrk: lobrk,
	longleftarrow: longleftarrow,
	LongLeftArrow: LongLeftArrow,
	Longleftarrow: Longleftarrow,
	longleftrightarrow: longleftrightarrow,
	LongLeftRightArrow: LongLeftRightArrow,
	Longleftrightarrow: Longleftrightarrow,
	longmapsto: longmapsto,
	longrightarrow: longrightarrow,
	LongRightArrow: LongRightArrow,
	Longrightarrow: Longrightarrow,
	looparrowleft: looparrowleft,
	looparrowright: looparrowright,
	lopar: lopar,
	Lopf: Lopf,
	lopf: lopf,
	loplus: loplus,
	lotimes: lotimes,
	lowast: lowast,
	lowbar: lowbar,
	LowerLeftArrow: LowerLeftArrow,
	LowerRightArrow: LowerRightArrow,
	loz: loz,
	lozenge: lozenge,
	lozf: lozf,
	lpar: lpar,
	lparlt: lparlt,
	lrarr: lrarr,
	lrcorner: lrcorner,
	lrhar: lrhar,
	lrhard: lrhard,
	lrm: lrm,
	lrtri: lrtri,
	lsaquo: lsaquo,
	lscr: lscr,
	Lscr: Lscr,
	lsh: lsh,
	Lsh: Lsh,
	lsim: lsim,
	lsime: lsime,
	lsimg: lsimg,
	lsqb: lsqb,
	lsquo: lsquo,
	lsquor: lsquor,
	Lstrok: Lstrok,
	lstrok: lstrok,
	ltcc: ltcc,
	ltcir: ltcir,
	lt: lt,
	LT: LT,
	Lt: Lt,
	ltdot: ltdot,
	lthree: lthree,
	ltimes: ltimes,
	ltlarr: ltlarr,
	ltquest: ltquest,
	ltri: ltri,
	ltrie: ltrie,
	ltrif: ltrif,
	ltrPar: ltrPar,
	lurdshar: lurdshar,
	luruhar: luruhar,
	lvertneqq: lvertneqq,
	lvnE: lvnE,
	macr: macr,
	male: male,
	malt: malt,
	maltese: maltese,
	"Map": "⤅",
	map: map$1,
	mapsto: mapsto,
	mapstodown: mapstodown,
	mapstoleft: mapstoleft,
	mapstoup: mapstoup,
	marker: marker,
	mcomma: mcomma,
	Mcy: Mcy,
	mcy: mcy,
	mdash: mdash,
	mDDot: mDDot,
	measuredangle: measuredangle,
	MediumSpace: MediumSpace,
	Mellintrf: Mellintrf,
	Mfr: Mfr,
	mfr: mfr,
	mho: mho,
	micro: micro,
	midast: midast,
	midcir: midcir,
	mid: mid,
	middot: middot,
	minusb: minusb,
	minus: minus,
	minusd: minusd,
	minusdu: minusdu,
	MinusPlus: MinusPlus,
	mlcp: mlcp,
	mldr: mldr,
	mnplus: mnplus,
	models: models,
	Mopf: Mopf,
	mopf: mopf,
	mp: mp,
	mscr: mscr,
	Mscr: Mscr,
	mstpos: mstpos,
	Mu: Mu,
	mu: mu,
	multimap: multimap,
	mumap: mumap,
	nabla: nabla,
	Nacute: Nacute,
	nacute: nacute,
	nang: nang,
	nap: nap,
	napE: napE,
	napid: napid,
	napos: napos,
	napprox: napprox,
	natural: natural,
	naturals: naturals,
	natur: natur,
	nbsp: nbsp,
	nbump: nbump,
	nbumpe: nbumpe,
	ncap: ncap,
	Ncaron: Ncaron,
	ncaron: ncaron,
	Ncedil: Ncedil,
	ncedil: ncedil,
	ncong: ncong,
	ncongdot: ncongdot,
	ncup: ncup,
	Ncy: Ncy,
	ncy: ncy,
	ndash: ndash,
	nearhk: nearhk,
	nearr: nearr,
	neArr: neArr,
	nearrow: nearrow,
	ne: ne,
	nedot: nedot,
	NegativeMediumSpace: NegativeMediumSpace,
	NegativeThickSpace: NegativeThickSpace,
	NegativeThinSpace: NegativeThinSpace,
	NegativeVeryThinSpace: NegativeVeryThinSpace,
	nequiv: nequiv,
	nesear: nesear,
	nesim: nesim,
	NestedGreaterGreater: NestedGreaterGreater,
	NestedLessLess: NestedLessLess,
	NewLine: NewLine,
	nexist: nexist,
	nexists: nexists,
	Nfr: Nfr,
	nfr: nfr,
	ngE: ngE,
	nge: nge,
	ngeq: ngeq,
	ngeqq: ngeqq,
	ngeqslant: ngeqslant,
	nges: nges,
	nGg: nGg,
	ngsim: ngsim,
	nGt: nGt,
	ngt: ngt,
	ngtr: ngtr,
	nGtv: nGtv,
	nharr: nharr,
	nhArr: nhArr,
	nhpar: nhpar,
	ni: ni,
	nis: nis,
	nisd: nisd,
	niv: niv,
	NJcy: NJcy,
	njcy: njcy,
	nlarr: nlarr,
	nlArr: nlArr,
	nldr: nldr,
	nlE: nlE,
	nle: nle,
	nleftarrow: nleftarrow,
	nLeftarrow: nLeftarrow,
	nleftrightarrow: nleftrightarrow,
	nLeftrightarrow: nLeftrightarrow,
	nleq: nleq,
	nleqq: nleqq,
	nleqslant: nleqslant,
	nles: nles,
	nless: nless,
	nLl: nLl,
	nlsim: nlsim,
	nLt: nLt,
	nlt: nlt,
	nltri: nltri,
	nltrie: nltrie,
	nLtv: nLtv,
	nmid: nmid,
	NoBreak: NoBreak,
	NonBreakingSpace: NonBreakingSpace,
	nopf: nopf,
	Nopf: Nopf,
	Not: Not,
	not: not,
	NotCongruent: NotCongruent,
	NotCupCap: NotCupCap,
	NotDoubleVerticalBar: NotDoubleVerticalBar,
	NotElement: NotElement,
	NotEqual: NotEqual,
	NotEqualTilde: NotEqualTilde,
	NotExists: NotExists,
	NotGreater: NotGreater,
	NotGreaterEqual: NotGreaterEqual,
	NotGreaterFullEqual: NotGreaterFullEqual,
	NotGreaterGreater: NotGreaterGreater,
	NotGreaterLess: NotGreaterLess,
	NotGreaterSlantEqual: NotGreaterSlantEqual,
	NotGreaterTilde: NotGreaterTilde,
	NotHumpDownHump: NotHumpDownHump,
	NotHumpEqual: NotHumpEqual,
	notin: notin,
	notindot: notindot,
	notinE: notinE,
	notinva: notinva,
	notinvb: notinvb,
	notinvc: notinvc,
	NotLeftTriangleBar: NotLeftTriangleBar,
	NotLeftTriangle: NotLeftTriangle,
	NotLeftTriangleEqual: NotLeftTriangleEqual,
	NotLess: NotLess,
	NotLessEqual: NotLessEqual,
	NotLessGreater: NotLessGreater,
	NotLessLess: NotLessLess,
	NotLessSlantEqual: NotLessSlantEqual,
	NotLessTilde: NotLessTilde,
	NotNestedGreaterGreater: NotNestedGreaterGreater,
	NotNestedLessLess: NotNestedLessLess,
	notni: notni,
	notniva: notniva,
	notnivb: notnivb,
	notnivc: notnivc,
	NotPrecedes: NotPrecedes,
	NotPrecedesEqual: NotPrecedesEqual,
	NotPrecedesSlantEqual: NotPrecedesSlantEqual,
	NotReverseElement: NotReverseElement,
	NotRightTriangleBar: NotRightTriangleBar,
	NotRightTriangle: NotRightTriangle,
	NotRightTriangleEqual: NotRightTriangleEqual,
	NotSquareSubset: NotSquareSubset,
	NotSquareSubsetEqual: NotSquareSubsetEqual,
	NotSquareSuperset: NotSquareSuperset,
	NotSquareSupersetEqual: NotSquareSupersetEqual,
	NotSubset: NotSubset,
	NotSubsetEqual: NotSubsetEqual,
	NotSucceeds: NotSucceeds,
	NotSucceedsEqual: NotSucceedsEqual,
	NotSucceedsSlantEqual: NotSucceedsSlantEqual,
	NotSucceedsTilde: NotSucceedsTilde,
	NotSuperset: NotSuperset,
	NotSupersetEqual: NotSupersetEqual,
	NotTilde: NotTilde,
	NotTildeEqual: NotTildeEqual,
	NotTildeFullEqual: NotTildeFullEqual,
	NotTildeTilde: NotTildeTilde,
	NotVerticalBar: NotVerticalBar,
	nparallel: nparallel,
	npar: npar,
	nparsl: nparsl,
	npart: npart,
	npolint: npolint,
	npr: npr,
	nprcue: nprcue,
	nprec: nprec,
	npreceq: npreceq,
	npre: npre,
	nrarrc: nrarrc,
	nrarr: nrarr,
	nrArr: nrArr,
	nrarrw: nrarrw,
	nrightarrow: nrightarrow,
	nRightarrow: nRightarrow,
	nrtri: nrtri,
	nrtrie: nrtrie,
	nsc: nsc,
	nsccue: nsccue,
	nsce: nsce,
	Nscr: Nscr,
	nscr: nscr,
	nshortmid: nshortmid,
	nshortparallel: nshortparallel,
	nsim: nsim,
	nsime: nsime,
	nsimeq: nsimeq,
	nsmid: nsmid,
	nspar: nspar,
	nsqsube: nsqsube,
	nsqsupe: nsqsupe,
	nsub: nsub,
	nsubE: nsubE,
	nsube: nsube,
	nsubset: nsubset,
	nsubseteq: nsubseteq,
	nsubseteqq: nsubseteqq,
	nsucc: nsucc,
	nsucceq: nsucceq,
	nsup: nsup,
	nsupE: nsupE,
	nsupe: nsupe,
	nsupset: nsupset,
	nsupseteq: nsupseteq,
	nsupseteqq: nsupseteqq,
	ntgl: ntgl,
	Ntilde: Ntilde,
	ntilde: ntilde,
	ntlg: ntlg,
	ntriangleleft: ntriangleleft,
	ntrianglelefteq: ntrianglelefteq,
	ntriangleright: ntriangleright,
	ntrianglerighteq: ntrianglerighteq,
	Nu: Nu,
	nu: nu,
	num: num,
	numero: numero,
	numsp: numsp,
	nvap: nvap,
	nvdash: nvdash,
	nvDash: nvDash,
	nVdash: nVdash,
	nVDash: nVDash,
	nvge: nvge,
	nvgt: nvgt,
	nvHarr: nvHarr,
	nvinfin: nvinfin,
	nvlArr: nvlArr,
	nvle: nvle,
	nvlt: nvlt,
	nvltrie: nvltrie,
	nvrArr: nvrArr,
	nvrtrie: nvrtrie,
	nvsim: nvsim,
	nwarhk: nwarhk,
	nwarr: nwarr,
	nwArr: nwArr,
	nwarrow: nwarrow,
	nwnear: nwnear,
	Oacute: Oacute,
	oacute: oacute,
	oast: oast,
	Ocirc: Ocirc,
	ocirc: ocirc,
	ocir: ocir,
	Ocy: Ocy,
	ocy: ocy,
	odash: odash,
	Odblac: Odblac,
	odblac: odblac,
	odiv: odiv,
	odot: odot,
	odsold: odsold,
	OElig: OElig,
	oelig: oelig,
	ofcir: ofcir,
	Ofr: Ofr,
	ofr: ofr,
	ogon: ogon,
	Ograve: Ograve,
	ograve: ograve,
	ogt: ogt,
	ohbar: ohbar,
	ohm: ohm,
	oint: oint,
	olarr: olarr,
	olcir: olcir,
	olcross: olcross,
	oline: oline,
	olt: olt,
	Omacr: Omacr,
	omacr: omacr,
	Omega: Omega,
	omega: omega,
	Omicron: Omicron,
	omicron: omicron,
	omid: omid,
	ominus: ominus,
	Oopf: Oopf,
	oopf: oopf,
	opar: opar,
	OpenCurlyDoubleQuote: OpenCurlyDoubleQuote,
	OpenCurlyQuote: OpenCurlyQuote,
	operp: operp,
	oplus: oplus,
	orarr: orarr,
	Or: Or,
	or: or,
	ord: ord,
	order: order,
	orderof: orderof,
	ordf: ordf,
	ordm: ordm,
	origof: origof,
	oror: oror,
	orslope: orslope,
	orv: orv,
	oS: oS,
	Oscr: Oscr,
	oscr: oscr,
	Oslash: Oslash,
	oslash: oslash,
	osol: osol,
	Otilde: Otilde,
	otilde: otilde,
	otimesas: otimesas,
	Otimes: Otimes,
	otimes: otimes,
	Ouml: Ouml,
	ouml: ouml,
	ovbar: ovbar,
	OverBar: OverBar,
	OverBrace: OverBrace,
	OverBracket: OverBracket,
	OverParenthesis: OverParenthesis,
	para: para,
	parallel: parallel,
	par: par,
	parsim: parsim,
	parsl: parsl,
	part: part,
	PartialD: PartialD,
	Pcy: Pcy,
	pcy: pcy,
	percnt: percnt,
	period: period,
	permil: permil,
	perp: perp,
	pertenk: pertenk,
	Pfr: Pfr,
	pfr: pfr,
	Phi: Phi,
	phi: phi,
	phiv: phiv,
	phmmat: phmmat,
	phone: phone,
	Pi: Pi,
	pi: pi,
	pitchfork: pitchfork,
	piv: piv,
	planck: planck,
	planckh: planckh,
	plankv: plankv,
	plusacir: plusacir,
	plusb: plusb,
	pluscir: pluscir,
	plus: plus,
	plusdo: plusdo,
	plusdu: plusdu,
	pluse: pluse,
	PlusMinus: PlusMinus,
	plusmn: plusmn,
	plussim: plussim,
	plustwo: plustwo,
	pm: pm,
	Poincareplane: Poincareplane,
	pointint: pointint,
	popf: popf,
	Popf: Popf,
	pound: pound,
	prap: prap,
	Pr: Pr,
	pr: pr,
	prcue: prcue,
	precapprox: precapprox,
	prec: prec,
	preccurlyeq: preccurlyeq,
	Precedes: Precedes,
	PrecedesEqual: PrecedesEqual,
	PrecedesSlantEqual: PrecedesSlantEqual,
	PrecedesTilde: PrecedesTilde,
	preceq: preceq,
	precnapprox: precnapprox,
	precneqq: precneqq,
	precnsim: precnsim,
	pre: pre,
	prE: prE,
	precsim: precsim,
	prime: prime,
	Prime: Prime,
	primes: primes,
	prnap: prnap,
	prnE: prnE,
	prnsim: prnsim,
	prod: prod,
	Product: Product,
	profalar: profalar,
	profline: profline,
	profsurf: profsurf,
	prop: prop,
	Proportional: Proportional,
	Proportion: Proportion,
	propto: propto,
	prsim: prsim,
	prurel: prurel,
	Pscr: Pscr,
	pscr: pscr,
	Psi: Psi,
	psi: psi,
	puncsp: puncsp,
	Qfr: Qfr,
	qfr: qfr,
	qint: qint,
	qopf: qopf,
	Qopf: Qopf,
	qprime: qprime,
	Qscr: Qscr,
	qscr: qscr,
	quaternions: quaternions,
	quatint: quatint,
	quest: quest,
	questeq: questeq,
	quot: quot,
	QUOT: QUOT,
	rAarr: rAarr,
	race: race,
	Racute: Racute,
	racute: racute,
	radic: radic,
	raemptyv: raemptyv,
	rang: rang,
	Rang: Rang,
	rangd: rangd,
	range: range,
	rangle: rangle,
	raquo: raquo,
	rarrap: rarrap,
	rarrb: rarrb,
	rarrbfs: rarrbfs,
	rarrc: rarrc,
	rarr: rarr,
	Rarr: Rarr,
	rArr: rArr,
	rarrfs: rarrfs,
	rarrhk: rarrhk,
	rarrlp: rarrlp,
	rarrpl: rarrpl,
	rarrsim: rarrsim,
	Rarrtl: Rarrtl,
	rarrtl: rarrtl,
	rarrw: rarrw,
	ratail: ratail,
	rAtail: rAtail,
	ratio: ratio,
	rationals: rationals,
	rbarr: rbarr,
	rBarr: rBarr,
	RBarr: RBarr,
	rbbrk: rbbrk,
	rbrace: rbrace,
	rbrack: rbrack,
	rbrke: rbrke,
	rbrksld: rbrksld,
	rbrkslu: rbrkslu,
	Rcaron: Rcaron,
	rcaron: rcaron,
	Rcedil: Rcedil,
	rcedil: rcedil,
	rceil: rceil,
	rcub: rcub,
	Rcy: Rcy,
	rcy: rcy,
	rdca: rdca,
	rdldhar: rdldhar,
	rdquo: rdquo,
	rdquor: rdquor,
	rdsh: rdsh,
	real: real,
	realine: realine,
	realpart: realpart,
	reals: reals,
	Re: Re,
	rect: rect,
	reg: reg,
	REG: REG,
	ReverseElement: ReverseElement,
	ReverseEquilibrium: ReverseEquilibrium,
	ReverseUpEquilibrium: ReverseUpEquilibrium,
	rfisht: rfisht,
	rfloor: rfloor,
	rfr: rfr,
	Rfr: Rfr,
	rHar: rHar,
	rhard: rhard,
	rharu: rharu,
	rharul: rharul,
	Rho: Rho,
	rho: rho,
	rhov: rhov,
	RightAngleBracket: RightAngleBracket,
	RightArrowBar: RightArrowBar,
	rightarrow: rightarrow,
	RightArrow: RightArrow,
	Rightarrow: Rightarrow,
	RightArrowLeftArrow: RightArrowLeftArrow,
	rightarrowtail: rightarrowtail,
	RightCeiling: RightCeiling,
	RightDoubleBracket: RightDoubleBracket,
	RightDownTeeVector: RightDownTeeVector,
	RightDownVectorBar: RightDownVectorBar,
	RightDownVector: RightDownVector,
	RightFloor: RightFloor,
	rightharpoondown: rightharpoondown,
	rightharpoonup: rightharpoonup,
	rightleftarrows: rightleftarrows,
	rightleftharpoons: rightleftharpoons,
	rightrightarrows: rightrightarrows,
	rightsquigarrow: rightsquigarrow,
	RightTeeArrow: RightTeeArrow,
	RightTee: RightTee,
	RightTeeVector: RightTeeVector,
	rightthreetimes: rightthreetimes,
	RightTriangleBar: RightTriangleBar,
	RightTriangle: RightTriangle,
	RightTriangleEqual: RightTriangleEqual,
	RightUpDownVector: RightUpDownVector,
	RightUpTeeVector: RightUpTeeVector,
	RightUpVectorBar: RightUpVectorBar,
	RightUpVector: RightUpVector,
	RightVectorBar: RightVectorBar,
	RightVector: RightVector,
	ring: ring,
	risingdotseq: risingdotseq,
	rlarr: rlarr,
	rlhar: rlhar,
	rlm: rlm,
	rmoustache: rmoustache,
	rmoust: rmoust,
	rnmid: rnmid,
	roang: roang,
	roarr: roarr,
	robrk: robrk,
	ropar: ropar,
	ropf: ropf,
	Ropf: Ropf,
	roplus: roplus,
	rotimes: rotimes,
	RoundImplies: RoundImplies,
	rpar: rpar,
	rpargt: rpargt,
	rppolint: rppolint,
	rrarr: rrarr,
	Rrightarrow: Rrightarrow,
	rsaquo: rsaquo,
	rscr: rscr,
	Rscr: Rscr,
	rsh: rsh,
	Rsh: Rsh,
	rsqb: rsqb,
	rsquo: rsquo,
	rsquor: rsquor,
	rthree: rthree,
	rtimes: rtimes,
	rtri: rtri,
	rtrie: rtrie,
	rtrif: rtrif,
	rtriltri: rtriltri,
	RuleDelayed: RuleDelayed,
	ruluhar: ruluhar,
	rx: rx,
	Sacute: Sacute,
	sacute: sacute,
	sbquo: sbquo,
	scap: scap,
	Scaron: Scaron,
	scaron: scaron,
	Sc: Sc,
	sc: sc,
	sccue: sccue,
	sce: sce,
	scE: scE,
	Scedil: Scedil,
	scedil: scedil,
	Scirc: Scirc,
	scirc: scirc,
	scnap: scnap,
	scnE: scnE,
	scnsim: scnsim,
	scpolint: scpolint,
	scsim: scsim,
	Scy: Scy,
	scy: scy,
	sdotb: sdotb,
	sdot: sdot,
	sdote: sdote,
	searhk: searhk,
	searr: searr,
	seArr: seArr,
	searrow: searrow,
	sect: sect,
	semi: semi,
	seswar: seswar,
	setminus: setminus,
	setmn: setmn,
	sext: sext,
	Sfr: Sfr,
	sfr: sfr,
	sfrown: sfrown,
	sharp: sharp,
	SHCHcy: SHCHcy,
	shchcy: shchcy,
	SHcy: SHcy,
	shcy: shcy,
	ShortDownArrow: ShortDownArrow,
	ShortLeftArrow: ShortLeftArrow,
	shortmid: shortmid,
	shortparallel: shortparallel,
	ShortRightArrow: ShortRightArrow,
	ShortUpArrow: ShortUpArrow,
	shy: shy,
	Sigma: Sigma,
	sigma: sigma,
	sigmaf: sigmaf,
	sigmav: sigmav,
	sim: sim,
	simdot: simdot,
	sime: sime,
	simeq: simeq,
	simg: simg,
	simgE: simgE,
	siml: siml,
	simlE: simlE,
	simne: simne,
	simplus: simplus,
	simrarr: simrarr,
	slarr: slarr,
	SmallCircle: SmallCircle,
	smallsetminus: smallsetminus,
	smashp: smashp,
	smeparsl: smeparsl,
	smid: smid,
	smile: smile,
	smt: smt,
	smte: smte,
	smtes: smtes,
	SOFTcy: SOFTcy,
	softcy: softcy,
	solbar: solbar,
	solb: solb,
	sol: sol,
	Sopf: Sopf,
	sopf: sopf,
	spades: spades,
	spadesuit: spadesuit,
	spar: spar,
	sqcap: sqcap,
	sqcaps: sqcaps,
	sqcup: sqcup,
	sqcups: sqcups,
	Sqrt: Sqrt,
	sqsub: sqsub,
	sqsube: sqsube,
	sqsubset: sqsubset,
	sqsubseteq: sqsubseteq,
	sqsup: sqsup,
	sqsupe: sqsupe,
	sqsupset: sqsupset,
	sqsupseteq: sqsupseteq,
	square: square,
	Square: Square,
	SquareIntersection: SquareIntersection,
	SquareSubset: SquareSubset,
	SquareSubsetEqual: SquareSubsetEqual,
	SquareSuperset: SquareSuperset,
	SquareSupersetEqual: SquareSupersetEqual,
	SquareUnion: SquareUnion,
	squarf: squarf,
	squ: squ,
	squf: squf,
	srarr: srarr,
	Sscr: Sscr,
	sscr: sscr,
	ssetmn: ssetmn,
	ssmile: ssmile,
	sstarf: sstarf,
	Star: Star,
	star: star,
	starf: starf,
	straightepsilon: straightepsilon,
	straightphi: straightphi,
	strns: strns,
	sub: sub,
	Sub: Sub,
	subdot: subdot,
	subE: subE,
	sube: sube,
	subedot: subedot,
	submult: submult,
	subnE: subnE,
	subne: subne,
	subplus: subplus,
	subrarr: subrarr,
	subset: subset,
	Subset: Subset,
	subseteq: subseteq,
	subseteqq: subseteqq,
	SubsetEqual: SubsetEqual,
	subsetneq: subsetneq,
	subsetneqq: subsetneqq,
	subsim: subsim,
	subsub: subsub,
	subsup: subsup,
	succapprox: succapprox,
	succ: succ,
	succcurlyeq: succcurlyeq,
	Succeeds: Succeeds,
	SucceedsEqual: SucceedsEqual,
	SucceedsSlantEqual: SucceedsSlantEqual,
	SucceedsTilde: SucceedsTilde,
	succeq: succeq,
	succnapprox: succnapprox,
	succneqq: succneqq,
	succnsim: succnsim,
	succsim: succsim,
	SuchThat: SuchThat,
	sum: sum,
	Sum: Sum,
	sung: sung,
	sup1: sup1,
	sup2: sup2,
	sup3: sup3,
	sup: sup,
	Sup: Sup,
	supdot: supdot,
	supdsub: supdsub,
	supE: supE,
	supe: supe,
	supedot: supedot,
	Superset: Superset,
	SupersetEqual: SupersetEqual,
	suphsol: suphsol,
	suphsub: suphsub,
	suplarr: suplarr,
	supmult: supmult,
	supnE: supnE,
	supne: supne,
	supplus: supplus,
	supset: supset,
	Supset: Supset,
	supseteq: supseteq,
	supseteqq: supseteqq,
	supsetneq: supsetneq,
	supsetneqq: supsetneqq,
	supsim: supsim,
	supsub: supsub,
	supsup: supsup,
	swarhk: swarhk,
	swarr: swarr,
	swArr: swArr,
	swarrow: swarrow,
	swnwar: swnwar,
	szlig: szlig,
	Tab: Tab,
	target: target,
	Tau: Tau,
	tau: tau,
	tbrk: tbrk,
	Tcaron: Tcaron,
	tcaron: tcaron,
	Tcedil: Tcedil,
	tcedil: tcedil,
	Tcy: Tcy,
	tcy: tcy,
	tdot: tdot,
	telrec: telrec,
	Tfr: Tfr,
	tfr: tfr,
	there4: there4,
	therefore: therefore,
	Therefore: Therefore,
	Theta: Theta,
	theta: theta,
	thetasym: thetasym,
	thetav: thetav,
	thickapprox: thickapprox,
	thicksim: thicksim,
	ThickSpace: ThickSpace,
	ThinSpace: ThinSpace,
	thinsp: thinsp,
	thkap: thkap,
	thksim: thksim,
	THORN: THORN,
	thorn: thorn,
	tilde: tilde,
	Tilde: Tilde,
	TildeEqual: TildeEqual,
	TildeFullEqual: TildeFullEqual,
	TildeTilde: TildeTilde,
	timesbar: timesbar,
	timesb: timesb,
	times: times,
	timesd: timesd,
	tint: tint,
	toea: toea,
	topbot: topbot,
	topcir: topcir,
	top: top,
	Topf: Topf,
	topf: topf,
	topfork: topfork,
	tosa: tosa,
	tprime: tprime,
	trade: trade,
	TRADE: TRADE,
	triangle: triangle,
	triangledown: triangledown,
	triangleleft: triangleleft,
	trianglelefteq: trianglelefteq,
	triangleq: triangleq,
	triangleright: triangleright,
	trianglerighteq: trianglerighteq,
	tridot: tridot,
	trie: trie,
	triminus: triminus,
	TripleDot: TripleDot,
	triplus: triplus,
	trisb: trisb,
	tritime: tritime,
	trpezium: trpezium,
	Tscr: Tscr,
	tscr: tscr,
	TScy: TScy,
	tscy: tscy,
	TSHcy: TSHcy,
	tshcy: tshcy,
	Tstrok: Tstrok,
	tstrok: tstrok,
	twixt: twixt,
	twoheadleftarrow: twoheadleftarrow,
	twoheadrightarrow: twoheadrightarrow,
	Uacute: Uacute,
	uacute: uacute,
	uarr: uarr,
	Uarr: Uarr,
	uArr: uArr,
	Uarrocir: Uarrocir,
	Ubrcy: Ubrcy,
	ubrcy: ubrcy,
	Ubreve: Ubreve,
	ubreve: ubreve,
	Ucirc: Ucirc,
	ucirc: ucirc,
	Ucy: Ucy,
	ucy: ucy,
	udarr: udarr,
	Udblac: Udblac,
	udblac: udblac,
	udhar: udhar,
	ufisht: ufisht,
	Ufr: Ufr,
	ufr: ufr,
	Ugrave: Ugrave,
	ugrave: ugrave,
	uHar: uHar,
	uharl: uharl,
	uharr: uharr,
	uhblk: uhblk,
	ulcorn: ulcorn,
	ulcorner: ulcorner,
	ulcrop: ulcrop,
	ultri: ultri,
	Umacr: Umacr,
	umacr: umacr,
	uml: uml,
	UnderBar: UnderBar,
	UnderBrace: UnderBrace,
	UnderBracket: UnderBracket,
	UnderParenthesis: UnderParenthesis,
	Union: Union,
	UnionPlus: UnionPlus,
	Uogon: Uogon,
	uogon: uogon,
	Uopf: Uopf,
	uopf: uopf,
	UpArrowBar: UpArrowBar,
	uparrow: uparrow,
	UpArrow: UpArrow,
	Uparrow: Uparrow,
	UpArrowDownArrow: UpArrowDownArrow,
	updownarrow: updownarrow,
	UpDownArrow: UpDownArrow,
	Updownarrow: Updownarrow,
	UpEquilibrium: UpEquilibrium,
	upharpoonleft: upharpoonleft,
	upharpoonright: upharpoonright,
	uplus: uplus,
	UpperLeftArrow: UpperLeftArrow,
	UpperRightArrow: UpperRightArrow,
	upsi: upsi,
	Upsi: Upsi,
	upsih: upsih,
	Upsilon: Upsilon,
	upsilon: upsilon,
	UpTeeArrow: UpTeeArrow,
	UpTee: UpTee,
	upuparrows: upuparrows,
	urcorn: urcorn,
	urcorner: urcorner,
	urcrop: urcrop,
	Uring: Uring,
	uring: uring,
	urtri: urtri,
	Uscr: Uscr,
	uscr: uscr,
	utdot: utdot,
	Utilde: Utilde,
	utilde: utilde,
	utri: utri,
	utrif: utrif,
	uuarr: uuarr,
	Uuml: Uuml,
	uuml: uuml,
	uwangle: uwangle,
	vangrt: vangrt,
	varepsilon: varepsilon,
	varkappa: varkappa,
	varnothing: varnothing,
	varphi: varphi,
	varpi: varpi,
	varpropto: varpropto,
	varr: varr,
	vArr: vArr,
	varrho: varrho,
	varsigma: varsigma,
	varsubsetneq: varsubsetneq,
	varsubsetneqq: varsubsetneqq,
	varsupsetneq: varsupsetneq,
	varsupsetneqq: varsupsetneqq,
	vartheta: vartheta,
	vartriangleleft: vartriangleleft,
	vartriangleright: vartriangleright,
	vBar: vBar,
	Vbar: Vbar,
	vBarv: vBarv,
	Vcy: Vcy,
	vcy: vcy,
	vdash: vdash,
	vDash: vDash,
	Vdash: Vdash,
	VDash: VDash,
	Vdashl: Vdashl,
	veebar: veebar,
	vee: vee,
	Vee: Vee,
	veeeq: veeeq,
	vellip: vellip,
	verbar: verbar,
	Verbar: Verbar,
	vert: vert,
	Vert: Vert,
	VerticalBar: VerticalBar,
	VerticalLine: VerticalLine,
	VerticalSeparator: VerticalSeparator,
	VerticalTilde: VerticalTilde,
	VeryThinSpace: VeryThinSpace,
	Vfr: Vfr,
	vfr: vfr,
	vltri: vltri,
	vnsub: vnsub,
	vnsup: vnsup,
	Vopf: Vopf,
	vopf: vopf,
	vprop: vprop,
	vrtri: vrtri,
	Vscr: Vscr,
	vscr: vscr,
	vsubnE: vsubnE,
	vsubne: vsubne,
	vsupnE: vsupnE,
	vsupne: vsupne,
	Vvdash: Vvdash,
	vzigzag: vzigzag,
	Wcirc: Wcirc,
	wcirc: wcirc,
	wedbar: wedbar,
	wedge: wedge,
	Wedge: Wedge,
	wedgeq: wedgeq,
	weierp: weierp,
	Wfr: Wfr,
	wfr: wfr,
	Wopf: Wopf,
	wopf: wopf,
	wp: wp,
	wr: wr,
	wreath: wreath,
	Wscr: Wscr,
	wscr: wscr,
	xcap: xcap,
	xcirc: xcirc,
	xcup: xcup,
	xdtri: xdtri,
	Xfr: Xfr,
	xfr: xfr,
	xharr: xharr,
	xhArr: xhArr,
	Xi: Xi,
	xi: xi,
	xlarr: xlarr,
	xlArr: xlArr,
	xmap: xmap,
	xnis: xnis,
	xodot: xodot,
	Xopf: Xopf,
	xopf: xopf,
	xoplus: xoplus,
	xotime: xotime,
	xrarr: xrarr,
	xrArr: xrArr,
	Xscr: Xscr,
	xscr: xscr,
	xsqcup: xsqcup,
	xuplus: xuplus,
	xutri: xutri,
	xvee: xvee,
	xwedge: xwedge,
	Yacute: Yacute,
	yacute: yacute,
	YAcy: YAcy,
	yacy: yacy,
	Ycirc: Ycirc,
	ycirc: ycirc,
	Ycy: Ycy,
	ycy: ycy,
	yen: yen,
	Yfr: Yfr,
	yfr: yfr,
	YIcy: YIcy,
	yicy: yicy,
	Yopf: Yopf,
	yopf: yopf,
	Yscr: Yscr,
	yscr: yscr,
	YUcy: YUcy,
	yucy: yucy,
	yuml: yuml,
	Yuml: Yuml,
	Zacute: Zacute,
	zacute: zacute,
	Zcaron: Zcaron,
	zcaron: zcaron,
	Zcy: Zcy,
	zcy: zcy,
	Zdot: Zdot,
	zdot: zdot,
	zeetrf: zeetrf,
	ZeroWidthSpace: ZeroWidthSpace,
	Zeta: Zeta,
	zeta: zeta,
	zfr: zfr,
	Zfr: Zfr,
	ZHcy: ZHcy,
	zhcy: zhcy,
	zigrarr: zigrarr,
	zopf: zopf,
	Zopf: Zopf,
	Zscr: Zscr,
	zscr: zscr,
	zwj: zwj,
	zwnj: zwnj
};

/*eslint quotes:0*/
var entities = require$$0;

var regex$4=/[!-#%-\*,-\/:;\?@\[-\]_\{\}\xA1\xA7\xAB\xB6\xB7\xBB\xBF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u09FD\u0A76\u0AF0\u0C84\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166D\u166E\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2010-\u2027\u2030-\u2043\u2045-\u2051\u2053-\u205E\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E4E\u3001-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]|\uD800[\uDD00-\uDD02\uDF9F\uDFD0]|\uD801\uDD6F|\uD802[\uDC57\uDD1F\uDD3F\uDE50-\uDE58\uDE7F\uDEF0-\uDEF6\uDF39-\uDF3F\uDF99-\uDF9C]|\uD803[\uDF55-\uDF59]|\uD804[\uDC47-\uDC4D\uDCBB\uDCBC\uDCBE-\uDCC1\uDD40-\uDD43\uDD74\uDD75\uDDC5-\uDDC8\uDDCD\uDDDB\uDDDD-\uDDDF\uDE38-\uDE3D\uDEA9]|\uD805[\uDC4B-\uDC4F\uDC5B\uDC5D\uDCC6\uDDC1-\uDDD7\uDE41-\uDE43\uDE60-\uDE6C\uDF3C-\uDF3E]|\uD806[\uDC3B\uDE3F-\uDE46\uDE9A-\uDE9C\uDE9E-\uDEA2]|\uD807[\uDC41-\uDC45\uDC70\uDC71\uDEF7\uDEF8]|\uD809[\uDC70-\uDC74]|\uD81A[\uDE6E\uDE6F\uDEF5\uDF37-\uDF3B\uDF44]|\uD81B[\uDE97-\uDE9A]|\uD82F\uDC9F|\uD836[\uDE87-\uDE8B]|\uD83A[\uDD5E\uDD5F]/;

var encodeCache = {};


// Create a lookup array where anything but characters in `chars` string
// and alphanumeric chars is percent-encoded.
//
function getEncodeCache(exclude) {
  var i, ch, cache = encodeCache[exclude];
  if (cache) { return cache; }

  cache = encodeCache[exclude] = [];

  for (i = 0; i < 128; i++) {
    ch = String.fromCharCode(i);

    if (/^[0-9a-z]$/i.test(ch)) {
      // always allow unencoded alphanumeric characters
      cache.push(ch);
    } else {
      cache.push('%' + ('0' + i.toString(16).toUpperCase()).slice(-2));
    }
  }

  for (i = 0; i < exclude.length; i++) {
    cache[exclude.charCodeAt(i)] = exclude[i];
  }

  return cache;
}


// Encode unsafe characters with percent-encoding, skipping already
// encoded sequences.
//
//  - string       - string to encode
//  - exclude      - list of characters to ignore (in addition to a-zA-Z0-9)
//  - keepEscaped  - don't encode '%' in a correct escape sequence (default: true)
//
function encode$2(string, exclude, keepEscaped) {
  var i, l, code, nextCode, cache,
      result = '';

  if (typeof exclude !== 'string') {
    // encode(string, keepEscaped)
    keepEscaped  = exclude;
    exclude = encode$2.defaultChars;
  }

  if (typeof keepEscaped === 'undefined') {
    keepEscaped = true;
  }

  cache = getEncodeCache(exclude);

  for (i = 0, l = string.length; i < l; i++) {
    code = string.charCodeAt(i);

    if (keepEscaped && code === 0x25 /* % */ && i + 2 < l) {
      if (/^[0-9a-f]{2}$/i.test(string.slice(i + 1, i + 3))) {
        result += string.slice(i, i + 3);
        i += 2;
        continue;
      }
    }

    if (code < 128) {
      result += cache[code];
      continue;
    }

    if (code >= 0xD800 && code <= 0xDFFF) {
      if (code >= 0xD800 && code <= 0xDBFF && i + 1 < l) {
        nextCode = string.charCodeAt(i + 1);
        if (nextCode >= 0xDC00 && nextCode <= 0xDFFF) {
          result += encodeURIComponent(string[i] + string[i + 1]);
          i++;
          continue;
        }
      }
      result += '%EF%BF%BD';
      continue;
    }

    result += encodeURIComponent(string[i]);
  }

  return result;
}

encode$2.defaultChars   = ";/?:@&=+$,-_.!~*'()#";
encode$2.componentChars = "-_.!~*'()";


var encode_1 = encode$2;

/* eslint-disable no-bitwise */

var decodeCache = {};

function getDecodeCache(exclude) {
  var i, ch, cache = decodeCache[exclude];
  if (cache) { return cache; }

  cache = decodeCache[exclude] = [];

  for (i = 0; i < 128; i++) {
    ch = String.fromCharCode(i);
    cache.push(ch);
  }

  for (i = 0; i < exclude.length; i++) {
    ch = exclude.charCodeAt(i);
    cache[ch] = '%' + ('0' + ch.toString(16).toUpperCase()).slice(-2);
  }

  return cache;
}


// Decode percent-encoded string.
//
function decode$2(string, exclude) {
  var cache;

  if (typeof exclude !== 'string') {
    exclude = decode$2.defaultChars;
  }

  cache = getDecodeCache(exclude);

  return string.replace(/(%[a-f0-9]{2})+/gi, function(seq) {
    var i, l, b1, b2, b3, b4, chr,
        result = '';

    for (i = 0, l = seq.length; i < l; i += 3) {
      b1 = parseInt(seq.slice(i + 1, i + 3), 16);

      if (b1 < 0x80) {
        result += cache[b1];
        continue;
      }

      if ((b1 & 0xE0) === 0xC0 && (i + 3 < l)) {
        // 110xxxxx 10xxxxxx
        b2 = parseInt(seq.slice(i + 4, i + 6), 16);

        if ((b2 & 0xC0) === 0x80) {
          chr = ((b1 << 6) & 0x7C0) | (b2 & 0x3F);

          if (chr < 0x80) {
            result += '\ufffd\ufffd';
          } else {
            result += String.fromCharCode(chr);
          }

          i += 3;
          continue;
        }
      }

      if ((b1 & 0xF0) === 0xE0 && (i + 6 < l)) {
        // 1110xxxx 10xxxxxx 10xxxxxx
        b2 = parseInt(seq.slice(i + 4, i + 6), 16);
        b3 = parseInt(seq.slice(i + 7, i + 9), 16);

        if ((b2 & 0xC0) === 0x80 && (b3 & 0xC0) === 0x80) {
          chr = ((b1 << 12) & 0xF000) | ((b2 << 6) & 0xFC0) | (b3 & 0x3F);

          if (chr < 0x800 || (chr >= 0xD800 && chr <= 0xDFFF)) {
            result += '\ufffd\ufffd\ufffd';
          } else {
            result += String.fromCharCode(chr);
          }

          i += 6;
          continue;
        }
      }

      if ((b1 & 0xF8) === 0xF0 && (i + 9 < l)) {
        // 111110xx 10xxxxxx 10xxxxxx 10xxxxxx
        b2 = parseInt(seq.slice(i + 4, i + 6), 16);
        b3 = parseInt(seq.slice(i + 7, i + 9), 16);
        b4 = parseInt(seq.slice(i + 10, i + 12), 16);

        if ((b2 & 0xC0) === 0x80 && (b3 & 0xC0) === 0x80 && (b4 & 0xC0) === 0x80) {
          chr = ((b1 << 18) & 0x1C0000) | ((b2 << 12) & 0x3F000) | ((b3 << 6) & 0xFC0) | (b4 & 0x3F);

          if (chr < 0x10000 || chr > 0x10FFFF) {
            result += '\ufffd\ufffd\ufffd\ufffd';
          } else {
            chr -= 0x10000;
            result += String.fromCharCode(0xD800 + (chr >> 10), 0xDC00 + (chr & 0x3FF));
          }

          i += 9;
          continue;
        }
      }

      result += '\ufffd';
    }

    return result;
  });
}


decode$2.defaultChars   = ';/?:@&=+$,#';
decode$2.componentChars = '';


var decode_1 = decode$2;

var format$1 = function format(url) {
  var result = '';

  result += url.protocol || '';
  result += url.slashes ? '//' : '';
  result += url.auth ? url.auth + '@' : '';

  if (url.hostname && url.hostname.indexOf(':') !== -1) {
    // ipv6 address
    result += '[' + url.hostname + ']';
  } else {
    result += url.hostname || '';
  }

  result += url.port ? ':' + url.port : '';
  result += url.pathname || '';
  result += url.search || '';
  result += url.hash || '';

  return result;
};

// Copyright Joyent, Inc. and other Node contributors.

//
// Changes from joyent/node:
//
// 1. No leading slash in paths,
//    e.g. in `url.parse('http://foo?bar')` pathname is ``, not `/`
//
// 2. Backslashes are not replaced with slashes,
//    so `http:\\example.org\` is treated like a relative path
//
// 3. Trailing colon is treated like a part of the path,
//    i.e. in `http://example.org:foo` pathname is `:foo`
//
// 4. Nothing is URL-encoded in the resulting object,
//    (in joyent/node some chars in auth and paths are encoded)
//
// 5. `url.parse()` does not have `parseQueryString` argument
//
// 6. Removed extraneous result properties: `host`, `path`, `query`, etc.,
//    which can be constructed using other parts of the url.
//


function Url() {
  this.protocol = null;
  this.slashes = null;
  this.auth = null;
  this.port = null;
  this.hostname = null;
  this.hash = null;
  this.search = null;
  this.pathname = null;
}

// Reference: RFC 3986, RFC 1808, RFC 2396

// define these here so at least they only have to be
// compiled once on the first module load.
var protocolPattern = /^([a-z0-9.+-]+:)/i,
    portPattern = /:[0-9]*$/,

    // Special case for a simple path URL
    simplePathPattern = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/,

    // RFC 2396: characters reserved for delimiting URLs.
    // We actually just auto-escape these.
    delims = [ '<', '>', '"', '`', ' ', '\r', '\n', '\t' ],

    // RFC 2396: characters not allowed for various reasons.
    unwise = [ '{', '}', '|', '\\', '^', '`' ].concat(delims),

    // Allowed by RFCs, but cause of XSS attacks.  Always escape these.
    autoEscape = [ '\'' ].concat(unwise),
    // Characters that are never ever allowed in a hostname.
    // Note that any invalid chars are also handled, but these
    // are the ones that are *expected* to be seen, so we fast-path
    // them.
    nonHostChars = [ '%', '/', '?', ';', '#' ].concat(autoEscape),
    hostEndingChars = [ '/', '?', '#' ],
    hostnameMaxLen = 255,
    hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/,
    hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/,
    // protocols that can allow "unsafe" and "unwise" chars.
    /* eslint-disable no-script-url */
    // protocols that never have a hostname.
    hostlessProtocol = {
      'javascript': true,
      'javascript:': true
    },
    // protocols that always contain a // bit.
    slashedProtocol = {
      'http': true,
      'https': true,
      'ftp': true,
      'gopher': true,
      'file': true,
      'http:': true,
      'https:': true,
      'ftp:': true,
      'gopher:': true,
      'file:': true
    };
    /* eslint-enable no-script-url */

function urlParse(url, slashesDenoteHost) {
  if (url && url instanceof Url) { return url; }

  var u = new Url();
  u.parse(url, slashesDenoteHost);
  return u;
}

Url.prototype.parse = function(url, slashesDenoteHost) {
  var i, l, lowerProto, hec, slashes,
      rest = url;

  // trim before proceeding.
  // This is to support parse stuff like "  http://foo.com  \n"
  rest = rest.trim();

  if (!slashesDenoteHost && url.split('#').length === 1) {
    // Try fast path regexp
    var simplePath = simplePathPattern.exec(rest);
    if (simplePath) {
      this.pathname = simplePath[1];
      if (simplePath[2]) {
        this.search = simplePath[2];
      }
      return this;
    }
  }

  var proto = protocolPattern.exec(rest);
  if (proto) {
    proto = proto[0];
    lowerProto = proto.toLowerCase();
    this.protocol = proto;
    rest = rest.substr(proto.length);
  }

  // figure out if it's got a host
  // user@server is *always* interpreted as a hostname, and url
  // resolution will treat //foo/bar as host=foo,path=bar because that's
  // how the browser resolves relative URLs.
  if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
    slashes = rest.substr(0, 2) === '//';
    if (slashes && !(proto && hostlessProtocol[proto])) {
      rest = rest.substr(2);
      this.slashes = true;
    }
  }

  if (!hostlessProtocol[proto] &&
      (slashes || (proto && !slashedProtocol[proto]))) {

    // there's a hostname.
    // the first instance of /, ?, ;, or # ends the host.
    //
    // If there is an @ in the hostname, then non-host chars *are* allowed
    // to the left of the last @ sign, unless some host-ending character
    // comes *before* the @-sign.
    // URLs are obnoxious.
    //
    // ex:
    // http://a@b@c/ => user:a@b host:c
    // http://a@b?@c => user:a host:c path:/?@c

    // v0.12 TODO(isaacs): This is not quite how Chrome does things.
    // Review our test case against browsers more comprehensively.

    // find the first instance of any hostEndingChars
    var hostEnd = -1;
    for (i = 0; i < hostEndingChars.length; i++) {
      hec = rest.indexOf(hostEndingChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) {
        hostEnd = hec;
      }
    }

    // at this point, either we have an explicit point where the
    // auth portion cannot go past, or the last @ char is the decider.
    var auth, atSign;
    if (hostEnd === -1) {
      // atSign can be anywhere.
      atSign = rest.lastIndexOf('@');
    } else {
      // atSign must be in auth portion.
      // http://a@b/c@d => host:b auth:a path:/c@d
      atSign = rest.lastIndexOf('@', hostEnd);
    }

    // Now we have a portion which is definitely the auth.
    // Pull that off.
    if (atSign !== -1) {
      auth = rest.slice(0, atSign);
      rest = rest.slice(atSign + 1);
      this.auth = auth;
    }

    // the host is the remaining to the left of the first non-host char
    hostEnd = -1;
    for (i = 0; i < nonHostChars.length; i++) {
      hec = rest.indexOf(nonHostChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) {
        hostEnd = hec;
      }
    }
    // if we still have not hit it, then the entire thing is a host.
    if (hostEnd === -1) {
      hostEnd = rest.length;
    }

    if (rest[hostEnd - 1] === ':') { hostEnd--; }
    var host = rest.slice(0, hostEnd);
    rest = rest.slice(hostEnd);

    // pull out port.
    this.parseHost(host);

    // we've indicated that there is a hostname,
    // so even if it's empty, it has to be present.
    this.hostname = this.hostname || '';

    // if hostname begins with [ and ends with ]
    // assume that it's an IPv6 address.
    var ipv6Hostname = this.hostname[0] === '[' &&
        this.hostname[this.hostname.length - 1] === ']';

    // validate a little.
    if (!ipv6Hostname) {
      var hostparts = this.hostname.split(/\./);
      for (i = 0, l = hostparts.length; i < l; i++) {
        var part = hostparts[i];
        if (!part) { continue; }
        if (!part.match(hostnamePartPattern)) {
          var newpart = '';
          for (var j = 0, k = part.length; j < k; j++) {
            if (part.charCodeAt(j) > 127) {
              // we replace non-ASCII char with a temporary placeholder
              // we need this to make sure size of hostname is not
              // broken by replacing non-ASCII by nothing
              newpart += 'x';
            } else {
              newpart += part[j];
            }
          }
          // we test again with ASCII char only
          if (!newpart.match(hostnamePartPattern)) {
            var validParts = hostparts.slice(0, i);
            var notHost = hostparts.slice(i + 1);
            var bit = part.match(hostnamePartStart);
            if (bit) {
              validParts.push(bit[1]);
              notHost.unshift(bit[2]);
            }
            if (notHost.length) {
              rest = notHost.join('.') + rest;
            }
            this.hostname = validParts.join('.');
            break;
          }
        }
      }
    }

    if (this.hostname.length > hostnameMaxLen) {
      this.hostname = '';
    }

    // strip [ and ] from the hostname
    // the host field still retains them, though
    if (ipv6Hostname) {
      this.hostname = this.hostname.substr(1, this.hostname.length - 2);
    }
  }

  // chop off from the tail first.
  var hash = rest.indexOf('#');
  if (hash !== -1) {
    // got a fragment string.
    this.hash = rest.substr(hash);
    rest = rest.slice(0, hash);
  }
  var qm = rest.indexOf('?');
  if (qm !== -1) {
    this.search = rest.substr(qm);
    rest = rest.slice(0, qm);
  }
  if (rest) { this.pathname = rest; }
  if (slashedProtocol[lowerProto] &&
      this.hostname && !this.pathname) {
    this.pathname = '';
  }

  return this;
};

Url.prototype.parseHost = function(host) {
  var port = portPattern.exec(host);
  if (port) {
    port = port[0];
    if (port !== ':') {
      this.port = port.substr(1);
    }
    host = host.substr(0, host.length - port.length);
  }
  if (host) { this.hostname = host; }
};

var parse$1 = urlParse;

var encode$1 = encode_1;
var decode$1 = decode_1;
var format = format$1;
var parse  = parse$1;

var mdurl = {
	encode: encode$1,
	decode: decode$1,
	format: format,
	parse: parse
};

var regex$3=/[\0-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;

var regex$2=/[\0-\x1F\x7F-\x9F]/;

var regex$1=/[\xAD\u0600-\u0605\u061C\u06DD\u070F\u08E2\u180E\u200B-\u200F\u202A-\u202E\u2060-\u2064\u2066-\u206F\uFEFF\uFFF9-\uFFFB]|\uD804[\uDCBD\uDCCD]|\uD82F[\uDCA0-\uDCA3]|\uD834[\uDD73-\uDD7A]|\uDB40[\uDC01\uDC20-\uDC7F]/;

var regex=/[ \xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000]/;

var Any = regex$3;
var Cc  = regex$2;
var Cf  = regex$1;
var P   = regex$4;
var Z   = regex;

var uc_micro = {
	Any: Any,
	Cc: Cc,
	Cf: Cf,
	P: P,
	Z: Z
};

var utils = createCommonjsModule(function (module, exports) {


function _class(obj) { return Object.prototype.toString.call(obj); }

function isString(obj) { return _class(obj) === '[object String]'; }

var _hasOwnProperty = Object.prototype.hasOwnProperty;

function has(object, key) {
  return _hasOwnProperty.call(object, key);
}

// Merge objects
//
function assign(obj /*from1, from2, from3, ...*/) {
  var sources = Array.prototype.slice.call(arguments, 1);

  sources.forEach(function (source) {
    if (!source) { return; }

    if (typeof source !== 'object') {
      throw new TypeError(source + 'must be object');
    }

    Object.keys(source).forEach(function (key) {
      obj[key] = source[key];
    });
  });

  return obj;
}

// Remove element from array and put another array at those position.
// Useful for some operations with tokens
function arrayReplaceAt(src, pos, newElements) {
  return [].concat(src.slice(0, pos), newElements, src.slice(pos + 1));
}

////////////////////////////////////////////////////////////////////////////////

function isValidEntityCode(c) {
  /*eslint no-bitwise:0*/
  // broken sequence
  if (c >= 0xD800 && c <= 0xDFFF) { return false; }
  // never used
  if (c >= 0xFDD0 && c <= 0xFDEF) { return false; }
  if ((c & 0xFFFF) === 0xFFFF || (c & 0xFFFF) === 0xFFFE) { return false; }
  // control codes
  if (c >= 0x00 && c <= 0x08) { return false; }
  if (c === 0x0B) { return false; }
  if (c >= 0x0E && c <= 0x1F) { return false; }
  if (c >= 0x7F && c <= 0x9F) { return false; }
  // out of range
  if (c > 0x10FFFF) { return false; }
  return true;
}

function fromCodePoint(c) {
  /*eslint no-bitwise:0*/
  if (c > 0xffff) {
    c -= 0x10000;
    var surrogate1 = 0xd800 + (c >> 10),
        surrogate2 = 0xdc00 + (c & 0x3ff);

    return String.fromCharCode(surrogate1, surrogate2);
  }
  return String.fromCharCode(c);
}


var UNESCAPE_MD_RE  = /\\([!"#$%&'()*+,\-.\/:;<=>?@[\\\]^_`{|}~])/g;
var ENTITY_RE       = /&([a-z#][a-z0-9]{1,31});/gi;
var UNESCAPE_ALL_RE = new RegExp(UNESCAPE_MD_RE.source + '|' + ENTITY_RE.source, 'gi');

var DIGITAL_ENTITY_TEST_RE = /^#((?:x[a-f0-9]{1,8}|[0-9]{1,8}))/i;



function replaceEntityPattern(match, name) {
  var code = 0;

  if (has(entities, name)) {
    return entities[name];
  }

  if (name.charCodeAt(0) === 0x23/* # */ && DIGITAL_ENTITY_TEST_RE.test(name)) {
    code = name[1].toLowerCase() === 'x' ?
      parseInt(name.slice(2), 16) : parseInt(name.slice(1), 10);

    if (isValidEntityCode(code)) {
      return fromCodePoint(code);
    }
  }

  return match;
}

/*function replaceEntities(str) {
  if (str.indexOf('&') < 0) { return str; }

  return str.replace(ENTITY_RE, replaceEntityPattern);
}*/

function unescapeMd(str) {
  if (str.indexOf('\\') < 0) { return str; }
  return str.replace(UNESCAPE_MD_RE, '$1');
}

function unescapeAll(str) {
  if (str.indexOf('\\') < 0 && str.indexOf('&') < 0) { return str; }

  return str.replace(UNESCAPE_ALL_RE, function (match, escaped, entity) {
    if (escaped) { return escaped; }
    return replaceEntityPattern(match, entity);
  });
}

////////////////////////////////////////////////////////////////////////////////

var HTML_ESCAPE_TEST_RE = /[&<>"]/;
var HTML_ESCAPE_REPLACE_RE = /[&<>"]/g;
var HTML_REPLACEMENTS = {
  '&': '&amp;',
  '<': '&lt;',
  '>': '&gt;',
  '"': '&quot;'
};

function replaceUnsafeChar(ch) {
  return HTML_REPLACEMENTS[ch];
}

function escapeHtml(str) {
  if (HTML_ESCAPE_TEST_RE.test(str)) {
    return str.replace(HTML_ESCAPE_REPLACE_RE, replaceUnsafeChar);
  }
  return str;
}

////////////////////////////////////////////////////////////////////////////////

var REGEXP_ESCAPE_RE = /[.?*+^$[\]\\(){}|-]/g;

function escapeRE(str) {
  return str.replace(REGEXP_ESCAPE_RE, '\\$&');
}

////////////////////////////////////////////////////////////////////////////////

function isSpace(code) {
  switch (code) {
    case 0x09:
    case 0x20:
      return true;
  }
  return false;
}

// Zs (unicode class) || [\t\f\v\r\n]
function isWhiteSpace(code) {
  if (code >= 0x2000 && code <= 0x200A) { return true; }
  switch (code) {
    case 0x09: // \t
    case 0x0A: // \n
    case 0x0B: // \v
    case 0x0C: // \f
    case 0x0D: // \r
    case 0x20:
    case 0xA0:
    case 0x1680:
    case 0x202F:
    case 0x205F:
    case 0x3000:
      return true;
  }
  return false;
}

////////////////////////////////////////////////////////////////////////////////

/*eslint-disable max-len*/


// Currently without astral characters support.
function isPunctChar(ch) {
  return regex$4.test(ch);
}


// Markdown ASCII punctuation characters.
//
// !, ", #, $, %, &, ', (, ), *, +, ,, -, ., /, :, ;, <, =, >, ?, @, [, \, ], ^, _, `, {, |, }, or ~
// http://spec.commonmark.org/0.15/#ascii-punctuation-character
//
// Don't confuse with unicode punctuation !!! It lacks some chars in ascii range.
//
function isMdAsciiPunct(ch) {
  switch (ch) {
    case 0x21/* ! */:
    case 0x22/* " */:
    case 0x23/* # */:
    case 0x24/* $ */:
    case 0x25/* % */:
    case 0x26/* & */:
    case 0x27/* ' */:
    case 0x28/* ( */:
    case 0x29/* ) */:
    case 0x2A/* * */:
    case 0x2B/* + */:
    case 0x2C/* , */:
    case 0x2D/* - */:
    case 0x2E/* . */:
    case 0x2F/* / */:
    case 0x3A/* : */:
    case 0x3B/* ; */:
    case 0x3C/* < */:
    case 0x3D/* = */:
    case 0x3E/* > */:
    case 0x3F/* ? */:
    case 0x40/* @ */:
    case 0x5B/* [ */:
    case 0x5C/* \ */:
    case 0x5D/* ] */:
    case 0x5E/* ^ */:
    case 0x5F/* _ */:
    case 0x60/* ` */:
    case 0x7B/* { */:
    case 0x7C/* | */:
    case 0x7D/* } */:
    case 0x7E/* ~ */:
      return true;
    default:
      return false;
  }
}

// Hepler to unify [reference labels].
//
function normalizeReference(str) {
  // Trim and collapse whitespace
  //
  str = str.trim().replace(/\s+/g, ' ');

  // In node v10 'ẞ'.toLowerCase() === 'Ṿ', which is presumed to be a bug
  // fixed in v12 (couldn't find any details).
  //
  // So treat this one as a special case
  // (remove this when node v10 is no longer supported).
  //
  if ('ẞ'.toLowerCase() === 'Ṿ') {
    str = str.replace(/ẞ/g, 'ß');
  }

  // .toLowerCase().toUpperCase() should get rid of all differences
  // between letter variants.
  //
  // Simple .toLowerCase() doesn't normalize 125 code points correctly,
  // and .toUpperCase doesn't normalize 6 of them (list of exceptions:
  // İ, ϴ, ẞ, Ω, K, Å - those are already uppercased, but have differently
  // uppercased versions).
  //
  // Here's an example showing how it happens. Lets take greek letter omega:
  // uppercase U+0398 (Θ), U+03f4 (ϴ) and lowercase U+03b8 (θ), U+03d1 (ϑ)
  //
  // Unicode entries:
  // 0398;GREEK CAPITAL LETTER THETA;Lu;0;L;;;;;N;;;;03B8;
  // 03B8;GREEK SMALL LETTER THETA;Ll;0;L;;;;;N;;;0398;;0398
  // 03D1;GREEK THETA SYMBOL;Ll;0;L;<compat> 03B8;;;;N;GREEK SMALL LETTER SCRIPT THETA;;0398;;0398
  // 03F4;GREEK CAPITAL THETA SYMBOL;Lu;0;L;<compat> 0398;;;;N;;;;03B8;
  //
  // Case-insensitive comparison should treat all of them as equivalent.
  //
  // But .toLowerCase() doesn't change ϑ (it's already lowercase),
  // and .toUpperCase() doesn't change ϴ (already uppercase).
  //
  // Applying first lower then upper case normalizes any character:
  // '\u0398\u03f4\u03b8\u03d1'.toLowerCase().toUpperCase() === '\u0398\u0398\u0398\u0398'
  //
  // Note: this is equivalent to unicode case folding; unicode normalization
  // is a different step that is not required here.
  //
  // Final result should be uppercased, because it's later stored in an object
  // (this avoid a conflict with Object.prototype members,
  // most notably, `__proto__`)
  //
  return str.toLowerCase().toUpperCase();
}

////////////////////////////////////////////////////////////////////////////////

// Re-export libraries commonly used in both markdown-it and its plugins,
// so plugins won't have to depend on them explicitly, which reduces their
// bundled size (e.g. a browser build).
//
exports.lib                 = {};
exports.lib.mdurl           = mdurl;
exports.lib.ucmicro         = uc_micro;

exports.assign              = assign;
exports.isString            = isString;
exports.has                 = has;
exports.unescapeMd          = unescapeMd;
exports.unescapeAll         = unescapeAll;
exports.isValidEntityCode   = isValidEntityCode;
exports.fromCodePoint       = fromCodePoint;
// exports.replaceEntities     = replaceEntities;
exports.escapeHtml          = escapeHtml;
exports.arrayReplaceAt      = arrayReplaceAt;
exports.isSpace             = isSpace;
exports.isWhiteSpace        = isWhiteSpace;
exports.isMdAsciiPunct      = isMdAsciiPunct;
exports.isPunctChar         = isPunctChar;
exports.escapeRE            = escapeRE;
exports.normalizeReference  = normalizeReference;
});

// Parse link label

var parse_link_label = function parseLinkLabel(state, start, disableNested) {
  var level, found, marker, prevPos,
      labelEnd = -1,
      max = state.posMax,
      oldPos = state.pos;

  state.pos = start + 1;
  level = 1;

  while (state.pos < max) {
    marker = state.src.charCodeAt(state.pos);
    if (marker === 0x5D /* ] */) {
      level--;
      if (level === 0) {
        found = true;
        break;
      }
    }

    prevPos = state.pos;
    state.md.inline.skipToken(state);
    if (marker === 0x5B /* [ */) {
      if (prevPos === state.pos - 1) {
        // increase level if we find text `[`, which is not a part of any token
        level++;
      } else if (disableNested) {
        state.pos = oldPos;
        return -1;
      }
    }
  }

  if (found) {
    labelEnd = state.pos;
  }

  // restore old state
  state.pos = oldPos;

  return labelEnd;
};

var unescapeAll$2 = utils.unescapeAll;


var parse_link_destination = function parseLinkDestination(str, pos, max) {
  var code, level,
      lines = 0,
      start = pos,
      result = {
        ok: false,
        pos: 0,
        lines: 0,
        str: ''
      };

  if (str.charCodeAt(pos) === 0x3C /* < */) {
    pos++;
    while (pos < max) {
      code = str.charCodeAt(pos);
      if (code === 0x0A /* \n */) { return result; }
      if (code === 0x3C /* < */) { return result; }
      if (code === 0x3E /* > */) {
        result.pos = pos + 1;
        result.str = unescapeAll$2(str.slice(start + 1, pos));
        result.ok = true;
        return result;
      }
      if (code === 0x5C /* \ */ && pos + 1 < max) {
        pos += 2;
        continue;
      }

      pos++;
    }

    // no closing '>'
    return result;
  }

  // this should be ... } else { ... branch

  level = 0;
  while (pos < max) {
    code = str.charCodeAt(pos);

    if (code === 0x20) { break; }

    // ascii control characters
    if (code < 0x20 || code === 0x7F) { break; }

    if (code === 0x5C /* \ */ && pos + 1 < max) {
      if (str.charCodeAt(pos + 1) === 0x20) { break; }
      pos += 2;
      continue;
    }

    if (code === 0x28 /* ( */) {
      level++;
      if (level > 32) { return result; }
    }

    if (code === 0x29 /* ) */) {
      if (level === 0) { break; }
      level--;
    }

    pos++;
  }

  if (start === pos) { return result; }
  if (level !== 0) { return result; }

  result.str = unescapeAll$2(str.slice(start, pos));
  result.lines = lines;
  result.pos = pos;
  result.ok = true;
  return result;
};

var unescapeAll$1 = utils.unescapeAll;


var parse_link_title = function parseLinkTitle(str, pos, max) {
  var code,
      marker,
      lines = 0,
      start = pos,
      result = {
        ok: false,
        pos: 0,
        lines: 0,
        str: ''
      };

  if (pos >= max) { return result; }

  marker = str.charCodeAt(pos);

  if (marker !== 0x22 /* " */ && marker !== 0x27 /* ' */ && marker !== 0x28 /* ( */) { return result; }

  pos++;

  // if opening marker is "(", switch it to closing marker ")"
  if (marker === 0x28) { marker = 0x29; }

  while (pos < max) {
    code = str.charCodeAt(pos);
    if (code === marker) {
      result.pos = pos + 1;
      result.lines = lines;
      result.str = unescapeAll$1(str.slice(start + 1, pos));
      result.ok = true;
      return result;
    } else if (code === 0x28 /* ( */ && marker === 0x29 /* ) */) {
      return result;
    } else if (code === 0x0A) {
      lines++;
    } else if (code === 0x5C /* \ */ && pos + 1 < max) {
      pos++;
      if (str.charCodeAt(pos) === 0x0A) {
        lines++;
      }
    }

    pos++;
  }

  return result;
};

var parseLinkLabel       = parse_link_label;
var parseLinkDestination = parse_link_destination;
var parseLinkTitle       = parse_link_title;

var helpers = {
	parseLinkLabel: parseLinkLabel,
	parseLinkDestination: parseLinkDestination,
	parseLinkTitle: parseLinkTitle
};

/**
 * class Renderer
 *
 * Generates HTML from parsed token stream. Each instance has independent
 * copy of rules. Those can be rewritten with ease. Also, you can add new
 * rules if you create plugin and adds new token types.
 **/


var assign$1          = utils.assign;
var unescapeAll     = utils.unescapeAll;
var escapeHtml      = utils.escapeHtml;


////////////////////////////////////////////////////////////////////////////////

var default_rules = {};


default_rules.code_inline = function (tokens, idx, options, env, slf) {
  var token = tokens[idx];

  return  '<code' + slf.renderAttrs(token) + '>' +
          escapeHtml(tokens[idx].content) +
          '</code>';
};


default_rules.code_block = function (tokens, idx, options, env, slf) {
  var token = tokens[idx];

  return  '<pre' + slf.renderAttrs(token) + '><code>' +
          escapeHtml(tokens[idx].content) +
          '</code></pre>\n';
};


default_rules.fence = function (tokens, idx, options, env, slf) {
  var token = tokens[idx],
      info = token.info ? unescapeAll(token.info).trim() : '',
      langName = '',
      langAttrs = '',
      highlighted, i, arr, tmpAttrs, tmpToken;

  if (info) {
    arr = info.split(/(\s+)/g);
    langName = arr[0];
    langAttrs = arr.slice(2).join('');
  }

  if (options.highlight) {
    highlighted = options.highlight(token.content, langName, langAttrs) || escapeHtml(token.content);
  } else {
    highlighted = escapeHtml(token.content);
  }

  if (highlighted.indexOf('<pre') === 0) {
    return highlighted + '\n';
  }

  // If language exists, inject class gently, without modifying original token.
  // May be, one day we will add .deepClone() for token and simplify this part, but
  // now we prefer to keep things local.
  if (info) {
    i        = token.attrIndex('class');
    tmpAttrs = token.attrs ? token.attrs.slice() : [];

    if (i < 0) {
      tmpAttrs.push([ 'class', options.langPrefix + langName ]);
    } else {
      tmpAttrs[i] = tmpAttrs[i].slice();
      tmpAttrs[i][1] += ' ' + options.langPrefix + langName;
    }

    // Fake token just to render attributes
    tmpToken = {
      attrs: tmpAttrs
    };

    return  '<pre><code' + slf.renderAttrs(tmpToken) + '>'
          + highlighted
          + '</code></pre>\n';
  }


  return  '<pre><code' + slf.renderAttrs(token) + '>'
        + highlighted
        + '</code></pre>\n';
};


default_rules.image = function (tokens, idx, options, env, slf) {
  var token = tokens[idx];

  // "alt" attr MUST be set, even if empty. Because it's mandatory and
  // should be placed on proper position for tests.
  //
  // Replace content with actual value

  token.attrs[token.attrIndex('alt')][1] =
    slf.renderInlineAsText(token.children, options, env);

  return slf.renderToken(tokens, idx, options);
};


default_rules.hardbreak = function (tokens, idx, options /*, env */) {
  return options.xhtmlOut ? '<br />\n' : '<br>\n';
};
default_rules.softbreak = function (tokens, idx, options /*, env */) {
  return options.breaks ? (options.xhtmlOut ? '<br />\n' : '<br>\n') : '\n';
};


default_rules.text = function (tokens, idx /*, options, env */) {
  return escapeHtml(tokens[idx].content);
};


default_rules.html_block = function (tokens, idx /*, options, env */) {
  return tokens[idx].content;
};
default_rules.html_inline = function (tokens, idx /*, options, env */) {
  return tokens[idx].content;
};


/**
 * new Renderer()
 *
 * Creates new [[Renderer]] instance and fill [[Renderer#rules]] with defaults.
 **/
function Renderer() {

  /**
   * Renderer#rules -> Object
   *
   * Contains render rules for tokens. Can be updated and extended.
   *
   * ##### Example
   *
   * ```javascript
   * var md = require('markdown-it')();
   *
   * md.renderer.rules.strong_open  = function () { return '<b>'; };
   * md.renderer.rules.strong_close = function () { return '</b>'; };
   *
   * var result = md.renderInline(...);
   * ```
   *
   * Each rule is called as independent static function with fixed signature:
   *
   * ```javascript
   * function my_token_render(tokens, idx, options, env, renderer) {
   *   // ...
   *   return renderedHTML;
   * }
   * ```
   *
   * See [source code](https://github.com/markdown-it/markdown-it/blob/master/lib/renderer.js)
   * for more details and examples.
   **/
  this.rules = assign$1({}, default_rules);
}


/**
 * Renderer.renderAttrs(token) -> String
 *
 * Render token attributes to string.
 **/
Renderer.prototype.renderAttrs = function renderAttrs(token) {
  var i, l, result;

  if (!token.attrs) { return ''; }

  result = '';

  for (i = 0, l = token.attrs.length; i < l; i++) {
    result += ' ' + escapeHtml(token.attrs[i][0]) + '="' + escapeHtml(token.attrs[i][1]) + '"';
  }

  return result;
};


/**
 * Renderer.renderToken(tokens, idx, options) -> String
 * - tokens (Array): list of tokens
 * - idx (Numbed): token index to render
 * - options (Object): params of parser instance
 *
 * Default token renderer. Can be overriden by custom function
 * in [[Renderer#rules]].
 **/
Renderer.prototype.renderToken = function renderToken(tokens, idx, options) {
  var nextToken,
      result = '',
      needLf = false,
      token = tokens[idx];

  // Tight list paragraphs
  if (token.hidden) {
    return '';
  }

  // Insert a newline between hidden paragraph and subsequent opening
  // block-level tag.
  //
  // For example, here we should insert a newline before blockquote:
  //  - a
  //    >
  //
  if (token.block && token.nesting !== -1 && idx && tokens[idx - 1].hidden) {
    result += '\n';
  }

  // Add token name, e.g. `<img`
  result += (token.nesting === -1 ? '</' : '<') + token.tag;

  // Encode attributes, e.g. `<img src="foo"`
  result += this.renderAttrs(token);

  // Add a slash for self-closing tags, e.g. `<img src="foo" /`
  if (token.nesting === 0 && options.xhtmlOut) {
    result += ' /';
  }

  // Check if we need to add a newline after this tag
  if (token.block) {
    needLf = true;

    if (token.nesting === 1) {
      if (idx + 1 < tokens.length) {
        nextToken = tokens[idx + 1];

        if (nextToken.type === 'inline' || nextToken.hidden) {
          // Block-level tag containing an inline tag.
          //
          needLf = false;

        } else if (nextToken.nesting === -1 && nextToken.tag === token.tag) {
          // Opening tag + closing tag of the same type. E.g. `<li></li>`.
          //
          needLf = false;
        }
      }
    }
  }

  result += needLf ? '>\n' : '>';

  return result;
};


/**
 * Renderer.renderInline(tokens, options, env) -> String
 * - tokens (Array): list on block tokens to renter
 * - options (Object): params of parser instance
 * - env (Object): additional data from parsed input (references, for example)
 *
 * The same as [[Renderer.render]], but for single token of `inline` type.
 **/
Renderer.prototype.renderInline = function (tokens, options, env) {
  var type,
      result = '',
      rules = this.rules;

  for (var i = 0, len = tokens.length; i < len; i++) {
    type = tokens[i].type;

    if (typeof rules[type] !== 'undefined') {
      result += rules[type](tokens, i, options, env, this);
    } else {
      result += this.renderToken(tokens, i, options);
    }
  }

  return result;
};


/** internal
 * Renderer.renderInlineAsText(tokens, options, env) -> String
 * - tokens (Array): list on block tokens to renter
 * - options (Object): params of parser instance
 * - env (Object): additional data from parsed input (references, for example)
 *
 * Special kludge for image `alt` attributes to conform CommonMark spec.
 * Don't try to use it! Spec requires to show `alt` content with stripped markup,
 * instead of simple escaping.
 **/
Renderer.prototype.renderInlineAsText = function (tokens, options, env) {
  var result = '';

  for (var i = 0, len = tokens.length; i < len; i++) {
    if (tokens[i].type === 'text') {
      result += tokens[i].content;
    } else if (tokens[i].type === 'image') {
      result += this.renderInlineAsText(tokens[i].children, options, env);
    }
  }

  return result;
};


/**
 * Renderer.render(tokens, options, env) -> String
 * - tokens (Array): list on block tokens to renter
 * - options (Object): params of parser instance
 * - env (Object): additional data from parsed input (references, for example)
 *
 * Takes token stream and generates HTML. Probably, you will never need to call
 * this method directly.
 **/
Renderer.prototype.render = function (tokens, options, env) {
  var i, len, type,
      result = '',
      rules = this.rules;

  for (i = 0, len = tokens.length; i < len; i++) {
    type = tokens[i].type;

    if (type === 'inline') {
      result += this.renderInline(tokens[i].children, options, env);
    } else if (typeof rules[type] !== 'undefined') {
      result += rules[tokens[i].type](tokens, i, options, env, this);
    } else {
      result += this.renderToken(tokens, i, options, env);
    }
  }

  return result;
};

var renderer = Renderer;

/**
 * class Ruler
 *
 * Helper class, used by [[MarkdownIt#core]], [[MarkdownIt#block]] and
 * [[MarkdownIt#inline]] to manage sequences of functions (rules):
 *
 * - keep rules in defined order
 * - assign the name to each rule
 * - enable/disable rules
 * - add/replace rules
 * - allow assign rules to additional named chains (in the same)
 * - cacheing lists of active rules
 *
 * You will not need use this class directly until write plugins. For simple
 * rules control use [[MarkdownIt.disable]], [[MarkdownIt.enable]] and
 * [[MarkdownIt.use]].
 **/


/**
 * new Ruler()
 **/
function Ruler() {
  // List of added rules. Each element is:
  //
  // {
  //   name: XXX,
  //   enabled: Boolean,
  //   fn: Function(),
  //   alt: [ name2, name3 ]
  // }
  //
  this.__rules__ = [];

  // Cached rule chains.
  //
  // First level - chain name, '' for default.
  // Second level - diginal anchor for fast filtering by charcodes.
  //
  this.__cache__ = null;
}

////////////////////////////////////////////////////////////////////////////////
// Helper methods, should not be used directly


// Find rule index by name
//
Ruler.prototype.__find__ = function (name) {
  for (var i = 0; i < this.__rules__.length; i++) {
    if (this.__rules__[i].name === name) {
      return i;
    }
  }
  return -1;
};


// Build rules lookup cache
//
Ruler.prototype.__compile__ = function () {
  var self = this;
  var chains = [ '' ];

  // collect unique names
  self.__rules__.forEach(function (rule) {
    if (!rule.enabled) { return; }

    rule.alt.forEach(function (altName) {
      if (chains.indexOf(altName) < 0) {
        chains.push(altName);
      }
    });
  });

  self.__cache__ = {};

  chains.forEach(function (chain) {
    self.__cache__[chain] = [];
    self.__rules__.forEach(function (rule) {
      if (!rule.enabled) { return; }

      if (chain && rule.alt.indexOf(chain) < 0) { return; }

      self.__cache__[chain].push(rule.fn);
    });
  });
};


/**
 * Ruler.at(name, fn [, options])
 * - name (String): rule name to replace.
 * - fn (Function): new rule function.
 * - options (Object): new rule options (not mandatory).
 *
 * Replace rule by name with new function & options. Throws error if name not
 * found.
 *
 * ##### Options:
 *
 * - __alt__ - array with names of "alternate" chains.
 *
 * ##### Example
 *
 * Replace existing typographer replacement rule with new one:
 *
 * ```javascript
 * var md = require('markdown-it')();
 *
 * md.core.ruler.at('replacements', function replace(state) {
 *   //...
 * });
 * ```
 **/
Ruler.prototype.at = function (name, fn, options) {
  var index = this.__find__(name);
  var opt = options || {};

  if (index === -1) { throw new Error('Parser rule not found: ' + name); }

  this.__rules__[index].fn = fn;
  this.__rules__[index].alt = opt.alt || [];
  this.__cache__ = null;
};


/**
 * Ruler.before(beforeName, ruleName, fn [, options])
 * - beforeName (String): new rule will be added before this one.
 * - ruleName (String): name of added rule.
 * - fn (Function): rule function.
 * - options (Object): rule options (not mandatory).
 *
 * Add new rule to chain before one with given name. See also
 * [[Ruler.after]], [[Ruler.push]].
 *
 * ##### Options:
 *
 * - __alt__ - array with names of "alternate" chains.
 *
 * ##### Example
 *
 * ```javascript
 * var md = require('markdown-it')();
 *
 * md.block.ruler.before('paragraph', 'my_rule', function replace(state) {
 *   //...
 * });
 * ```
 **/
Ruler.prototype.before = function (beforeName, ruleName, fn, options) {
  var index = this.__find__(beforeName);
  var opt = options || {};

  if (index === -1) { throw new Error('Parser rule not found: ' + beforeName); }

  this.__rules__.splice(index, 0, {
    name: ruleName,
    enabled: true,
    fn: fn,
    alt: opt.alt || []
  });

  this.__cache__ = null;
};


/**
 * Ruler.after(afterName, ruleName, fn [, options])
 * - afterName (String): new rule will be added after this one.
 * - ruleName (String): name of added rule.
 * - fn (Function): rule function.
 * - options (Object): rule options (not mandatory).
 *
 * Add new rule to chain after one with given name. See also
 * [[Ruler.before]], [[Ruler.push]].
 *
 * ##### Options:
 *
 * - __alt__ - array with names of "alternate" chains.
 *
 * ##### Example
 *
 * ```javascript
 * var md = require('markdown-it')();
 *
 * md.inline.ruler.after('text', 'my_rule', function replace(state) {
 *   //...
 * });
 * ```
 **/
Ruler.prototype.after = function (afterName, ruleName, fn, options) {
  var index = this.__find__(afterName);
  var opt = options || {};

  if (index === -1) { throw new Error('Parser rule not found: ' + afterName); }

  this.__rules__.splice(index + 1, 0, {
    name: ruleName,
    enabled: true,
    fn: fn,
    alt: opt.alt || []
  });

  this.__cache__ = null;
};

/**
 * Ruler.push(ruleName, fn [, options])
 * - ruleName (String): name of added rule.
 * - fn (Function): rule function.
 * - options (Object): rule options (not mandatory).
 *
 * Push new rule to the end of chain. See also
 * [[Ruler.before]], [[Ruler.after]].
 *
 * ##### Options:
 *
 * - __alt__ - array with names of "alternate" chains.
 *
 * ##### Example
 *
 * ```javascript
 * var md = require('markdown-it')();
 *
 * md.core.ruler.push('my_rule', function replace(state) {
 *   //...
 * });
 * ```
 **/
Ruler.prototype.push = function (ruleName, fn, options) {
  var opt = options || {};

  this.__rules__.push({
    name: ruleName,
    enabled: true,
    fn: fn,
    alt: opt.alt || []
  });

  this.__cache__ = null;
};


/**
 * Ruler.enable(list [, ignoreInvalid]) -> Array
 * - list (String|Array): list of rule names to enable.
 * - ignoreInvalid (Boolean): set `true` to ignore errors when rule not found.
 *
 * Enable rules with given names. If any rule name not found - throw Error.
 * Errors can be disabled by second param.
 *
 * Returns list of found rule names (if no exception happened).
 *
 * See also [[Ruler.disable]], [[Ruler.enableOnly]].
 **/
Ruler.prototype.enable = function (list, ignoreInvalid) {
  if (!Array.isArray(list)) { list = [ list ]; }

  var result = [];

  // Search by name and enable
  list.forEach(function (name) {
    var idx = this.__find__(name);

    if (idx < 0) {
      if (ignoreInvalid) { return; }
      throw new Error('Rules manager: invalid rule name ' + name);
    }
    this.__rules__[idx].enabled = true;
    result.push(name);
  }, this);

  this.__cache__ = null;
  return result;
};


/**
 * Ruler.enableOnly(list [, ignoreInvalid])
 * - list (String|Array): list of rule names to enable (whitelist).
 * - ignoreInvalid (Boolean): set `true` to ignore errors when rule not found.
 *
 * Enable rules with given names, and disable everything else. If any rule name
 * not found - throw Error. Errors can be disabled by second param.
 *
 * See also [[Ruler.disable]], [[Ruler.enable]].
 **/
Ruler.prototype.enableOnly = function (list, ignoreInvalid) {
  if (!Array.isArray(list)) { list = [ list ]; }

  this.__rules__.forEach(function (rule) { rule.enabled = false; });

  this.enable(list, ignoreInvalid);
};


/**
 * Ruler.disable(list [, ignoreInvalid]) -> Array
 * - list (String|Array): list of rule names to disable.
 * - ignoreInvalid (Boolean): set `true` to ignore errors when rule not found.
 *
 * Disable rules with given names. If any rule name not found - throw Error.
 * Errors can be disabled by second param.
 *
 * Returns list of found rule names (if no exception happened).
 *
 * See also [[Ruler.enable]], [[Ruler.enableOnly]].
 **/
Ruler.prototype.disable = function (list, ignoreInvalid) {
  if (!Array.isArray(list)) { list = [ list ]; }

  var result = [];

  // Search by name and disable
  list.forEach(function (name) {
    var idx = this.__find__(name);

    if (idx < 0) {
      if (ignoreInvalid) { return; }
      throw new Error('Rules manager: invalid rule name ' + name);
    }
    this.__rules__[idx].enabled = false;
    result.push(name);
  }, this);

  this.__cache__ = null;
  return result;
};


/**
 * Ruler.getRules(chainName) -> Array
 *
 * Return array of active functions (rules) for given chain name. It analyzes
 * rules configuration, compiles caches if not exists and returns result.
 *
 * Default chain name is `''` (empty string). It can't be skipped. That's
 * done intentionally, to keep signature monomorphic for high speed.
 **/
Ruler.prototype.getRules = function (chainName) {
  if (this.__cache__ === null) {
    this.__compile__();
  }

  // Chain can be empty, if rules disabled. But we still have to return Array.
  return this.__cache__[chainName] || [];
};

var ruler = Ruler;

// Normalize input string


// https://spec.commonmark.org/0.29/#line-ending
var NEWLINES_RE  = /\r\n?|\n/g;
var NULL_RE      = /\0/g;


var normalize = function normalize(state) {
  var str;

  // Normalize newlines
  str = state.src.replace(NEWLINES_RE, '\n');

  // Replace NULL characters
  str = str.replace(NULL_RE, '\uFFFD');

  state.src = str;
};

var block = function block(state) {
  var token;

  if (state.inlineMode) {
    token          = new state.Token('inline', '', 0);
    token.content  = state.src;
    token.map      = [ 0, 1 ];
    token.children = [];
    state.tokens.push(token);
  } else {
    state.md.block.parse(state.src, state.md, state.env, state.tokens);
  }
};

var inline = function inline(state) {
  var tokens = state.tokens, tok, i, l;

  // Parse inlines
  for (i = 0, l = tokens.length; i < l; i++) {
    tok = tokens[i];
    if (tok.type === 'inline') {
      state.md.inline.parse(tok.content, state.md, state.env, tok.children);
    }
  }
};

var arrayReplaceAt = utils.arrayReplaceAt;


function isLinkOpen(str) {
  return /^<a[>\s]/i.test(str);
}
function isLinkClose(str) {
  return /^<\/a\s*>/i.test(str);
}


var linkify = function linkify(state) {
  var i, j, l, tokens, token, currentToken, nodes, ln, text, pos, lastPos,
      level, htmlLinkLevel, url, fullUrl, urlText,
      blockTokens = state.tokens,
      links;

  if (!state.md.options.linkify) { return; }

  for (j = 0, l = blockTokens.length; j < l; j++) {
    if (blockTokens[j].type !== 'inline' ||
        !state.md.linkify.pretest(blockTokens[j].content)) {
      continue;
    }

    tokens = blockTokens[j].children;

    htmlLinkLevel = 0;

    // We scan from the end, to keep position when new tags added.
    // Use reversed logic in links start/end match
    for (i = tokens.length - 1; i >= 0; i--) {
      currentToken = tokens[i];

      // Skip content of markdown links
      if (currentToken.type === 'link_close') {
        i--;
        while (tokens[i].level !== currentToken.level && tokens[i].type !== 'link_open') {
          i--;
        }
        continue;
      }

      // Skip content of html tag links
      if (currentToken.type === 'html_inline') {
        if (isLinkOpen(currentToken.content) && htmlLinkLevel > 0) {
          htmlLinkLevel--;
        }
        if (isLinkClose(currentToken.content)) {
          htmlLinkLevel++;
        }
      }
      if (htmlLinkLevel > 0) { continue; }

      if (currentToken.type === 'text' && state.md.linkify.test(currentToken.content)) {

        text = currentToken.content;
        links = state.md.linkify.match(text);

        // Now split string to nodes
        nodes = [];
        level = currentToken.level;
        lastPos = 0;

        for (ln = 0; ln < links.length; ln++) {

          url = links[ln].url;
          fullUrl = state.md.normalizeLink(url);
          if (!state.md.validateLink(fullUrl)) { continue; }

          urlText = links[ln].text;

          // Linkifier might send raw hostnames like "example.com", where url
          // starts with domain name. So we prepend http:// in those cases,
          // and remove it afterwards.
          //
          if (!links[ln].schema) {
            urlText = state.md.normalizeLinkText('http://' + urlText).replace(/^http:\/\//, '');
          } else if (links[ln].schema === 'mailto:' && !/^mailto:/i.test(urlText)) {
            urlText = state.md.normalizeLinkText('mailto:' + urlText).replace(/^mailto:/, '');
          } else {
            urlText = state.md.normalizeLinkText(urlText);
          }

          pos = links[ln].index;

          if (pos > lastPos) {
            token         = new state.Token('text', '', 0);
            token.content = text.slice(lastPos, pos);
            token.level   = level;
            nodes.push(token);
          }

          token         = new state.Token('link_open', 'a', 1);
          token.attrs   = [ [ 'href', fullUrl ] ];
          token.level   = level++;
          token.markup  = 'linkify';
          token.info    = 'auto';
          nodes.push(token);

          token         = new state.Token('text', '', 0);
          token.content = urlText;
          token.level   = level;
          nodes.push(token);

          token         = new state.Token('link_close', 'a', -1);
          token.level   = --level;
          token.markup  = 'linkify';
          token.info    = 'auto';
          nodes.push(token);

          lastPos = links[ln].lastIndex;
        }
        if (lastPos < text.length) {
          token         = new state.Token('text', '', 0);
          token.content = text.slice(lastPos);
          token.level   = level;
          nodes.push(token);
        }

        // replace current node
        blockTokens[j].children = tokens = arrayReplaceAt(tokens, i, nodes);
      }
    }
  }
};

// Simple typographic replacements

// TODO:
// - fractionals 1/2, 1/4, 3/4 -> ½, ¼, ¾
// - miltiplication 2 x 4 -> 2 × 4

var RARE_RE = /\+-|\.\.|\?\?\?\?|!!!!|,,|--/;

// Workaround for phantomjs - need regex without /g flag,
// or root check will fail every second time
var SCOPED_ABBR_TEST_RE = /\((c|tm|r|p)\)/i;

var SCOPED_ABBR_RE = /\((c|tm|r|p)\)/ig;
var SCOPED_ABBR = {
  c: '©',
  r: '®',
  p: '§',
  tm: '™'
};

function replaceFn(match, name) {
  return SCOPED_ABBR[name.toLowerCase()];
}

function replace_scoped(inlineTokens) {
  var i, token, inside_autolink = 0;

  for (i = inlineTokens.length - 1; i >= 0; i--) {
    token = inlineTokens[i];

    if (token.type === 'text' && !inside_autolink) {
      token.content = token.content.replace(SCOPED_ABBR_RE, replaceFn);
    }

    if (token.type === 'link_open' && token.info === 'auto') {
      inside_autolink--;
    }

    if (token.type === 'link_close' && token.info === 'auto') {
      inside_autolink++;
    }
  }
}

function replace_rare(inlineTokens) {
  var i, token, inside_autolink = 0;

  for (i = inlineTokens.length - 1; i >= 0; i--) {
    token = inlineTokens[i];

    if (token.type === 'text' && !inside_autolink) {
      if (RARE_RE.test(token.content)) {
        token.content = token.content
          .replace(/\+-/g, '±')
          // .., ..., ....... -> …
          // but ?..... & !..... -> ?.. & !..
          .replace(/\.{2,}/g, '…').replace(/([?!])…/g, '$1..')
          .replace(/([?!]){4,}/g, '$1$1$1').replace(/,{2,}/g, ',')
          // em-dash
          .replace(/(^|[^-])---(?=[^-]|$)/mg, '$1\u2014')
          // en-dash
          .replace(/(^|\s)--(?=\s|$)/mg, '$1\u2013')
          .replace(/(^|[^-\s])--(?=[^-\s]|$)/mg, '$1\u2013');
      }
    }

    if (token.type === 'link_open' && token.info === 'auto') {
      inside_autolink--;
    }

    if (token.type === 'link_close' && token.info === 'auto') {
      inside_autolink++;
    }
  }
}


var replacements = function replace(state) {
  var blkIdx;

  if (!state.md.options.typographer) { return; }

  for (blkIdx = state.tokens.length - 1; blkIdx >= 0; blkIdx--) {

    if (state.tokens[blkIdx].type !== 'inline') { continue; }

    if (SCOPED_ABBR_TEST_RE.test(state.tokens[blkIdx].content)) {
      replace_scoped(state.tokens[blkIdx].children);
    }

    if (RARE_RE.test(state.tokens[blkIdx].content)) {
      replace_rare(state.tokens[blkIdx].children);
    }

  }
};

var isWhiteSpace$1   = utils.isWhiteSpace;
var isPunctChar$1    = utils.isPunctChar;
var isMdAsciiPunct$1 = utils.isMdAsciiPunct;

var QUOTE_TEST_RE = /['"]/;
var QUOTE_RE = /['"]/g;
var APOSTROPHE = '\u2019'; /* ’ */


function replaceAt(str, index, ch) {
  return str.substr(0, index) + ch + str.substr(index + 1);
}

function process_inlines(tokens, state) {
  var i, token, text, t, pos, max, thisLevel, item, lastChar, nextChar,
      isLastPunctChar, isNextPunctChar, isLastWhiteSpace, isNextWhiteSpace,
      canOpen, canClose, j, isSingle, stack, openQuote, closeQuote;

  stack = [];

  for (i = 0; i < tokens.length; i++) {
    token = tokens[i];

    thisLevel = tokens[i].level;

    for (j = stack.length - 1; j >= 0; j--) {
      if (stack[j].level <= thisLevel) { break; }
    }
    stack.length = j + 1;

    if (token.type !== 'text') { continue; }

    text = token.content;
    pos = 0;
    max = text.length;

    /*eslint no-labels:0,block-scoped-var:0*/
    OUTER:
    while (pos < max) {
      QUOTE_RE.lastIndex = pos;
      t = QUOTE_RE.exec(text);
      if (!t) { break; }

      canOpen = canClose = true;
      pos = t.index + 1;
      isSingle = (t[0] === "'");

      // Find previous character,
      // default to space if it's the beginning of the line
      //
      lastChar = 0x20;

      if (t.index - 1 >= 0) {
        lastChar = text.charCodeAt(t.index - 1);
      } else {
        for (j = i - 1; j >= 0; j--) {
          if (tokens[j].type === 'softbreak' || tokens[j].type === 'hardbreak') break; // lastChar defaults to 0x20
          if (!tokens[j].content) continue; // should skip all tokens except 'text', 'html_inline' or 'code_inline'

          lastChar = tokens[j].content.charCodeAt(tokens[j].content.length - 1);
          break;
        }
      }

      // Find next character,
      // default to space if it's the end of the line
      //
      nextChar = 0x20;

      if (pos < max) {
        nextChar = text.charCodeAt(pos);
      } else {
        for (j = i + 1; j < tokens.length; j++) {
          if (tokens[j].type === 'softbreak' || tokens[j].type === 'hardbreak') break; // nextChar defaults to 0x20
          if (!tokens[j].content) continue; // should skip all tokens except 'text', 'html_inline' or 'code_inline'

          nextChar = tokens[j].content.charCodeAt(0);
          break;
        }
      }

      isLastPunctChar = isMdAsciiPunct$1(lastChar) || isPunctChar$1(String.fromCharCode(lastChar));
      isNextPunctChar = isMdAsciiPunct$1(nextChar) || isPunctChar$1(String.fromCharCode(nextChar));

      isLastWhiteSpace = isWhiteSpace$1(lastChar);
      isNextWhiteSpace = isWhiteSpace$1(nextChar);

      if (isNextWhiteSpace) {
        canOpen = false;
      } else if (isNextPunctChar) {
        if (!(isLastWhiteSpace || isLastPunctChar)) {
          canOpen = false;
        }
      }

      if (isLastWhiteSpace) {
        canClose = false;
      } else if (isLastPunctChar) {
        if (!(isNextWhiteSpace || isNextPunctChar)) {
          canClose = false;
        }
      }

      if (nextChar === 0x22 /* " */ && t[0] === '"') {
        if (lastChar >= 0x30 /* 0 */ && lastChar <= 0x39 /* 9 */) {
          // special case: 1"" - count first quote as an inch
          canClose = canOpen = false;
        }
      }

      if (canOpen && canClose) {
        // Replace quotes in the middle of punctuation sequence, but not
        // in the middle of the words, i.e.:
        //
        // 1. foo " bar " baz - not replaced
        // 2. foo-"-bar-"-baz - replaced
        // 3. foo"bar"baz     - not replaced
        //
        canOpen = isLastPunctChar;
        canClose = isNextPunctChar;
      }

      if (!canOpen && !canClose) {
        // middle of word
        if (isSingle) {
          token.content = replaceAt(token.content, t.index, APOSTROPHE);
        }
        continue;
      }

      if (canClose) {
        // this could be a closing quote, rewind the stack to get a match
        for (j = stack.length - 1; j >= 0; j--) {
          item = stack[j];
          if (stack[j].level < thisLevel) { break; }
          if (item.single === isSingle && stack[j].level === thisLevel) {
            item = stack[j];

            if (isSingle) {
              openQuote = state.md.options.quotes[2];
              closeQuote = state.md.options.quotes[3];
            } else {
              openQuote = state.md.options.quotes[0];
              closeQuote = state.md.options.quotes[1];
            }

            // replace token.content *before* tokens[item.token].content,
            // because, if they are pointing at the same token, replaceAt
            // could mess up indices when quote length != 1
            token.content = replaceAt(token.content, t.index, closeQuote);
            tokens[item.token].content = replaceAt(
              tokens[item.token].content, item.pos, openQuote);

            pos += closeQuote.length - 1;
            if (item.token === i) { pos += openQuote.length - 1; }

            text = token.content;
            max = text.length;

            stack.length = j;
            continue OUTER;
          }
        }
      }

      if (canOpen) {
        stack.push({
          token: i,
          pos: t.index,
          single: isSingle,
          level: thisLevel
        });
      } else if (canClose && isSingle) {
        token.content = replaceAt(token.content, t.index, APOSTROPHE);
      }
    }
  }
}


var smartquotes = function smartquotes(state) {
  /*eslint max-depth:0*/
  var blkIdx;

  if (!state.md.options.typographer) { return; }

  for (blkIdx = state.tokens.length - 1; blkIdx >= 0; blkIdx--) {

    if (state.tokens[blkIdx].type !== 'inline' ||
        !QUOTE_TEST_RE.test(state.tokens[blkIdx].content)) {
      continue;
    }

    process_inlines(state.tokens[blkIdx].children, state);
  }
};

// Token class


/**
 * class Token
 **/

/**
 * new Token(type, tag, nesting)
 *
 * Create new token and fill passed properties.
 **/
function Token$1(type, tag, nesting) {
  /**
   * Token#type -> String
   *
   * Type of the token (string, e.g. "paragraph_open")
   **/
  this.type     = type;

  /**
   * Token#tag -> String
   *
   * html tag name, e.g. "p"
   **/
  this.tag      = tag;

  /**
   * Token#attrs -> Array
   *
   * Html attributes. Format: `[ [ name1, value1 ], [ name2, value2 ] ]`
   **/
  this.attrs    = null;

  /**
   * Token#map -> Array
   *
   * Source map info. Format: `[ line_begin, line_end ]`
   **/
  this.map      = null;

  /**
   * Token#nesting -> Number
   *
   * Level change (number in {-1, 0, 1} set), where:
   *
   * -  `1` means the tag is opening
   * -  `0` means the tag is self-closing
   * - `-1` means the tag is closing
   **/
  this.nesting  = nesting;

  /**
   * Token#level -> Number
   *
   * nesting level, the same as `state.level`
   **/
  this.level    = 0;

  /**
   * Token#children -> Array
   *
   * An array of child nodes (inline and img tokens)
   **/
  this.children = null;

  /**
   * Token#content -> String
   *
   * In a case of self-closing tag (code, html, fence, etc.),
   * it has contents of this tag.
   **/
  this.content  = '';

  /**
   * Token#markup -> String
   *
   * '*' or '_' for emphasis, fence string for fence, etc.
   **/
  this.markup   = '';

  /**
   * Token#info -> String
   *
   * fence infostring
   **/
  this.info     = '';

  /**
   * Token#meta -> Object
   *
   * A place for plugins to store an arbitrary data
   **/
  this.meta     = null;

  /**
   * Token#block -> Boolean
   *
   * True for block-level tokens, false for inline tokens.
   * Used in renderer to calculate line breaks
   **/
  this.block    = false;

  /**
   * Token#hidden -> Boolean
   *
   * If it's true, ignore this element when rendering. Used for tight lists
   * to hide paragraphs.
   **/
  this.hidden   = false;
}


/**
 * Token.attrIndex(name) -> Number
 *
 * Search attribute index by name.
 **/
Token$1.prototype.attrIndex = function attrIndex(name) {
  var attrs, i, len;

  if (!this.attrs) { return -1; }

  attrs = this.attrs;

  for (i = 0, len = attrs.length; i < len; i++) {
    if (attrs[i][0] === name) { return i; }
  }
  return -1;
};


/**
 * Token.attrPush(attrData)
 *
 * Add `[ name, value ]` attribute to list. Init attrs if necessary
 **/
Token$1.prototype.attrPush = function attrPush(attrData) {
  if (this.attrs) {
    this.attrs.push(attrData);
  } else {
    this.attrs = [ attrData ];
  }
};


/**
 * Token.attrSet(name, value)
 *
 * Set `name` attribute to `value`. Override old value if exists.
 **/
Token$1.prototype.attrSet = function attrSet(name, value) {
  var idx = this.attrIndex(name),
      attrData = [ name, value ];

  if (idx < 0) {
    this.attrPush(attrData);
  } else {
    this.attrs[idx] = attrData;
  }
};


/**
 * Token.attrGet(name)
 *
 * Get the value of attribute `name`, or null if it does not exist.
 **/
Token$1.prototype.attrGet = function attrGet(name) {
  var idx = this.attrIndex(name), value = null;
  if (idx >= 0) {
    value = this.attrs[idx][1];
  }
  return value;
};


/**
 * Token.attrJoin(name, value)
 *
 * Join value to existing attribute via space. Or create new attribute if not
 * exists. Useful to operate with token classes.
 **/
Token$1.prototype.attrJoin = function attrJoin(name, value) {
  var idx = this.attrIndex(name);

  if (idx < 0) {
    this.attrPush([ name, value ]);
  } else {
    this.attrs[idx][1] = this.attrs[idx][1] + ' ' + value;
  }
};


var token = Token$1;

function StateCore(src, md, env) {
  this.src = src;
  this.env = env;
  this.tokens = [];
  this.inlineMode = false;
  this.md = md; // link to parser instance
}

// re-export Token class to use in core rules
StateCore.prototype.Token = token;


var state_core = StateCore;

/** internal
 * class Core
 *
 * Top-level rules executor. Glues block/inline parsers and does intermediate
 * transformations.
 **/





var _rules$2 = [
  [ 'normalize',      normalize      ],
  [ 'block',          block          ],
  [ 'inline',         inline         ],
  [ 'linkify',        linkify        ],
  [ 'replacements',   replacements   ],
  [ 'smartquotes',    smartquotes    ]
];


/**
 * new Core()
 **/
function Core() {
  /**
   * Core#ruler -> Ruler
   *
   * [[Ruler]] instance. Keep configuration of core rules.
   **/
  this.ruler = new ruler();

  for (var i = 0; i < _rules$2.length; i++) {
    this.ruler.push(_rules$2[i][0], _rules$2[i][1]);
  }
}


/**
 * Core.process(state)
 *
 * Executes core chain rules.
 **/
Core.prototype.process = function (state) {
  var i, l, rules;

  rules = this.ruler.getRules('');

  for (i = 0, l = rules.length; i < l; i++) {
    rules[i](state);
  }
};

Core.prototype.State = state_core;


var parser_core = Core;

var isSpace$a = utils.isSpace;


function getLine(state, line) {
  var pos = state.bMarks[line] + state.tShift[line],
      max = state.eMarks[line];

  return state.src.substr(pos, max - pos);
}

function escapedSplit(str) {
  var result = [],
      pos = 0,
      max = str.length,
      ch,
      isEscaped = false,
      lastPos = 0,
      current = '';

  ch  = str.charCodeAt(pos);

  while (pos < max) {
    if (ch === 0x7c/* | */) {
      if (!isEscaped) {
        // pipe separating cells, '|'
        result.push(current + str.substring(lastPos, pos));
        current = '';
        lastPos = pos + 1;
      } else {
        // escaped pipe, '\|'
        current += str.substring(lastPos, pos - 1);
        lastPos = pos;
      }
    }

    isEscaped = (ch === 0x5c/* \ */);
    pos++;

    ch = str.charCodeAt(pos);
  }

  result.push(current + str.substring(lastPos));

  return result;
}


var table = function table(state, startLine, endLine, silent) {
  var ch, lineText, pos, i, l, nextLine, columns, columnCount, token,
      aligns, t, tableLines, tbodyLines, oldParentType, terminate,
      terminatorRules;

  // should have at least two lines
  if (startLine + 2 > endLine) { return false; }

  nextLine = startLine + 1;

  if (state.sCount[nextLine] < state.blkIndent) { return false; }

  // if it's indented more than 3 spaces, it should be a code block
  if (state.sCount[nextLine] - state.blkIndent >= 4) { return false; }

  // first character of the second line should be '|', '-', ':',
  // and no other characters are allowed but spaces;
  // basically, this is the equivalent of /^[-:|][-:|\s]*$/ regexp

  pos = state.bMarks[nextLine] + state.tShift[nextLine];
  if (pos >= state.eMarks[nextLine]) { return false; }

  ch = state.src.charCodeAt(pos++);
  if (ch !== 0x7C/* | */ && ch !== 0x2D/* - */ && ch !== 0x3A/* : */) { return false; }

  while (pos < state.eMarks[nextLine]) {
    ch = state.src.charCodeAt(pos);

    if (ch !== 0x7C/* | */ && ch !== 0x2D/* - */ && ch !== 0x3A/* : */ && !isSpace$a(ch)) { return false; }

    pos++;
  }

  lineText = getLine(state, startLine + 1);

  columns = lineText.split('|');
  aligns = [];
  for (i = 0; i < columns.length; i++) {
    t = columns[i].trim();
    if (!t) {
      // allow empty columns before and after table, but not in between columns;
      // e.g. allow ` |---| `, disallow ` ---||--- `
      if (i === 0 || i === columns.length - 1) {
        continue;
      } else {
        return false;
      }
    }

    if (!/^:?-+:?$/.test(t)) { return false; }
    if (t.charCodeAt(t.length - 1) === 0x3A/* : */) {
      aligns.push(t.charCodeAt(0) === 0x3A/* : */ ? 'center' : 'right');
    } else if (t.charCodeAt(0) === 0x3A/* : */) {
      aligns.push('left');
    } else {
      aligns.push('');
    }
  }

  lineText = getLine(state, startLine).trim();
  if (lineText.indexOf('|') === -1) { return false; }
  if (state.sCount[startLine] - state.blkIndent >= 4) { return false; }
  columns = escapedSplit(lineText);
  if (columns.length && columns[0] === '') columns.shift();
  if (columns.length && columns[columns.length - 1] === '') columns.pop();

  // header row will define an amount of columns in the entire table,
  // and align row should be exactly the same (the rest of the rows can differ)
  columnCount = columns.length;
  if (columnCount === 0 || columnCount !== aligns.length) { return false; }

  if (silent) { return true; }

  oldParentType = state.parentType;
  state.parentType = 'table';

  // use 'blockquote' lists for termination because it's
  // the most similar to tables
  terminatorRules = state.md.block.ruler.getRules('blockquote');

  token     = state.push('table_open', 'table', 1);
  token.map = tableLines = [ startLine, 0 ];

  token     = state.push('thead_open', 'thead', 1);
  token.map = [ startLine, startLine + 1 ];

  token     = state.push('tr_open', 'tr', 1);
  token.map = [ startLine, startLine + 1 ];

  for (i = 0; i < columns.length; i++) {
    token          = state.push('th_open', 'th', 1);
    if (aligns[i]) {
      token.attrs  = [ [ 'style', 'text-align:' + aligns[i] ] ];
    }

    token          = state.push('inline', '', 0);
    token.content  = columns[i].trim();
    token.children = [];

    token          = state.push('th_close', 'th', -1);
  }

  token     = state.push('tr_close', 'tr', -1);
  token     = state.push('thead_close', 'thead', -1);

  for (nextLine = startLine + 2; nextLine < endLine; nextLine++) {
    if (state.sCount[nextLine] < state.blkIndent) { break; }

    terminate = false;
    for (i = 0, l = terminatorRules.length; i < l; i++) {
      if (terminatorRules[i](state, nextLine, endLine, true)) {
        terminate = true;
        break;
      }
    }

    if (terminate) { break; }
    lineText = getLine(state, nextLine).trim();
    if (!lineText) { break; }
    if (state.sCount[nextLine] - state.blkIndent >= 4) { break; }
    columns = escapedSplit(lineText);
    if (columns.length && columns[0] === '') columns.shift();
    if (columns.length && columns[columns.length - 1] === '') columns.pop();

    if (nextLine === startLine + 2) {
      token     = state.push('tbody_open', 'tbody', 1);
      token.map = tbodyLines = [ startLine + 2, 0 ];
    }

    token     = state.push('tr_open', 'tr', 1);
    token.map = [ nextLine, nextLine + 1 ];

    for (i = 0; i < columnCount; i++) {
      token          = state.push('td_open', 'td', 1);
      if (aligns[i]) {
        token.attrs  = [ [ 'style', 'text-align:' + aligns[i] ] ];
      }

      token          = state.push('inline', '', 0);
      token.content  = columns[i] ? columns[i].trim() : '';
      token.children = [];

      token          = state.push('td_close', 'td', -1);
    }
    token = state.push('tr_close', 'tr', -1);
  }

  if (tbodyLines) {
    token = state.push('tbody_close', 'tbody', -1);
    tbodyLines[1] = nextLine;
  }

  token = state.push('table_close', 'table', -1);
  tableLines[1] = nextLine;

  state.parentType = oldParentType;
  state.line = nextLine;
  return true;
};

// Code block (4 spaces padded)


var code = function code(state, startLine, endLine/*, silent*/) {
  var nextLine, last, token;

  if (state.sCount[startLine] - state.blkIndent < 4) { return false; }

  last = nextLine = startLine + 1;

  while (nextLine < endLine) {
    if (state.isEmpty(nextLine)) {
      nextLine++;
      continue;
    }

    if (state.sCount[nextLine] - state.blkIndent >= 4) {
      nextLine++;
      last = nextLine;
      continue;
    }
    break;
  }

  state.line = last;

  token         = state.push('code_block', 'code', 0);
  token.content = state.getLines(startLine, last, 4 + state.blkIndent, true);
  token.map     = [ startLine, state.line ];

  return true;
};

// fences (``` lang, ~~~ lang)


var fence = function fence(state, startLine, endLine, silent) {
  var marker, len, params, nextLine, mem, token, markup,
      haveEndMarker = false,
      pos = state.bMarks[startLine] + state.tShift[startLine],
      max = state.eMarks[startLine];

  // if it's indented more than 3 spaces, it should be a code block
  if (state.sCount[startLine] - state.blkIndent >= 4) { return false; }

  if (pos + 3 > max) { return false; }

  marker = state.src.charCodeAt(pos);

  if (marker !== 0x7E/* ~ */ && marker !== 0x60 /* ` */) {
    return false;
  }

  // scan marker length
  mem = pos;
  pos = state.skipChars(pos, marker);

  len = pos - mem;

  if (len < 3) { return false; }

  markup = state.src.slice(mem, pos);
  params = state.src.slice(pos, max);

  if (marker === 0x60 /* ` */) {
    if (params.indexOf(String.fromCharCode(marker)) >= 0) {
      return false;
    }
  }

  // Since start is found, we can report success here in validation mode
  if (silent) { return true; }

  // search end of block
  nextLine = startLine;

  for (;;) {
    nextLine++;
    if (nextLine >= endLine) {
      // unclosed block should be autoclosed by end of document.
      // also block seems to be autoclosed by end of parent
      break;
    }

    pos = mem = state.bMarks[nextLine] + state.tShift[nextLine];
    max = state.eMarks[nextLine];

    if (pos < max && state.sCount[nextLine] < state.blkIndent) {
      // non-empty line with negative indent should stop the list:
      // - ```
      //  test
      break;
    }

    if (state.src.charCodeAt(pos) !== marker) { continue; }

    if (state.sCount[nextLine] - state.blkIndent >= 4) {
      // closing fence should be indented less than 4 spaces
      continue;
    }

    pos = state.skipChars(pos, marker);

    // closing code fence must be at least as long as the opening one
    if (pos - mem < len) { continue; }

    // make sure tail has spaces only
    pos = state.skipSpaces(pos);

    if (pos < max) { continue; }

    haveEndMarker = true;
    // found!
    break;
  }

  // If a fence has heading spaces, they should be removed from its inner block
  len = state.sCount[startLine];

  state.line = nextLine + (haveEndMarker ? 1 : 0);

  token         = state.push('fence', 'code', 0);
  token.info    = params;
  token.content = state.getLines(startLine + 1, nextLine, len, true);
  token.markup  = markup;
  token.map     = [ startLine, state.line ];

  return true;
};

var isSpace$9 = utils.isSpace;


var blockquote = function blockquote(state, startLine, endLine, silent) {
  var adjustTab,
      ch,
      i,
      initial,
      l,
      lastLineEmpty,
      lines,
      nextLine,
      offset,
      oldBMarks,
      oldBSCount,
      oldIndent,
      oldParentType,
      oldSCount,
      oldTShift,
      spaceAfterMarker,
      terminate,
      terminatorRules,
      token,
      isOutdented,
      oldLineMax = state.lineMax,
      pos = state.bMarks[startLine] + state.tShift[startLine],
      max = state.eMarks[startLine];

  // if it's indented more than 3 spaces, it should be a code block
  if (state.sCount[startLine] - state.blkIndent >= 4) { return false; }

  // check the block quote marker
  if (state.src.charCodeAt(pos++) !== 0x3E/* > */) { return false; }

  // we know that it's going to be a valid blockquote,
  // so no point trying to find the end of it in silent mode
  if (silent) { return true; }

  // set offset past spaces and ">"
  initial = offset = state.sCount[startLine] + 1;

  // skip one optional space after '>'
  if (state.src.charCodeAt(pos) === 0x20 /* space */) {
    // ' >   test '
    //     ^ -- position start of line here:
    pos++;
    initial++;
    offset++;
    adjustTab = false;
    spaceAfterMarker = true;
  } else if (state.src.charCodeAt(pos) === 0x09 /* tab */) {
    spaceAfterMarker = true;

    if ((state.bsCount[startLine] + offset) % 4 === 3) {
      // '  >\t  test '
      //       ^ -- position start of line here (tab has width===1)
      pos++;
      initial++;
      offset++;
      adjustTab = false;
    } else {
      // ' >\t  test '
      //    ^ -- position start of line here + shift bsCount slightly
      //         to make extra space appear
      adjustTab = true;
    }
  } else {
    spaceAfterMarker = false;
  }

  oldBMarks = [ state.bMarks[startLine] ];
  state.bMarks[startLine] = pos;

  while (pos < max) {
    ch = state.src.charCodeAt(pos);

    if (isSpace$9(ch)) {
      if (ch === 0x09) {
        offset += 4 - (offset + state.bsCount[startLine] + (adjustTab ? 1 : 0)) % 4;
      } else {
        offset++;
      }
    } else {
      break;
    }

    pos++;
  }

  oldBSCount = [ state.bsCount[startLine] ];
  state.bsCount[startLine] = state.sCount[startLine] + 1 + (spaceAfterMarker ? 1 : 0);

  lastLineEmpty = pos >= max;

  oldSCount = [ state.sCount[startLine] ];
  state.sCount[startLine] = offset - initial;

  oldTShift = [ state.tShift[startLine] ];
  state.tShift[startLine] = pos - state.bMarks[startLine];

  terminatorRules = state.md.block.ruler.getRules('blockquote');

  oldParentType = state.parentType;
  state.parentType = 'blockquote';

  // Search the end of the block
  //
  // Block ends with either:
  //  1. an empty line outside:
  //     ```
  //     > test
  //
  //     ```
  //  2. an empty line inside:
  //     ```
  //     >
  //     test
  //     ```
  //  3. another tag:
  //     ```
  //     > test
  //      - - -
  //     ```
  for (nextLine = startLine + 1; nextLine < endLine; nextLine++) {
    // check if it's outdented, i.e. it's inside list item and indented
    // less than said list item:
    //
    // ```
    // 1. anything
    //    > current blockquote
    // 2. checking this line
    // ```
    isOutdented = state.sCount[nextLine] < state.blkIndent;

    pos = state.bMarks[nextLine] + state.tShift[nextLine];
    max = state.eMarks[nextLine];

    if (pos >= max) {
      // Case 1: line is not inside the blockquote, and this line is empty.
      break;
    }

    if (state.src.charCodeAt(pos++) === 0x3E/* > */ && !isOutdented) {
      // This line is inside the blockquote.

      // set offset past spaces and ">"
      initial = offset = state.sCount[nextLine] + 1;

      // skip one optional space after '>'
      if (state.src.charCodeAt(pos) === 0x20 /* space */) {
        // ' >   test '
        //     ^ -- position start of line here:
        pos++;
        initial++;
        offset++;
        adjustTab = false;
        spaceAfterMarker = true;
      } else if (state.src.charCodeAt(pos) === 0x09 /* tab */) {
        spaceAfterMarker = true;

        if ((state.bsCount[nextLine] + offset) % 4 === 3) {
          // '  >\t  test '
          //       ^ -- position start of line here (tab has width===1)
          pos++;
          initial++;
          offset++;
          adjustTab = false;
        } else {
          // ' >\t  test '
          //    ^ -- position start of line here + shift bsCount slightly
          //         to make extra space appear
          adjustTab = true;
        }
      } else {
        spaceAfterMarker = false;
      }

      oldBMarks.push(state.bMarks[nextLine]);
      state.bMarks[nextLine] = pos;

      while (pos < max) {
        ch = state.src.charCodeAt(pos);

        if (isSpace$9(ch)) {
          if (ch === 0x09) {
            offset += 4 - (offset + state.bsCount[nextLine] + (adjustTab ? 1 : 0)) % 4;
          } else {
            offset++;
          }
        } else {
          break;
        }

        pos++;
      }

      lastLineEmpty = pos >= max;

      oldBSCount.push(state.bsCount[nextLine]);
      state.bsCount[nextLine] = state.sCount[nextLine] + 1 + (spaceAfterMarker ? 1 : 0);

      oldSCount.push(state.sCount[nextLine]);
      state.sCount[nextLine] = offset - initial;

      oldTShift.push(state.tShift[nextLine]);
      state.tShift[nextLine] = pos - state.bMarks[nextLine];
      continue;
    }

    // Case 2: line is not inside the blockquote, and the last line was empty.
    if (lastLineEmpty) { break; }

    // Case 3: another tag found.
    terminate = false;
    for (i = 0, l = terminatorRules.length; i < l; i++) {
      if (terminatorRules[i](state, nextLine, endLine, true)) {
        terminate = true;
        break;
      }
    }

    if (terminate) {
      // Quirk to enforce "hard termination mode" for paragraphs;
      // normally if you call `tokenize(state, startLine, nextLine)`,
      // paragraphs will look below nextLine for paragraph continuation,
      // but if blockquote is terminated by another tag, they shouldn't
      state.lineMax = nextLine;

      if (state.blkIndent !== 0) {
        // state.blkIndent was non-zero, we now set it to zero,
        // so we need to re-calculate all offsets to appear as
        // if indent wasn't changed
        oldBMarks.push(state.bMarks[nextLine]);
        oldBSCount.push(state.bsCount[nextLine]);
        oldTShift.push(state.tShift[nextLine]);
        oldSCount.push(state.sCount[nextLine]);
        state.sCount[nextLine] -= state.blkIndent;
      }

      break;
    }

    oldBMarks.push(state.bMarks[nextLine]);
    oldBSCount.push(state.bsCount[nextLine]);
    oldTShift.push(state.tShift[nextLine]);
    oldSCount.push(state.sCount[nextLine]);

    // A negative indentation means that this is a paragraph continuation
    //
    state.sCount[nextLine] = -1;
  }

  oldIndent = state.blkIndent;
  state.blkIndent = 0;

  token        = state.push('blockquote_open', 'blockquote', 1);
  token.markup = '>';
  token.map    = lines = [ startLine, 0 ];

  state.md.block.tokenize(state, startLine, nextLine);

  token        = state.push('blockquote_close', 'blockquote', -1);
  token.markup = '>';

  state.lineMax = oldLineMax;
  state.parentType = oldParentType;
  lines[1] = state.line;

  // Restore original tShift; this might not be necessary since the parser
  // has already been here, but just to make sure we can do that.
  for (i = 0; i < oldTShift.length; i++) {
    state.bMarks[i + startLine] = oldBMarks[i];
    state.tShift[i + startLine] = oldTShift[i];
    state.sCount[i + startLine] = oldSCount[i];
    state.bsCount[i + startLine] = oldBSCount[i];
  }
  state.blkIndent = oldIndent;

  return true;
};

var isSpace$8 = utils.isSpace;


var hr = function hr(state, startLine, endLine, silent) {
  var marker, cnt, ch, token,
      pos = state.bMarks[startLine] + state.tShift[startLine],
      max = state.eMarks[startLine];

  // if it's indented more than 3 spaces, it should be a code block
  if (state.sCount[startLine] - state.blkIndent >= 4) { return false; }

  marker = state.src.charCodeAt(pos++);

  // Check hr marker
  if (marker !== 0x2A/* * */ &&
      marker !== 0x2D/* - */ &&
      marker !== 0x5F/* _ */) {
    return false;
  }

  // markers can be mixed with spaces, but there should be at least 3 of them

  cnt = 1;
  while (pos < max) {
    ch = state.src.charCodeAt(pos++);
    if (ch !== marker && !isSpace$8(ch)) { return false; }
    if (ch === marker) { cnt++; }
  }

  if (cnt < 3) { return false; }

  if (silent) { return true; }

  state.line = startLine + 1;

  token        = state.push('hr', 'hr', 0);
  token.map    = [ startLine, state.line ];
  token.markup = Array(cnt + 1).join(String.fromCharCode(marker));

  return true;
};

var isSpace$7 = utils.isSpace;


// Search `[-+*][\n ]`, returns next pos after marker on success
// or -1 on fail.
function skipBulletListMarker(state, startLine) {
  var marker, pos, max, ch;

  pos = state.bMarks[startLine] + state.tShift[startLine];
  max = state.eMarks[startLine];

  marker = state.src.charCodeAt(pos++);
  // Check bullet
  if (marker !== 0x2A/* * */ &&
      marker !== 0x2D/* - */ &&
      marker !== 0x2B/* + */) {
    return -1;
  }

  if (pos < max) {
    ch = state.src.charCodeAt(pos);

    if (!isSpace$7(ch)) {
      // " -test " - is not a list item
      return -1;
    }
  }

  return pos;
}

// Search `\d+[.)][\n ]`, returns next pos after marker on success
// or -1 on fail.
function skipOrderedListMarker(state, startLine) {
  var ch,
      start = state.bMarks[startLine] + state.tShift[startLine],
      pos = start,
      max = state.eMarks[startLine];

  // List marker should have at least 2 chars (digit + dot)
  if (pos + 1 >= max) { return -1; }

  ch = state.src.charCodeAt(pos++);

  if (ch < 0x30/* 0 */ || ch > 0x39/* 9 */) { return -1; }

  for (;;) {
    // EOL -> fail
    if (pos >= max) { return -1; }

    ch = state.src.charCodeAt(pos++);

    if (ch >= 0x30/* 0 */ && ch <= 0x39/* 9 */) {

      // List marker should have no more than 9 digits
      // (prevents integer overflow in browsers)
      if (pos - start >= 10) { return -1; }

      continue;
    }

    // found valid marker
    if (ch === 0x29/* ) */ || ch === 0x2e/* . */) {
      break;
    }

    return -1;
  }


  if (pos < max) {
    ch = state.src.charCodeAt(pos);

    if (!isSpace$7(ch)) {
      // " 1.test " - is not a list item
      return -1;
    }
  }
  return pos;
}

function markTightParagraphs(state, idx) {
  var i, l,
      level = state.level + 2;

  for (i = idx + 2, l = state.tokens.length - 2; i < l; i++) {
    if (state.tokens[i].level === level && state.tokens[i].type === 'paragraph_open') {
      state.tokens[i + 2].hidden = true;
      state.tokens[i].hidden = true;
      i += 2;
    }
  }
}


var list = function list(state, startLine, endLine, silent) {
  var ch,
      contentStart,
      i,
      indent,
      indentAfterMarker,
      initial,
      isOrdered,
      itemLines,
      l,
      listLines,
      listTokIdx,
      markerCharCode,
      markerValue,
      max,
      nextLine,
      offset,
      oldListIndent,
      oldParentType,
      oldSCount,
      oldTShift,
      oldTight,
      pos,
      posAfterMarker,
      prevEmptyEnd,
      start,
      terminate,
      terminatorRules,
      token,
      isTerminatingParagraph = false,
      tight = true;

  // if it's indented more than 3 spaces, it should be a code block
  if (state.sCount[startLine] - state.blkIndent >= 4) { return false; }

  // Special case:
  //  - item 1
  //   - item 2
  //    - item 3
  //     - item 4
  //      - this one is a paragraph continuation
  if (state.listIndent >= 0 &&
      state.sCount[startLine] - state.listIndent >= 4 &&
      state.sCount[startLine] < state.blkIndent) {
    return false;
  }

  // limit conditions when list can interrupt
  // a paragraph (validation mode only)
  if (silent && state.parentType === 'paragraph') {
    // Next list item should still terminate previous list item;
    //
    // This code can fail if plugins use blkIndent as well as lists,
    // but I hope the spec gets fixed long before that happens.
    //
    if (state.tShift[startLine] >= state.blkIndent) {
      isTerminatingParagraph = true;
    }
  }

  // Detect list type and position after marker
  if ((posAfterMarker = skipOrderedListMarker(state, startLine)) >= 0) {
    isOrdered = true;
    start = state.bMarks[startLine] + state.tShift[startLine];
    markerValue = Number(state.src.substr(start, posAfterMarker - start - 1));

    // If we're starting a new ordered list right after
    // a paragraph, it should start with 1.
    if (isTerminatingParagraph && markerValue !== 1) return false;

  } else if ((posAfterMarker = skipBulletListMarker(state, startLine)) >= 0) {
    isOrdered = false;

  } else {
    return false;
  }

  // If we're starting a new unordered list right after
  // a paragraph, first line should not be empty.
  if (isTerminatingParagraph) {
    if (state.skipSpaces(posAfterMarker) >= state.eMarks[startLine]) return false;
  }

  // We should terminate list on style change. Remember first one to compare.
  markerCharCode = state.src.charCodeAt(posAfterMarker - 1);

  // For validation mode we can terminate immediately
  if (silent) { return true; }

  // Start list
  listTokIdx = state.tokens.length;

  if (isOrdered) {
    token       = state.push('ordered_list_open', 'ol', 1);
    if (markerValue !== 1) {
      token.attrs = [ [ 'start', markerValue ] ];
    }

  } else {
    token       = state.push('bullet_list_open', 'ul', 1);
  }

  token.map    = listLines = [ startLine, 0 ];
  token.markup = String.fromCharCode(markerCharCode);

  //
  // Iterate list items
  //

  nextLine = startLine;
  prevEmptyEnd = false;
  terminatorRules = state.md.block.ruler.getRules('list');

  oldParentType = state.parentType;
  state.parentType = 'list';

  while (nextLine < endLine) {
    pos = posAfterMarker;
    max = state.eMarks[nextLine];

    initial = offset = state.sCount[nextLine] + posAfterMarker - (state.bMarks[startLine] + state.tShift[startLine]);

    while (pos < max) {
      ch = state.src.charCodeAt(pos);

      if (ch === 0x09) {
        offset += 4 - (offset + state.bsCount[nextLine]) % 4;
      } else if (ch === 0x20) {
        offset++;
      } else {
        break;
      }

      pos++;
    }

    contentStart = pos;

    if (contentStart >= max) {
      // trimming space in "-    \n  3" case, indent is 1 here
      indentAfterMarker = 1;
    } else {
      indentAfterMarker = offset - initial;
    }

    // If we have more than 4 spaces, the indent is 1
    // (the rest is just indented code block)
    if (indentAfterMarker > 4) { indentAfterMarker = 1; }

    // "  -  test"
    //  ^^^^^ - calculating total length of this thing
    indent = initial + indentAfterMarker;

    // Run subparser & write tokens
    token        = state.push('list_item_open', 'li', 1);
    token.markup = String.fromCharCode(markerCharCode);
    token.map    = itemLines = [ startLine, 0 ];

    // change current state, then restore it after parser subcall
    oldTight = state.tight;
    oldTShift = state.tShift[startLine];
    oldSCount = state.sCount[startLine];

    //  - example list
    // ^ listIndent position will be here
    //   ^ blkIndent position will be here
    //
    oldListIndent = state.listIndent;
    state.listIndent = state.blkIndent;
    state.blkIndent = indent;

    state.tight = true;
    state.tShift[startLine] = contentStart - state.bMarks[startLine];
    state.sCount[startLine] = offset;

    if (contentStart >= max && state.isEmpty(startLine + 1)) {
      // workaround for this case
      // (list item is empty, list terminates before "foo"):
      // ~~~~~~~~
      //   -
      //
      //     foo
      // ~~~~~~~~
      state.line = Math.min(state.line + 2, endLine);
    } else {
      state.md.block.tokenize(state, startLine, endLine, true);
    }

    // If any of list item is tight, mark list as tight
    if (!state.tight || prevEmptyEnd) {
      tight = false;
    }
    // Item become loose if finish with empty line,
    // but we should filter last element, because it means list finish
    prevEmptyEnd = (state.line - startLine) > 1 && state.isEmpty(state.line - 1);

    state.blkIndent = state.listIndent;
    state.listIndent = oldListIndent;
    state.tShift[startLine] = oldTShift;
    state.sCount[startLine] = oldSCount;
    state.tight = oldTight;

    token        = state.push('list_item_close', 'li', -1);
    token.markup = String.fromCharCode(markerCharCode);

    nextLine = startLine = state.line;
    itemLines[1] = nextLine;
    contentStart = state.bMarks[startLine];

    if (nextLine >= endLine) { break; }

    //
    // Try to check if list is terminated or continued.
    //
    if (state.sCount[nextLine] < state.blkIndent) { break; }

    // if it's indented more than 3 spaces, it should be a code block
    if (state.sCount[startLine] - state.blkIndent >= 4) { break; }

    // fail if terminating block found
    terminate = false;
    for (i = 0, l = terminatorRules.length; i < l; i++) {
      if (terminatorRules[i](state, nextLine, endLine, true)) {
        terminate = true;
        break;
      }
    }
    if (terminate) { break; }

    // fail if list has another type
    if (isOrdered) {
      posAfterMarker = skipOrderedListMarker(state, nextLine);
      if (posAfterMarker < 0) { break; }
    } else {
      posAfterMarker = skipBulletListMarker(state, nextLine);
      if (posAfterMarker < 0) { break; }
    }

    if (markerCharCode !== state.src.charCodeAt(posAfterMarker - 1)) { break; }
  }

  // Finalize list
  if (isOrdered) {
    token = state.push('ordered_list_close', 'ol', -1);
  } else {
    token = state.push('bullet_list_close', 'ul', -1);
  }
  token.markup = String.fromCharCode(markerCharCode);

  listLines[1] = nextLine;
  state.line = nextLine;

  state.parentType = oldParentType;

  // mark paragraphs tight if needed
  if (tight) {
    markTightParagraphs(state, listTokIdx);
  }

  return true;
};

var normalizeReference$2   = utils.normalizeReference;
var isSpace$6              = utils.isSpace;


var reference = function reference(state, startLine, _endLine, silent) {
  var ch,
      destEndPos,
      destEndLineNo,
      endLine,
      href,
      i,
      l,
      label,
      labelEnd,
      oldParentType,
      res,
      start,
      str,
      terminate,
      terminatorRules,
      title,
      lines = 0,
      pos = state.bMarks[startLine] + state.tShift[startLine],
      max = state.eMarks[startLine],
      nextLine = startLine + 1;

  // if it's indented more than 3 spaces, it should be a code block
  if (state.sCount[startLine] - state.blkIndent >= 4) { return false; }

  if (state.src.charCodeAt(pos) !== 0x5B/* [ */) { return false; }

  // Simple check to quickly interrupt scan on [link](url) at the start of line.
  // Can be useful on practice: https://github.com/markdown-it/markdown-it/issues/54
  while (++pos < max) {
    if (state.src.charCodeAt(pos) === 0x5D /* ] */ &&
        state.src.charCodeAt(pos - 1) !== 0x5C/* \ */) {
      if (pos + 1 === max) { return false; }
      if (state.src.charCodeAt(pos + 1) !== 0x3A/* : */) { return false; }
      break;
    }
  }

  endLine = state.lineMax;

  // jump line-by-line until empty one or EOF
  terminatorRules = state.md.block.ruler.getRules('reference');

  oldParentType = state.parentType;
  state.parentType = 'reference';

  for (; nextLine < endLine && !state.isEmpty(nextLine); nextLine++) {
    // this would be a code block normally, but after paragraph
    // it's considered a lazy continuation regardless of what's there
    if (state.sCount[nextLine] - state.blkIndent > 3) { continue; }

    // quirk for blockquotes, this line should already be checked by that rule
    if (state.sCount[nextLine] < 0) { continue; }

    // Some tags can terminate paragraph without empty line.
    terminate = false;
    for (i = 0, l = terminatorRules.length; i < l; i++) {
      if (terminatorRules[i](state, nextLine, endLine, true)) {
        terminate = true;
        break;
      }
    }
    if (terminate) { break; }
  }

  str = state.getLines(startLine, nextLine, state.blkIndent, false).trim();
  max = str.length;

  for (pos = 1; pos < max; pos++) {
    ch = str.charCodeAt(pos);
    if (ch === 0x5B /* [ */) {
      return false;
    } else if (ch === 0x5D /* ] */) {
      labelEnd = pos;
      break;
    } else if (ch === 0x0A /* \n */) {
      lines++;
    } else if (ch === 0x5C /* \ */) {
      pos++;
      if (pos < max && str.charCodeAt(pos) === 0x0A) {
        lines++;
      }
    }
  }

  if (labelEnd < 0 || str.charCodeAt(labelEnd + 1) !== 0x3A/* : */) { return false; }

  // [label]:   destination   'title'
  //         ^^^ skip optional whitespace here
  for (pos = labelEnd + 2; pos < max; pos++) {
    ch = str.charCodeAt(pos);
    if (ch === 0x0A) {
      lines++;
    } else if (isSpace$6(ch)) ; else {
      break;
    }
  }

  // [label]:   destination   'title'
  //            ^^^^^^^^^^^ parse this
  res = state.md.helpers.parseLinkDestination(str, pos, max);
  if (!res.ok) { return false; }

  href = state.md.normalizeLink(res.str);
  if (!state.md.validateLink(href)) { return false; }

  pos = res.pos;
  lines += res.lines;

  // save cursor state, we could require to rollback later
  destEndPos = pos;
  destEndLineNo = lines;

  // [label]:   destination   'title'
  //                       ^^^ skipping those spaces
  start = pos;
  for (; pos < max; pos++) {
    ch = str.charCodeAt(pos);
    if (ch === 0x0A) {
      lines++;
    } else if (isSpace$6(ch)) ; else {
      break;
    }
  }

  // [label]:   destination   'title'
  //                          ^^^^^^^ parse this
  res = state.md.helpers.parseLinkTitle(str, pos, max);
  if (pos < max && start !== pos && res.ok) {
    title = res.str;
    pos = res.pos;
    lines += res.lines;
  } else {
    title = '';
    pos = destEndPos;
    lines = destEndLineNo;
  }

  // skip trailing spaces until the rest of the line
  while (pos < max) {
    ch = str.charCodeAt(pos);
    if (!isSpace$6(ch)) { break; }
    pos++;
  }

  if (pos < max && str.charCodeAt(pos) !== 0x0A) {
    if (title) {
      // garbage at the end of the line after title,
      // but it could still be a valid reference if we roll back
      title = '';
      pos = destEndPos;
      lines = destEndLineNo;
      while (pos < max) {
        ch = str.charCodeAt(pos);
        if (!isSpace$6(ch)) { break; }
        pos++;
      }
    }
  }

  if (pos < max && str.charCodeAt(pos) !== 0x0A) {
    // garbage at the end of the line
    return false;
  }

  label = normalizeReference$2(str.slice(1, labelEnd));
  if (!label) {
    // CommonMark 0.20 disallows empty labels
    return false;
  }

  // Reference can not terminate anything. This check is for safety only.
  /*istanbul ignore if*/
  if (silent) { return true; }

  if (typeof state.env.references === 'undefined') {
    state.env.references = {};
  }
  if (typeof state.env.references[label] === 'undefined') {
    state.env.references[label] = { title: title, href: href };
  }

  state.parentType = oldParentType;

  state.line = startLine + lines + 1;
  return true;
};

var isSpace$5 = utils.isSpace;


var heading = function heading(state, startLine, endLine, silent) {
  var ch, level, tmp, token,
      pos = state.bMarks[startLine] + state.tShift[startLine],
      max = state.eMarks[startLine];

  // if it's indented more than 3 spaces, it should be a code block
  if (state.sCount[startLine] - state.blkIndent >= 4) { return false; }

  ch  = state.src.charCodeAt(pos);

  if (ch !== 0x23/* # */ || pos >= max) { return false; }

  // count heading level
  level = 1;
  ch = state.src.charCodeAt(++pos);
  while (ch === 0x23/* # */ && pos < max && level <= 6) {
    level++;
    ch = state.src.charCodeAt(++pos);
  }

  if (level > 6 || (pos < max && !isSpace$5(ch))) { return false; }

  if (silent) { return true; }

  // Let's cut tails like '    ###  ' from the end of string

  max = state.skipSpacesBack(max, pos);
  tmp = state.skipCharsBack(max, 0x23, pos); // #
  if (tmp > pos && isSpace$5(state.src.charCodeAt(tmp - 1))) {
    max = tmp;
  }

  state.line = startLine + 1;

  token        = state.push('heading_open', 'h' + String(level), 1);
  token.markup = '########'.slice(0, level);
  token.map    = [ startLine, state.line ];

  token          = state.push('inline', '', 0);
  token.content  = state.src.slice(pos, max).trim();
  token.map      = [ startLine, state.line ];
  token.children = [];

  token        = state.push('heading_close', 'h' + String(level), -1);
  token.markup = '########'.slice(0, level);

  return true;
};

// lheading (---, ===)


var lheading = function lheading(state, startLine, endLine/*, silent*/) {
  var content, terminate, i, l, token, pos, max, level, marker,
      nextLine = startLine + 1, oldParentType,
      terminatorRules = state.md.block.ruler.getRules('paragraph');

  // if it's indented more than 3 spaces, it should be a code block
  if (state.sCount[startLine] - state.blkIndent >= 4) { return false; }

  oldParentType = state.parentType;
  state.parentType = 'paragraph'; // use paragraph to match terminatorRules

  // jump line-by-line until empty one or EOF
  for (; nextLine < endLine && !state.isEmpty(nextLine); nextLine++) {
    // this would be a code block normally, but after paragraph
    // it's considered a lazy continuation regardless of what's there
    if (state.sCount[nextLine] - state.blkIndent > 3) { continue; }

    //
    // Check for underline in setext header
    //
    if (state.sCount[nextLine] >= state.blkIndent) {
      pos = state.bMarks[nextLine] + state.tShift[nextLine];
      max = state.eMarks[nextLine];

      if (pos < max) {
        marker = state.src.charCodeAt(pos);

        if (marker === 0x2D/* - */ || marker === 0x3D/* = */) {
          pos = state.skipChars(pos, marker);
          pos = state.skipSpaces(pos);

          if (pos >= max) {
            level = (marker === 0x3D/* = */ ? 1 : 2);
            break;
          }
        }
      }
    }

    // quirk for blockquotes, this line should already be checked by that rule
    if (state.sCount[nextLine] < 0) { continue; }

    // Some tags can terminate paragraph without empty line.
    terminate = false;
    for (i = 0, l = terminatorRules.length; i < l; i++) {
      if (terminatorRules[i](state, nextLine, endLine, true)) {
        terminate = true;
        break;
      }
    }
    if (terminate) { break; }
  }

  if (!level) {
    // Didn't find valid underline
    return false;
  }

  content = state.getLines(startLine, nextLine, state.blkIndent, false).trim();

  state.line = nextLine + 1;

  token          = state.push('heading_open', 'h' + String(level), 1);
  token.markup   = String.fromCharCode(marker);
  token.map      = [ startLine, state.line ];

  token          = state.push('inline', '', 0);
  token.content  = content;
  token.map      = [ startLine, state.line - 1 ];
  token.children = [];

  token          = state.push('heading_close', 'h' + String(level), -1);
  token.markup   = String.fromCharCode(marker);

  state.parentType = oldParentType;

  return true;
};

// List of valid html blocks names, accorting to commonmark spec


var html_blocks = [
  'address',
  'article',
  'aside',
  'base',
  'basefont',
  'blockquote',
  'body',
  'caption',
  'center',
  'col',
  'colgroup',
  'dd',
  'details',
  'dialog',
  'dir',
  'div',
  'dl',
  'dt',
  'fieldset',
  'figcaption',
  'figure',
  'footer',
  'form',
  'frame',
  'frameset',
  'h1',
  'h2',
  'h3',
  'h4',
  'h5',
  'h6',
  'head',
  'header',
  'hr',
  'html',
  'iframe',
  'legend',
  'li',
  'link',
  'main',
  'menu',
  'menuitem',
  'nav',
  'noframes',
  'ol',
  'optgroup',
  'option',
  'p',
  'param',
  'section',
  'source',
  'summary',
  'table',
  'tbody',
  'td',
  'tfoot',
  'th',
  'thead',
  'title',
  'tr',
  'track',
  'ul'
];

// Regexps to match html elements

var attr_name     = '[a-zA-Z_:][a-zA-Z0-9:._-]*';

var unquoted      = '[^"\'=<>`\\x00-\\x20]+';
var single_quoted = "'[^']*'";
var double_quoted = '"[^"]*"';

var attr_value  = '(?:' + unquoted + '|' + single_quoted + '|' + double_quoted + ')';

var attribute   = '(?:\\s+' + attr_name + '(?:\\s*=\\s*' + attr_value + ')?)';

var open_tag    = '<[A-Za-z][A-Za-z0-9\\-]*' + attribute + '*\\s*\\/?>';

var close_tag   = '<\\/[A-Za-z][A-Za-z0-9\\-]*\\s*>';
var comment     = '<!---->|<!--(?:-?[^>-])(?:-?[^-])*-->';
var processing  = '<[?][\\s\\S]*?[?]>';
var declaration = '<![A-Z]+\\s+[^>]*>';
var cdata       = '<!\\[CDATA\\[[\\s\\S]*?\\]\\]>';

var HTML_TAG_RE$1 = new RegExp('^(?:' + open_tag + '|' + close_tag + '|' + comment +
                        '|' + processing + '|' + declaration + '|' + cdata + ')');
var HTML_OPEN_CLOSE_TAG_RE$1 = new RegExp('^(?:' + open_tag + '|' + close_tag + ')');

var HTML_TAG_RE_1 = HTML_TAG_RE$1;
var HTML_OPEN_CLOSE_TAG_RE_1 = HTML_OPEN_CLOSE_TAG_RE$1;

var html_re = {
	HTML_TAG_RE: HTML_TAG_RE_1,
	HTML_OPEN_CLOSE_TAG_RE: HTML_OPEN_CLOSE_TAG_RE_1
};

var HTML_OPEN_CLOSE_TAG_RE = html_re.HTML_OPEN_CLOSE_TAG_RE;

// An array of opening and corresponding closing sequences for html tags,
// last argument defines whether it can terminate a paragraph or not
//
var HTML_SEQUENCES = [
  [ /^<(script|pre|style)(?=(\s|>|$))/i, /<\/(script|pre|style)>/i, true ],
  [ /^<!--/,        /-->/,   true ],
  [ /^<\?/,         /\?>/,   true ],
  [ /^<![A-Z]/,     />/,     true ],
  [ /^<!\[CDATA\[/, /\]\]>/, true ],
  [ new RegExp('^</?(' + html_blocks.join('|') + ')(?=(\\s|/?>|$))', 'i'), /^$/, true ],
  [ new RegExp(HTML_OPEN_CLOSE_TAG_RE.source + '\\s*$'),  /^$/, false ]
];


var html_block = function html_block(state, startLine, endLine, silent) {
  var i, nextLine, token, lineText,
      pos = state.bMarks[startLine] + state.tShift[startLine],
      max = state.eMarks[startLine];

  // if it's indented more than 3 spaces, it should be a code block
  if (state.sCount[startLine] - state.blkIndent >= 4) { return false; }

  if (!state.md.options.html) { return false; }

  if (state.src.charCodeAt(pos) !== 0x3C/* < */) { return false; }

  lineText = state.src.slice(pos, max);

  for (i = 0; i < HTML_SEQUENCES.length; i++) {
    if (HTML_SEQUENCES[i][0].test(lineText)) { break; }
  }

  if (i === HTML_SEQUENCES.length) { return false; }

  if (silent) {
    // true if this sequence can be a terminator, false otherwise
    return HTML_SEQUENCES[i][2];
  }

  nextLine = startLine + 1;

  // If we are here - we detected HTML block.
  // Let's roll down till block end.
  if (!HTML_SEQUENCES[i][1].test(lineText)) {
    for (; nextLine < endLine; nextLine++) {
      if (state.sCount[nextLine] < state.blkIndent) { break; }

      pos = state.bMarks[nextLine] + state.tShift[nextLine];
      max = state.eMarks[nextLine];
      lineText = state.src.slice(pos, max);

      if (HTML_SEQUENCES[i][1].test(lineText)) {
        if (lineText.length !== 0) { nextLine++; }
        break;
      }
    }
  }

  state.line = nextLine;

  token         = state.push('html_block', '', 0);
  token.map     = [ startLine, nextLine ];
  token.content = state.getLines(startLine, nextLine, state.blkIndent, true);

  return true;
};

// Paragraph


var paragraph = function paragraph(state, startLine/*, endLine*/) {
  var content, terminate, i, l, token, oldParentType,
      nextLine = startLine + 1,
      terminatorRules = state.md.block.ruler.getRules('paragraph'),
      endLine = state.lineMax;

  oldParentType = state.parentType;
  state.parentType = 'paragraph';

  // jump line-by-line until empty one or EOF
  for (; nextLine < endLine && !state.isEmpty(nextLine); nextLine++) {
    // this would be a code block normally, but after paragraph
    // it's considered a lazy continuation regardless of what's there
    if (state.sCount[nextLine] - state.blkIndent > 3) { continue; }

    // quirk for blockquotes, this line should already be checked by that rule
    if (state.sCount[nextLine] < 0) { continue; }

    // Some tags can terminate paragraph without empty line.
    terminate = false;
    for (i = 0, l = terminatorRules.length; i < l; i++) {
      if (terminatorRules[i](state, nextLine, endLine, true)) {
        terminate = true;
        break;
      }
    }
    if (terminate) { break; }
  }

  content = state.getLines(startLine, nextLine, state.blkIndent, false).trim();

  state.line = nextLine;

  token          = state.push('paragraph_open', 'p', 1);
  token.map      = [ startLine, state.line ];

  token          = state.push('inline', '', 0);
  token.content  = content;
  token.map      = [ startLine, state.line ];
  token.children = [];

  token          = state.push('paragraph_close', 'p', -1);

  state.parentType = oldParentType;

  return true;
};

var isSpace$4 = utils.isSpace;


function StateBlock(src, md, env, tokens) {
  var ch, s, start, pos, len, indent, offset, indent_found;

  this.src = src;

  // link to parser instance
  this.md     = md;

  this.env = env;

  //
  // Internal state vartiables
  //

  this.tokens = tokens;

  this.bMarks = [];  // line begin offsets for fast jumps
  this.eMarks = [];  // line end offsets for fast jumps
  this.tShift = [];  // offsets of the first non-space characters (tabs not expanded)
  this.sCount = [];  // indents for each line (tabs expanded)

  // An amount of virtual spaces (tabs expanded) between beginning
  // of each line (bMarks) and real beginning of that line.
  //
  // It exists only as a hack because blockquotes override bMarks
  // losing information in the process.
  //
  // It's used only when expanding tabs, you can think about it as
  // an initial tab length, e.g. bsCount=21 applied to string `\t123`
  // means first tab should be expanded to 4-21%4 === 3 spaces.
  //
  this.bsCount = [];

  // block parser variables
  this.blkIndent  = 0; // required block content indent (for example, if we are
                       // inside a list, it would be positioned after list marker)
  this.line       = 0; // line index in src
  this.lineMax    = 0; // lines count
  this.tight      = false;  // loose/tight mode for lists
  this.ddIndent   = -1; // indent of the current dd block (-1 if there isn't any)
  this.listIndent = -1; // indent of the current list block (-1 if there isn't any)

  // can be 'blockquote', 'list', 'root', 'paragraph' or 'reference'
  // used in lists to determine if they interrupt a paragraph
  this.parentType = 'root';

  this.level = 0;

  // renderer
  this.result = '';

  // Create caches
  // Generate markers.
  s = this.src;
  indent_found = false;

  for (start = pos = indent = offset = 0, len = s.length; pos < len; pos++) {
    ch = s.charCodeAt(pos);

    if (!indent_found) {
      if (isSpace$4(ch)) {
        indent++;

        if (ch === 0x09) {
          offset += 4 - offset % 4;
        } else {
          offset++;
        }
        continue;
      } else {
        indent_found = true;
      }
    }

    if (ch === 0x0A || pos === len - 1) {
      if (ch !== 0x0A) { pos++; }
      this.bMarks.push(start);
      this.eMarks.push(pos);
      this.tShift.push(indent);
      this.sCount.push(offset);
      this.bsCount.push(0);

      indent_found = false;
      indent = 0;
      offset = 0;
      start = pos + 1;
    }
  }

  // Push fake entry to simplify cache bounds checks
  this.bMarks.push(s.length);
  this.eMarks.push(s.length);
  this.tShift.push(0);
  this.sCount.push(0);
  this.bsCount.push(0);

  this.lineMax = this.bMarks.length - 1; // don't count last fake line
}

// Push new token to "stream".
//
StateBlock.prototype.push = function (type, tag, nesting) {
  var token$1 = new token(type, tag, nesting);
  token$1.block = true;

  if (nesting < 0) this.level--; // closing tag
  token$1.level = this.level;
  if (nesting > 0) this.level++; // opening tag

  this.tokens.push(token$1);
  return token$1;
};

StateBlock.prototype.isEmpty = function isEmpty(line) {
  return this.bMarks[line] + this.tShift[line] >= this.eMarks[line];
};

StateBlock.prototype.skipEmptyLines = function skipEmptyLines(from) {
  for (var max = this.lineMax; from < max; from++) {
    if (this.bMarks[from] + this.tShift[from] < this.eMarks[from]) {
      break;
    }
  }
  return from;
};

// Skip spaces from given position.
StateBlock.prototype.skipSpaces = function skipSpaces(pos) {
  var ch;

  for (var max = this.src.length; pos < max; pos++) {
    ch = this.src.charCodeAt(pos);
    if (!isSpace$4(ch)) { break; }
  }
  return pos;
};

// Skip spaces from given position in reverse.
StateBlock.prototype.skipSpacesBack = function skipSpacesBack(pos, min) {
  if (pos <= min) { return pos; }

  while (pos > min) {
    if (!isSpace$4(this.src.charCodeAt(--pos))) { return pos + 1; }
  }
  return pos;
};

// Skip char codes from given position
StateBlock.prototype.skipChars = function skipChars(pos, code) {
  for (var max = this.src.length; pos < max; pos++) {
    if (this.src.charCodeAt(pos) !== code) { break; }
  }
  return pos;
};

// Skip char codes reverse from given position - 1
StateBlock.prototype.skipCharsBack = function skipCharsBack(pos, code, min) {
  if (pos <= min) { return pos; }

  while (pos > min) {
    if (code !== this.src.charCodeAt(--pos)) { return pos + 1; }
  }
  return pos;
};

// cut lines range from source.
StateBlock.prototype.getLines = function getLines(begin, end, indent, keepLastLF) {
  var i, lineIndent, ch, first, last, queue, lineStart,
      line = begin;

  if (begin >= end) {
    return '';
  }

  queue = new Array(end - begin);

  for (i = 0; line < end; line++, i++) {
    lineIndent = 0;
    lineStart = first = this.bMarks[line];

    if (line + 1 < end || keepLastLF) {
      // No need for bounds check because we have fake entry on tail.
      last = this.eMarks[line] + 1;
    } else {
      last = this.eMarks[line];
    }

    while (first < last && lineIndent < indent) {
      ch = this.src.charCodeAt(first);

      if (isSpace$4(ch)) {
        if (ch === 0x09) {
          lineIndent += 4 - (lineIndent + this.bsCount[line]) % 4;
        } else {
          lineIndent++;
        }
      } else if (first - lineStart < this.tShift[line]) {
        // patched tShift masked characters to look like spaces (blockquotes, list markers)
        lineIndent++;
      } else {
        break;
      }

      first++;
    }

    if (lineIndent > indent) {
      // partially expanding tabs in code blocks, e.g '\t\tfoobar'
      // with indent=2 becomes '  \tfoobar'
      queue[i] = new Array(lineIndent - indent + 1).join(' ') + this.src.slice(first, last);
    } else {
      queue[i] = this.src.slice(first, last);
    }
  }

  return queue.join('');
};

// re-export Token class to use in block rules
StateBlock.prototype.Token = token;


var state_block = StateBlock;

/** internal
 * class ParserBlock
 *
 * Block-level tokenizer.
 **/





var _rules$1 = [
  // First 2 params - rule name & source. Secondary array - list of rules,
  // which can be terminated by this one.
  [ 'table',      table,      [ 'paragraph', 'reference' ] ],
  [ 'code',       code ],
  [ 'fence',      fence,      [ 'paragraph', 'reference', 'blockquote', 'list' ] ],
  [ 'blockquote', blockquote, [ 'paragraph', 'reference', 'blockquote', 'list' ] ],
  [ 'hr',         hr,         [ 'paragraph', 'reference', 'blockquote', 'list' ] ],
  [ 'list',       list,       [ 'paragraph', 'reference', 'blockquote' ] ],
  [ 'reference',  reference ],
  [ 'heading',    heading,    [ 'paragraph', 'reference', 'blockquote' ] ],
  [ 'lheading',   lheading ],
  [ 'html_block', html_block, [ 'paragraph', 'reference', 'blockquote' ] ],
  [ 'paragraph',  paragraph ]
];


/**
 * new ParserBlock()
 **/
function ParserBlock() {
  /**
   * ParserBlock#ruler -> Ruler
   *
   * [[Ruler]] instance. Keep configuration of block rules.
   **/
  this.ruler = new ruler();

  for (var i = 0; i < _rules$1.length; i++) {
    this.ruler.push(_rules$1[i][0], _rules$1[i][1], { alt: (_rules$1[i][2] || []).slice() });
  }
}


// Generate tokens for input range
//
ParserBlock.prototype.tokenize = function (state, startLine, endLine) {
  var ok, i,
      rules = this.ruler.getRules(''),
      len = rules.length,
      line = startLine,
      hasEmptyLines = false,
      maxNesting = state.md.options.maxNesting;

  while (line < endLine) {
    state.line = line = state.skipEmptyLines(line);
    if (line >= endLine) { break; }

    // Termination condition for nested calls.
    // Nested calls currently used for blockquotes & lists
    if (state.sCount[line] < state.blkIndent) { break; }

    // If nesting level exceeded - skip tail to the end. That's not ordinary
    // situation and we should not care about content.
    if (state.level >= maxNesting) {
      state.line = endLine;
      break;
    }

    // Try all possible rules.
    // On success, rule should:
    //
    // - update `state.line`
    // - update `state.tokens`
    // - return true

    for (i = 0; i < len; i++) {
      ok = rules[i](state, line, endLine, false);
      if (ok) { break; }
    }

    // set state.tight if we had an empty line before current tag
    // i.e. latest empty line should not count
    state.tight = !hasEmptyLines;

    // paragraph might "eat" one newline after it in nested lists
    if (state.isEmpty(state.line - 1)) {
      hasEmptyLines = true;
    }

    line = state.line;

    if (line < endLine && state.isEmpty(line)) {
      hasEmptyLines = true;
      line++;
      state.line = line;
    }
  }
};


/**
 * ParserBlock.parse(str, md, env, outTokens)
 *
 * Process input string and push block tokens into `outTokens`
 **/
ParserBlock.prototype.parse = function (src, md, env, outTokens) {
  var state;

  if (!src) { return; }

  state = new this.State(src, md, env, outTokens);

  this.tokenize(state, state.line, state.lineMax);
};


ParserBlock.prototype.State = state_block;


var parser_block = ParserBlock;

// Skip text characters for text token, place those to pending buffer


// Rule to skip pure text
// '{}$%@~+=:' reserved for extentions

// !, ", #, $, %, &, ', (, ), *, +, ,, -, ., /, :, ;, <, =, >, ?, @, [, \, ], ^, _, `, {, |, }, or ~

// !!!! Don't confuse with "Markdown ASCII Punctuation" chars
// http://spec.commonmark.org/0.15/#ascii-punctuation-character
function isTerminatorChar(ch) {
  switch (ch) {
    case 0x0A/* \n */:
    case 0x21/* ! */:
    case 0x23/* # */:
    case 0x24/* $ */:
    case 0x25/* % */:
    case 0x26/* & */:
    case 0x2A/* * */:
    case 0x2B/* + */:
    case 0x2D/* - */:
    case 0x3A/* : */:
    case 0x3C/* < */:
    case 0x3D/* = */:
    case 0x3E/* > */:
    case 0x40/* @ */:
    case 0x5B/* [ */:
    case 0x5C/* \ */:
    case 0x5D/* ] */:
    case 0x5E/* ^ */:
    case 0x5F/* _ */:
    case 0x60/* ` */:
    case 0x7B/* { */:
    case 0x7D/* } */:
    case 0x7E/* ~ */:
      return true;
    default:
      return false;
  }
}

var text = function text(state, silent) {
  var pos = state.pos;

  while (pos < state.posMax && !isTerminatorChar(state.src.charCodeAt(pos))) {
    pos++;
  }

  if (pos === state.pos) { return false; }

  if (!silent) { state.pending += state.src.slice(state.pos, pos); }

  state.pos = pos;

  return true;
};

var isSpace$3 = utils.isSpace;


var newline = function newline(state, silent) {
  var pmax, max, pos = state.pos;

  if (state.src.charCodeAt(pos) !== 0x0A/* \n */) { return false; }

  pmax = state.pending.length - 1;
  max = state.posMax;

  // '  \n' -> hardbreak
  // Lookup in pending chars is bad practice! Don't copy to other rules!
  // Pending string is stored in concat mode, indexed lookups will cause
  // convertion to flat mode.
  if (!silent) {
    if (pmax >= 0 && state.pending.charCodeAt(pmax) === 0x20) {
      if (pmax >= 1 && state.pending.charCodeAt(pmax - 1) === 0x20) {
        state.pending = state.pending.replace(/ +$/, '');
        state.push('hardbreak', 'br', 0);
      } else {
        state.pending = state.pending.slice(0, -1);
        state.push('softbreak', 'br', 0);
      }

    } else {
      state.push('softbreak', 'br', 0);
    }
  }

  pos++;

  // skip heading spaces for next line
  while (pos < max && isSpace$3(state.src.charCodeAt(pos))) { pos++; }

  state.pos = pos;
  return true;
};

var isSpace$2 = utils.isSpace;

var ESCAPED = [];

for (var i = 0; i < 256; i++) { ESCAPED.push(0); }

'\\!"#$%&\'()*+,./:;<=>?@[]^_`{|}~-'
  .split('').forEach(function (ch) { ESCAPED[ch.charCodeAt(0)] = 1; });


var _escape = function escape(state, silent) {
  var ch, pos = state.pos, max = state.posMax;

  if (state.src.charCodeAt(pos) !== 0x5C/* \ */) { return false; }

  pos++;

  if (pos < max) {
    ch = state.src.charCodeAt(pos);

    if (ch < 256 && ESCAPED[ch] !== 0) {
      if (!silent) { state.pending += state.src[pos]; }
      state.pos += 2;
      return true;
    }

    if (ch === 0x0A) {
      if (!silent) {
        state.push('hardbreak', 'br', 0);
      }

      pos++;
      // skip leading whitespaces from next line
      while (pos < max) {
        ch = state.src.charCodeAt(pos);
        if (!isSpace$2(ch)) { break; }
        pos++;
      }

      state.pos = pos;
      return true;
    }
  }

  if (!silent) { state.pending += '\\'; }
  state.pos++;
  return true;
};

// Parse backticks


var backticks = function backtick(state, silent) {
  var start, max, marker, token, matchStart, matchEnd, openerLength, closerLength,
      pos = state.pos,
      ch = state.src.charCodeAt(pos);

  if (ch !== 0x60/* ` */) { return false; }

  start = pos;
  pos++;
  max = state.posMax;

  // scan marker length
  while (pos < max && state.src.charCodeAt(pos) === 0x60/* ` */) { pos++; }

  marker = state.src.slice(start, pos);
  openerLength = marker.length;

  if (state.backticksScanned && (state.backticks[openerLength] || 0) <= start) {
    if (!silent) state.pending += marker;
    state.pos += openerLength;
    return true;
  }

  matchStart = matchEnd = pos;

  // Nothing found in the cache, scan until the end of the line (or until marker is found)
  while ((matchStart = state.src.indexOf('`', matchEnd)) !== -1) {
    matchEnd = matchStart + 1;

    // scan marker length
    while (matchEnd < max && state.src.charCodeAt(matchEnd) === 0x60/* ` */) { matchEnd++; }

    closerLength = matchEnd - matchStart;

    if (closerLength === openerLength) {
      // Found matching closer length.
      if (!silent) {
        token     = state.push('code_inline', 'code', 0);
        token.markup  = marker;
        token.content = state.src.slice(pos, matchStart)
          .replace(/\n/g, ' ')
          .replace(/^ (.+) $/, '$1');
      }
      state.pos = matchEnd;
      return true;
    }

    // Some different length found, put it in cache as upper limit of where closer can be found
    state.backticks[closerLength] = matchStart;
  }

  // Scanned through the end, didn't find anything
  state.backticksScanned = true;

  if (!silent) state.pending += marker;
  state.pos += openerLength;
  return true;
};

// ~~strike through~~


// Insert each marker as a separate text token, and add it to delimiter list
//
var tokenize$1 = function strikethrough(state, silent) {
  var i, scanned, token, len, ch,
      start = state.pos,
      marker = state.src.charCodeAt(start);

  if (silent) { return false; }

  if (marker !== 0x7E/* ~ */) { return false; }

  scanned = state.scanDelims(state.pos, true);
  len = scanned.length;
  ch = String.fromCharCode(marker);

  if (len < 2) { return false; }

  if (len % 2) {
    token         = state.push('text', '', 0);
    token.content = ch;
    len--;
  }

  for (i = 0; i < len; i += 2) {
    token         = state.push('text', '', 0);
    token.content = ch + ch;

    state.delimiters.push({
      marker: marker,
      length: 0,     // disable "rule of 3" length checks meant for emphasis
      jump:   i / 2, // for `~~` 1 marker = 2 characters
      token:  state.tokens.length - 1,
      end:    -1,
      open:   scanned.can_open,
      close:  scanned.can_close
    });
  }

  state.pos += scanned.length;

  return true;
};


function postProcess$1(state, delimiters) {
  var i, j,
      startDelim,
      endDelim,
      token,
      loneMarkers = [],
      max = delimiters.length;

  for (i = 0; i < max; i++) {
    startDelim = delimiters[i];

    if (startDelim.marker !== 0x7E/* ~ */) {
      continue;
    }

    if (startDelim.end === -1) {
      continue;
    }

    endDelim = delimiters[startDelim.end];

    token         = state.tokens[startDelim.token];
    token.type    = 's_open';
    token.tag     = 's';
    token.nesting = 1;
    token.markup  = '~~';
    token.content = '';

    token         = state.tokens[endDelim.token];
    token.type    = 's_close';
    token.tag     = 's';
    token.nesting = -1;
    token.markup  = '~~';
    token.content = '';

    if (state.tokens[endDelim.token - 1].type === 'text' &&
        state.tokens[endDelim.token - 1].content === '~') {

      loneMarkers.push(endDelim.token - 1);
    }
  }

  // If a marker sequence has an odd number of characters, it's splitted
  // like this: `~~~~~` -> `~` + `~~` + `~~`, leaving one marker at the
  // start of the sequence.
  //
  // So, we have to move all those markers after subsequent s_close tags.
  //
  while (loneMarkers.length) {
    i = loneMarkers.pop();
    j = i + 1;

    while (j < state.tokens.length && state.tokens[j].type === 's_close') {
      j++;
    }

    j--;

    if (i !== j) {
      token = state.tokens[j];
      state.tokens[j] = state.tokens[i];
      state.tokens[i] = token;
    }
  }
}


// Walk through delimiter list and replace text tokens with tags
//
var postProcess_1$1 = function strikethrough(state) {
  var curr,
      tokens_meta = state.tokens_meta,
      max = state.tokens_meta.length;

  postProcess$1(state, state.delimiters);

  for (curr = 0; curr < max; curr++) {
    if (tokens_meta[curr] && tokens_meta[curr].delimiters) {
      postProcess$1(state, tokens_meta[curr].delimiters);
    }
  }
};

var strikethrough = {
	tokenize: tokenize$1,
	postProcess: postProcess_1$1
};

// Process *this* and _that_


// Insert each marker as a separate text token, and add it to delimiter list
//
var tokenize = function emphasis(state, silent) {
  var i, scanned, token,
      start = state.pos,
      marker = state.src.charCodeAt(start);

  if (silent) { return false; }

  if (marker !== 0x5F /* _ */ && marker !== 0x2A /* * */) { return false; }

  scanned = state.scanDelims(state.pos, marker === 0x2A);

  for (i = 0; i < scanned.length; i++) {
    token         = state.push('text', '', 0);
    token.content = String.fromCharCode(marker);

    state.delimiters.push({
      // Char code of the starting marker (number).
      //
      marker: marker,

      // Total length of these series of delimiters.
      //
      length: scanned.length,

      // An amount of characters before this one that's equivalent to
      // current one. In plain English: if this delimiter does not open
      // an emphasis, neither do previous `jump` characters.
      //
      // Used to skip sequences like "*****" in one step, for 1st asterisk
      // value will be 0, for 2nd it's 1 and so on.
      //
      jump:   i,

      // A position of the token this delimiter corresponds to.
      //
      token:  state.tokens.length - 1,

      // If this delimiter is matched as a valid opener, `end` will be
      // equal to its position, otherwise it's `-1`.
      //
      end:    -1,

      // Boolean flags that determine if this delimiter could open or close
      // an emphasis.
      //
      open:   scanned.can_open,
      close:  scanned.can_close
    });
  }

  state.pos += scanned.length;

  return true;
};


function postProcess(state, delimiters) {
  var i,
      startDelim,
      endDelim,
      token,
      ch,
      isStrong,
      max = delimiters.length;

  for (i = max - 1; i >= 0; i--) {
    startDelim = delimiters[i];

    if (startDelim.marker !== 0x5F/* _ */ && startDelim.marker !== 0x2A/* * */) {
      continue;
    }

    // Process only opening markers
    if (startDelim.end === -1) {
      continue;
    }

    endDelim = delimiters[startDelim.end];

    // If the previous delimiter has the same marker and is adjacent to this one,
    // merge those into one strong delimiter.
    //
    // `<em><em>whatever</em></em>` -> `<strong>whatever</strong>`
    //
    isStrong = i > 0 &&
               delimiters[i - 1].end === startDelim.end + 1 &&
               delimiters[i - 1].token === startDelim.token - 1 &&
               delimiters[startDelim.end + 1].token === endDelim.token + 1 &&
               delimiters[i - 1].marker === startDelim.marker;

    ch = String.fromCharCode(startDelim.marker);

    token         = state.tokens[startDelim.token];
    token.type    = isStrong ? 'strong_open' : 'em_open';
    token.tag     = isStrong ? 'strong' : 'em';
    token.nesting = 1;
    token.markup  = isStrong ? ch + ch : ch;
    token.content = '';

    token         = state.tokens[endDelim.token];
    token.type    = isStrong ? 'strong_close' : 'em_close';
    token.tag     = isStrong ? 'strong' : 'em';
    token.nesting = -1;
    token.markup  = isStrong ? ch + ch : ch;
    token.content = '';

    if (isStrong) {
      state.tokens[delimiters[i - 1].token].content = '';
      state.tokens[delimiters[startDelim.end + 1].token].content = '';
      i--;
    }
  }
}


// Walk through delimiter list and replace text tokens with tags
//
var postProcess_1 = function emphasis(state) {
  var curr,
      tokens_meta = state.tokens_meta,
      max = state.tokens_meta.length;

  postProcess(state, state.delimiters);

  for (curr = 0; curr < max; curr++) {
    if (tokens_meta[curr] && tokens_meta[curr].delimiters) {
      postProcess(state, tokens_meta[curr].delimiters);
    }
  }
};

var emphasis = {
	tokenize: tokenize,
	postProcess: postProcess_1
};

var normalizeReference$1   = utils.normalizeReference;
var isSpace$1              = utils.isSpace;


var link = function link(state, silent) {
  var attrs,
      code,
      label,
      labelEnd,
      labelStart,
      pos,
      res,
      ref,
      token,
      href = '',
      title = '',
      oldPos = state.pos,
      max = state.posMax,
      start = state.pos,
      parseReference = true;

  if (state.src.charCodeAt(state.pos) !== 0x5B/* [ */) { return false; }

  labelStart = state.pos + 1;
  labelEnd = state.md.helpers.parseLinkLabel(state, state.pos, true);

  // parser failed to find ']', so it's not a valid link
  if (labelEnd < 0) { return false; }

  pos = labelEnd + 1;
  if (pos < max && state.src.charCodeAt(pos) === 0x28/* ( */) {
    //
    // Inline link
    //

    // might have found a valid shortcut link, disable reference parsing
    parseReference = false;

    // [link](  <href>  "title"  )
    //        ^^ skipping these spaces
    pos++;
    for (; pos < max; pos++) {
      code = state.src.charCodeAt(pos);
      if (!isSpace$1(code) && code !== 0x0A) { break; }
    }
    if (pos >= max) { return false; }

    // [link](  <href>  "title"  )
    //          ^^^^^^ parsing link destination
    start = pos;
    res = state.md.helpers.parseLinkDestination(state.src, pos, state.posMax);
    if (res.ok) {
      href = state.md.normalizeLink(res.str);
      if (state.md.validateLink(href)) {
        pos = res.pos;
      } else {
        href = '';
      }

      // [link](  <href>  "title"  )
      //                ^^ skipping these spaces
      start = pos;
      for (; pos < max; pos++) {
        code = state.src.charCodeAt(pos);
        if (!isSpace$1(code) && code !== 0x0A) { break; }
      }

      // [link](  <href>  "title"  )
      //                  ^^^^^^^ parsing link title
      res = state.md.helpers.parseLinkTitle(state.src, pos, state.posMax);
      if (pos < max && start !== pos && res.ok) {
        title = res.str;
        pos = res.pos;

        // [link](  <href>  "title"  )
        //                         ^^ skipping these spaces
        for (; pos < max; pos++) {
          code = state.src.charCodeAt(pos);
          if (!isSpace$1(code) && code !== 0x0A) { break; }
        }
      }
    }

    if (pos >= max || state.src.charCodeAt(pos) !== 0x29/* ) */) {
      // parsing a valid shortcut link failed, fallback to reference
      parseReference = true;
    }
    pos++;
  }

  if (parseReference) {
    //
    // Link reference
    //
    if (typeof state.env.references === 'undefined') { return false; }

    if (pos < max && state.src.charCodeAt(pos) === 0x5B/* [ */) {
      start = pos + 1;
      pos = state.md.helpers.parseLinkLabel(state, pos);
      if (pos >= 0) {
        label = state.src.slice(start, pos++);
      } else {
        pos = labelEnd + 1;
      }
    } else {
      pos = labelEnd + 1;
    }

    // covers label === '' and label === undefined
    // (collapsed reference link and shortcut reference link respectively)
    if (!label) { label = state.src.slice(labelStart, labelEnd); }

    ref = state.env.references[normalizeReference$1(label)];
    if (!ref) {
      state.pos = oldPos;
      return false;
    }
    href = ref.href;
    title = ref.title;
  }

  //
  // We found the end of the link, and know for a fact it's a valid link;
  // so all that's left to do is to call tokenizer.
  //
  if (!silent) {
    state.pos = labelStart;
    state.posMax = labelEnd;

    token        = state.push('link_open', 'a', 1);
    token.attrs  = attrs = [ [ 'href', href ] ];
    if (title) {
      attrs.push([ 'title', title ]);
    }

    state.md.inline.tokenize(state);

    token        = state.push('link_close', 'a', -1);
  }

  state.pos = pos;
  state.posMax = max;
  return true;
};

var normalizeReference   = utils.normalizeReference;
var isSpace              = utils.isSpace;


var image = function image(state, silent) {
  var attrs,
      code,
      content,
      label,
      labelEnd,
      labelStart,
      pos,
      ref,
      res,
      title,
      token,
      tokens,
      start,
      href = '',
      oldPos = state.pos,
      max = state.posMax;

  if (state.src.charCodeAt(state.pos) !== 0x21/* ! */) { return false; }
  if (state.src.charCodeAt(state.pos + 1) !== 0x5B/* [ */) { return false; }

  labelStart = state.pos + 2;
  labelEnd = state.md.helpers.parseLinkLabel(state, state.pos + 1, false);

  // parser failed to find ']', so it's not a valid link
  if (labelEnd < 0) { return false; }

  pos = labelEnd + 1;
  if (pos < max && state.src.charCodeAt(pos) === 0x28/* ( */) {
    //
    // Inline link
    //

    // [link](  <href>  "title"  )
    //        ^^ skipping these spaces
    pos++;
    for (; pos < max; pos++) {
      code = state.src.charCodeAt(pos);
      if (!isSpace(code) && code !== 0x0A) { break; }
    }
    if (pos >= max) { return false; }

    // [link](  <href>  "title"  )
    //          ^^^^^^ parsing link destination
    start = pos;
    res = state.md.helpers.parseLinkDestination(state.src, pos, state.posMax);
    if (res.ok) {
      href = state.md.normalizeLink(res.str);
      if (state.md.validateLink(href)) {
        pos = res.pos;
      } else {
        href = '';
      }
    }

    // [link](  <href>  "title"  )
    //                ^^ skipping these spaces
    start = pos;
    for (; pos < max; pos++) {
      code = state.src.charCodeAt(pos);
      if (!isSpace(code) && code !== 0x0A) { break; }
    }

    // [link](  <href>  "title"  )
    //                  ^^^^^^^ parsing link title
    res = state.md.helpers.parseLinkTitle(state.src, pos, state.posMax);
    if (pos < max && start !== pos && res.ok) {
      title = res.str;
      pos = res.pos;

      // [link](  <href>  "title"  )
      //                         ^^ skipping these spaces
      for (; pos < max; pos++) {
        code = state.src.charCodeAt(pos);
        if (!isSpace(code) && code !== 0x0A) { break; }
      }
    } else {
      title = '';
    }

    if (pos >= max || state.src.charCodeAt(pos) !== 0x29/* ) */) {
      state.pos = oldPos;
      return false;
    }
    pos++;
  } else {
    //
    // Link reference
    //
    if (typeof state.env.references === 'undefined') { return false; }

    if (pos < max && state.src.charCodeAt(pos) === 0x5B/* [ */) {
      start = pos + 1;
      pos = state.md.helpers.parseLinkLabel(state, pos);
      if (pos >= 0) {
        label = state.src.slice(start, pos++);
      } else {
        pos = labelEnd + 1;
      }
    } else {
      pos = labelEnd + 1;
    }

    // covers label === '' and label === undefined
    // (collapsed reference link and shortcut reference link respectively)
    if (!label) { label = state.src.slice(labelStart, labelEnd); }

    ref = state.env.references[normalizeReference(label)];
    if (!ref) {
      state.pos = oldPos;
      return false;
    }
    href = ref.href;
    title = ref.title;
  }

  //
  // We found the end of the link, and know for a fact it's a valid link;
  // so all that's left to do is to call tokenizer.
  //
  if (!silent) {
    content = state.src.slice(labelStart, labelEnd);

    state.md.inline.parse(
      content,
      state.md,
      state.env,
      tokens = []
    );

    token          = state.push('image', 'img', 0);
    token.attrs    = attrs = [ [ 'src', href ], [ 'alt', '' ] ];
    token.children = tokens;
    token.content  = content;

    if (title) {
      attrs.push([ 'title', title ]);
    }
  }

  state.pos = pos;
  state.posMax = max;
  return true;
};

// Process autolinks '<protocol:...>'


/*eslint max-len:0*/
var EMAIL_RE    = /^([a-zA-Z0-9.!#$%&'*+\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*)$/;
var AUTOLINK_RE = /^([a-zA-Z][a-zA-Z0-9+.\-]{1,31}):([^<>\x00-\x20]*)$/;


var autolink = function autolink(state, silent) {
  var url, fullUrl, token, ch, start, max,
      pos = state.pos;

  if (state.src.charCodeAt(pos) !== 0x3C/* < */) { return false; }

  start = state.pos;
  max = state.posMax;

  for (;;) {
    if (++pos >= max) return false;

    ch = state.src.charCodeAt(pos);

    if (ch === 0x3C /* < */) return false;
    if (ch === 0x3E /* > */) break;
  }

  url = state.src.slice(start + 1, pos);

  if (AUTOLINK_RE.test(url)) {
    fullUrl = state.md.normalizeLink(url);
    if (!state.md.validateLink(fullUrl)) { return false; }

    if (!silent) {
      token         = state.push('link_open', 'a', 1);
      token.attrs   = [ [ 'href', fullUrl ] ];
      token.markup  = 'autolink';
      token.info    = 'auto';

      token         = state.push('text', '', 0);
      token.content = state.md.normalizeLinkText(url);

      token         = state.push('link_close', 'a', -1);
      token.markup  = 'autolink';
      token.info    = 'auto';
    }

    state.pos += url.length + 2;
    return true;
  }

  if (EMAIL_RE.test(url)) {
    fullUrl = state.md.normalizeLink('mailto:' + url);
    if (!state.md.validateLink(fullUrl)) { return false; }

    if (!silent) {
      token         = state.push('link_open', 'a', 1);
      token.attrs   = [ [ 'href', fullUrl ] ];
      token.markup  = 'autolink';
      token.info    = 'auto';

      token         = state.push('text', '', 0);
      token.content = state.md.normalizeLinkText(url);

      token         = state.push('link_close', 'a', -1);
      token.markup  = 'autolink';
      token.info    = 'auto';
    }

    state.pos += url.length + 2;
    return true;
  }

  return false;
};

var HTML_TAG_RE = html_re.HTML_TAG_RE;


function isLetter(ch) {
  /*eslint no-bitwise:0*/
  var lc = ch | 0x20; // to lower case
  return (lc >= 0x61/* a */) && (lc <= 0x7a/* z */);
}


var html_inline = function html_inline(state, silent) {
  var ch, match, max, token,
      pos = state.pos;

  if (!state.md.options.html) { return false; }

  // Check start
  max = state.posMax;
  if (state.src.charCodeAt(pos) !== 0x3C/* < */ ||
      pos + 2 >= max) {
    return false;
  }

  // Quick fail on second char
  ch = state.src.charCodeAt(pos + 1);
  if (ch !== 0x21/* ! */ &&
      ch !== 0x3F/* ? */ &&
      ch !== 0x2F/* / */ &&
      !isLetter(ch)) {
    return false;
  }

  match = state.src.slice(pos).match(HTML_TAG_RE);
  if (!match) { return false; }

  if (!silent) {
    token         = state.push('html_inline', '', 0);
    token.content = state.src.slice(pos, pos + match[0].length);
  }
  state.pos += match[0].length;
  return true;
};

var has               = utils.has;
var isValidEntityCode = utils.isValidEntityCode;
var fromCodePoint     = utils.fromCodePoint;


var DIGITAL_RE = /^&#((?:x[a-f0-9]{1,6}|[0-9]{1,7}));/i;
var NAMED_RE   = /^&([a-z][a-z0-9]{1,31});/i;


var entity = function entity(state, silent) {
  var ch, code, match, pos = state.pos, max = state.posMax;

  if (state.src.charCodeAt(pos) !== 0x26/* & */) { return false; }

  if (pos + 1 < max) {
    ch = state.src.charCodeAt(pos + 1);

    if (ch === 0x23 /* # */) {
      match = state.src.slice(pos).match(DIGITAL_RE);
      if (match) {
        if (!silent) {
          code = match[1][0].toLowerCase() === 'x' ? parseInt(match[1].slice(1), 16) : parseInt(match[1], 10);
          state.pending += isValidEntityCode(code) ? fromCodePoint(code) : fromCodePoint(0xFFFD);
        }
        state.pos += match[0].length;
        return true;
      }
    } else {
      match = state.src.slice(pos).match(NAMED_RE);
      if (match) {
        if (has(entities, match[1])) {
          if (!silent) { state.pending += entities[match[1]]; }
          state.pos += match[0].length;
          return true;
        }
      }
    }
  }

  if (!silent) { state.pending += '&'; }
  state.pos++;
  return true;
};

// For each opening emphasis-like marker find a matching closing one


function processDelimiters(state, delimiters) {
  var closerIdx, openerIdx, closer, opener, minOpenerIdx, newMinOpenerIdx,
      isOddMatch, lastJump,
      openersBottom = {},
      max = delimiters.length;

  for (closerIdx = 0; closerIdx < max; closerIdx++) {
    closer = delimiters[closerIdx];

    // Length is only used for emphasis-specific "rule of 3",
    // if it's not defined (in strikethrough or 3rd party plugins),
    // we can default it to 0 to disable those checks.
    //
    closer.length = closer.length || 0;

    if (!closer.close) continue;

    // Previously calculated lower bounds (previous fails)
    // for each marker and each delimiter length modulo 3.
    if (!openersBottom.hasOwnProperty(closer.marker)) {
      openersBottom[closer.marker] = [ -1, -1, -1 ];
    }

    minOpenerIdx = openersBottom[closer.marker][closer.length % 3];

    openerIdx = closerIdx - closer.jump - 1;

    // avoid crash if `closer.jump` is pointing outside of the array, see #742
    if (openerIdx < -1) openerIdx = -1;

    newMinOpenerIdx = openerIdx;

    for (; openerIdx > minOpenerIdx; openerIdx -= opener.jump + 1) {
      opener = delimiters[openerIdx];

      if (opener.marker !== closer.marker) continue;

      if (opener.open && opener.end < 0) {

        isOddMatch = false;

        // from spec:
        //
        // If one of the delimiters can both open and close emphasis, then the
        // sum of the lengths of the delimiter runs containing the opening and
        // closing delimiters must not be a multiple of 3 unless both lengths
        // are multiples of 3.
        //
        if (opener.close || closer.open) {
          if ((opener.length + closer.length) % 3 === 0) {
            if (opener.length % 3 !== 0 || closer.length % 3 !== 0) {
              isOddMatch = true;
            }
          }
        }

        if (!isOddMatch) {
          // If previous delimiter cannot be an opener, we can safely skip
          // the entire sequence in future checks. This is required to make
          // sure algorithm has linear complexity (see *_*_*_*_*_... case).
          //
          lastJump = openerIdx > 0 && !delimiters[openerIdx - 1].open ?
            delimiters[openerIdx - 1].jump + 1 :
            0;

          closer.jump  = closerIdx - openerIdx + lastJump;
          closer.open  = false;
          opener.end   = closerIdx;
          opener.jump  = lastJump;
          opener.close = false;
          newMinOpenerIdx = -1;
          break;
        }
      }
    }

    if (newMinOpenerIdx !== -1) {
      // If match for this delimiter run failed, we want to set lower bound for
      // future lookups. This is required to make sure algorithm has linear
      // complexity.
      //
      // See details here:
      // https://github.com/commonmark/cmark/issues/178#issuecomment-270417442
      //
      openersBottom[closer.marker][(closer.length || 0) % 3] = newMinOpenerIdx;
    }
  }
}


var balance_pairs = function link_pairs(state) {
  var curr,
      tokens_meta = state.tokens_meta,
      max = state.tokens_meta.length;

  processDelimiters(state, state.delimiters);

  for (curr = 0; curr < max; curr++) {
    if (tokens_meta[curr] && tokens_meta[curr].delimiters) {
      processDelimiters(state, tokens_meta[curr].delimiters);
    }
  }
};

// Clean up tokens after emphasis and strikethrough postprocessing:


var text_collapse = function text_collapse(state) {
  var curr, last,
      level = 0,
      tokens = state.tokens,
      max = state.tokens.length;

  for (curr = last = 0; curr < max; curr++) {
    // re-calculate levels after emphasis/strikethrough turns some text nodes
    // into opening/closing tags
    if (tokens[curr].nesting < 0) level--; // closing tag
    tokens[curr].level = level;
    if (tokens[curr].nesting > 0) level++; // opening tag

    if (tokens[curr].type === 'text' &&
        curr + 1 < max &&
        tokens[curr + 1].type === 'text') {

      // collapse two adjacent text nodes
      tokens[curr + 1].content = tokens[curr].content + tokens[curr + 1].content;
    } else {
      if (curr !== last) { tokens[last] = tokens[curr]; }

      last++;
    }
  }

  if (curr !== last) {
    tokens.length = last;
  }
};

var isWhiteSpace   = utils.isWhiteSpace;
var isPunctChar    = utils.isPunctChar;
var isMdAsciiPunct = utils.isMdAsciiPunct;


function StateInline(src, md, env, outTokens) {
  this.src = src;
  this.env = env;
  this.md = md;
  this.tokens = outTokens;
  this.tokens_meta = Array(outTokens.length);

  this.pos = 0;
  this.posMax = this.src.length;
  this.level = 0;
  this.pending = '';
  this.pendingLevel = 0;

  // Stores { start: end } pairs. Useful for backtrack
  // optimization of pairs parse (emphasis, strikes).
  this.cache = {};

  // List of emphasis-like delimiters for current tag
  this.delimiters = [];

  // Stack of delimiter lists for upper level tags
  this._prev_delimiters = [];

  // backtick length => last seen position
  this.backticks = {};
  this.backticksScanned = false;
}


// Flush pending text
//
StateInline.prototype.pushPending = function () {
  var token$1 = new token('text', '', 0);
  token$1.content = this.pending;
  token$1.level = this.pendingLevel;
  this.tokens.push(token$1);
  this.pending = '';
  return token$1;
};


// Push new token to "stream".
// If pending text exists - flush it as text token
//
StateInline.prototype.push = function (type, tag, nesting) {
  if (this.pending) {
    this.pushPending();
  }

  var token$1 = new token(type, tag, nesting);
  var token_meta = null;

  if (nesting < 0) {
    // closing tag
    this.level--;
    this.delimiters = this._prev_delimiters.pop();
  }

  token$1.level = this.level;

  if (nesting > 0) {
    // opening tag
    this.level++;
    this._prev_delimiters.push(this.delimiters);
    this.delimiters = [];
    token_meta = { delimiters: this.delimiters };
  }

  this.pendingLevel = this.level;
  this.tokens.push(token$1);
  this.tokens_meta.push(token_meta);
  return token$1;
};


// Scan a sequence of emphasis-like markers, and determine whether
// it can start an emphasis sequence or end an emphasis sequence.
//
//  - start - position to scan from (it should point at a valid marker);
//  - canSplitWord - determine if these markers can be found inside a word
//
StateInline.prototype.scanDelims = function (start, canSplitWord) {
  var pos = start, lastChar, nextChar, count, can_open, can_close,
      isLastWhiteSpace, isLastPunctChar,
      isNextWhiteSpace, isNextPunctChar,
      left_flanking = true,
      right_flanking = true,
      max = this.posMax,
      marker = this.src.charCodeAt(start);

  // treat beginning of the line as a whitespace
  lastChar = start > 0 ? this.src.charCodeAt(start - 1) : 0x20;

  while (pos < max && this.src.charCodeAt(pos) === marker) { pos++; }

  count = pos - start;

  // treat end of the line as a whitespace
  nextChar = pos < max ? this.src.charCodeAt(pos) : 0x20;

  isLastPunctChar = isMdAsciiPunct(lastChar) || isPunctChar(String.fromCharCode(lastChar));
  isNextPunctChar = isMdAsciiPunct(nextChar) || isPunctChar(String.fromCharCode(nextChar));

  isLastWhiteSpace = isWhiteSpace(lastChar);
  isNextWhiteSpace = isWhiteSpace(nextChar);

  if (isNextWhiteSpace) {
    left_flanking = false;
  } else if (isNextPunctChar) {
    if (!(isLastWhiteSpace || isLastPunctChar)) {
      left_flanking = false;
    }
  }

  if (isLastWhiteSpace) {
    right_flanking = false;
  } else if (isLastPunctChar) {
    if (!(isNextWhiteSpace || isNextPunctChar)) {
      right_flanking = false;
    }
  }

  if (!canSplitWord) {
    can_open  = left_flanking  && (!right_flanking || isLastPunctChar);
    can_close = right_flanking && (!left_flanking  || isNextPunctChar);
  } else {
    can_open  = left_flanking;
    can_close = right_flanking;
  }

  return {
    can_open:  can_open,
    can_close: can_close,
    length:    count
  };
};


// re-export Token class to use in block rules
StateInline.prototype.Token = token;


var state_inline = StateInline;

/** internal
 * class ParserInline
 *
 * Tokenizes paragraph content.
 **/





////////////////////////////////////////////////////////////////////////////////
// Parser rules

var _rules = [
  [ 'text',            text ],
  [ 'newline',         newline ],
  [ 'escape',          _escape ],
  [ 'backticks',       backticks ],
  [ 'strikethrough',   strikethrough.tokenize ],
  [ 'emphasis',        emphasis.tokenize ],
  [ 'link',            link ],
  [ 'image',           image ],
  [ 'autolink',        autolink ],
  [ 'html_inline',     html_inline ],
  [ 'entity',          entity ]
];

var _rules2 = [
  [ 'balance_pairs',   balance_pairs ],
  [ 'strikethrough',   strikethrough.postProcess ],
  [ 'emphasis',        emphasis.postProcess ],
  [ 'text_collapse',   text_collapse ]
];


/**
 * new ParserInline()
 **/
function ParserInline() {
  var i;

  /**
   * ParserInline#ruler -> Ruler
   *
   * [[Ruler]] instance. Keep configuration of inline rules.
   **/
  this.ruler = new ruler();

  for (i = 0; i < _rules.length; i++) {
    this.ruler.push(_rules[i][0], _rules[i][1]);
  }

  /**
   * ParserInline#ruler2 -> Ruler
   *
   * [[Ruler]] instance. Second ruler used for post-processing
   * (e.g. in emphasis-like rules).
   **/
  this.ruler2 = new ruler();

  for (i = 0; i < _rules2.length; i++) {
    this.ruler2.push(_rules2[i][0], _rules2[i][1]);
  }
}


// Skip single token by running all rules in validation mode;
// returns `true` if any rule reported success
//
ParserInline.prototype.skipToken = function (state) {
  var ok, i, pos = state.pos,
      rules = this.ruler.getRules(''),
      len = rules.length,
      maxNesting = state.md.options.maxNesting,
      cache = state.cache;


  if (typeof cache[pos] !== 'undefined') {
    state.pos = cache[pos];
    return;
  }

  if (state.level < maxNesting) {
    for (i = 0; i < len; i++) {
      // Increment state.level and decrement it later to limit recursion.
      // It's harmless to do here, because no tokens are created. But ideally,
      // we'd need a separate private state variable for this purpose.
      //
      state.level++;
      ok = rules[i](state, true);
      state.level--;

      if (ok) { break; }
    }
  } else {
    // Too much nesting, just skip until the end of the paragraph.
    //
    // NOTE: this will cause links to behave incorrectly in the following case,
    //       when an amount of `[` is exactly equal to `maxNesting + 1`:
    //
    //       [[[[[[[[[[[[[[[[[[[[[foo]()
    //
    // TODO: remove this workaround when CM standard will allow nested links
    //       (we can replace it by preventing links from being parsed in
    //       validation mode)
    //
    state.pos = state.posMax;
  }

  if (!ok) { state.pos++; }
  cache[pos] = state.pos;
};


// Generate tokens for input range
//
ParserInline.prototype.tokenize = function (state) {
  var ok, i,
      rules = this.ruler.getRules(''),
      len = rules.length,
      end = state.posMax,
      maxNesting = state.md.options.maxNesting;

  while (state.pos < end) {
    // Try all possible rules.
    // On success, rule should:
    //
    // - update `state.pos`
    // - update `state.tokens`
    // - return true

    if (state.level < maxNesting) {
      for (i = 0; i < len; i++) {
        ok = rules[i](state, false);
        if (ok) { break; }
      }
    }

    if (ok) {
      if (state.pos >= end) { break; }
      continue;
    }

    state.pending += state.src[state.pos++];
  }

  if (state.pending) {
    state.pushPending();
  }
};


/**
 * ParserInline.parse(str, md, env, outTokens)
 *
 * Process input string and push inline tokens into `outTokens`
 **/
ParserInline.prototype.parse = function (str, md, env, outTokens) {
  var i, rules, len;
  var state = new this.State(str, md, env, outTokens);

  this.tokenize(state);

  rules = this.ruler2.getRules('');
  len = rules.length;

  for (i = 0; i < len; i++) {
    rules[i](state);
  }
};


ParserInline.prototype.State = state_inline;


var parser_inline = ParserInline;

var re = function (opts) {
  var re = {};

  // Use direct extract instead of `regenerate` to reduse browserified size
  re.src_Any = regex$3.source;
  re.src_Cc  = regex$2.source;
  re.src_Z   = regex.source;
  re.src_P   = regex$4.source;

  // \p{\Z\P\Cc\CF} (white spaces + control + format + punctuation)
  re.src_ZPCc = [ re.src_Z, re.src_P, re.src_Cc ].join('|');

  // \p{\Z\Cc} (white spaces + control)
  re.src_ZCc = [ re.src_Z, re.src_Cc ].join('|');

  // Experimental. List of chars, completely prohibited in links
  // because can separate it from other part of text
  var text_separators = '[><\uff5c]';

  // All possible word characters (everything without punctuation, spaces & controls)
  // Defined via punctuation & spaces to save space
  // Should be something like \p{\L\N\S\M} (\w but without `_`)
  re.src_pseudo_letter       = '(?:(?!' + text_separators + '|' + re.src_ZPCc + ')' + re.src_Any + ')';
  // The same as abothe but without [0-9]
  // var src_pseudo_letter_non_d = '(?:(?![0-9]|' + src_ZPCc + ')' + src_Any + ')';

  ////////////////////////////////////////////////////////////////////////////////

  re.src_ip4 =

    '(?:(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)';

  // Prohibit any of "@/[]()" in user/pass to avoid wrong domain fetch.
  re.src_auth    = '(?:(?:(?!' + re.src_ZCc + '|[@/\\[\\]()]).)+@)?';

  re.src_port =

    '(?::(?:6(?:[0-4]\\d{3}|5(?:[0-4]\\d{2}|5(?:[0-2]\\d|3[0-5])))|[1-5]?\\d{1,4}))?';

  re.src_host_terminator =

    '(?=$|' + text_separators + '|' + re.src_ZPCc + ')(?!-|_|:\\d|\\.-|\\.(?!$|' + re.src_ZPCc + '))';

  re.src_path =

    '(?:' +
      '[/?#]' +
        '(?:' +
          '(?!' + re.src_ZCc + '|' + text_separators + '|[()[\\]{}.,"\'?!\\-]).|' +
          '\\[(?:(?!' + re.src_ZCc + '|\\]).)*\\]|' +
          '\\((?:(?!' + re.src_ZCc + '|[)]).)*\\)|' +
          '\\{(?:(?!' + re.src_ZCc + '|[}]).)*\\}|' +
          '\\"(?:(?!' + re.src_ZCc + '|["]).)+\\"|' +
          "\\'(?:(?!" + re.src_ZCc + "|[']).)+\\'|" +
          "\\'(?=" + re.src_pseudo_letter + '|[-]).|' +  // allow `I'm_king` if no pair found
          '\\.{2,}[a-zA-Z0-9%/&]|' + // google has many dots in "google search" links (#66, #81).
                                     // github has ... in commit range links,
                                     // Restrict to
                                     // - english
                                     // - percent-encoded
                                     // - parts of file path
                                     // - params separator
                                     // until more examples found.
          '\\.(?!' + re.src_ZCc + '|[.]).|' +
          (opts && opts['---'] ?
            '\\-(?!--(?:[^-]|$))(?:-*)|' // `---` => long dash, terminate
            :
            '\\-+|'
          ) +
          '\\,(?!' + re.src_ZCc + ').|' +       // allow `,,,` in paths
          '\\!+(?!' + re.src_ZCc + '|[!]).|' +  // allow `!!!` in paths, but not at the end
          '\\?(?!' + re.src_ZCc + '|[?]).' +
        ')+' +
      '|\\/' +
    ')?';

  // Allow anything in markdown spec, forbid quote (") at the first position
  // because emails enclosed in quotes are far more common
  re.src_email_name =

    '[\\-;:&=\\+\\$,\\.a-zA-Z0-9_][\\-;:&=\\+\\$,\\"\\.a-zA-Z0-9_]*';

  re.src_xn =

    'xn--[a-z0-9\\-]{1,59}';

  // More to read about domain names
  // http://serverfault.com/questions/638260/

  re.src_domain_root =

    // Allow letters & digits (http://test1)
    '(?:' +
      re.src_xn +
      '|' +
      re.src_pseudo_letter + '{1,63}' +
    ')';

  re.src_domain =

    '(?:' +
      re.src_xn +
      '|' +
      '(?:' + re.src_pseudo_letter + ')' +
      '|' +
      '(?:' + re.src_pseudo_letter + '(?:-|' + re.src_pseudo_letter + '){0,61}' + re.src_pseudo_letter + ')' +
    ')';

  re.src_host =

    '(?:' +
    // Don't need IP check, because digits are already allowed in normal domain names
    //   src_ip4 +
    // '|' +
      '(?:(?:(?:' + re.src_domain + ')\\.)*' + re.src_domain/*_root*/ + ')' +
    ')';

  re.tpl_host_fuzzy =

    '(?:' +
      re.src_ip4 +
    '|' +
      '(?:(?:(?:' + re.src_domain + ')\\.)+(?:%TLDS%))' +
    ')';

  re.tpl_host_no_ip_fuzzy =

    '(?:(?:(?:' + re.src_domain + ')\\.)+(?:%TLDS%))';

  re.src_host_strict =

    re.src_host + re.src_host_terminator;

  re.tpl_host_fuzzy_strict =

    re.tpl_host_fuzzy + re.src_host_terminator;

  re.src_host_port_strict =

    re.src_host + re.src_port + re.src_host_terminator;

  re.tpl_host_port_fuzzy_strict =

    re.tpl_host_fuzzy + re.src_port + re.src_host_terminator;

  re.tpl_host_port_no_ip_fuzzy_strict =

    re.tpl_host_no_ip_fuzzy + re.src_port + re.src_host_terminator;


  ////////////////////////////////////////////////////////////////////////////////
  // Main rules

  // Rude test fuzzy links by host, for quick deny
  re.tpl_host_fuzzy_test =

    'localhost|www\\.|\\.\\d{1,3}\\.|(?:\\.(?:%TLDS%)(?:' + re.src_ZPCc + '|>|$))';

  re.tpl_email_fuzzy =

      '(^|' + text_separators + '|"|\\(|' + re.src_ZCc + ')' +
      '(' + re.src_email_name + '@' + re.tpl_host_fuzzy_strict + ')';

  re.tpl_link_fuzzy =
      // Fuzzy link can't be prepended with .:/\- and non punctuation.
      // but can start with > (markdown blockquote)
      '(^|(?![.:/\\-_@])(?:[$+<=>^`|\uff5c]|' + re.src_ZPCc + '))' +
      '((?![$+<=>^`|\uff5c])' + re.tpl_host_port_fuzzy_strict + re.src_path + ')';

  re.tpl_link_no_ip_fuzzy =
      // Fuzzy link can't be prepended with .:/\- and non punctuation.
      // but can start with > (markdown blockquote)
      '(^|(?![.:/\\-_@])(?:[$+<=>^`|\uff5c]|' + re.src_ZPCc + '))' +
      '((?![$+<=>^`|\uff5c])' + re.tpl_host_port_no_ip_fuzzy_strict + re.src_path + ')';

  return re;
};

////////////////////////////////////////////////////////////////////////////////
// Helpers

// Merge objects
//
function assign(obj /*from1, from2, from3, ...*/) {
  var sources = Array.prototype.slice.call(arguments, 1);

  sources.forEach(function (source) {
    if (!source) { return; }

    Object.keys(source).forEach(function (key) {
      obj[key] = source[key];
    });
  });

  return obj;
}

function _class(obj) { return Object.prototype.toString.call(obj); }
function isString(obj) { return _class(obj) === '[object String]'; }
function isObject(obj) { return _class(obj) === '[object Object]'; }
function isRegExp(obj) { return _class(obj) === '[object RegExp]'; }
function isFunction(obj) { return _class(obj) === '[object Function]'; }


function escapeRE(str) { return str.replace(/[.?*+^$[\]\\(){}|-]/g, '\\$&'); }

////////////////////////////////////////////////////////////////////////////////


var defaultOptions = {
  fuzzyLink: true,
  fuzzyEmail: true,
  fuzzyIP: false
};


function isOptionsObj(obj) {
  return Object.keys(obj || {}).reduce(function (acc, k) {
    return acc || defaultOptions.hasOwnProperty(k);
  }, false);
}


var defaultSchemas = {
  'http:': {
    validate: function (text, pos, self) {
      var tail = text.slice(pos);

      if (!self.re.http) {
        // compile lazily, because "host"-containing variables can change on tlds update.
        self.re.http =  new RegExp(
          '^\\/\\/' + self.re.src_auth + self.re.src_host_port_strict + self.re.src_path, 'i'
        );
      }
      if (self.re.http.test(tail)) {
        return tail.match(self.re.http)[0].length;
      }
      return 0;
    }
  },
  'https:':  'http:',
  'ftp:':    'http:',
  '//':      {
    validate: function (text, pos, self) {
      var tail = text.slice(pos);

      if (!self.re.no_http) {
      // compile lazily, because "host"-containing variables can change on tlds update.
        self.re.no_http =  new RegExp(
          '^' +
          self.re.src_auth +
          // Don't allow single-level domains, because of false positives like '//test'
          // with code comments
          '(?:localhost|(?:(?:' + self.re.src_domain + ')\\.)+' + self.re.src_domain_root + ')' +
          self.re.src_port +
          self.re.src_host_terminator +
          self.re.src_path,

          'i'
        );
      }

      if (self.re.no_http.test(tail)) {
        // should not be `://` & `///`, that protects from errors in protocol name
        if (pos >= 3 && text[pos - 3] === ':') { return 0; }
        if (pos >= 3 && text[pos - 3] === '/') { return 0; }
        return tail.match(self.re.no_http)[0].length;
      }
      return 0;
    }
  },
  'mailto:': {
    validate: function (text, pos, self) {
      var tail = text.slice(pos);

      if (!self.re.mailto) {
        self.re.mailto =  new RegExp(
          '^' + self.re.src_email_name + '@' + self.re.src_host_strict, 'i'
        );
      }
      if (self.re.mailto.test(tail)) {
        return tail.match(self.re.mailto)[0].length;
      }
      return 0;
    }
  }
};

/*eslint-disable max-len*/

// RE pattern for 2-character tlds (autogenerated by ./support/tlds_2char_gen.js)
var tlds_2ch_src_re = 'a[cdefgilmnoqrstuwxz]|b[abdefghijmnorstvwyz]|c[acdfghiklmnoruvwxyz]|d[ejkmoz]|e[cegrstu]|f[ijkmor]|g[abdefghilmnpqrstuwy]|h[kmnrtu]|i[delmnoqrst]|j[emop]|k[eghimnprwyz]|l[abcikrstuvy]|m[acdeghklmnopqrstuvwxyz]|n[acefgilopruz]|om|p[aefghklmnrstwy]|qa|r[eosuw]|s[abcdeghijklmnortuvxyz]|t[cdfghjklmnortvwz]|u[agksyz]|v[aceginu]|w[fs]|y[et]|z[amw]';

// DON'T try to make PRs with changes. Extend TLDs with LinkifyIt.tlds() instead
var tlds_default = 'biz|com|edu|gov|net|org|pro|web|xxx|aero|asia|coop|info|museum|name|shop|рф'.split('|');

/*eslint-enable max-len*/

////////////////////////////////////////////////////////////////////////////////

function resetScanCache(self) {
  self.__index__ = -1;
  self.__text_cache__   = '';
}

function createValidator(re) {
  return function (text, pos) {
    var tail = text.slice(pos);

    if (re.test(tail)) {
      return tail.match(re)[0].length;
    }
    return 0;
  };
}

function createNormalizer() {
  return function (match, self) {
    self.normalize(match);
  };
}

// Schemas compiler. Build regexps.
//
function compile(self) {

  // Load & clone RE patterns.
  var re$1 = self.re = re(self.__opts__);

  // Define dynamic patterns
  var tlds = self.__tlds__.slice();

  self.onCompile();

  if (!self.__tlds_replaced__) {
    tlds.push(tlds_2ch_src_re);
  }
  tlds.push(re$1.src_xn);

  re$1.src_tlds = tlds.join('|');

  function untpl(tpl) { return tpl.replace('%TLDS%', re$1.src_tlds); }

  re$1.email_fuzzy      = RegExp(untpl(re$1.tpl_email_fuzzy), 'i');
  re$1.link_fuzzy       = RegExp(untpl(re$1.tpl_link_fuzzy), 'i');
  re$1.link_no_ip_fuzzy = RegExp(untpl(re$1.tpl_link_no_ip_fuzzy), 'i');
  re$1.host_fuzzy_test  = RegExp(untpl(re$1.tpl_host_fuzzy_test), 'i');

  //
  // Compile each schema
  //

  var aliases = [];

  self.__compiled__ = {}; // Reset compiled data

  function schemaError(name, val) {
    throw new Error('(LinkifyIt) Invalid schema "' + name + '": ' + val);
  }

  Object.keys(self.__schemas__).forEach(function (name) {
    var val = self.__schemas__[name];

    // skip disabled methods
    if (val === null) { return; }

    var compiled = { validate: null, link: null };

    self.__compiled__[name] = compiled;

    if (isObject(val)) {
      if (isRegExp(val.validate)) {
        compiled.validate = createValidator(val.validate);
      } else if (isFunction(val.validate)) {
        compiled.validate = val.validate;
      } else {
        schemaError(name, val);
      }

      if (isFunction(val.normalize)) {
        compiled.normalize = val.normalize;
      } else if (!val.normalize) {
        compiled.normalize = createNormalizer();
      } else {
        schemaError(name, val);
      }

      return;
    }

    if (isString(val)) {
      aliases.push(name);
      return;
    }

    schemaError(name, val);
  });

  //
  // Compile postponed aliases
  //

  aliases.forEach(function (alias) {
    if (!self.__compiled__[self.__schemas__[alias]]) {
      // Silently fail on missed schemas to avoid errons on disable.
      // schemaError(alias, self.__schemas__[alias]);
      return;
    }

    self.__compiled__[alias].validate =
      self.__compiled__[self.__schemas__[alias]].validate;
    self.__compiled__[alias].normalize =
      self.__compiled__[self.__schemas__[alias]].normalize;
  });

  //
  // Fake record for guessed links
  //
  self.__compiled__[''] = { validate: null, normalize: createNormalizer() };

  //
  // Build schema condition
  //
  var slist = Object.keys(self.__compiled__)
                      .filter(function (name) {
                        // Filter disabled & fake schemas
                        return name.length > 0 && self.__compiled__[name];
                      })
                      .map(escapeRE)
                      .join('|');
  // (?!_) cause 1.5x slowdown
  self.re.schema_test   = RegExp('(^|(?!_)(?:[><\uff5c]|' + re$1.src_ZPCc + '))(' + slist + ')', 'i');
  self.re.schema_search = RegExp('(^|(?!_)(?:[><\uff5c]|' + re$1.src_ZPCc + '))(' + slist + ')', 'ig');

  self.re.pretest = RegExp(
    '(' + self.re.schema_test.source + ')|(' + self.re.host_fuzzy_test.source + ')|@',
    'i'
  );

  //
  // Cleanup
  //

  resetScanCache(self);
}

/**
 * class Match
 *
 * Match result. Single element of array, returned by [[LinkifyIt#match]]
 **/
function Match(self, shift) {
  var start = self.__index__,
      end   = self.__last_index__,
      text  = self.__text_cache__.slice(start, end);

  /**
   * Match#schema -> String
   *
   * Prefix (protocol) for matched string.
   **/
  this.schema    = self.__schema__.toLowerCase();
  /**
   * Match#index -> Number
   *
   * First position of matched string.
   **/
  this.index     = start + shift;
  /**
   * Match#lastIndex -> Number
   *
   * Next position after matched string.
   **/
  this.lastIndex = end + shift;
  /**
   * Match#raw -> String
   *
   * Matched string.
   **/
  this.raw       = text;
  /**
   * Match#text -> String
   *
   * Notmalized text of matched string.
   **/
  this.text      = text;
  /**
   * Match#url -> String
   *
   * Normalized url of matched string.
   **/
  this.url       = text;
}

function createMatch(self, shift) {
  var match = new Match(self, shift);

  self.__compiled__[match.schema].normalize(match, self);

  return match;
}


/**
 * class LinkifyIt
 **/

/**
 * new LinkifyIt(schemas, options)
 * - schemas (Object): Optional. Additional schemas to validate (prefix/validator)
 * - options (Object): { fuzzyLink|fuzzyEmail|fuzzyIP: true|false }
 *
 * Creates new linkifier instance with optional additional schemas.
 * Can be called without `new` keyword for convenience.
 *
 * By default understands:
 *
 * - `http(s)://...` , `ftp://...`, `mailto:...` & `//...` links
 * - "fuzzy" links and emails (example.com, foo@bar.com).
 *
 * `schemas` is an object, where each key/value describes protocol/rule:
 *
 * - __key__ - link prefix (usually, protocol name with `:` at the end, `skype:`
 *   for example). `linkify-it` makes shure that prefix is not preceeded with
 *   alphanumeric char and symbols. Only whitespaces and punctuation allowed.
 * - __value__ - rule to check tail after link prefix
 *   - _String_ - just alias to existing rule
 *   - _Object_
 *     - _validate_ - validator function (should return matched length on success),
 *       or `RegExp`.
 *     - _normalize_ - optional function to normalize text & url of matched result
 *       (for example, for @twitter mentions).
 *
 * `options`:
 *
 * - __fuzzyLink__ - recognige URL-s without `http(s):` prefix. Default `true`.
 * - __fuzzyIP__ - allow IPs in fuzzy links above. Can conflict with some texts
 *   like version numbers. Default `false`.
 * - __fuzzyEmail__ - recognize emails without `mailto:` prefix.
 *
 **/
function LinkifyIt(schemas, options) {
  if (!(this instanceof LinkifyIt)) {
    return new LinkifyIt(schemas, options);
  }

  if (!options) {
    if (isOptionsObj(schemas)) {
      options = schemas;
      schemas = {};
    }
  }

  this.__opts__           = assign({}, defaultOptions, options);

  // Cache last tested result. Used to skip repeating steps on next `match` call.
  this.__index__          = -1;
  this.__last_index__     = -1; // Next scan position
  this.__schema__         = '';
  this.__text_cache__     = '';

  this.__schemas__        = assign({}, defaultSchemas, schemas);
  this.__compiled__       = {};

  this.__tlds__           = tlds_default;
  this.__tlds_replaced__  = false;

  this.re = {};

  compile(this);
}


/** chainable
 * LinkifyIt#add(schema, definition)
 * - schema (String): rule name (fixed pattern prefix)
 * - definition (String|RegExp|Object): schema definition
 *
 * Add new rule definition. See constructor description for details.
 **/
LinkifyIt.prototype.add = function add(schema, definition) {
  this.__schemas__[schema] = definition;
  compile(this);
  return this;
};


/** chainable
 * LinkifyIt#set(options)
 * - options (Object): { fuzzyLink|fuzzyEmail|fuzzyIP: true|false }
 *
 * Set recognition options for links without schema.
 **/
LinkifyIt.prototype.set = function set(options) {
  this.__opts__ = assign(this.__opts__, options);
  return this;
};


/**
 * LinkifyIt#test(text) -> Boolean
 *
 * Searches linkifiable pattern and returns `true` on success or `false` on fail.
 **/
LinkifyIt.prototype.test = function test(text) {
  // Reset scan cache
  this.__text_cache__ = text;
  this.__index__      = -1;

  if (!text.length) { return false; }

  var m, ml, me, len, shift, next, re, tld_pos, at_pos;

  // try to scan for link with schema - that's the most simple rule
  if (this.re.schema_test.test(text)) {
    re = this.re.schema_search;
    re.lastIndex = 0;
    while ((m = re.exec(text)) !== null) {
      len = this.testSchemaAt(text, m[2], re.lastIndex);
      if (len) {
        this.__schema__     = m[2];
        this.__index__      = m.index + m[1].length;
        this.__last_index__ = m.index + m[0].length + len;
        break;
      }
    }
  }

  if (this.__opts__.fuzzyLink && this.__compiled__['http:']) {
    // guess schemaless links
    tld_pos = text.search(this.re.host_fuzzy_test);
    if (tld_pos >= 0) {
      // if tld is located after found link - no need to check fuzzy pattern
      if (this.__index__ < 0 || tld_pos < this.__index__) {
        if ((ml = text.match(this.__opts__.fuzzyIP ? this.re.link_fuzzy : this.re.link_no_ip_fuzzy)) !== null) {

          shift = ml.index + ml[1].length;

          if (this.__index__ < 0 || shift < this.__index__) {
            this.__schema__     = '';
            this.__index__      = shift;
            this.__last_index__ = ml.index + ml[0].length;
          }
        }
      }
    }
  }

  if (this.__opts__.fuzzyEmail && this.__compiled__['mailto:']) {
    // guess schemaless emails
    at_pos = text.indexOf('@');
    if (at_pos >= 0) {
      // We can't skip this check, because this cases are possible:
      // 192.168.1.1@gmail.com, my.in@example.com
      if ((me = text.match(this.re.email_fuzzy)) !== null) {

        shift = me.index + me[1].length;
        next  = me.index + me[0].length;

        if (this.__index__ < 0 || shift < this.__index__ ||
            (shift === this.__index__ && next > this.__last_index__)) {
          this.__schema__     = 'mailto:';
          this.__index__      = shift;
          this.__last_index__ = next;
        }
      }
    }
  }

  return this.__index__ >= 0;
};


/**
 * LinkifyIt#pretest(text) -> Boolean
 *
 * Very quick check, that can give false positives. Returns true if link MAY BE
 * can exists. Can be used for speed optimization, when you need to check that
 * link NOT exists.
 **/
LinkifyIt.prototype.pretest = function pretest(text) {
  return this.re.pretest.test(text);
};


/**
 * LinkifyIt#testSchemaAt(text, name, position) -> Number
 * - text (String): text to scan
 * - name (String): rule (schema) name
 * - position (Number): text offset to check from
 *
 * Similar to [[LinkifyIt#test]] but checks only specific protocol tail exactly
 * at given position. Returns length of found pattern (0 on fail).
 **/
LinkifyIt.prototype.testSchemaAt = function testSchemaAt(text, schema, pos) {
  // If not supported schema check requested - terminate
  if (!this.__compiled__[schema.toLowerCase()]) {
    return 0;
  }
  return this.__compiled__[schema.toLowerCase()].validate(text, pos, this);
};


/**
 * LinkifyIt#match(text) -> Array|null
 *
 * Returns array of found link descriptions or `null` on fail. We strongly
 * recommend to use [[LinkifyIt#test]] first, for best speed.
 *
 * ##### Result match description
 *
 * - __schema__ - link schema, can be empty for fuzzy links, or `//` for
 *   protocol-neutral  links.
 * - __index__ - offset of matched text
 * - __lastIndex__ - index of next char after mathch end
 * - __raw__ - matched text
 * - __text__ - normalized text
 * - __url__ - link, generated from matched text
 **/
LinkifyIt.prototype.match = function match(text) {
  var shift = 0, result = [];

  // Try to take previous element from cache, if .test() called before
  if (this.__index__ >= 0 && this.__text_cache__ === text) {
    result.push(createMatch(this, shift));
    shift = this.__last_index__;
  }

  // Cut head if cache was used
  var tail = shift ? text.slice(shift) : text;

  // Scan string until end reached
  while (this.test(tail)) {
    result.push(createMatch(this, shift));

    tail = tail.slice(this.__last_index__);
    shift += this.__last_index__;
  }

  if (result.length) {
    return result;
  }

  return null;
};


/** chainable
 * LinkifyIt#tlds(list [, keepOld]) -> this
 * - list (Array): list of tlds
 * - keepOld (Boolean): merge with current list if `true` (`false` by default)
 *
 * Load (or merge) new tlds list. Those are user for fuzzy links (without prefix)
 * to avoid false positives. By default this algorythm used:
 *
 * - hostname with any 2-letter root zones are ok.
 * - biz|com|edu|gov|net|org|pro|web|xxx|aero|asia|coop|info|museum|name|shop|рф
 *   are ok.
 * - encoded (`xn--...`) root zones are ok.
 *
 * If list is replaced, then exact match for 2-chars root zones will be checked.
 **/
LinkifyIt.prototype.tlds = function tlds(list, keepOld) {
  list = Array.isArray(list) ? list : [ list ];

  if (!keepOld) {
    this.__tlds__ = list.slice();
    this.__tlds_replaced__ = true;
    compile(this);
    return this;
  }

  this.__tlds__ = this.__tlds__.concat(list)
                                  .sort()
                                  .filter(function (el, idx, arr) {
                                    return el !== arr[idx - 1];
                                  })
                                  .reverse();

  compile(this);
  return this;
};

/**
 * LinkifyIt#normalize(match)
 *
 * Default normalizer (if schema does not define it's own).
 **/
LinkifyIt.prototype.normalize = function normalize(match) {

  // Do minimal possible changes by default. Need to collect feedback prior
  // to move forward https://github.com/markdown-it/linkify-it/issues/1

  if (!match.schema) { match.url = 'http://' + match.url; }

  if (match.schema === 'mailto:' && !/^mailto:/i.test(match.url)) {
    match.url = 'mailto:' + match.url;
  }
};


/**
 * LinkifyIt#onCompile()
 *
 * Override to modify basic RegExp-s.
 **/
LinkifyIt.prototype.onCompile = function onCompile() {
};


var linkifyIt = LinkifyIt;

/** Highest positive signed 32-bit float value */
const maxInt = 2147483647; // aka. 0x7FFFFFFF or 2^31-1

/** Bootstring parameters */
const base = 36;
const tMin = 1;
const tMax = 26;
const skew = 38;
const damp = 700;
const initialBias = 72;
const initialN = 128; // 0x80
const delimiter = '-'; // '\x2D'

/** Regular expressions */
const regexPunycode = /^xn--/;
const regexNonASCII = /[^\0-\x7E]/; // non-ASCII chars
const regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g; // RFC 3490 separators

/** Error messages */
const errors = {
	'overflow': 'Overflow: input needs wider integers to process',
	'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
	'invalid-input': 'Invalid input'
};

/** Convenience shortcuts */
const baseMinusTMin = base - tMin;
const floor = Math.floor;
const stringFromCharCode = String.fromCharCode;

/*--------------------------------------------------------------------------*/

/**
 * A generic error utility function.
 * @private
 * @param {String} type The error type.
 * @returns {Error} Throws a `RangeError` with the applicable error message.
 */
function error(type) {
	throw new RangeError(errors[type]);
}

/**
 * A generic `Array#map` utility function.
 * @private
 * @param {Array} array The array to iterate over.
 * @param {Function} callback The function that gets called for every array
 * item.
 * @returns {Array} A new array of values returned by the callback function.
 */
function map(array, fn) {
	const result = [];
	let length = array.length;
	while (length--) {
		result[length] = fn(array[length]);
	}
	return result;
}

/**
 * A simple `Array#map`-like wrapper to work with domain name strings or email
 * addresses.
 * @private
 * @param {String} domain The domain name or email address.
 * @param {Function} callback The function that gets called for every
 * character.
 * @returns {Array} A new string of characters returned by the callback
 * function.
 */
function mapDomain(string, fn) {
	const parts = string.split('@');
	let result = '';
	if (parts.length > 1) {
		// In email addresses, only the domain name should be punycoded. Leave
		// the local part (i.e. everything up to `@`) intact.
		result = parts[0] + '@';
		string = parts[1];
	}
	// Avoid `split(regex)` for IE8 compatibility. See #17.
	string = string.replace(regexSeparators, '\x2E');
	const labels = string.split('.');
	const encoded = map(labels, fn).join('.');
	return result + encoded;
}

/**
 * Creates an array containing the numeric code points of each Unicode
 * character in the string. While JavaScript uses UCS-2 internally,
 * this function will convert a pair of surrogate halves (each of which
 * UCS-2 exposes as separate characters) into a single code point,
 * matching UTF-16.
 * @see `punycode.ucs2.encode`
 * @see <https://mathiasbynens.be/notes/javascript-encoding>
 * @memberOf punycode.ucs2
 * @name decode
 * @param {String} string The Unicode input string (UCS-2).
 * @returns {Array} The new array of code points.
 */
function ucs2decode(string) {
	const output = [];
	let counter = 0;
	const length = string.length;
	while (counter < length) {
		const value = string.charCodeAt(counter++);
		if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
			// It's a high surrogate, and there is a next character.
			const extra = string.charCodeAt(counter++);
			if ((extra & 0xFC00) == 0xDC00) { // Low surrogate.
				output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
			} else {
				// It's an unmatched surrogate; only append this code unit, in case the
				// next code unit is the high surrogate of a surrogate pair.
				output.push(value);
				counter--;
			}
		} else {
			output.push(value);
		}
	}
	return output;
}

/**
 * Creates a string based on an array of numeric code points.
 * @see `punycode.ucs2.decode`
 * @memberOf punycode.ucs2
 * @name encode
 * @param {Array} codePoints The array of numeric code points.
 * @returns {String} The new Unicode string (UCS-2).
 */
const ucs2encode = array => String.fromCodePoint(...array);

/**
 * Converts a basic code point into a digit/integer.
 * @see `digitToBasic()`
 * @private
 * @param {Number} codePoint The basic numeric code point value.
 * @returns {Number} The numeric value of a basic code point (for use in
 * representing integers) in the range `0` to `base - 1`, or `base` if
 * the code point does not represent a value.
 */
const basicToDigit = function(codePoint) {
	if (codePoint - 0x30 < 0x0A) {
		return codePoint - 0x16;
	}
	if (codePoint - 0x41 < 0x1A) {
		return codePoint - 0x41;
	}
	if (codePoint - 0x61 < 0x1A) {
		return codePoint - 0x61;
	}
	return base;
};

/**
 * Converts a digit/integer into a basic code point.
 * @see `basicToDigit()`
 * @private
 * @param {Number} digit The numeric value of a basic code point.
 * @returns {Number} The basic code point whose value (when used for
 * representing integers) is `digit`, which needs to be in the range
 * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
 * used; else, the lowercase form is used. The behavior is undefined
 * if `flag` is non-zero and `digit` has no uppercase form.
 */
const digitToBasic = function(digit, flag) {
	//  0..25 map to ASCII a..z or A..Z
	// 26..35 map to ASCII 0..9
	return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
};

/**
 * Bias adaptation function as per section 3.4 of RFC 3492.
 * https://tools.ietf.org/html/rfc3492#section-3.4
 * @private
 */
const adapt = function(delta, numPoints, firstTime) {
	let k = 0;
	delta = firstTime ? floor(delta / damp) : delta >> 1;
	delta += floor(delta / numPoints);
	for (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) {
		delta = floor(delta / baseMinusTMin);
	}
	return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
};

/**
 * Converts a Punycode string of ASCII-only symbols to a string of Unicode
 * symbols.
 * @memberOf punycode
 * @param {String} input The Punycode string of ASCII-only symbols.
 * @returns {String} The resulting string of Unicode symbols.
 */
const decode = function(input) {
	// Don't use UCS-2.
	const output = [];
	const inputLength = input.length;
	let i = 0;
	let n = initialN;
	let bias = initialBias;

	// Handle the basic code points: let `basic` be the number of input code
	// points before the last delimiter, or `0` if there is none, then copy
	// the first basic code points to the output.

	let basic = input.lastIndexOf(delimiter);
	if (basic < 0) {
		basic = 0;
	}

	for (let j = 0; j < basic; ++j) {
		// if it's not a basic code point
		if (input.charCodeAt(j) >= 0x80) {
			error('not-basic');
		}
		output.push(input.charCodeAt(j));
	}

	// Main decoding loop: start just after the last delimiter if any basic code
	// points were copied; start at the beginning otherwise.

	for (let index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */) {

		// `index` is the index of the next character to be consumed.
		// Decode a generalized variable-length integer into `delta`,
		// which gets added to `i`. The overflow checking is easier
		// if we increase `i` as we go, then subtract off its starting
		// value at the end to obtain `delta`.
		let oldi = i;
		for (let w = 1, k = base; /* no condition */; k += base) {

			if (index >= inputLength) {
				error('invalid-input');
			}

			const digit = basicToDigit(input.charCodeAt(index++));

			if (digit >= base || digit > floor((maxInt - i) / w)) {
				error('overflow');
			}

			i += digit * w;
			const t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);

			if (digit < t) {
				break;
			}

			const baseMinusT = base - t;
			if (w > floor(maxInt / baseMinusT)) {
				error('overflow');
			}

			w *= baseMinusT;

		}

		const out = output.length + 1;
		bias = adapt(i - oldi, out, oldi == 0);

		// `i` was supposed to wrap around from `out` to `0`,
		// incrementing `n` each time, so we'll fix that now:
		if (floor(i / out) > maxInt - n) {
			error('overflow');
		}

		n += floor(i / out);
		i %= out;

		// Insert `n` at position `i` of the output.
		output.splice(i++, 0, n);

	}

	return String.fromCodePoint(...output);
};

/**
 * Converts a string of Unicode symbols (e.g. a domain name label) to a
 * Punycode string of ASCII-only symbols.
 * @memberOf punycode
 * @param {String} input The string of Unicode symbols.
 * @returns {String} The resulting Punycode string of ASCII-only symbols.
 */
const encode = function(input) {
	const output = [];

	// Convert the input in UCS-2 to an array of Unicode code points.
	input = ucs2decode(input);

	// Cache the length.
	let inputLength = input.length;

	// Initialize the state.
	let n = initialN;
	let delta = 0;
	let bias = initialBias;

	// Handle the basic code points.
	for (const currentValue of input) {
		if (currentValue < 0x80) {
			output.push(stringFromCharCode(currentValue));
		}
	}

	let basicLength = output.length;
	let handledCPCount = basicLength;

	// `handledCPCount` is the number of code points that have been handled;
	// `basicLength` is the number of basic code points.

	// Finish the basic string with a delimiter unless it's empty.
	if (basicLength) {
		output.push(delimiter);
	}

	// Main encoding loop:
	while (handledCPCount < inputLength) {

		// All non-basic code points < n have been handled already. Find the next
		// larger one:
		let m = maxInt;
		for (const currentValue of input) {
			if (currentValue >= n && currentValue < m) {
				m = currentValue;
			}
		}

		// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
		// but guard against overflow.
		const handledCPCountPlusOne = handledCPCount + 1;
		if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
			error('overflow');
		}

		delta += (m - n) * handledCPCountPlusOne;
		n = m;

		for (const currentValue of input) {
			if (currentValue < n && ++delta > maxInt) {
				error('overflow');
			}
			if (currentValue == n) {
				// Represent delta as a generalized variable-length integer.
				let q = delta;
				for (let k = base; /* no condition */; k += base) {
					const t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);
					if (q < t) {
						break;
					}
					const qMinusT = q - t;
					const baseMinusT = base - t;
					output.push(
						stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))
					);
					q = floor(qMinusT / baseMinusT);
				}

				output.push(stringFromCharCode(digitToBasic(q, 0)));
				bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
				delta = 0;
				++handledCPCount;
			}
		}

		++delta;
		++n;

	}
	return output.join('');
};

/**
 * Converts a Punycode string representing a domain name or an email address
 * to Unicode. Only the Punycoded parts of the input will be converted, i.e.
 * it doesn't matter if you call it on a string that has already been
 * converted to Unicode.
 * @memberOf punycode
 * @param {String} input The Punycoded domain name or email address to
 * convert to Unicode.
 * @returns {String} The Unicode representation of the given Punycode
 * string.
 */
const toUnicode = function(input) {
	return mapDomain(input, function(string) {
		return regexPunycode.test(string)
			? decode(string.slice(4).toLowerCase())
			: string;
	});
};

/**
 * Converts a Unicode string representing a domain name or an email address to
 * Punycode. Only the non-ASCII parts of the domain name will be converted,
 * i.e. it doesn't matter if you call it with a domain that's already in
 * ASCII.
 * @memberOf punycode
 * @param {String} input The domain name or email address to convert, as a
 * Unicode string.
 * @returns {String} The Punycode representation of the given domain name or
 * email address.
 */
const toASCII = function(input) {
	return mapDomain(input, function(string) {
		return regexNonASCII.test(string)
			? 'xn--' + encode(string)
			: string;
	});
};

/*--------------------------------------------------------------------------*/

/** Define the public API */
const punycode$1 = {
	/**
	 * A string representing the current Punycode.js version number.
	 * @memberOf punycode
	 * @type String
	 */
	'version': '2.1.0',
	/**
	 * An object of methods to convert from JavaScript's internal character
	 * representation (UCS-2) to Unicode code points, and back.
	 * @see <https://mathiasbynens.be/notes/javascript-encoding>
	 * @memberOf punycode
	 * @type Object
	 */
	'ucs2': {
		'decode': ucs2decode,
		'encode': ucs2encode
	},
	'decode': decode,
	'encode': encode,
	'toASCII': toASCII,
	'toUnicode': toUnicode
};

const punycode_es6 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  ucs2decode: ucs2decode,
  ucs2encode: ucs2encode,
  decode: decode,
  encode: encode,
  toASCII: toASCII,
  toUnicode: toUnicode,
  'default': punycode$1
});

// markdown-it default options


var _default = {
  options: {
    html:         false,        // Enable HTML tags in source
    xhtmlOut:     false,        // Use '/' to close single tags (<br />)
    breaks:       false,        // Convert '\n' in paragraphs into <br>
    langPrefix:   'language-',  // CSS language prefix for fenced blocks
    linkify:      false,        // autoconvert URL-like texts to links

    // Enable some language-neutral replacements + quotes beautification
    typographer:  false,

    // Double + single quotes replacement pairs, when typographer enabled,
    // and smartquotes on. Could be either a String or an Array.
    //
    // For example, you can use '«»„“' for Russian, '„“‚‘' for German,
    // and ['«\xA0', '\xA0»', '‹\xA0', '\xA0›'] for French (including nbsp).
    quotes: '\u201c\u201d\u2018\u2019', /* “”‘’ */

    // Highlighter function. Should return escaped HTML,
    // or '' if the source string is not changed and should be escaped externaly.
    // If result starts with <pre... internal wrapper is skipped.
    //
    // function (/*str, lang*/) { return ''; }
    //
    highlight: null,

    maxNesting:   100            // Internal protection, recursion limit
  },

  components: {

    core: {},
    block: {},
    inline: {}
  }
};

// "Zero" preset, with nothing enabled. Useful for manual configuring of simple


var zero = {
  options: {
    html:         false,        // Enable HTML tags in source
    xhtmlOut:     false,        // Use '/' to close single tags (<br />)
    breaks:       false,        // Convert '\n' in paragraphs into <br>
    langPrefix:   'language-',  // CSS language prefix for fenced blocks
    linkify:      false,        // autoconvert URL-like texts to links

    // Enable some language-neutral replacements + quotes beautification
    typographer:  false,

    // Double + single quotes replacement pairs, when typographer enabled,
    // and smartquotes on. Could be either a String or an Array.
    //
    // For example, you can use '«»„“' for Russian, '„“‚‘' for German,
    // and ['«\xA0', '\xA0»', '‹\xA0', '\xA0›'] for French (including nbsp).
    quotes: '\u201c\u201d\u2018\u2019', /* “”‘’ */

    // Highlighter function. Should return escaped HTML,
    // or '' if the source string is not changed and should be escaped externaly.
    // If result starts with <pre... internal wrapper is skipped.
    //
    // function (/*str, lang*/) { return ''; }
    //
    highlight: null,

    maxNesting:   20            // Internal protection, recursion limit
  },

  components: {

    core: {
      rules: [
        'normalize',
        'block',
        'inline'
      ]
    },

    block: {
      rules: [
        'paragraph'
      ]
    },

    inline: {
      rules: [
        'text'
      ],
      rules2: [
        'balance_pairs',
        'text_collapse'
      ]
    }
  }
};

// Commonmark default options


var commonmark = {
  options: {
    html:         true,         // Enable HTML tags in source
    xhtmlOut:     true,         // Use '/' to close single tags (<br />)
    breaks:       false,        // Convert '\n' in paragraphs into <br>
    langPrefix:   'language-',  // CSS language prefix for fenced blocks
    linkify:      false,        // autoconvert URL-like texts to links

    // Enable some language-neutral replacements + quotes beautification
    typographer:  false,

    // Double + single quotes replacement pairs, when typographer enabled,
    // and smartquotes on. Could be either a String or an Array.
    //
    // For example, you can use '«»„“' for Russian, '„“‚‘' for German,
    // and ['«\xA0', '\xA0»', '‹\xA0', '\xA0›'] for French (including nbsp).
    quotes: '\u201c\u201d\u2018\u2019', /* “”‘’ */

    // Highlighter function. Should return escaped HTML,
    // or '' if the source string is not changed and should be escaped externaly.
    // If result starts with <pre... internal wrapper is skipped.
    //
    // function (/*str, lang*/) { return ''; }
    //
    highlight: null,

    maxNesting:   20            // Internal protection, recursion limit
  },

  components: {

    core: {
      rules: [
        'normalize',
        'block',
        'inline'
      ]
    },

    block: {
      rules: [
        'blockquote',
        'code',
        'fence',
        'heading',
        'hr',
        'html_block',
        'lheading',
        'list',
        'reference',
        'paragraph'
      ]
    },

    inline: {
      rules: [
        'autolink',
        'backticks',
        'emphasis',
        'entity',
        'escape',
        'html_inline',
        'image',
        'link',
        'newline',
        'text'
      ],
      rules2: [
        'balance_pairs',
        'emphasis',
        'text_collapse'
      ]
    }
  }
};

const punycode = /*@__PURE__*/getAugmentedNamespace(punycode_es6);

var config = {
  default: _default,
  zero: zero,
  commonmark: commonmark
};

////////////////////////////////////////////////////////////////////////////////
//
// This validator can prohibit more than really needed to prevent XSS. It's a
// tradeoff to keep code simple and to be secure by default.
//
// If you need different setup - override validator method as you wish. Or
// replace it with dummy function and use external sanitizer.
//

var BAD_PROTO_RE = /^(vbscript|javascript|file|data):/;
var GOOD_DATA_RE = /^data:image\/(gif|png|jpeg|webp);/;

function validateLink(url) {
  // url should be normalized at this point, and existing entities are decoded
  var str = url.trim().toLowerCase();

  return BAD_PROTO_RE.test(str) ? (GOOD_DATA_RE.test(str) ? true : false) : true;
}

////////////////////////////////////////////////////////////////////////////////


var RECODE_HOSTNAME_FOR = [ 'http:', 'https:', 'mailto:' ];

function normalizeLink(url) {
  var parsed = mdurl.parse(url, true);

  if (parsed.hostname) {
    // Encode hostnames in urls like:
    // `http://host/`, `https://host/`, `mailto:user@host`, `//host/`
    //
    // We don't encode unknown schemas, because it's likely that we encode
    // something we shouldn't (e.g. `skype:name` treated as `skype:host`)
    //
    if (!parsed.protocol || RECODE_HOSTNAME_FOR.indexOf(parsed.protocol) >= 0) {
      try {
        parsed.hostname = punycode.toASCII(parsed.hostname);
      } catch (er) { /**/ }
    }
  }

  return mdurl.encode(mdurl.format(parsed));
}

function normalizeLinkText(url) {
  var parsed = mdurl.parse(url, true);

  if (parsed.hostname) {
    // Encode hostnames in urls like:
    // `http://host/`, `https://host/`, `mailto:user@host`, `//host/`
    //
    // We don't encode unknown schemas, because it's likely that we encode
    // something we shouldn't (e.g. `skype:name` treated as `skype:host`)
    //
    if (!parsed.protocol || RECODE_HOSTNAME_FOR.indexOf(parsed.protocol) >= 0) {
      try {
        parsed.hostname = punycode.toUnicode(parsed.hostname);
      } catch (er) { /**/ }
    }
  }

  // add '%' to exclude list because of https://github.com/markdown-it/markdown-it/issues/720
  return mdurl.decode(mdurl.format(parsed), mdurl.decode.defaultChars + '%');
}


/**
 * class MarkdownIt
 *
 * Main parser/renderer class.
 *
 * ##### Usage
 *
 * ```javascript
 * // node.js, "classic" way:
 * var MarkdownIt = require('markdown-it'),
 *     md = new MarkdownIt();
 * var result = md.render('# markdown-it rulezz!');
 *
 * // node.js, the same, but with sugar:
 * var md = require('markdown-it')();
 * var result = md.render('# markdown-it rulezz!');
 *
 * // browser without AMD, added to "window" on script load
 * // Note, there are no dash.
 * var md = window.markdownit();
 * var result = md.render('# markdown-it rulezz!');
 * ```
 *
 * Single line rendering, without paragraph wrap:
 *
 * ```javascript
 * var md = require('markdown-it')();
 * var result = md.renderInline('__markdown-it__ rulezz!');
 * ```
 **/

/**
 * new MarkdownIt([presetName, options])
 * - presetName (String): optional, `commonmark` / `zero`
 * - options (Object)
 *
 * Creates parser instanse with given config. Can be called without `new`.
 *
 * ##### presetName
 *
 * MarkdownIt provides named presets as a convenience to quickly
 * enable/disable active syntax rules and options for common use cases.
 *
 * - ["commonmark"](https://github.com/markdown-it/markdown-it/blob/master/lib/presets/commonmark.js) -
 *   configures parser to strict [CommonMark](http://commonmark.org/) mode.
 * - [default](https://github.com/markdown-it/markdown-it/blob/master/lib/presets/default.js) -
 *   similar to GFM, used when no preset name given. Enables all available rules,
 *   but still without html, typographer & autolinker.
 * - ["zero"](https://github.com/markdown-it/markdown-it/blob/master/lib/presets/zero.js) -
 *   all rules disabled. Useful to quickly setup your config via `.enable()`.
 *   For example, when you need only `bold` and `italic` markup and nothing else.
 *
 * ##### options:
 *
 * - __html__ - `false`. Set `true` to enable HTML tags in source. Be careful!
 *   That's not safe! You may need external sanitizer to protect output from XSS.
 *   It's better to extend features via plugins, instead of enabling HTML.
 * - __xhtmlOut__ - `false`. Set `true` to add '/' when closing single tags
 *   (`<br />`). This is needed only for full CommonMark compatibility. In real
 *   world you will need HTML output.
 * - __breaks__ - `false`. Set `true` to convert `\n` in paragraphs into `<br>`.
 * - __langPrefix__ - `language-`. CSS language class prefix for fenced blocks.
 *   Can be useful for external highlighters.
 * - __linkify__ - `false`. Set `true` to autoconvert URL-like text to links.
 * - __typographer__  - `false`. Set `true` to enable [some language-neutral
 *   replacement](https://github.com/markdown-it/markdown-it/blob/master/lib/rules_core/replacements.js) +
 *   quotes beautification (smartquotes).
 * - __quotes__ - `“”‘’`, String or Array. Double + single quotes replacement
 *   pairs, when typographer enabled and smartquotes on. For example, you can
 *   use `'«»„“'` for Russian, `'„“‚‘'` for German, and
 *   `['«\xA0', '\xA0»', '‹\xA0', '\xA0›']` for French (including nbsp).
 * - __highlight__ - `null`. Highlighter function for fenced code blocks.
 *   Highlighter `function (str, lang)` should return escaped HTML. It can also
 *   return empty string if the source was not changed and should be escaped
 *   externaly. If result starts with <pre... internal wrapper is skipped.
 *
 * ##### Example
 *
 * ```javascript
 * // commonmark mode
 * var md = require('markdown-it')('commonmark');
 *
 * // default mode
 * var md = require('markdown-it')();
 *
 * // enable everything
 * var md = require('markdown-it')({
 *   html: true,
 *   linkify: true,
 *   typographer: true
 * });
 * ```
 *
 * ##### Syntax highlighting
 *
 * ```js
 * var hljs = require('highlight.js') // https://highlightjs.org/
 *
 * var md = require('markdown-it')({
 *   highlight: function (str, lang) {
 *     if (lang && hljs.getLanguage(lang)) {
 *       try {
 *         return hljs.highlight(lang, str, true).value;
 *       } catch (__) {}
 *     }
 *
 *     return ''; // use external default escaping
 *   }
 * });
 * ```
 *
 * Or with full wrapper override (if you need assign class to `<pre>`):
 *
 * ```javascript
 * var hljs = require('highlight.js') // https://highlightjs.org/
 *
 * // Actual default values
 * var md = require('markdown-it')({
 *   highlight: function (str, lang) {
 *     if (lang && hljs.getLanguage(lang)) {
 *       try {
 *         return '<pre class="hljs"><code>' +
 *                hljs.highlight(lang, str, true).value +
 *                '</code></pre>';
 *       } catch (__) {}
 *     }
 *
 *     return '<pre class="hljs"><code>' + md.utils.escapeHtml(str) + '</code></pre>';
 *   }
 * });
 * ```
 *
 **/
function MarkdownIt(presetName, options) {
  if (!(this instanceof MarkdownIt)) {
    return new MarkdownIt(presetName, options);
  }

  if (!options) {
    if (!utils.isString(presetName)) {
      options = presetName || {};
      presetName = 'default';
    }
  }

  /**
   * MarkdownIt#inline -> ParserInline
   *
   * Instance of [[ParserInline]]. You may need it to add new rules when
   * writing plugins. For simple rules control use [[MarkdownIt.disable]] and
   * [[MarkdownIt.enable]].
   **/
  this.inline = new parser_inline();

  /**
   * MarkdownIt#block -> ParserBlock
   *
   * Instance of [[ParserBlock]]. You may need it to add new rules when
   * writing plugins. For simple rules control use [[MarkdownIt.disable]] and
   * [[MarkdownIt.enable]].
   **/
  this.block = new parser_block();

  /**
   * MarkdownIt#core -> Core
   *
   * Instance of [[Core]] chain executor. You may need it to add new rules when
   * writing plugins. For simple rules control use [[MarkdownIt.disable]] and
   * [[MarkdownIt.enable]].
   **/
  this.core = new parser_core();

  /**
   * MarkdownIt#renderer -> Renderer
   *
   * Instance of [[Renderer]]. Use it to modify output look. Or to add rendering
   * rules for new token types, generated by plugins.
   *
   * ##### Example
   *
   * ```javascript
   * var md = require('markdown-it')();
   *
   * function myToken(tokens, idx, options, env, self) {
   *   //...
   *   return result;
   * };
   *
   * md.renderer.rules['my_token'] = myToken
   * ```
   *
   * See [[Renderer]] docs and [source code](https://github.com/markdown-it/markdown-it/blob/master/lib/renderer.js).
   **/
  this.renderer = new renderer();

  /**
   * MarkdownIt#linkify -> LinkifyIt
   *
   * [linkify-it](https://github.com/markdown-it/linkify-it) instance.
   * Used by [linkify](https://github.com/markdown-it/markdown-it/blob/master/lib/rules_core/linkify.js)
   * rule.
   **/
  this.linkify = new linkifyIt();

  /**
   * MarkdownIt#validateLink(url) -> Boolean
   *
   * Link validation function. CommonMark allows too much in links. By default
   * we disable `javascript:`, `vbscript:`, `file:` schemas, and almost all `data:...` schemas
   * except some embedded image types.
   *
   * You can change this behaviour:
   *
   * ```javascript
   * var md = require('markdown-it')();
   * // enable everything
   * md.validateLink = function () { return true; }
   * ```
   **/
  this.validateLink = validateLink;

  /**
   * MarkdownIt#normalizeLink(url) -> String
   *
   * Function used to encode link url to a machine-readable format,
   * which includes url-encoding, punycode, etc.
   **/
  this.normalizeLink = normalizeLink;

  /**
   * MarkdownIt#normalizeLinkText(url) -> String
   *
   * Function used to decode link url to a human-readable format`
   **/
  this.normalizeLinkText = normalizeLinkText;


  // Expose utils & helpers for easy acces from plugins

  /**
   * MarkdownIt#utils -> utils
   *
   * Assorted utility functions, useful to write plugins. See details
   * [here](https://github.com/markdown-it/markdown-it/blob/master/lib/common/utils.js).
   **/
  this.utils = utils;

  /**
   * MarkdownIt#helpers -> helpers
   *
   * Link components parser functions, useful to write plugins. See details
   * [here](https://github.com/markdown-it/markdown-it/blob/master/lib/helpers).
   **/
  this.helpers = utils.assign({}, helpers);


  this.options = {};
  this.configure(presetName);

  if (options) { this.set(options); }
}


/** chainable
 * MarkdownIt.set(options)
 *
 * Set parser options (in the same format as in constructor). Probably, you
 * will never need it, but you can change options after constructor call.
 *
 * ##### Example
 *
 * ```javascript
 * var md = require('markdown-it')()
 *             .set({ html: true, breaks: true })
 *             .set({ typographer, true });
 * ```
 *
 * __Note:__ To achieve the best possible performance, don't modify a
 * `markdown-it` instance options on the fly. If you need multiple configurations
 * it's best to create multiple instances and initialize each with separate
 * config.
 **/
MarkdownIt.prototype.set = function (options) {
  utils.assign(this.options, options);
  return this;
};


/** chainable, internal
 * MarkdownIt.configure(presets)
 *
 * Batch load of all options and compenent settings. This is internal method,
 * and you probably will not need it. But if you will - see available presets
 * and data structure [here](https://github.com/markdown-it/markdown-it/tree/master/lib/presets)
 *
 * We strongly recommend to use presets instead of direct config loads. That
 * will give better compatibility with next versions.
 **/
MarkdownIt.prototype.configure = function (presets) {
  var self = this, presetName;

  if (utils.isString(presets)) {
    presetName = presets;
    presets = config[presetName];
    if (!presets) { throw new Error('Wrong `markdown-it` preset "' + presetName + '", check name'); }
  }

  if (!presets) { throw new Error('Wrong `markdown-it` preset, can\'t be empty'); }

  if (presets.options) { self.set(presets.options); }

  if (presets.components) {
    Object.keys(presets.components).forEach(function (name) {
      if (presets.components[name].rules) {
        self[name].ruler.enableOnly(presets.components[name].rules);
      }
      if (presets.components[name].rules2) {
        self[name].ruler2.enableOnly(presets.components[name].rules2);
      }
    });
  }
  return this;
};


/** chainable
 * MarkdownIt.enable(list, ignoreInvalid)
 * - list (String|Array): rule name or list of rule names to enable
 * - ignoreInvalid (Boolean): set `true` to ignore errors when rule not found.
 *
 * Enable list or rules. It will automatically find appropriate components,
 * containing rules with given names. If rule not found, and `ignoreInvalid`
 * not set - throws exception.
 *
 * ##### Example
 *
 * ```javascript
 * var md = require('markdown-it')()
 *             .enable(['sub', 'sup'])
 *             .disable('smartquotes');
 * ```
 **/
MarkdownIt.prototype.enable = function (list, ignoreInvalid) {
  var result = [];

  if (!Array.isArray(list)) { list = [ list ]; }

  [ 'core', 'block', 'inline' ].forEach(function (chain) {
    result = result.concat(this[chain].ruler.enable(list, true));
  }, this);

  result = result.concat(this.inline.ruler2.enable(list, true));

  var missed = list.filter(function (name) { return result.indexOf(name) < 0; });

  if (missed.length && !ignoreInvalid) {
    throw new Error('MarkdownIt. Failed to enable unknown rule(s): ' + missed);
  }

  return this;
};


/** chainable
 * MarkdownIt.disable(list, ignoreInvalid)
 * - list (String|Array): rule name or list of rule names to disable.
 * - ignoreInvalid (Boolean): set `true` to ignore errors when rule not found.
 *
 * The same as [[MarkdownIt.enable]], but turn specified rules off.
 **/
MarkdownIt.prototype.disable = function (list, ignoreInvalid) {
  var result = [];

  if (!Array.isArray(list)) { list = [ list ]; }

  [ 'core', 'block', 'inline' ].forEach(function (chain) {
    result = result.concat(this[chain].ruler.disable(list, true));
  }, this);

  result = result.concat(this.inline.ruler2.disable(list, true));

  var missed = list.filter(function (name) { return result.indexOf(name) < 0; });

  if (missed.length && !ignoreInvalid) {
    throw new Error('MarkdownIt. Failed to disable unknown rule(s): ' + missed);
  }
  return this;
};


/** chainable
 * MarkdownIt.use(plugin, params)
 *
 * Load specified plugin with given params into current parser instance.
 * It's just a sugar to call `plugin(md, params)` with curring.
 *
 * ##### Example
 *
 * ```javascript
 * var iterator = require('markdown-it-for-inline');
 * var md = require('markdown-it')()
 *             .use(iterator, 'foo_replace', 'text', function (tokens, idx) {
 *               tokens[idx].content = tokens[idx].content.replace(/foo/g, 'bar');
 *             });
 * ```
 **/
MarkdownIt.prototype.use = function (plugin /*, params, ... */) {
  var args = [ this ].concat(Array.prototype.slice.call(arguments, 1));
  plugin.apply(plugin, args);
  return this;
};


/** internal
 * MarkdownIt.parse(src, env) -> Array
 * - src (String): source string
 * - env (Object): environment sandbox
 *
 * Parse input string and return list of block tokens (special token type
 * "inline" will contain list of inline tokens). You should not call this
 * method directly, until you write custom renderer (for example, to produce
 * AST).
 *
 * `env` is used to pass data between "distributed" rules and return additional
 * metadata like reference info, needed for the renderer. It also can be used to
 * inject data in specific cases. Usually, you will be ok to pass `{}`,
 * and then pass updated object to renderer.
 **/
MarkdownIt.prototype.parse = function (src, env) {
  if (typeof src !== 'string') {
    throw new Error('Input data should be a String');
  }

  var state = new this.core.State(src, this, env);

  this.core.process(state);

  return state.tokens;
};


/**
 * MarkdownIt.render(src [, env]) -> String
 * - src (String): source string
 * - env (Object): environment sandbox
 *
 * Render markdown string into html. It does all magic for you :).
 *
 * `env` can be used to inject additional metadata (`{}` by default).
 * But you will not need it with high probability. See also comment
 * in [[MarkdownIt.parse]].
 **/
MarkdownIt.prototype.render = function (src, env) {
  env = env || {};

  return this.renderer.render(this.parse(src, env), this.options, env);
};


/** internal
 * MarkdownIt.parseInline(src, env) -> Array
 * - src (String): source string
 * - env (Object): environment sandbox
 *
 * The same as [[MarkdownIt.parse]] but skip all block rules. It returns the
 * block tokens list with the single `inline` element, containing parsed inline
 * tokens in `children` property. Also updates `env` object.
 **/
MarkdownIt.prototype.parseInline = function (src, env) {
  var state = new this.core.State(src, this, env);

  state.inlineMode = true;
  this.core.process(state);

  return state.tokens;
};


/**
 * MarkdownIt.renderInline(src [, env]) -> String
 * - src (String): source string
 * - env (Object): environment sandbox
 *
 * Similar to [[MarkdownIt.render]] but for single paragraph content. Result
 * will NOT be wrapped into `<p>` tags.
 **/
MarkdownIt.prototype.renderInline = function (src, env) {
  env = env || {};

  return this.renderer.render(this.parseInline(src, env), this.options, env);
};


var lib = MarkdownIt;

var markdownIt = lib;

class ChangeLogWindow extends FormApplication {
  constructor(lastVersion) {
    super({}, {});

    this.lastVersion = lastVersion;
  }

  static get defaultOptions() {
    const options = super.defaultOptions;
    return mergeObject(options, {
      id: "changelog",
      classes: ["ffd20", "changelog"],
      template: "systems/ffd20/templates/apps/changelog.hbs",
      width: 500,
      submitOnChange: true,
      closeOnSubmit: false,
    });
  }

  get title() {
    return `${game.i18n.localize("FFD20.title")} ~ ${game.i18n.localize("FFD20.Changelog")}`;
  }

  async getData() {
    let data = await super.getData();

    data.dontShowAgain = game.settings.get("ffd20", "dontShowChangelog");

    let xhr = new XMLHttpRequest();
    xhr.open("GET", "systems/ffd20/CHANGELOG.md");

    let promise = new Promise((resolve) => {
      xhr.onload = () => {
        if (xhr.status === 200) {
          data.changelog = this._processChangelog(xhr.response);
          resolve(data);
        }
      };
    });
    xhr.send(null);

    return promise;
  }

  _processChangelog(md) {
    const MD = new markdownIt();

    // Cut off irrelevant changelog entries
    let lines = md.split(/[\n\r]/);
    if (this.lastVersion) {
      for (let a = 0; a < lines.length; a++) {
        let line = lines[a];
        if (line.match(/##\s+([0-9]+\.[0-9]+\.[0-9]+)/)) {
          const version = SemanticVersion.fromString(RegExp.$1);
          if (!version.isHigherThan(this.lastVersion)) {
            lines = lines.slice(0, a);
            break;
          }
        }
      }
    }

    return MD.render(lines.join("\n"));
  }

  async _updateObject(event, formData) {
    if (formData.dontShowAgain != null) {
      await game.settings.set("ffd20", "dontShowChangelog", formData.dontShowAgain);
    }
  }
}

class TooltipFFD20 extends Application {
  constructor() {
    super();

    this.mousePos = {
      x: 0,
      y: 0,
    };
    document.addEventListener("mousemove", (event) => {
      this.mousePos.x = event.clientX;
      this.mousePos.y = event.clientY;
      if (this.onMouse && !this.hidden) this._setPosition();
    });

    this.objects = [];

    this.forceHideGMInfo = false;

    this.lock = {
      new: false,
      old: false,
    };
  }

  static get defaultOptions() {
    return mergeObject(super.defaultOptions, {
      template: "systems/ffd20/templates/hud/tooltip.hbs",
      popOut: false,
    });
  }

  get config() {
    return game.settings.get("ffd20", "tooltipConfig");
  }

  get worldConfig() {
    return game.settings.get("ffd20", "tooltipWorldConfig");
  }

  get anchor() {
    return this.config.anchor;
  }

  get offset() {
    return this.config.offset;
  }

  get onMouse() {
    return this.config.onMouse;
  }

  get hidden() {
    return this.element[0]?.style.visibility === "hidden";
  }

  bind(object) {
    if (this.lock.new) return;

    if (this.objects.indexOf(object) === -1) {
      this.objects.push(object);
      this.render(true);
    }
  }

  unbind(object) {
    if (this.lock.old) return;

    const idx = this.objects.indexOf(object);
    if (idx >= 0) {
      this.objects.splice(idx, 1);
      if (this.objects.length === 0) {
        this.hide();
      } else {
        this.render();
      }
    }
  }

  clearBinds() {
    this.objects = [];
    this.hide();
  }

  get object() {
    return this.objects[0];
  }

  async getData() {
    if (typeof this.object === "string") {
      return { stringContent: this.object };
    } else if (this.object instanceof Token) {
      return {
        actorData: this.getTokenData(this.object),
      };
    } else if (this.object instanceof Actor) {
      return {
        actorData: this.getActorData(this.object),
      };
    }

    return {};
  }

  getTokenData(token) {
    const data = this.getActorData(token.actor);
    if (!data) return null;

    data.name = token.data.name;
    if (
      (game.user.isGM && this.forceHideGMInfo) ||
      (!game.user.isGM && !token.actor.testUserPermission(game.user, "OBSERVER"))
    ) {
      const tooltipName = getProperty(token.actor.data, "data.details.tooltip.name");
      data.name = tooltipName || token.data.name;

      if (
        (this.worldConfig.hideActorName === true && !tooltipName) ||
        getProperty(token.actor.data, "data.details.tooltip.hideName") === true
      ) {
        data.name = this.worldConfig.hideActorNameReplacement || "???";
      }
    }

    return data;
  }

  getActorData(actor) {
    if (!actor) return null;

    const data = {
      data: actor.data,
      name: actor.data.name,
    };

    if (!(game.user.isGM && !this.forceHideGMInfo)) {
      data.name = getProperty(actor.data, "data.details.tooltip.name") || actor.data.name;
    }

    data.isOwner = game.user.isGM || actor.isOwner;
    if (!data.isOwner) data.name = "???";
    this.getPortrait(data, actor.img);

    // Get conditions
    if (
      (game.user.isGM && !this.forceHideGMInfo) ||
      actor.isOwner ||
      (!getProperty(actor.data, "data.details.tooltip.hideConditions") &&
        !getProperty(this.worldConfig, "hideConditions"))
    ) {
      const conditions = getProperty(actor.data, "data.attributes.conditions") || {};
      for (const [ck, cv] of Object.entries(conditions)) {
        if (cv === true) {
          data.conditions = data.conditions || [];
          data.conditions.push({
            label: CONFIG.FFD20.conditions[ck],
            icon: CONFIG.FFD20.conditionTextures[ck],
          });
        }
      }
    }

    // Get buffs
    if (
      (game.user.isGM && !this.forceHideGMInfo) ||
      actor.isOwner ||
      (!getProperty(actor.data, "data.details.tooltip.hideBuffs") && !getProperty(this.worldConfig, "hideBuffs"))
    ) {
      const buffs = actor.items.filter((i) => i.data.data.active && !i.data.data.hideFromToken);
      for (const b of buffs) {
        data.buffs = data.buffs || [];
        data.buffs.push({
          label: b.name,
          icon: b.img,
          level: b.data.data.level,
        });
      }
    }

    // Get held items
    if (
      (game.user.isGM && !this.forceHideGMInfo) ||
      actor.isOwner ||
      (!getProperty(actor.data, "data.details.tooltip.hideHeld") && !getProperty(this.worldConfig, "hideHeld"))
    ) {
      const held = actor.items.filter((i) => {
        if (!["weapon", "equipment"].includes(i.type)) return false;
        if (!i.data.data.equipped) return false;
        if (i.type === "equipment") {
          if (i.data.data.equipmentType !== "shield") return false;
        }
        return true;
      });

      for (const i of held) {
        data.held = data.held || [];
        data.held.push({
          label: i.getName(this.forceHideGMInfo),
          icon: i.img,
        });
      }
    }

    // Get armor
    if (
      (game.user.isGM && !this.forceHideGMInfo) ||
      actor.isOwner ||
      (!getProperty(actor.data, "data.details.tooltip.hideArmor") && !getProperty(this.worldConfig, "hideArmor"))
    ) {
      const armor = actor.items.filter((i) => {
        if (i.type !== "equipment") return false;
        if (!i.data.data.equipped) return false;
        if (i.data.data.equipmentType !== "armor") return false;
        return true;
      });

      for (const i of armor) {
        data.armor = data.armor || [];
        data.armor.push({
          label: i.getName(this.forceHideGMInfo),
          icon: i.img,
        });
      }
    }

    // Get clothing
    if (
      (game.user.isGM && !this.forceHideGMInfo) ||
      actor.isOwner ||
      (!getProperty(actor.data, "data.details.tooltip.hideClothing") && !getProperty(this.worldConfig, "hideClothing"))
    ) {
      const clothing = actor.items.filter((i) => {
        if (i.type !== "equipment") return false;
        if (!i.data.data.equipped) return false;
        if (i.data.data.equipmentType !== "misc") return false;
        if (i.data.data.equipmentSubtype !== "clothing") return false;
        return true;
      });

      for (const i of clothing) {
        data.clothing = data.clothing || [];
        data.clothing.push({
          label: i.getName(this.forceHideGMInfo),
          icon: i.img,
        });
      }
    }

    return data;
  }

  getPortrait(data, url) {
    if (getProperty(this.config, "portrait.hide") === true || getProperty(this.worldConfig, "portrait.hide") === true)
      return;

    data.portrait = {
      maxWidth: getProperty(this.config, "portrait.maxSize.width") || 100,
      maxHeight: getProperty(this.config, "portrait.maxSize.height") || 100,
      url: url,
    };
  }

  _setPosition() {
    if (!this.element[0]) return;

    const v = canvas.app.view.getBoundingClientRect();
    const elSize = this.element[0].getBoundingClientRect();
    const position = {
      width: elSize.width,
      height: elSize.height,
      left: 0,
      top: 0,
    };

    const sb = ui.sidebar.element[0].getBoundingClientRect();
    const mw = v.width - position.width - sb.width,
      mh = v.height - position.height;

    // Calculate final position
    if (this.onMouse) {
      const minPos = {
        x: v.left,
        y: v.top,
      };
      const maxPos = {
        x: minPos.x + mw,
        y: minPos.y + mh,
      };
      const pos = {
        x: this.mousePos.x - position.width + position.width * this.anchor.x + this.offset.x,
        y: this.mousePos.y - position.height + position.height * this.anchor.y + this.offset.y,
      };
      position.left = Math.max(minPos.x, Math.min(maxPos.x, pos.x));
      position.top = Math.max(minPos.y, Math.min(maxPos.y, pos.y));
    } else {
      position.left = v.left + mw * this.anchor.x + this.offset.x;
      position.top = v.top + mh * this.anchor.y + this.offset.y;
    }

    this.element.css(position);
  }

  show() {
    if (this.objects.length === 0) return;
    if (this.config.hideWithoutKey && !game.keyboard.isDown("Control")) return;
    if (!this.config.hideWithoutKey && game.keyboard.isDown("Control")) return;
    if (getProperty(this.config, "disable") === true || getProperty(this.worldConfig, "disable") === true) return;

    this.element.css("visibility", "visible");
  }

  hide() {
    this.element.css("visibility", "hidden");
  }

  async _render(force = false, options = {}) {
    const p = super._render(force, options);

    await p;
    this.hide();

    // Required to re-align portraits
    const loadableContent = this.element.find("img");
    const loadableContentCount = loadableContent.length;
    if (loadableContentCount > 0) {
      let loadedContentCount = 0;
      loadableContent.one("load", () => {
        loadedContentCount++;
        if (loadedContentCount === loadableContentCount && this.objects.length) {
          this._setPosition();
          this.show();
        }
      });
    } else if (this.objects.length) {
      this._setPosition();
      this.show();
    }
  }

  activateListeners(html) {
    html.find(".controls .close").click(() => {
      this.clearBinds();
    });
  }
}

/**
 * Perform a system migration for the entire World, applying migrations for Actors, Items, and Compendium packs
 *
 * @returns {Promise}      A Promise which resolves once the migration is completed
 */
const migrateWorld = async function () {
  if (!game.user.isGM) {
    const msg = game.i18n.localize("FFD20.ErrorUnauthorizedAction");
    console.error(msg);
    return ui.notifications.error(msg);
  }
  game.ffd20.isMigrating = true;
  ui.notifications.info(game.i18n.format("FFD20.Migration.Start", { version: game.system.data.version }), {
    permanent: true,
  });
  console.log("System Migration starting.");

  await _migrateWorldSettings();

  // Migrate World Actors
  console.log("Migrating Actor entities");
  for (let a of game.actors.contents) {
    try {
      const updateData = migrateActorData(a.data);
      if (!foundry.utils.isObjectEmpty(updateData)) {
        console.log(`Migrating Actor entity ${a.name}`);
        await a.update(updateData, { enforceTypes: false });
      }
    } catch (err) {
      console.error(`Error migrating actor entity ${a.name}`, err);
    }
  }

  // Migrate World Items
  console.log("Migrating Item entities.");
  for (let i of game.items.contents) {
    try {
      const updateData = migrateItemData(i.data);
      if (!foundry.utils.isObjectEmpty(updateData)) {
        console.log(`Migrating Item entity ${i.name}`);
        await i.update(updateData, { enforceTypes: false });
      }
    } catch (err) {
      console.error(`Error migrating item entity ${i.name}`, err);
    }
  }

  // Migrate Actor Override Tokens
  console.log("Migrating Scene entities.");
  for (let s of game.scenes.contents) {
    try {
      const updateData = migrateSceneData(s.data);
      if (!foundry.utils.isObjectEmpty(updateData)) {
        console.log(`Migrating Scene entity ${s.name}`);
        await s.update(updateData, { enforceTypes: false });
        // If we do not do this, then synthetic token actors remain in cache
        // with the un-updated actorData.
        s.tokens.contents.forEach((t) => {
          t._actor = null;
        });
      }
    } catch (err) {
      console.error(`Error migrating scene entity ${s.name}`, err);
    }
  }

  // Migrate World Compendium Packs
  const packs = game.packs.filter((p) => {
    return (
      (["world", "ffd20"].includes(p.metadata.package) || p.metadata.system === "ffd20") &&
      ["Actor", "Item", "Scene"].includes(p.metadata.entity) &&
      !p.locked
    );
  });
  for (let p of packs) {
    await migrateCompendium(p);
  }

  // Set the migration as complete
  game.settings.set("ffd20", "systemMigrationVersion", game.system.data.version);
  ui.notifications.active
    .find(
      (o) =>
        o.hasClass("permanent") &&
        o[0].innerText === game.i18n.format("FFD20.Migration.Start", { version: game.system.data.version })
    )
    ?.click();
  ui.notifications.info(game.i18n.format("FFD20.Migration.End", { version: game.system.data.version }));
  console.log("System Migration completed.");
  game.ffd20.isMigrating = false;
  Hooks.callAll("ffd20.migrationFinished");
};

/* -------------------------------------------- */

/**
 * Apply migration rules to all Entities within a single Compendium pack
 *
 * @param pack
 * @returns {Promise}
 */
const migrateCompendium = async function (pack) {
  const entity = pack.metadata.entity;
  if (!["Actor", "Item", "Scene"].includes(entity)) return;

  // Begin by requesting server-side data model migration and get the migrated content
  await pack.migrate();
  const content = await pack.getDocuments();

  // Iterate over compendium entries - applying fine-tuned migration functions
  console.log(`Migrating ${entity} entities in Compendium ${pack.collection}`);
  for (let ent of content) {
    try {
      let updateData = null;
      if (entity === "Item") updateData = migrateItemData(ent.data);
      else if (entity === "Actor") updateData = migrateActorData(ent.data);
      else if (entity === "Scene") updateData = migrateSceneData(ent.data);
      expandObject(updateData);
      updateData["_id"] = ent.id;
      await ent.update(updateData);
      console.log(`Migrated ${entity} entity ${ent.name} in Compendium ${pack.collection}`);
    } catch (err) {
      console.error(`Error migrating ${entity} entity ${ent.name} in Compendium ${pack.collection}`, err);
    }
  }
  console.log(`Migrated all ${entity} entities from Compendium ${pack.collection}`);
};

/**
 * Migrates world settings.
 */
const _migrateWorldSettings = async function () {
  const oldXPTrack = game.settings.get("ffd20", "experienceRate");
  if (oldXPTrack !== "" && oldXPTrack != null) {
    // Set new config style
    const config = game.settings.get("ffd20", "experienceConfig") || ExperienceConfig.defaultSettings;
    config.track = oldXPTrack;
    await game.settings.set("ffd20", "experienceConfig", config);
    // Remove old config style
    await game.settings.set("ffd20", "experienceRate", "");
  }
};

/* -------------------------------------------- */
/*  Entity Type Migration Helpers               */
/* -------------------------------------------- */

/**
 * Migrate a single Actor entity to incorporate latest data model changes
 * Return an Object of updateData to be applied
 *
 * @param {Actor} actor   The actor data to derive an update from
 * @param token
 * @returns {object}       The updateData to apply
 */
const migrateActorData = function (actor, token) {
  const updateData = {};
  const linked = token?.isLinked ?? true;
  _migrateCharacterLevel(actor, updateData, linked);
  _migrateActorEncumbrance(actor, updateData, linked);
  _migrateActorNoteArrays(actor, updateData);
  _migrateActorSpeed(actor, updateData, linked);
  _migrateSpellDivineFocus(actor, updateData);
  _migrateActorSpellbookCL(actor, updateData);
  _migrateActorSpellbookSlots(actor, updateData, linked);
  _migrateActorBaseStats(actor, updateData);
  _migrateUnusedActorCreatureType(actor, updateData);
  _migrateActorSpellbookDCFormula(actor, updateData, linked);
  _migrateActorHPAbility(actor, updateData);
  _migrateActorCR(actor, updateData, linked);
  _migrateAttackAbility(actor, updateData, linked);
  _migrateActorDefenseAbility(actor, updateData);
  _migrateActorTokenVision(actor, updateData);
  _migrateActorSpellbookUsage(actor, updateData, linked);
  _migrateActorNullValues(actor, updateData);
  _migrateActorSpellbookDomainSlots(actor, updateData);
  _migrateActorStatures(actor, updateData);
  _migrateActorInitAbility(actor, updateData);
  _migrateActorChangeRevamp(actor, updateData);
  _migrateActorConditions(actor, updateData);
  _migrateActorSkillRanks(actor, updateData, linked);
  _migrateCarryBonus(actor, updateData, linked);

  // Migrate Owned Items
  if (!actor.items) return updateData;
  const items = actor.items.reduce((arr, i) => {
    // Migrate the Owned Item
    const itemData = i instanceof CONFIG.Item.documentClass ? i.toObject() : i;
    let itemUpdate = migrateItemData(itemData);

    // Update the Owned Item
    if (!isObjectEmpty(itemUpdate)) {
      itemUpdate._id = itemData._id;
      arr.push(expandObject(itemUpdate));
    }

    return arr;
  }, []);
  if (items.length > 0) updateData.items = items;
  return updateData;
};

/* -------------------------------------------- */

/**
 * Migrate a single Item entity to incorporate latest data model changes
 *
 * @param {Actor} item   The item data to derive an update from
 * @returns {object}       The updateData to apply
 */
const migrateItemData = function (item) {
  const updateData = {};

  _migrateItemArrayTypes(item, updateData);
  _migrateItemSpellUses(item, updateData);
  _migrateWeaponDamage(item, updateData);
  _migrateWeaponImprovised(item, updateData);
  _migrateSpellDescription(item, updateData);
  _migrateClassDynamics(item, updateData);
  _migrateClassType(item, updateData);
  _migrateWeaponCategories(item, updateData);
  _migrateEquipmentCategories(item, updateData);
  _migrateItemSize(item, updateData);
  _migrateAbilityTypes(item, updateData);
  _migrateClassLevels(item, updateData);
  _migrateSavingThrowTypes(item, updateData);
  _migrateCR(item, updateData);
  _migrateItemChanges(item, updateData);
  _migrateTemplateSize(item, updateData);
  _migrateEquipmentSize(item, updateData);
  _migrateTags(item, updateData);
  _migrateSpellCosts(item, updateData);
  _migrateLootEquip(item, updateData);
  _migrateUnchainedActionEconomy(item, updateData);
  _migrateItemRange(item, updateData);
  _migrateItemLinks(item, updateData);
  _migrateProficiencies(item, updateData);
  _migrateItemNotes(item, updateData);

  // Return the migrated update data
  return updateData;
};

/* -------------------------------------------- */

/**
 * Migrate a single Scene entity to incorporate changes to the data model of it's actor data overrides
 * Return an Object of updateData to be applied
 *
 * @param {object} scene - The Scene to Update
 * @returns {object} The updateData to apply
 */
const migrateSceneData = function (scene) {
  const tokens = scene.tokens.map((token) => {
    const t = token.toJSON();
    if (!t.actorId || t.actorLink) {
      t.actorData = {};
    } else if (!game.actors.has(t.actorId)) {
      t.actorId = null;
      t.actorData = {};
    } else if (!t.actorLink) {
      const actorData = duplicate(t.actorData);
      actorData.type = token.actor?.type;
      const update = migrateActorData(actorData, token);
      ["items", "effects"].forEach((embeddedName) => {
        if (!update[embeddedName]?.length) return;
        const updates = new Map(update[embeddedName].map((u) => [u._id, u]));
        t.actorData[embeddedName].forEach((original) => {
          const update = updates.get(original._id);
          if (update) mergeObject(original, update);
        });
        delete update[embeddedName];
      });

      mergeObject(t.actorData, update);
    }
    return t;
  });
  return { tokens };
};

/* -------------------------------------------- */

const _migrateCharacterLevel = function (ent, updateData, linked) {
  const arr = ["details.level.value", "details.level.min", "details.level.max", "details.mythicTier"];
  if (!linked) return; // skip unlinked tokens
  for (let k of arr) {
    const value = getProperty(ent.data, k);
    if (value == null) {
      updateData["data." + k] = 0;
    }
  }
};

const _migrateActorEncumbrance = function (ent, updateData, linked) {
  const arr = [
    "attributes.encumbrance.level",
    "attributes.encumbrance.levels.light",
    "attributes.encumbrance.levels.medium",
    "attributes.encumbrance.levels.heavy",
    "attributes.encumbrance.levels.carry",
    "attributes.encumbrance.levels.drag",
    "attributes.encumbrance.carriedWeight",
  ];
  for (let k of arr) {
    const value = getProperty(ent.data, k);
    if (value == null) {
      if (!linked) continue; // skip with unlinked tokens
      updateData["data." + k] = 0;
    }
  }
};

const _migrateActorNoteArrays = function (ent, updateData) {
  const list = ["data.attributes.acNotes", "data.attributes.cmdNotes", "data.attributes.srNotes"];
  for (let k of list) {
    const value = getProperty(ent, k);
    const hasValue = hasProperty(ent, k);
    if (hasValue && value instanceof Array) {
      updateData[k] = value.join("\n");
    }
  }
};

const _migrateActorSpeed = function (ent, updateData, linked) {
  const arr = [
    "attributes.speed.land",
    "attributes.speed.climb",
    "attributes.speed.swim",
    "attributes.speed.fly",
    "attributes.speed.burrow",
  ];
  for (let k of arr) {
    let value = getProperty(ent.data, k);
    if (!linked && value === undefined) continue; // skip with unlinked tokens
    if (typeof value === "string") value = parseInt(value);
    if (typeof value === "number") {
      updateData[`data.${k}.base`] = value;
      updateData[`data.${k}.total`] = value;
    } else if (value === null) {
      updateData[`data.${k}.base`] = 0;
      updateData[`data.${k}.total`] = null;
    }

    // Add maneuverability
    if (k === "attributes.speed.fly" && getProperty(ent.data, `${k}.maneuverability`) === undefined) {
      updateData[`data.${k}.maneuverability`] = "average";
    }
  }
};

const _migrateActorSpellbookSlots = function (ent, updateData, linked) {
  for (let spellbookSlot of Object.keys(getProperty(ent, "data.attributes.spells.spellbooks") || {})) {
    if (getProperty(ent, `data.attributes.spells.spellbooks.${spellbookSlot}.autoSpellLevels`) == null) {
      updateData[`data.attributes.spells.spellbooks.${spellbookSlot}.autoSpellLevels`] = true;
    }

    for (let a = 0; a < 10; a++) {
      const baseKey = `data.attributes.spells.spellbooks.${spellbookSlot}.spells.spell${a}.base`;
      const maxKey = `data.attributes.spells.spellbooks.${spellbookSlot}.spells.spell${a}.max`;
      const base = getProperty(ent, baseKey);
      const max = getProperty(ent, maxKey);

      if (base === undefined) {
        if (!linked) continue; // skip with unlinked tokens
        if (typeof max === "number" && max > 0) {
          updateData[baseKey] = max.toString();
        } else {
          updateData[baseKey] = "";
        }
      }
    }
  }
};

const _migrateActorBaseStats = function (ent, updateData) {
  const keys = [
    "data.attributes.hp.base",
    "data.attributes.hd.base",
    "data.attributes.mp.base",
    "data.attributes.savingThrows.fort.value",
    "data.attributes.savingThrows.ref.value",
    "data.attributes.savingThrows.will.value",
  ];
  for (let k of keys) {
    if (k === "data.attributes.hp.base" && !(getProperty(ent, "items") || []).filter((o) => o.type === "class").length)
      continue;
    if (k === "data.attributes.mp.base" && !(getProperty(ent, "items") || []).filter((o) => o.type === "class").length)
      continue;
    if (getProperty(ent, k) != null) {
      let kList = k.split(".");
      kList[kList.length - 1] = `-=${kList[kList.length - 1]}`;
      updateData[kList.join(".")] = null;
    }
  }
};

const _migrateUnusedActorCreatureType = function (ent, updateData) {
  const type = getProperty(ent, "data.attributes.creatureType");
  if (type != undefined) updateData["data.attributes.-=creatureType"] = null;
};

const _migrateActorSpellbookDCFormula = function (ent, updateData, linked) {
  const spellbooks = Object.keys(getProperty(ent, "data.attributes.spells.spellbooks") || {});

  for (let k of spellbooks) {
    const key = `data.attributes.spells.spellbooks.${k}.baseDCFormula`;
    const curFormula = getProperty(ent, key);
    if (!linked && curFormula === undefined) continue; // skip with unlinked tokens
    if (curFormula == null) updateData[key] = "10 + @sl + @ablMod";
  }
};

const _migrateActorSpellbookCL = function (ent, updateData) {
  const spellbooks = Object.keys(getProperty(ent, "data.attributes.spells.spellbooks") || {});

  for (let k of spellbooks) {
    const key = `data.attributes.spells.spellbooks.${k}.cl`;
    const curBase = parseInt(getProperty(ent, key + ".base"));
    const curFormula = getProperty(ent, key + ".formula");
    if (curBase > 0) {
      if (curFormula.length > 0) updateData[`${key}.formula`] = curFormula + " + " + curBase;
      else updateData[`${key}.formula`] = curFormula + curBase;
      updateData[`${key}.base`] = 0;
    }
  }
};

const _migrateActorHPAbility = function (ent, updateData) {
  // Set HP ability
  if (getProperty(ent, "data.attributes.hpAbility") === undefined) {
    updateData["data.attributes.hpAbility"] = "con";
  }

  // Set Fortitude save ability
  if (getProperty(ent, "data.attributes.savingThrows.fort.ability") === undefined) {
    updateData["data.attributes.savingThrows.fort.ability"] = "con";
  }

  // Set Reflex save ability
  if (getProperty(ent, "data.attributes.savingThrows.ref.ability") === undefined) {
    updateData["data.attributes.savingThrows.ref.ability"] = "dex";
  }

  // Set Will save ability
  if (getProperty(ent, "data.attributes.savingThrows.will.ability") === undefined) {
    updateData["data.attributes.savingThrows.will.ability"] = "wis";
  }
};

const _migrateItemArrayTypes = function (ent, updateData) {
  const conditionals = getProperty(ent, "data.conditionals");
  if (conditionals != null && !(conditionals instanceof Array)) {
    updateData["data.conditionals"] = [];
  }

  const contextNotes = getProperty(ent, "data.contextNotes");
  if (contextNotes != null && !(contextNotes instanceof Array)) {
    if (contextNotes instanceof Object) updateData["data.contextNotes"] = Object.values(contextNotes);
    else updateData["data.contextNotes"] = [];
  }
};

const _migrateItemSpellUses = function (ent, updateData) {
  if (getProperty(ent.data, "preparation") === undefined) return;

  const value = getProperty(ent.data, "preparation.maxAmount");
  if (typeof value !== "number") updateData["data.preparation.maxAmount"] = 0;
};

const _migrateWeaponDamage = function (ent, updateData) {
  if (ent.type !== "weapon") return;

  const value = getProperty(ent.data, "weaponData");
  if (typeof value !== "object") {
    updateData["data.weaponData"] = {};
    updateData["data.weaponData.critRange"] = 20;
    updateData["data.weaponData.critMult"] = 2;
  }
};

const _migrateWeaponImprovised = function (ent, updateData) {
  if (ent.type !== "weapon") return;

  const value = getProperty(ent.data, "weaponType");
  if (value === "improv") {
    updateData["data.weaponType"] = "misc";
    updateData["data.properties.imp"] = true;
  }
};

const _migrateSpellDescription = function (ent, updateData) {
  if (ent.type !== "spell") return;

  const curValue = getProperty(ent.data, "shortDescription");
  if (curValue != null) return;

  const obj = getProperty(ent.data, "description.value");
  if (typeof obj !== "string") return;
  const html = $(`<div>${obj}</div>`);
  const elem = html.find("h2").next();
  if (elem.length === 1) updateData["data.shortDescription"] = elem.prop("outerHTML");
  else updateData["data.shortDescription"] = html.prop("innerHTML");
};

const _migrateSpellDivineFocus = function (ent, updateData) {
  if (ent.type !== "spell") return;

  const value = getProperty(ent.data, "components.divineFocus");
  if (typeof value === "boolean") updateData["data.components.divineFocus"] = value === true ? 1 : 0;
};

const _migrateClassDynamics = function (ent, updateData) {
  if (ent.type !== "class") return;

  const bab = getProperty(ent.data, "bab");
  if (typeof bab === "number") updateData["data.bab"] = "low";

  const stKeys = ["data.savingThrows.fort.value", "data.savingThrows.ref.value", "data.savingThrows.will.value"];
  for (let key of stKeys) {
    let value = getProperty(ent, key);
    if (typeof value === "number") updateData[key] = "low";
  }
};

const _migrateClassType = function (ent, updateData) {
  if (ent.type !== "class") return;

  if (getProperty(ent.data, "classType") == null) updateData["data.classType"] = "base";
};

const _migrateWeaponCategories = function (ent, updateData) {
  if (ent.type !== "weapon") return;

  // Change category
  const type = getProperty(ent.data, "weaponType");
  if (type === "misc") {
    updateData["data.weaponType"] = "misc";
    updateData["data.weaponSubtype"] = "other";
  } else if (type === "splash") {
    updateData["data.weaponType"] = "misc";
    updateData["data.weaponSubtype"] = "splash";
  }

  const changeProp = ["simple", "martial", "exotic", "chef", "power"].includes(type);
  if (changeProp && getProperty(ent.data, "weaponSubtype") == null) {
    updateData["data.weaponSubtype"] = "1h";
  }

  // Change light property
  const lgt = getProperty(ent.data, "properties.lgt");
  if (lgt != null) {
    updateData["data.properties.-=lgt"] = null;
    if (lgt === true && changeProp) {
      updateData["data.weaponSubtype"] = "light";
    }
  }

  // Change two-handed property
  const two = getProperty(ent.data, "properties.two");
  if (two != null) {
    updateData["data.properties.-=two"] = null;
    if (two === true && changeProp) {
      updateData["data.weaponSubtype"] = "2h";
    }
  }

  // Change melee property
  const melee = getProperty(ent.data, "weaponData.isMelee");
  if (melee != null) {
    updateData["data.weaponData.-=isMelee"] = null;
    if (melee === false && changeProp) {
      updateData["data.weaponSubtype"] = "ranged";
    }
  }
};

const _migrateEquipmentCategories = function (ent, updateData) {
  if (ent.type !== "equipment") return;

  const oldType = getProperty(ent.data, "armor.type");
  if (oldType == null) return;

  if (oldType === "clothing") {
    updateData["data.equipmentType"] = "misc";
    updateData["data.equipmentSubtype"] = "clothing";
  } else if (oldType === "shield") {
    updateData["data.equipmentType"] = "shield";
    updateData["data.equipmentSubtype"] = "lightShield";
    updateData["data.slot"] = "shield";
  } else if (oldType === "misc") {
    updateData["data.equipmentType"] = "misc";
    updateData["data.equipmentSubtype"] = "wondrous";
  } else if (["light", "medium", "heavy"].includes(oldType)) {
    updateData["data.equipmentType"] = "armor";
    updateData["data.equipmentSubtype"] = `${oldType}Armor`;
  }

  updateData["data.armor.-=type"] = null;
};

const _migrateItemSize = function (ent, updateData, linked) {
  // Convert custom sizing in weapons
  if (ent.type === "weapon") {
    const wdSize = getProperty(ent, "data.weaponData.size");
    if (wdSize) {
      // Move old
      updateData["data.size"] = wdSize;
      updateData["data.weaponData.-=size"] = null;
      return;
    }
  }
  // Convert any other instances
  if (!getProperty(ent, "data.size")) {
    // Fill in missing
    updateData["data.size"] = "med";
  }
};

const _migrateAbilityTypes = function (ent, updateData) {
  if (ent.type !== "feat") return;

  if (getProperty(ent, "data.abilityType") == null) {
    updateData["data.abilityType"] = "none";
  }
  // Fix buggy value
  if (getProperty(ent, "data.abilityType") === "n/a") {
    updateData["data.abilityType"] = "none";
  }
};

const _migrateClassLevels = function (ent, updateData) {
  const level = getProperty(ent, "data.levels");
  if (typeof level === "number" && getProperty(ent, "data.level") == null) {
    updateData["data.level"] = level;
    updateData["data.-=levels"] = null;
  }
};

const _migrateSavingThrowTypes = function (ent, updateData) {
  if (getProperty(ent, "data.save.type") == null && typeof getProperty(ent, "data.save.description") === "string") {
    const desc = getProperty(ent, "data.save.description");
    if (desc.match(/REF/i)) updateData["data.save.type"] = "ref";
    else if (desc.match(/FORT/i)) updateData["data.save.type"] = "fort";
    else if (desc.match(/WILL/i)) updateData["data.save.type"] = "will";
  }
};

const _migrateCR = function (ent, updateData) {
  // Migrate CR offset
  const crOffset = getProperty(ent, "data.crOffset");
  if (typeof crOffset === "number") {
    updateData["data.crOffset"] = crOffset.toString();
  }
};

const _migrateItemChanges = function (ent, updateData) {
  // Migrate changes
  const changes = getProperty(ent, "data.changes");
  if (changes != null && changes instanceof Array) {
    let newChanges = [];
    for (let c of changes) {
      if (c instanceof Array) {
        const nc = ItemChange.create(
          {
            formula: c[0],
            target: c[1],
            subTarget: c[2],
            modifier: c[3],
            value: c[4],
          },
          null
        );
        newChanges.push(nc.data);
      } else {
        const nc = ItemChange.create(c, null);
        newChanges.push(nc.data);
      }
    }

    // Alter the changes list
    updateData["data.changes"] = newChanges;
  }

  // Migrate context notes
  const notes = getProperty(ent, "data.contextNotes");
  if (notes != null && notes instanceof Array) {
    let newNotes = [];
    for (let n of notes) {
      if (n instanceof Array) {
        newNotes.push(mergeObject(ItemFFD20.defaultContextNote, { text: n[0], subTarget: n[2] }, { inplace: false }));
      } else {
        newNotes.push(n);
      }

      // Migrate old note targets
      if (n.target === "spell" && n.subTarget === "effect") {
        n.subTarget = "spellEffect";
      }
    }

    // Alter the context note list
    updateData["data.contextNotes"] = newNotes;
  }
};

const _migrateTemplateSize = function (ent, updateData) {
  const measureSize = getProperty(ent, "data.measureTemplate.size");
  if (typeof measureSize === "number") {
    updateData["data.measureTemplate.size"] = measureSize.toString();
  }
};

const _migrateEquipmentSize = function (ent, updateData) {
  if (ent.type !== "equipment") return;

  const size = getProperty(ent, "data.size");
  if (!size) {
    updateData["data.size"] = "med";
  }
};

const _migrateTags = function (ent, updateData) {
  if (!["class"].includes(ent.type)) return;

  const tag = getProperty(ent, "data.tag");
  if (!tag && ent.name) {
    updateData["data.tag"] = createTag(ent.name);
  }
};

const _migrateSpellCosts = function (ent, updateData) {
  if (ent.type !== "spell") return;

  const spellPointCost = getProperty(ent, "data.spellPoints.cost");
  if (spellPointCost == null) {
    updateData["data.spellPoints.cost"] = "@sl";
  }

  const slotCost = getProperty(ent, "data.slotCost");
  if (slotCost == null) {
    updateData["data.slotCost"] = 1;
  }

  // Migrate level 0 spell charge deduction in a specific version
  if (
    !SemanticVersion.fromString(game.system.data.version).isHigherThan(SemanticVersion.fromString("0.77.11")) &&
    getProperty(ent, "data.level") === 0
  ) {
    updateData["data.preparation.autoDeductCharges"] = false;
  }
};

const _migrateLootEquip = function (ent, updateData) {
  if (ent.type === "loot" && !hasProperty(ent, "equipped")) {
    updateData["data.equipped"] = false;
  }
};

const _migrateUnchainedActionEconomy = function (ent, updateData) {
  // Determine existing data
  const curAction = getProperty(ent, "data.activation");
  const unchainedAction = getProperty(ent, "data.unchainedAction.activation");
  if (!curAction || (curAction && !curAction.type)) return;
  if (unchainedAction && unchainedAction.type) return;

  // Create unchained action economy data
  if (CONFIG.FFD20.abilityActivationTypes_unchained[curAction.type] != null) {
    updateData["data.unchainedAction.activation.cost"] = curAction.cost;
    updateData["data.unchainedAction.activation.type"] = curAction.type;
  }
  if (["swift", "attack"].includes(curAction.type)) {
    updateData["data.unchainedAction.activation.cost"] = 1;
    updateData["data.unchainedAction.activation.type"] = curAction.type === "attack" ? "attack" : "action";
  }
  if (curAction.type === "standard") {
    updateData["data.unchainedAction.activation.cost"] = 2;
    updateData["data.unchainedAction.activation.type"] = "action";
  }
  if (curAction.type === "full" || curAction.type === "round") {
    updateData["data.unchainedAction.activation.cost"] = 3 * (curAction.cost || 1);
    updateData["data.unchainedAction.activation.type"] = "action";
  }
  if (curAction.type === "immediate") {
    updateData["data.unchainedAction.activation.type"] = "reaction";
    updateData["data.unchainedAction.activation.cost"] = 1;
  }
};

const _migrateItemRange = function (ent, updateData) {
  // Set max range increment
  if (getProperty(ent, "data.range.maxIncrements") === undefined) {
    setProperty(updateData, "data.range.maxIncrements", 1);
  }

  if (ent.type === "weapon" && getProperty(ent, "data.weaponData.maxRangeIncrements") === undefined) {
    setProperty(updateData, "data.weaponData.maxRangeIncrements", 1);
  }
};

const _migrateItemLinks = function (ent, updateData) {
  if (["attack", "consumable", "equipment"].includes(ent.type) && !hasProperty(ent, "data.links.charges")) {
    updateData["data.links.charges"] = [];
  }
};

const _migrateProficiencies = function (ent, updateData) {
  // Add proficiency objects to items able to grant proficiencies
  if (["feat", "class", "race"].includes(ent.type)) {
    for (const prof of ["armorProf", "weaponProf", "languages"]) {
      if (!hasProperty(ent, `data.${prof}`))
        updateData[`data.${prof}`] = {
          value: [],
          custom: "",
        };
    }
  }
};

const _migrateItemNotes = function (ent, updateData) {
  const list = ["data.attackNotes", "data.effectNotes"];
  for (let k of list) {
    const value = getProperty(ent, k);
    const hasValue = hasProperty(ent, k);
    if (hasValue && !(value instanceof Array)) {
      updateData[k] = [];
      if (typeof value === "string" && value.length > 0) {
        updateData[k] = value.trim().split(/[\n\r]/);
      }
    }
  }
};

const _migrateActorCR = function (ent, updateData, linked) {
  // Migrate base CR
  const cr = getProperty(ent, "data.details.cr");
  if (!linked && cr === undefined) return; // skip with unlinked tokens
  if (typeof cr === "number") {
    updateData["data.details.cr.base"] = cr;
    updateData["data.details.cr.total"] = cr;
  } else if (cr == null) {
    updateData["data.details.cr.base"] = 1;
    updateData["data.details.cr.total"] = 1;
  }
};

const _migrateAttackAbility = function (ent, updateData, linked) {
  const cmbAbl = getProperty(ent, "data.attributes.cmbAbility");
  if (cmbAbl == null && linked) updateData["data.attributes.cmbAbility"] = "str";

  const meleeAbl = getProperty(ent, "data.attributes.attack.meleeAbility");
  if (meleeAbl == null && linked) updateData["data.attributes.attack.meleeAbility"] = "str";

  const rangedAbl = getProperty(ent, "data.attributes.attack.rangedAbility");
  if (rangedAbl == null && linked) updateData["data.attributes.attack.rangedAbility"] = "dex";
};

const _migrateActorTokenVision = function (ent, updateData) {
  const vision = getProperty(ent, "data.attributes.vision");
  if (!vision) return;

  updateData["data.attributes.-=vision"] = null;
  updateData["token.flags.ffd20.lowLightVision"] = vision.lowLight;
  if (!getProperty(ent, "token.brightSight")) updateData["token.brightSight"] = vision.darkvision ?? 0;
};

const _migrateActorSpellbookUsage = function (ent, updateData, linked) {
  const spellbookUsage = getProperty(ent, "data.attributes.spells.usedSpellbooks");

  if (!linked && spellbookUsage === undefined) return; // skip with unlinked tokens
  if (spellbookUsage == null) {
    let usedSpellbooks = [];
    if (!ent.items) return;
    const spells = ent.items.filter((o) => o.type === "spell");
    for (let o of spells) {
      const sb = o.data.spellbook;
      if (sb && !usedSpellbooks.includes(sb)) {
        usedSpellbooks.push(sb);
      }
    }
    updateData["data.attributes.spells.usedSpellbooks"] = usedSpellbooks;
  }
};

const _migrateActorNullValues = function (ent, updateData) {
  // Prepare test data
  const entries = { "data.attributes.energyDrain": getProperty(ent, "data.attributes.energyDrain") };
  for (let [k, a] of Object.entries(getProperty(ent.data, "data.abilities") || {})) {
    entries[`data.abilities.${k}.damage`] = a.damage;
    entries[`data.abilities.${k}.drain`] = a.drain;
    entries[`data.abilities.${k}.penalty`] = a.penalty;
  }

  // Set null values to 0
  for (let [k, v] of Object.entries(entries)) {
    if (v === null) {
      updateData[k] = 0;
    }
  }
};

const _migrateActorSpellbookDomainSlots = function (ent, updateData) {
  const spellbooks = getProperty(ent, "data.attributes.spells.spellbooks") || {};

  for (let [k, b] of Object.entries(spellbooks)) {
    if (b.domainSlotValue !== undefined) continue;
    const key = `data.attributes.spells.spellbooks.${k}.domainSlotValue`;
    updateData[key] = 1;
  }
};

const _migrateActorStatures = function (ent, updateData) {
  const stature = getProperty(ent, "data.traits.stature");

  if (stature === undefined) {
    updateData["data.traits.stature"] = "tall";
  }
};

const _migrateActorDefenseAbility = function (ent, updateData) {
  const normalACAbl = getProperty(ent, "data.attributes.ac.normal.ability");
  if (normalACAbl === undefined) updateData["data.attributes.ac.normal.ability"] = "dex";
  const touchACAbl = getProperty(ent, "data.attributes.ac.touch.ability");
  if (touchACAbl === undefined) updateData["data.attributes.ac.touch.ability"] = "dex";
  const cmdAbl = getProperty(ent, "data.attributes.cmd.dexAbility");
  if (cmdAbl === undefined) updateData["data.attributes.cmd.dexAbility"] = "dex";
};

const _migrateActorInitAbility = function (ent, updateData) {
  const abl = getProperty(ent, "data.attributes.init.ability");

  if (abl === undefined) {
    updateData["data.attributes.init.ability"] = "dex";
  }
};

const _migrateActorChangeRevamp = function (ent, updateData) {
  const keys = {
    "data.attributes.ac.normal.total": 10,
    "data.attributes.ac.touch.total": 10,
    "data.attributes.ac.flatFooted.total": 10,
    "data.attributes.cmd.total": 10,
    "data.attributes.cmd.flatFootedTotal": 10,
    "data.attributes.sr.total": 0,
    "data.attributes.init.total": 0,
    "data.attributes.cmb.total": 0,
    "data.attributes.hp.max": 0,
  };

  const skillKeys = Object.keys(getProperty(ent, "data.skills") ?? {}).reduce((cur, s) => {
    cur.push(`data.skills.${s}.changeBonus`);
    // Check for subskill
    Object.keys(getProperty(ent, `data.skills.${s}.subSkills`) ?? {}).forEach((s2) => {
      cur.push(`data.skills.${s}.subSkills.${s2}.changeBonus`);
    });

    return cur;
  }, []);
  for (let k of skillKeys) {
    keys[k] = 0;
  }

  for (const [k, v] of Object.entries(keys)) {
    updateData[k] = v;
  }
};

const _migrateActorConditions = function (ent, updateData) {
  // Migrate fear to shaken
  {
    const cond = getProperty(ent, "data.conditions.fear");
    if (cond === true) {
      updateData["data.conditions.shaken"] = true;
      updateData["data.conditions.-=fear"] = null;
    }
  }
};

/**
 * Migrate abnormal skill rank values to 0.
 * Primarily changing nulls to 0 to match new actors.
 *
 * @param ent
 * @param updateData
 * @param linked
 */
const _migrateActorSkillRanks = function (ent, updateData, linked) {
  const skills = getProperty(ent, "data.skills");
  if (!skills) return; // Unlinked with no skill overrides of any kind
  for (let [key, data] of Object.entries(skills)) {
    if (!linked && data.rank === undefined) continue; // Unlinked with no override
    if (!Number.isFinite(data.rank)) updateData[`data.skills.${key}.rank`] = 0;
    for (let [subKey, subData] of Object.entries(data.subSkills ?? {})) {
      if (!linked && subData.rank === undefined) continue; // Unlinked with no override
      if (!Number.isFinite(subData.rank)) updateData[`data.skills.${key}.subSkills.${subKey}.rank`] = 0;
    }
  }
};

const _migrateCarryBonus = function (ent, updateData, linked) {
  if (getProperty("data.details.carryCapacity.bonus.user") === undefined) {
    let bonus = getProperty(ent, "data.abilities.str.carryBonus");
    if (bonus !== undefined || linked) {
      bonus = bonus || 0;
      updateData["data.details.carryCapacity.bonus.user"] = bonus;
    }
    updateData["data.abilities.str.-=carryBonus"] = null;
  }
  if (getProperty("data.details.carryCapacity.multiplier.user") === undefined) {
    let mult = getProperty(ent, "data.abilities.str.carryMultiplier");
    if (mult !== undefined || linked) {
      mult = mult || 1;
      updateData["data.details.carryCapacity.multiplier.user"] = mult - 1;
    }
    updateData["data.abilities.str.-=carryMultiplier"] = null;
  }
};

const migrations = /*#__PURE__*/Object.freeze({
  __proto__: null,
  migrateWorld: migrateWorld,
  migrateCompendium: migrateCompendium,
  migrateActorData: migrateActorData,
  migrateItemData: migrateItemData,
  migrateSceneData: migrateSceneData
});

/**
 * Various functions dealing with the creation and usage of macros.
 *
 * @module macros
 */

/**
 * Create a Macro from an Item drop, or get an existing one.
 *
 * @param {object} item     The item data
 * @param {number} slot     The hotbar slot to use
 * @returns {Promise<User>} The updated User
 */
const createItemMacro = async function (item, slot) {
  const actor = getItemOwner(item);
  const command =
    `game.ffd20.rollItemMacro("${item.name}", {\n` +
    `  itemId: "${item._id}",\n` +
    `  itemType: "${item.type}",\n` +
    (actor != null ? `  actorId: "${actor._id}",\n` : "") +
    `});`;
  let macro = game.macros.contents.find((m) => m.name === item.name && m.data.command === command);
  if (!macro) {
    macro = await Macro.create(
      {
        name: item.name,
        type: "script",
        img: item.img,
        command: command,
        flags: { "ffd20.itemMacro": true },
      },
      { displaySheet: false }
    );
  }
  return game.user.assignHotbarMacro(macro, slot);
};

/**
 * Create a Macro from skill data to roll an actor's skill, or get an existing one.
 *
 * @async
 * @param {string} skillId - The skill's identifier
 * @param {string} actorId - The actor's identifier
 * @param {number} slot - The hotbar slot to use
 * @returns {Promise<User>} The updated User
 */
const createSkillMacro = async function (skillId, actorId, slot) {
  const actor = getActorFromId(actorId);
  if (!actor) return;

  const skillInfo = actor.getSkillInfo(skillId);
  const command = `game.ffd20.rollSkillMacro("${actorId}", "${skillId}");`;
  const name = game.i18n.format("FFD20.RollSkillMacroName", { 0: actor.name, 1: skillInfo.name });
  let macro = game.macros.contents.find((m) => m.name === name && m.data.command === command);
  if (!macro) {
    macro = await Macro.create(
      {
        name: name,
        type: "script",
        img: "systems/ffd20/icons/items/inventory/dice.jpg",
        command: command,
        flags: { "ffd20.skillMacro": true },
      },
      { displaySheet: false }
    );
  }

  return game.user.assignHotbarMacro(macro, slot);
};

/**
 * Create a Macro from save data to roll an actor's save, or get an existing one.
 *
 * @async
 * @param {string} saveId - The save's identifier
 * @param {string} actorId - The actor's identifier
 * @param {number} slot - The hotbar slot to use
 * @returns {Promise<User>} The updated User
 */
const createSaveMacro = async function (saveId, actorId, slot) {
  const actor = getActorFromId(actorId);
  let saveName = game.i18n.localize("FFD20.SavingThrow" + saveId.substr(0, 1).toUpperCase() + saveId.substr(1));
  if (!actor) return;

  const command = `game.ffd20.rollSaveMacro("${actorId}", "${saveId}");`;

  const name = game.i18n.format("FFD20.RollSaveMacroName", { 0: actor.name, 1: saveName });
  let macro = game.macros.contents.find((m) => m.name === name && m.data.command === command);
  if (!macro) {
    macro = await Macro.create(
      {
        name: name,
        type: "script",
        img: "systems/ffd20/icons/items/inventory/dice.jpg",
        command: command,
        flags: { "ffd20.saveMacro": true },
      },
      { displaySheet: false }
    );
  }

  return game.user.assignHotbarMacro(macro, slot);
};

/**
 * Create a Macro to roll one of various checks for an actor
 *
 * @async
 * @param {string} type - The type of macro to create
 * @param {string} actorId - The actor's identifier
 * @param {number} slot - The hotbar slot to use
 * @param {string} [altType] - An alternative type, used to denote a spellbook
 * @returns {Promise<User|void>} The updated User, if an update is triggered
 */
const createMiscActorMacro = async function (type, actorId, slot, altType = null) {
  const actor = getActorFromId(actorId);
  if (!actor) return;

  let altTypeLabel = "";
  switch (altType) {
    case "primary":
      altTypeLabel = "Primary";
      break;
    case "secondary":
      altTypeLabel = "Secondary";
      break;
    case "tertiary":
      altTypeLabel = "Tertiary";
      break;
    case "spelllike":
      altTypeLabel = "Spell-like";
      break;
  }

  const command = altType
    ? `game.ffd20.rollActorAttributeMacro("${actorId}", "${type}", "${altType}");`
    : `game.ffd20.rollActorAttributeMacro("${actorId}", "${type}");`;
  let name, img;
  switch (type) {
    case "defenses":
      name = game.i18n.format("FFD20.RollDefensesMacroName", { 0: actor.name });
      img = "systems/ffd20/icons/items/armor/shield-light-metal.png";
      break;
    case "cmb":
      name = game.i18n.format("FFD20.RollCMBMacroName", { 0: actor.name });
      img = "systems/ffd20/icons/feats/improved-grapple.jpg";
      break;
    case "cl":
      name = game.i18n.format("FFD20.RollCLMacroName", { 0: actor.name, 1: altTypeLabel });
      img = "systems/ffd20/icons/spells/wind-grasp-eerie-3.jpg";
      break;
    case "concentration":
      name = game.i18n.format("FFD20.RollConcentrationMacroName", { 0: actor.name, 1: altTypeLabel });
      img = "systems/ffd20/icons/skills/light_01.jpg";
      break;
    case "bab":
      name = game.i18n.format("FFD20.RollBABMacroName", { 0: actor.name });
      img = "systems/ffd20/icons/skills/yellow_08.jpg";
      break;
  }

  if (!name) return;

  let macro = game.macros.contents.find((o) => o.name === name && o.data.command === command);
  if (!macro) {
    macro = await Macro.create(
      {
        name: name,
        type: "script",
        img: img,
        command: command,
        flags: { "ffd20.miscMacro": true },
      },
      { displaySheet: false }
    );
  }

  return game.user.assignHotbarMacro(macro, slot);
};

/**
 * Roll an actor's item
 *
 * @param {string} itemName - The item's name
 * @param {object} [options] - Additional options
 * @param {string} [options.itemId] - The item's identifier
 * @param {string} [options.itemType] - The item's type
 * @param {string} [options.actorId] - The actorś identifier
 * @returns {Promise|void} The item's roll or void if any requirements are not met
 */
const rollItemMacro = function (itemName, { itemId, itemType, actorId } = {}) {
  let actor = getActorFromId(actorId);
  if (actor && !actor.testUserPermission(game.user, "OWNER")) {
    const msg = game.i18n.localize("FFD20.ErrorNoActorPermission");
    console.warn(msg);
    return ui.notifications.warn(msg);
  }
  const item = actor
    ? actor.items.find((i) => {
        if (itemId != null && i.id !== itemId) return false;
        if (itemType != null && i.type !== itemType) return false;
        return i.name === itemName;
      })
    : null;
  if (!item) {
    const msg = game.i18n.format("FFD20.WarningNoItemOnActor", { 0: actor.name, 1: itemName });
    console.warn(msg);
    return ui.notifications.warn(msg);
  }

  // Trigger the item roll
  if (!game.keyboard.isDown("Control")) {
    return item.use({ skipDialog: getSkipActionPrompt() });
  }
  return item.roll();
};

/**
 * Roll an actor's skill
 *
 * @param {string} actorId - The actor's identifier
 * @param {string} skillId - The skill's identifier
 * @returns {Promise|void} The skill roll, or void if no skill is found
 */
const rollSkillMacro = function (actorId, skillId) {
  const actor = getActorFromId(actorId);
  if (!actor) {
    const msg = game.i18n.format("FFD20.ErrorActorNotFound", { 0: actorId });
    console.warn(msg);
    return ui.notifications.error(msg);
  }

  return actor.rollSkill(skillId, { skipDialog: getSkipActionPrompt() });
};

/**
 * Roll an actor's save
 *
 * @param {string} actorId - The actor's identifier
 * @param {string} saveId - The save's identifier
 * @returns {Promise|void} The save roll, or void if no save is found
 */
const rollSaveMacro = function (actorId, saveId) {
  const actor = getActorFromId(actorId);
  if (!actor) {
    const msg = game.i18n.format("FFD20.ErrorActorNotFound", { 0: actorId });
    console.warn(msg);
    return ui.notifications.error(msg);
  }

  return actor.rollSavingThrow(saveId, { skipDialog: getSkipActionPrompt() });
};

/**
 * Show an actor's defenses
 *
 * @param {object} [options] - Additional parameters
 * @param {string} [options.actorName] - The actor's name
 * @param {string} [options.actorId] - The actor's identifier
 * @returns {Promise|void} The defense roll, or void if no actor is found
 */
const rollDefenses = function ({ actorName = null, actorId = null } = {}) {
  const actor = ActorFFD20.getActiveActor({ actorName: actorName, actorId: actorId });
  if (!actor) {
    const msg = game.i18n.format("FFD20.ErrorNoApplicableActorFoundForAction", {
      0: game.i18n.localize("FFD20.Action_RollDefenses"),
    });
    console.warn(msg);
    return ui.notifications.warn(msg);
  }

  return actor.rollDefenses();
};

/**
 * Roll one of an actor's various attributes
 *
 * @param {string} actorId - The actor's identifier
 * @param {string} type - The attribute to roll
 * @param {string} [altType] - An additional qualifier, used e.g. to determine a roll's spellbook
 * @returns {Promise|void} The roll, or void if no actor is found
 */
const rollActorAttributeMacro = function (actorId, type, altType = null) {
  const actor = getActorFromId(actorId);
  if (!actor) {
    const msg = game.i18n.format("FFD20.ErrorActorNotFound", { 0: actorId });
    console.error(msg);
    return ui.notifications.error(msg);
  }

  switch (type) {
    case "defenses":
      return actor.rollDefenses();
    case "cmb":
      return actor.rollCMB();
    case "cl":
      return actor.rollCL(altType);
    case "concentration":
      return actor.rollConcentration(altType);
    case "bab":
      return actor.rollBAB();
  }
};

const macros = /*#__PURE__*/Object.freeze({
  __proto__: null,
  createItemMacro: createItemMacro,
  createSkillMacro: createSkillMacro,
  createSaveMacro: createSaveMacro,
  createMiscActorMacro: createMiscActorMacro,
  rollItemMacro: rollItemMacro,
  rollSkillMacro: rollSkillMacro,
  rollSaveMacro: rollSaveMacro,
  rollDefenses: rollDefenses,
  rollActorAttributeMacro: rollActorAttributeMacro
});

class Registry {
  static _createDatabase(key) {
    if (!Object.hasOwnProperty.call(this, "database")) this.database = {};
    if (!Object.hasOwnProperty.call(this.database, key)) this.database[key] = [];
  }

  /**
   * Registers a value to a database.
   *
   * @param {string} databaseKey - The key of the database to register to.
   * @param {string} module - The module to register this value as. Should be equal to that of the 'name' field in the module's manifest. Used primarily for de-registering values.
   * @param {object} value - The value to register to the registry.
   * @returns {boolean} Whether successful.
   */
  static register(databaseKey, module, value) {
    this._createDatabase(databaseKey);

    this.database[databaseKey].push({ value, module });
    return true;
  }
  /**
   * De-registers something from a database.
   *
   * @param {string} databaseKey - The database key to de-register values from.
   * @param {string} module - The module for which to de-register stuff from.
   * @param {object} [value=null] - The specific value to de-register. Leave null to de-register all values of the given module from this database.
   */
  static unregister(databaseKey, module, value) {
    this._createDatabase(databaseKey);

    if (this.value == null) this.database[databaseKey] = this.database[databaseKey].filter((o) => o.module !== module);
    else {
      this.database[databaseKey] = this.database[databaseKey].filter((o) => {
        return !(o.value === value && o.module === module);
      });
    }
  }
  /**
   * @param {string} databaseKey - The key of the database to find results from.
   * @returns {object[]} All values associated with the database.
   */
  static getAll(databaseKey) {
    this._createDatabase(databaseKey);

    if (!Object.hasOwnProperty.call(this.database, databaseKey)) return [];
    return this.database[databaseKey].map((o) => o.value);
  }

  // Script calls
  /**
   * Registers a category for item script calls.
   *
   * @param {string} module - The module to register this value as. Should be equal to that of the 'name' field in the module's manifest. Used primarily for de-registering values.
   * @param {string} key - The unique key of the category.
   * @param {string} name - The name of the category. Can be something usable with `game.i18n.localize`.
   * @param {string[]} itemTypes - The item types to add this category to. Something like `["equipment", "buffs"]`.
   * @param {string} [info=null] - The information of the category. Can be something usable with `game.i18n.localize`.
   * @returns {boolean} Whether successful.
   */
  static registerItemScriptCategory(module, key, name, itemTypes, info) {
    if (this.getAll("itemScriptCategories").find((o) => o.key === key)) return false;
    return this.register("itemScriptCategories", module, { key, name, itemTypes, info });
  }
  static unregisterItemScriptCategory(module, key) {
    const dbKey = "itemScriptCategories";
    this._createDatabase(dbKey);

    if (key == null) this.database[dbKey] = this.database[dbKey].filter((o) => o.module !== module);
    else {
      this.database[dbKey] = this.database[dbKey].filter((o) => {
        return !(o.value.key === key && o.module === module);
      });
    }
  }
  static getItemScriptCategories() {
    return this.getAll("itemScriptCategories");
  }
}

/**
 * Initialize module compatibility/integration code.
 *
 * Currently integrated modules:
 * - Drag Ruler
 */
function initializeModules() {
  // Drag Ruler
  {
    Hooks.once("dragRuler.ready", (SpeedProvider) => {
      const enhancedTerrain = game.modules.get("enhanced-terrain-layer")?.active;

      class ffd20SpeedProvider extends SpeedProvider {
        get colors() {
          return [
            { id: "walk", default: 0x00ff00, name: "SETTINGS.ffd20DragRulerWalk" },
            { id: "dash", default: 0xffff00, name: "SETTINGS.ffd20DragRulerDash" },
            { id: "run", default: 0xff8000, name: "SETTINGS.ffd20DragRulerRun" },
          ];
        }

        getRanges(token) {
          const baseSpeed = convertDistance(this.getBaseSpeed(token))[0];
          // Search through items for pieces of heavy armor that is equipped
          const heavyArmor = token.actor.items.find(
            (item) =>
              item.data.type === "equipment" &&
              item.data.data.equipmentType === "armor" &&
              item.data.data.equipped &&
              item.data.data.equipmentSubtype === "heavyArmor"
          );
          // Check for heavy load encumbrance
          const heavyLoad = token.actor.data.data.attributes.encumbrance.level >= 2;

          let runMultiplier = 4;
          if (heavyArmor || heavyLoad) runMultiplier = 3;
          return [
            { range: baseSpeed, color: "walk" },
            { range: baseSpeed * 2, color: "dash" },
            { range: baseSpeed * runMultiplier, color: "run" },
          ];
        }

        getBaseSpeed(token) {
          const [y, x] = canvas.grid.grid.getGridPositionFromPixels(token.x, token.y);

          if (token.data.elevation > 0) {
            const flySpeed = token.actor.data.data.attributes.speed.fly.total;
            if (flySpeed > 0) {
              return flySpeed;
            }
          }

          if (
            enhancedTerrain &&
            canvas.terrain.terrainAt(x, y).some((terrain) => terrain.data.environment === "water")
          ) {
            const swimSpeed = token.actor.data.data.attributes.speed.swim.total;
            if (swimSpeed > 0) {
              return swimSpeed;
            }
          }

          if (token.data.elevation < 0) {
            const burrowSpeed = token.actor.data.data.attributes.speed.burrow.total;
            if (burrowSpeed > 0) {
              return burrowSpeed;
            }
          }

          return token.actor.data.data.attributes.speed.land.total;
        }
      }
      dragRuler.registerSystem("ffd20", ffd20SpeedProvider);
    });
  }
}

/* eslint-disable no-case-declarations */

// Add String.format
if (!String.prototype.format) {
  String.prototype.format = function (...args) {
    return this.replace(/{(\d+)}/g, function (match, number) {
      return args[number] != null ? args[number] : match;
    });
  };
}

/* -------------------------------------------- */
/*  Foundry VTT Initialization                  */
/* -------------------------------------------- */

Hooks.once("init", function () {
  console.log(`FFD20 | Initializing Final Fantasy D20 System`);

  // Register client settings
  registerClientSettings();

  // Create a FFD20 namespace within the game global
  game.ffd20 = {
    documents: { ActorFFD20, ItemFFD20, TokenDocumentFFD20 },
    entities: { ActorFFD20, ItemFFD20, TokenDocumentFFD20 },
    applications: {
      // Actors
      ActorSheetFFD20,
      ActorSheetFFD20Character,
      ActorSheetFFD20NPC,
      ActorSheetFFD20NPCLite,
      ActorSheetFFD20NPCLoot,
      // Items
      ItemSheetFFD20,
      ItemSheetFFD20_Container,
      // Misc
      ActorSheetFlags,
      ActorRestDialog,
      ActorTraitSelector,
      CompendiumDirectoryFFD20,
      CompendiumBrowser,
      EntrySelector,
      LevelUpForm,
      PointBuyCalculator,
      ScriptEditor,
      SidebarFFD20,
      TooltipFFD20,
      FFD20_HelpBrowser,
      ExperienceDistributor,
      // Widgets
      Widget_CategorizedItemPicker,
      CurrencyTransfer,
    },
    compendiums: {},
    // Rolling
    DiceFFD20,
    rollPreProcess: {
      sizeRoll: sizeDieExt,
      sizeReach: sizeReach,
      roll: normalDie,
    },
    //Chat
    chat: { ChatAttack, ChatMessageFFD20 },
    // Utility
    utils: {
      createTag,
      createTabs,
      getItemOwner,
      getActorFromId,
      getChangeFlat,
      getSourceInfo,
      convertDistance,
      convertWeight,
      convertWeightBack,
      measureDistances,
      measureReachDistance,
      dialogGetActor,
      dialogGetNumber,
      SemanticVersion,
      binarySearch,
      sortArrayByName,
      findInCompendia,
    },
    // Components
    documentComponents: {
      ItemChange,
    },
    // API
    registry: Registry,
    // Macros
    macros,
    rollItemMacro: rollItemMacro,
    rollSkillMacro: rollSkillMacro,
    rollSaveMacro: rollSaveMacro,
    rollDefenses: rollDefenses,
    rollActorAttributeMacro: rollActorAttributeMacro,
    // Migrations
    migrations,
    migrateWorld: migrateWorld,
    isMigrating: false,
    // Misc
    config: FFD20,
    tooltip: null,
    runUnitTests,
    AbilityTemplate,
    // Function library
    functions: {
      getBuffTargets,
      getBuffTargetDictionary,
    },
  };

  // Global exports
  globalThis.RollFFD20 = RollFFD20$1;

  // Record Configuration Values
  CONFIG.FFD20 = FFD20;
  CONFIG.Actor.documentClass = ActorFFD20;
  CONFIG.Token.documentClass = TokenDocumentFFD20;
  CONFIG.ActiveEffect.documentClass = ActiveEffectFFD20;
  CONFIG.Item.documentClass = ItemFFD20;
  CONFIG.ui.compendium = CompendiumDirectoryFFD20;
  CONFIG.ChatMessage.documentClass = ChatMessageFFD20;
  CONFIG.Dice.rolls.splice(0, 0, RollFFD20$1);

  // Register System Settings
  registerSystemSettings();

  //Calculate conditions for world
  CONFIG.statusEffects = getConditions();

  // Preload Handlebars Templates
  preloadHandlebarsTemplates();
  registerHandlebarsHelpers();

  // Patch Core Functions
  PatchCore();

  // Register sheet application classes
  Actors.unregisterSheet("core", ActorSheet);
  Actors.registerSheet("FFD20", ActorSheetFFD20Character, {
    label: "FFD20.Sheet.PC",
    types: ["character"],
    makeDefault: true,
  });
  Actors.registerSheet("FFD20", ActorSheetFFD20NPC, { label: "FFD20.Sheet.NPC", types: ["npc"], makeDefault: true });
  Actors.registerSheet("FFD20", ActorSheetFFD20NPCLite, { label: "FFD20.Sheet.NPCLite", types: ["npc"], makeDefault: false });
  Actors.registerSheet("FFD20", ActorSheetFFD20NPCLoot, { label: "FFD20.Sheet.NPCLoot", types: ["npc"], makeDefault: false });
  Items.unregisterSheet("core", ItemSheet);
  Items.registerSheet("FFD20", ItemSheetFFD20, {
    label: "FFD20.Sheet.Item",
    types: ["class", "feat", "spell", "consumable", "equipment", "loot", "weapon", "buff", "attack", "race"],
    makeDefault: true,
  });
  Items.registerSheet("FFD20", ItemSheetFFD20_Container, {
    label: "FFD20.Sheet.Container",
    types: ["container"],
    makeDefault: true,
  });

  // Register item categories
  game.ffd20.registry.registerItemScriptCategory(
    "ffd20",
    "use",
    "FFD20.ScriptCalls.Use.Name",
    ["attack", "feat", "equipment", "consumable", "spell"],
    "FFD20.ScriptCalls.Use.Info"
  );
  game.ffd20.registry.registerItemScriptCategory(
    "ffd20",
    "equip",
    "FFD20.ScriptCalls.Equip.Name",
    ["weapon", "equipment", "loot"],
    "FFD20.ScriptCalls.Equip.Info"
  );
  game.ffd20.registry.registerItemScriptCategory(
    "ffd20",
    "toggle",
    "FFD20.ScriptCalls.Toggle.Name",
    ["buff", "feat"],
    "FFD20.ScriptCalls.Toggle.Info"
  );
  game.ffd20.registry.registerItemScriptCategory(
    "ffd20",
    "changeQuantity",
    "FFD20.ScriptCalls.ChangeQuantity.Name",
    ["loot", "equipment", "weapon", "consumable", "container"],
    "FFD20.ScriptCalls.ChangeQuantity.Info"
  );
  game.ffd20.registry.registerItemScriptCategory(
    "ffd20",
    "changeLevel",
    "FFD20.ScriptCalls.ChangeLevel.Name",
    ["buff", "class"],
    "FFD20.ScriptCalls.ChangeLevel.Info"
  );

  // Initialize socket listener
  initializeSocket();

  // Initialize module integrations
  initializeModules();
});

/* -------------------------------------------- */
/*  Foundry VTT Setup                           */
/* -------------------------------------------- */

/**
 * This function runs after game data has been requested and loaded from the servers, so entities exist
 */
Hooks.once("setup", function () {
  // Localize CONFIG objects once up-front
  const toLocalize = [
    "abilities",
    "abilitiesShort",
    "alignments",
    "currencies",
    "distanceUnits",
    "itemActionTypes",
    "senses",
    "skills",
    "targetTypes",
    "timePeriods",
    "timePeriodsShort",
    "savingThrows",
    "ac",
    "acValueLabels",
    "featTypes",
    "featTypesPlurals",
    "conditions",
    "lootTypes",
    "flyManeuverabilities",
    "abilityTypes",
    "spellPreparationModes",
    "weaponTypes",
    "weaponProperties",
    "spellComponents",
    "spellSchools",
    "multiSchools",
    "spellLevels",
    "conditionTypes",
    "favouredClassBonuses",
    "armorProf",
    "weaponProf",
    "actorSizes",
    "abilityActivationTypes",
    "abilityActivationTypesPlurals",
    "limitedUsePeriods",
    "equipmentTypes",
    "equipmentSlots",
    "consumableTypes",
    "attackTypes",
    "buffTypes",
    // "buffTargets",
    // "contextNoteTargets",
    "healingTypes",
    "divineFocus",
    "classSavingThrows",
    "classBAB",
    "classTypes",
    "measureTemplateTypes",
    "creatureTypes",
    "measureUnits",
    "measureUnitsShort",
    "languages",
    "damageTypes",
    "weaponHoldTypes",
    "auraStrengths",
    "conditionalTargets",
    "bonusModifiers",
    "abilityActivationTypes_unchained",
    "abilityActivationTypesPlurals_unchained",
    "actorStatures",
    "classBaseMPTypes",
    "classSubTypes",
    "classBaseMPauto",
    "classCastingStats",
    "countforexp",
    "materiaAdvancement",
    "materiaRarity",
  ];

  // Config (sub-)objects to be sorted
  const toSort = [
    // "buffTargets",
    // "buffTargets.misc",
    // "contextNoteTargets",
    // "contextNoteTargets.misc",
    "skills",
    "conditions",
    "conditionTypes",
    "consumableTypes",
    "creatureTypes",
    "featTypes",
    "weaponProperties",
    "spellSchools",
    "multiSchools",
    "damageTypes",
  ];

  /**
   * Helper function to recursively localize object entries
   *
   * @param {object} obj - The object to be localized
   * @param {string} cat - The object's name
   * @returns {object} The localized object
   */
  const doLocalize = (obj, cat) => {
    // Create tuples of (key, localized object/string)
    const localized = Object.entries(obj).reduce((arr, e) => {
      if (typeof e[1] === "string") arr.push([e[0], game.i18n.localize(e[1])]);
      else if (typeof e[1] === "object") arr.push([e[0], doLocalize(e[1], `${cat}.${e[0]}`)]);
      return arr;
    }, []);
    if (toSort.includes(cat)) {
      // Sort simple strings, fall back to sorting by label for objects/categories
      localized.sort((a, b) => {
        const localA = typeof a?.[1] === "string" ? a[1] : a[1]?._label;
        const localB = typeof b?.[1] === "string" ? b[1] : b[1]?._label;
        // Move misc to bottom of every list
        if (a[0] === "misc") return 1;
        else if (b[0] === "misc") return -1;
        // Regular sorting of localized strings
        return localA.localeCompare(localB);
      });
    }
    // Get the localized and sorted object out of tuple
    return localized.reduce((obj, e) => {
      obj[e[0]] = e[1];
      return obj;
    }, {});
  };

  // Localize and sort CONFIG objects
  for (const o of toLocalize) {
    CONFIG.FFD20[o] = doLocalize(CONFIG.FFD20[o], o);
  }

  // Localize buff targets
  const localizeLabels = ["buffTargets", "buffTargetCategories", "contextNoteTargets", "contextNoteCategories"];
  for (let l of localizeLabels) {
    for (let [k, v] of Object.entries(CONFIG.FFD20[l])) {
      CONFIG.FFD20[l][k].label = game.i18n.localize(v.label);
    }
  }

  // TinyMCE variables and commands
  tinyMCEInit();
});

/* -------------------------------------------- */

/**
 * Once the entire VTT framework is initialized, check to see if we should perform a data migration
 */
Hooks.once("ready", async function () {
  // Create tooltip
  game.ffd20.tooltip = new TooltipFFD20();
  window.addEventListener("resize", () => {
    game.ffd20.tooltip.setPosition();
  });
  window.addEventListener("keydown", (event) => {
    const tooltipConfig = game.settings.get("ffd20", "tooltipConfig");
    if (event.key === "Shift" && game.user.isGM) {
      game.ffd20.tooltip.forceHideGMInfo = true;
      game.ffd20.tooltip.render();
    } else if (event.key === "Control") {
      if (tooltipConfig.hideWithoutKey) {
        game.ffd20.tooltip.show();
      } else {
        game.ffd20.tooltip.hide();
      }
    }
  });
  window.addEventListener("keyup", (event) => {
    const tooltipConfig = game.settings.get("ffd20", "tooltipConfig");
    if (event.key === "Shift" && game.user.isGM) {
      game.ffd20.tooltip.forceHideGMInfo = false;
      game.ffd20.tooltip.render();
    } else if (event.key === "Control") {
      if (tooltipConfig.hideWithoutKey) {
        game.ffd20.tooltip.hide();
      } else {
        game.ffd20.tooltip.show();
      }
    }
  });

  // Migrate data
  const NEEDS_MIGRATION_VERSION = "0.2.1";
  let PREVIOUS_MIGRATION_VERSION = game.settings.get("ffd20", "systemMigrationVersion");
  if (typeof PREVIOUS_MIGRATION_VERSION === "number") {
    PREVIOUS_MIGRATION_VERSION = PREVIOUS_MIGRATION_VERSION.toString() + ".0";
  } else if (
    typeof PREVIOUS_MIGRATION_VERSION === "string" &&
    PREVIOUS_MIGRATION_VERSION.match(/^([0-9]+)\.([0-9]+)$/)
  ) {
    PREVIOUS_MIGRATION_VERSION = `${PREVIOUS_MIGRATION_VERSION}.0`;
  }
  let needMigration = SemanticVersion.fromString(NEEDS_MIGRATION_VERSION).isHigherThan(
    SemanticVersion.fromString(PREVIOUS_MIGRATION_VERSION)
  );
  if (needMigration && game.user.isGM) {
    await migrateWorld();
  }

  // Migrate system settings
  await migrateSystemSettings();

  // Create compendium browsers
  game.ffd20.compendiums = {
    spells: new CompendiumBrowser({ type: "spells" }),
    items: new CompendiumBrowser({ type: "items" }),
    bestiary: new CompendiumBrowser({ type: "bestiary" }),
    feats: new CompendiumBrowser({ type: "feats" }),
    classes: new CompendiumBrowser({ type: "classes" }),
    races: new CompendiumBrowser({ type: "races" }),
    buffs: new CompendiumBrowser({ type: "buffs" }),
  };

  // Show changelog
  if (!game.settings.get("ffd20", "dontShowChangelog")) {
    const v = game.settings.get("ffd20", "changelogVersion") || "0.0.1";
    const changelogVersion = SemanticVersion.fromString(v);
    const curVersion = SemanticVersion.fromString(game.system.data.version);

    if (curVersion.isHigherThan(changelogVersion)) {
      const app = new ChangeLogWindow(changelogVersion);
      app.render(true);
      game.settings.set("ffd20", "changelogVersion", curVersion.toString());
    }
  }
});

/* -------------------------------------------- */
/*  Canvas Initialization                       */
/* -------------------------------------------- */

Hooks.on("canvasInit", function () {
  // Extend Diagonal Measurement
  canvas.grid.diagonalRule = game.settings.get("ffd20", "diagonalMovement");
  SquareGrid.prototype.measureDistances = measureDistances;
});

{
  let callbacks = [];

  Hooks.on("canvasReady", () => {
    // Remove old reach callbacks
    for (let cb of callbacks) {
      cb.elem.off(cb.event, cb.callback);
    }

    // Add reach measurements
    game.messages.forEach(async (m) => {
      const elem = $(`#chat .chat-message[data-message-id="${m.data._id}"]`);
      if (!elem || (elem && !elem.length)) return;
      const results = await addReachCallback(m.data, elem);
      callbacks.push(...results);
    });

    // Toggle token condition icons
    if (game.user.isGM) {
      canvas.tokens.placeables.forEach((t) => {
        if (t.actor) t.actor.toggleConditionStatusIcons();
      });
    }
  });

  Hooks.on("renderChatMessage", async (app, html, data) => {
    // Wait for setup after this
    if (!game.ready) return;

    // Add reach measurements on hover
    const results = await addReachCallback(data.message, html);
    callbacks.push(...results);
  });
}

/* -------------------------------------------- */
/*  Other Hooks                                 */
/* -------------------------------------------- */

Hooks.on("renderChatMessage", (app, html, data) => {
  // Hide roll info
  hideRollInfo(app, html);

  // Hide GM sensitive info
  hideGMSensitiveInfo(app, html);

  // Optionally collapse the content
  if (game.settings.get("ffd20", "autoCollapseItemCards")) html.find(".card-content").hide();

  // Optionally hide chat buttons
  if (game.settings.get("ffd20", "hideChatButtons")) html.find(".card-buttons").hide();

  // Apply accessibility settings to chat message
  applyAccessibilitySettings(app, html, data, game.settings.get("ffd20", "accessibilityConfig"));

  // Alter chat card title color
  addChatCardTitleGradient(app, html);

  // Handle chat tooltips
  html.find(".tooltip").on("mousemove", (ev) => handleChatTooltips(ev));
});

Hooks.on("renderChatPopout", (app, html, data) => {
  // Optionally collapse the content
  if (game.settings.get("ffd20", "autoCollapseItemCards")) html.find(".card-content").hide();

  // Optionally hide chat buttons
  if (game.settings.get("ffd20", "hideChatButtons")) html.find(".card-buttons").hide();
});

Hooks.on("renderChatLog", (_, html) => ItemFFD20.chatListeners(html));
Hooks.on("renderChatLog", (_, html) => ActorFFD20.chatListeners(html));

Hooks.on("renderChatPopout", (_, html) => ItemFFD20.chatListeners(html));
Hooks.on("renderChatPopout", (_, html) => ActorFFD20.chatListeners(html));

Hooks.on("renderLightConfig", (app, html) => {
  addLowLightVisionToLightConfig(app, html);
});

Hooks.on("renderTokenHUD", (app, html, data) => {
  TokenQuickActions.addTop3Attacks(app, html, data);
});

Hooks.on("preUpdateItem", (item, changedData, options, userId) => {
  const actor = item.parent instanceof ActorFFD20 ? item.parent : null;

  if (actor) {
    // Update level
    {
      if (item.type === "class" && hasProperty(changedData, "data.level")) {
        const prevLevel = getProperty(item.data, "data.level");
        // const newLevel = getProperty(changedData, "data.level");
        // item._onLevelChange(prevLevel, newLevel);
        item._prevLevel = prevLevel;
      }
    }
  }
});

Hooks.on("updateActor", (actor, data, options, userId) => {
  // Call hook for toggling conditions
  {
    const conditions = getProperty(data, "data.attributes.conditions") || {};
    for (let [k, v] of Object.entries(conditions)) {
      Hooks.callAll("FFD20.toggleActorCondition", actor, k, v);
    }
  }
});

Hooks.on("createToken", (scene, token, options, userId) => {
  if (userId !== game.user.id) return;

  const actor = game.actors.tokens[token.data._id] ?? game.actors.get(token.actorId);

  // Update changes and generate sourceDetails to ensure valid actor data
  if (actor != null) {
    actor.toggleConditionStatusIcons();
  }
});

Hooks.on("preCreateToken", async (scene, token, options, userId) => {
  const actor = game.actors.get(token.actorId),
    buffTextures = Object.values(actor?._calcBuffTextures() ?? []).map((b) => b.icon);
  for (let icon of buffTextures) await loadTexture(icon);
});

Hooks.on("hoverToken", (token, hovering) => {
  // Show token tooltip
  if (hovering && !game.keyboard.isDown("Alt")) {
    const p = game.ffd20.tooltip.mousePos;
    const el = document.elementFromPoint(p.x, p.y);
    // This check is required to prevent hovering over tokens under application windows
    if (el?.id === "board") {
      game.ffd20.tooltip.bind(token);
    }
  }
  // Hide token tooltip
  else game.ffd20.tooltip.unbind(token);
});

Hooks.on("preDeleteToken", (token, options, userId) => {
  // Hide token tooltip on token deletion
  game.ffd20.tooltip.unbind(token.object);
});

Hooks.on("updateToken", (scene, data, updateData, options, userId) => {
  const token = canvas.tokens.placeables.find((t) => t.data.id === data.id);
  if (!token) return;

  // Hide token tooltip on token update
  game.ffd20.tooltip.unbind(token);

  // Update token's actor sheet (if any)
  token.actor?.sheet?.render();
});

Hooks.on("controlToken", (token, selected) => {
  // Refresh canvas sight
  canvas.lighting.initializeSources();
});

// Create race on actor
Hooks.on("preCreateItem", (item, options, userId) => {
  const actor = item.parent instanceof ActorFFD20 ? item.parent : null;

  if (actor && actor.race && item.type === "race") {
    actor.race.update(item.data._source);
    return false;
  }
});

Hooks.on("createItem", (item, options, userId) => {
  const actor = item.parent instanceof ActorFFD20 ? item.parent : null;
  if (userId !== game.user.id) return;

  // Create class
  if (item.type === "class" && actor) {
    item._onLevelChange(0, item.data.data.level);
  }

  // Show buff if active
  if (item.type === "buff" && getProperty(item.data, "data.active") === true) {
    // Call hook
    if (actor) {
      Hooks.callAll("FFD20.toggleActorBuff", actor, item.data, true);
    }

    // Execute script calls
    item.executeScriptCalls("toggle", { state: true });
  }
  // Simulate toggling a feature on
  if (item.type === "feat") {
    const disabled = getProperty(item.data, "data.disabled");
    if (disabled === false) {
      item.executeScriptCalls("toggle", { state: true });
    }
  }
  // Simulate equipping items
  {
    const equipped = getProperty(item.data, "data.equipped");
    if (equipped === true) {
      item.executeScriptCalls("equip", { equipped: true });
    }
  }
  // Quantity change
  {
    const quantity = getProperty(item.data, "data.quantity");
    if (typeof quantity === "number" && quantity > 0) {
      item.executeScriptCalls("changeQuantity", { quantity: { previous: 0, new: quantity } });
    }
  }

  if (userId !== game.user.id) return;
});

Hooks.on("deleteItem", async (item, options, userId) => {
  const actor = item.parent instanceof ActorFFD20 ? item.parent : null;

  if (actor) {
    // Remove token effects for deleted buff
    const isLinkedToken = getProperty(actor.data, "token.actorLink");
    if (isLinkedToken) {
      let promises = [];
      if (item.data.type === "buff" && item.data.data.active) {
        actor.effects.find((e) => e.data.origin?.indexOf(item.data.id) > 0)?.delete();
        const tokens = actor.getActiveTokens();
        for (const token of tokens) {
          promises.push(token.toggleEffect(item.data.img, { active: false }));
        }
      }
      await Promise.all(promises);
    }

    // Remove links
    const itemLinks = getProperty(item.data, "data.links");
    if (itemLinks) {
      for (let [linkType, links] of Object.entries(itemLinks)) {
        for (let link of links) {
          const item = actor.items.find((o) => o.id === link.id);
          let otherItemLinks = item?.links || {};
          if (otherItemLinks[linkType]) {
            delete otherItemLinks[linkType];
          }
        }
      }
    }

    // Call buff removal hook
    if (item.type === "buff" && getProperty(item.data, "data.active") === true) {
      Hooks.callAll("FFD20.toggleActorBuff", actor, item.data, false);
    }
  }

  if (item.type === "buff" && getProperty(item.data, "data.active") === true) {
    item.executeScriptCalls("toggle", { state: false });
  }
  // Simulate toggling a feature on
  if (item.type === "feat") {
    const disabled = getProperty(item.data, "data.disabled");
    if (disabled === false) {
      item.executeScriptCalls("toggle", { state: false });
    }
  }
  // Simulate equipping items
  {
    const equipped = getProperty(item.data, "data.equipped");
    if (equipped === true) {
      item.executeScriptCalls("equip", { equipped: false });
    }
  }
  // Quantity change
  {
    const quantity = getProperty(item.data, "data.quantity");
    if (typeof quantity === "number" && quantity > 0) {
      item.executeScriptCalls("changeQuantity", { quantity: { previous: quantity, new: 0 } });
    }
  }
});

Hooks.on("updateItem", async (item, changedData, options, userId) => {
  const actor = item.parent instanceof ActorFFD20 ? item.parent : null;

  if (actor) {
    // Toggle buff
    if (item.type === "buff" && getProperty(changedData, "data.active") !== undefined) {
      // Call hook
      Hooks.callAll("FFD20.toggleActorBuff", actor, item.data, getProperty(changedData, "data.active"));
    }

    {
      // Update level
      await new Promise((resolve) => {
        if (item.type === "class" && hasProperty(changedData, "data.level")) {
          const newLevel = getProperty(changedData, "data.level");
          const prevLevel = item._prevLevel ?? newLevel;
          if (item._prevLevel !== undefined) delete item._prevLevel;
          item._onLevelChange(prevLevel, newLevel).then(() => {
            resolve();
          });
        } else {
          resolve();
        }
      });
    }
  }
});

Hooks.on("chatMessage", (log, message, chatData) => {
  const result = customRolls(message, chatData.speaker);
  return !result;
});

Hooks.on("renderActorDirectory", (app, html, data) => {
  html.find("li.actor").each((i, li) => {
    li.addEventListener("drop", CurrencyTransfer._directoryDrop.bind(undefined, li.getAttribute("data-entity-id")));
  });
});

Hooks.on("renderItemDirectory", (app, html, data) => {
  html.find("li.item").each((i, li) => {
    li.addEventListener("drop", CurrencyTransfer._directoryDrop.bind(undefined, li.getAttribute("data-entity-id")));
  });
});

Hooks.on("dropActorSheetData", (act, sheet, data) => {
  if (data.type === "Currency") sheet._onDropCurrency(event, data);
});

/* -------------------------------------------- */
/*  Hotbar Macros                               */
/* -------------------------------------------- */

Hooks.on("hotbarDrop", (bar, data, slot) => {
  let macro;
  if (data.type === "Item") macro = createItemMacro(data.data, slot);
  else if (data.type === "skill") macro = createSkillMacro(data.skill, data.actor, slot);
  else if (data.type === "save") macro = createSaveMacro(data.altType, data.actor, slot);
  else if (["defenses", "cmb", "concentration", "cl", "bab"].includes(data.type))
    macro = createMiscActorMacro(data.type, data.actor, slot, data.altType);
  else return true;

  if (macro === undefined) return false;
});

// Render TokenConfig
Hooks.on("renderTokenConfig", async (app, html) => {
  const TokenData = foundry.data.TokenData;
  // Add vision inputs
  let newHTML = await renderTemplate("systems/ffd20/templates/internal/token-config_vision.hbs", {
    object: duplicate(app.object.data instanceof TokenData ? app.object.data : app.object.data.token),
  });
  html.find('.tab[data-tab="vision"] > *:nth-child(2)').after(newHTML);

  // Add static size checkbox
  newHTML = `<div class="form-group"><label>${game.i18n.localize(
    "FFD20.StaticSize"
  )}</label><input type="checkbox" name="flags.ffd20.staticSize" data-dtype="Boolean"`;
  if (
    getProperty(app.object instanceof TokenDocument ? app.object.data : app.object.data.token, "flags.ffd20.staticSize")
  )
    newHTML += " checked";
  newHTML += "/></div>";
  html.find('.tab[data-tab="image"] > *:nth-child(3)').after(newHTML);

  // Add disable low-light vision checkbox
  addLowLightVisionToTokenConfig(app, html);
});

// Render Sidebar
Hooks.on("renderSidebarTab", (app, html) => {
  if (app instanceof Settings) {
    // Add buttons
    const chlogButton = $(`<button>${game.i18n.localize("FFD20.Changelog")}</button>`);
    const helpButton = $(`<button>${game.i18n.localize("FFD20.Help.Label")}</button>`);
    html
      .find("#game-details")
      .after(
        $(`<h2>${game.i18n.localize("FFD20.title")}</h2>`),
        $("<div id='ffd20-details'>").append(chlogButton, helpButton)
      );

    chlogButton.click(() => new ChangeLogWindow().render(true));
    helpButton.click(() => new FFD20_HelpBrowser().openURL("systems/ffd20/help/index.hbs"));
  }
});

// Add compendium sidebar context options
Hooks.on("getCompendiumDirectoryFFD20EntryContext", (html, entryOptions) => {
  // Add option to disable pack
  entryOptions.push({
    name: game.i18n.localize("FFD20.Disable"),
    icon: '<i class="fas fa-low-vision"></i>',
    callback: (li) => {
      const pack = game.packs.get(li.data("pack"));
      const config = game.settings.get("core", "compendiumConfiguration")[pack.collection];
      const disabled = getProperty(config, "FFD20.disabled") === true;
      pack.configure({ "FFD20.disabled": !disabled });
    },
  });
});

// Show experience distributor after combat
Hooks.on("deleteCombat", (combat, options, userId) => {
  const isGM = game.user.isGM;
  const shiftPressed = game.keyboard.isDown("Shift");
  const { disableExperienceTracking, openXpDistributor } = game.settings.get("ffd20", "experienceConfig");
  if (
    isGM &&
    !disableExperienceTracking &&
    combat.started &&
    ((openXpDistributor && !shiftPressed) || (!openXpDistributor && shiftPressed))
  ) {
    const app = new ExperienceDistributor(combat);

    if (app.getCharacters().length > 0) {
      app.render(true);
    } else {
      app.close();
    }
  }
});

// Handle chat tooltips
const handleChatTooltips = function (event) {
  const elem = $(event.currentTarget);
  const rect = event.currentTarget.getBoundingClientRect();
  // const x = event.pageX;
  // const y = event.pageY;
  const x = rect.x;
  const y = rect.y;
  const w = rect.width;
  elem.find(".tooltipcontent").css("left", `${x}px`).css("top", `${y}px`).css("width", `${w}px`);
};

export { ActiveEffectFFD20, ActorFFD20, ActorSheetFFD20, ActorSheetFFD20Character, ActorSheetFFD20NPC, ActorSheetFFD20NPCLite, ActorSheetFFD20NPCLoot, ChatAttack, ChatMessageFFD20, DiceFFD20, FFD20, ItemChange, ItemFFD20, ItemSheetFFD20, ItemSheetFFD20_Container, RollFFD20$1 as RollFFD20, SemanticVersion, TokenDocumentFFD20, dialogGetActor, dialogGetNumber, getChangeFlat, getSourceInfo, measureDistances };
//# sourceMappingURL=ffd20.js.map
