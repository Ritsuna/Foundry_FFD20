{"_id":"13AHAyh9DklWxvWP","name":"Show Defenses","type":"script","sort":100001,"flags":{},"scope":"global","command":"game.ffd20.rollDefenses();","author":"T9i9xVjdkHeFZC72","img":"systems/ffd20/icons/items/armor/shield-light-metal.png","actorIds":[]}
{"name":"Calculate Spellbook Price","type":"script","flags":{},"scope":"global","command":"const CONFIG = {\n  basePrice: 15,\n  spellValue: {\n    \"0\": {\n      gil: 5,\n      pages: 1,\n    },\n    \"1\": {\n      gil: 10,\n      pages: 1,\n    },\n    \"2\": {\n      gil: 40,\n      pages: 2,\n    },\n    \"3\": {\n      gil: 90,\n      pages: 3,\n    },\n    \"4\": {\n      gil: 160,\n      pages: 4,\n    },\n    \"5\": {\n      gil: 250,\n      pages: 5,\n    },\n    \"6\": {\n      gil: 360,\n      pages: 6,\n    },\n    \"7\": {\n      gil: 490,\n      pages: 7,\n    },\n    \"8\": {\n      gil: 640,\n      pages: 8,\n    },\n    \"9\": {\n      gil: 810,\n      pages: 9,\n    },\n  },\n};\n\nlet html = `\n<table>\n  <thead>\n    <tr>\n      <th>Spell level</th>\n      <th>Amount of spells</th>\n    </tr>\n  </thead>\n  <tbody>\n`;\nfor (const [k, v] of Object.entries(CONFIG.spellValue)) {\n  html += `\n    <tr>\n      <td>${k}</td>\n      <td>\n        <input class=\"spell-input\" type=\"text\" name=\"level-${k}\" value=\"0\" data-price=\"${v.gil}\" data-pages=\"${v.pages}\" />\n      </td>\n    </tr>\n  `;\n}\nhtml += `\n  </tbody>\n  <thead>\n    <tr>\n      <th>Spellbook price</th>\n      <th>Pages required</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td><input class=\"spellbook-price\" type=\"text\" disabled name=\"spellbook-price\" value=\"${CONFIG.basePrice}\" /></td>\n      <td><input class=\"spellbook-pages\" type=\"text\" disabled name=\"page-value\" value=\"0\" /></td>\n    </tr>\n  </tbody>\n</table>\n\n<div class=\"help-text\">\n  Typical spellbooks can only hold 100 pages.\n</div>\n`;\n\n// -------------------------\n// Functions\n// -------------------------\n\nconst _onChange = function (event) {\n  event.preventDefault();\n  const html = $(this.element);\n\n  let pages = 0;\n  let price = CONFIG.basePrice;\n  html.find(\".spell-input\").each((idx, elem) => {\n    const amount = Number(elem.value);\n    if (Number.isNaN(amount)) return;\n\n    price += Number(elem.dataset.price) * amount;\n    pages += Number(elem.dataset.pages) * amount;\n  });\n\n  html.find(\".spellbook-price\").attr(\"value\", price);\n  html.find(\".spellbook-pages\").attr(\"value\", pages);\n};\n\n// -------------------------\n// Dialog\n// -------------------------\n\nconst d = new Dialog({\n  title: \"Calculate spellbook value\",\n  content: html,\n  buttons: {},\n});\n\nd.activateListeners = function (html) {\n  Dialog.prototype.activateListeners.call(this, html);\n\n  html.find(\"input.spell-input\").change(_onChange.bind(this));\n};\n\nd.render(true);","author":"61klraqiWb97OOLa","img":"icons/sundries/books/book-embossed-jewel-gold-purple.webp","actorIds":[],"_id":"1l7Iw6xRgx8OMnJH"}
{"_id":"8VcUUx7d4TX4WTkt","name":"Award XP","type":"script","author":"T9i9xVjdkHeFZC72","img":"icons/svg/book.svg","scope":"global","command":"// CONFIGURATION\n// If one or more tokens are selected, those will be used instead of the listed actors\n// Leave the actorNames array empty to guess the players\n// Example actorNames: `actorNames: [\"Bob\", \"John\"],`\nconst c = {\n  actorNames: [],\n};\n// END CONFIGURATION\n\nconst tokens = canvas.tokens.controlled;\nlet actors = tokens.map(o => o.actor);\nif (!actors.length && c.actorNames.length) actors = game.actors.filter(o => c.actorNames.includes(o.name));\nif (!actors.length) actors = game.actors.filter(o => o.isPC);\nactors = actors.filter(o => o.testUserPermission(game.user, 'OWNER'));\n\nif (!actors.length) ui.notifications.warn('No applicable actor(s) found');\nelse {\n  const appCls = game.ffd20.applications.ExperienceDistributor;\n  new appCls(actors).render(true);\n}","sort":0,"flags":{}}
{"name":"Wild Shape","type":"script","flags":{},"scope":"global","command":"// Author: @Adam\n\n// SETUP NEEDED: for each transformation option you want, please enter it as below\n// you also need to set imageFolder to the location of where you store your tokens.\n// token art is selected by name & as a png, so for example the image for Bat is located at 'worlds/golarion/tokens/Bestiary/Bat.png'\n\n// support for elemental body is not complete yet - only air elemental is hardcoded\n\nconst imageFolder = \"worlds/golarion/tokens/Bestiary\";\n\nconst transformationOptions = {\n  Bat: {\n    size: \"diminutive\",\n    spellSource: \"beast shape\",\n  },\n  \"Giant Squid\": {\n    size: \"huge\",\n    spellSource: \"beast shape\",\n  },\n  Tendriculos: {\n    size: \"huge\",\n    spellSource: \"plant shape\",\n  },\n  \"Air Elemental\": {\n    size: \"huge\",\n    spellSource: \"elemental body\",\n  },\n};\n\nconst sizes = [\n  \"diminutive\",\n  \"tiny\",\n  \"small\",\n  \"medium\",\n  \"large\",\n  \"huge\",\n  \"gargantuan\",\n  \"colossal\",\n];\n\nconst sizeTranslation = {\n  fine: \"fine\",\n  diminutive: \"dim\",\n  tiny: \"tiny\",\n  small: \"sm\",\n  medium: \"med\",\n  large: \"lg\",\n  huge: \"huge\",\n  gargantuan: \"grg\",\n  colossal: \"col\",\n};\n\nconst createSizeObject = ({ w, h, scale }) => {\n  return {\n    width: w,\n    height: h,\n    scale,\n  };\n};\n\nconst mediumOrBigger = (size) => {\n  return sizes.indexOf(size) >= sizes.indexOf(\"medium\");\n};\n\nconst createAbilityChange = (formula, subTarget) => {\n  formula = \"\" + formula;\n  return {\n    formula,\n    priority: 1,\n    target: \"ability\",\n    subTarget,\n    modifier: \"size\",\n  };\n};\n\nconst createNACChange = (formula) => {\n  formula = \"\" + formula;\n  return {\n    formula,\n    priority: 1,\n    target: \"ac\",\n    subTarget: \"nac\",\n    modifier: \"size\",\n  };\n};\n\nconst createSpeedChange = (formula, subTarget) => {\n  formula = \"\" + formula;\n  return {\n    formula,\n    priority: 1,\n    target: \"speed\",\n    subTarget,\n    modifier: \"size\",\n  };\n};\n\nconst createBuffChanges = (name) => {\n  const creature = transformationOptions[name];\n  const bulking = mediumOrBigger(creature.size);\n  let buffLevel = null;\n\n  const changes = [];\n\n  if (bulking) {\n    buffLevel = sizes.indexOf(creature.size) - sizes.indexOf(\"medium\") + 1;\n  } else {\n    buffLevel = sizes.indexOf(\"medium\") - sizes.indexOf(creature.size);\n  }\n\n  switch (creature.spellSource.toLowerCase()) {\n    case \"beast shape\": {\n      const mainBonus = buffLevel * 2;\n      const nacBonus = buffLevel * 2;\n      const penalty = buffLevel > 1 ? -(buffLevel * 2 - 2) : 0;\n      const mainBonusAbility = bulking ? \"str\" : \"dex\";\n      const penaltyAbility = bulking ? \"dex\" : \"str\";\n\n      changes.push(createAbilityChange(mainBonus, mainBonusAbility));\n      changes.push(createAbilityChange(penalty, penaltyAbility));\n      changes.push(createNACChange(nacBonus));\n      break;\n    }\n    case \"plant shape\": {\n      const nacBonus = buffLevel * 2;\n      if (bulking) {\n        const strBonus = Math.pow(2, buffLevel);\n        const conBonus = Math.max(2, buffLevel / 2);\n        const penalty = -(buffLevel > 2 ? 2 : 0);\n\n        changes.push(createAbilityChange(strBonus, \"str\"));\n        changes.push(createAbilityChange(conBonus, \"con\"));\n        changes.push(createAbilityChange(penalty, \"dex\"));\n      } else {\n        const conBonus = buffLevel * 2;\n        changes.push(createAbilityChange(conBonus, \"con\"));\n      }\n      changes.push(createNACChange(nacBonus));\n      break;\n    }\n    case \"elemental body\": {\n      if (name === \"Air Elemental\") {\n        changes.push(createAbilityChange(4, \"str\"));\n        changes.push(createAbilityChange(6, \"dex\"));\n        changes.push(createNACChange(4));\n        changes.push(createSpeedChange(120, \"flySpeed\"));\n      }\n      break;\n    }\n    default: {\n      ui.notifications.error(\n        `Cannot find spellSource (${creature.spellSource.toLowerCase()}) in programmed list. Ensure there are no typos.`\n      );\n    }\n  }\n\n  return changes;\n};\n\n\nconst createWSBuff = async (caster, data) => {\n  const itemData = foundry.utils.mergeObject({\n    type: \"buff\",\n    name: \"Wild Shape (Auto)\",\n    system: { buffType: \"temp\", level: 1 },\n  }, data);\n  // Get templates\n  await caster.createEmbeddedDocuments(\"Item\", [itemData]);\n  return getWSBuff(caster);\n};\n\nconst getWSBuff = (caster) => {\n  return caster.items.find(\n    (i) => i.type === \"buff\" && i.name === \"Wild Shape (Auto)\"\n  );\n};\n\nconst transform = async (caster, token, name) => {\n  const creature = transformationOptions[name];\n  const changes = createBuffChanges(name);\n\n  let buff = getWSBuff(caster);\n  if (!buff) buff = await createWSBuff(caster, { \"system.changes\": changes, \"system.active\": true });\n\n  await token.document.update(\n    foundry.utils.mergeObject(\n      { texture: { src: `${imageFolder}/${name}.png` } },\n      createSizeObject(CONFIG.FFD20.tokenSizes[sizeTranslation[creature.size]])\n    )\n  );\n  await caster.update({ \"system.traits.size\": sizeTranslation[creature.size] });\n};\n\nconst revertForm = async (caster, token) => {\n  const originalData = caster.flags.ffd20?.wildshape?.originalData;\n  await getWSBuff(caster).update({ \"system.active\": false });\n  if (originalData) {\n    await caster.update({ \"system.traits.size\": originalData.size, \"flags.ffd20.-=wildshape\": null });\n    await token.document.update(\n      foundry.utils.mergeObject(\n        { texture: { src: originalData.image } },\n        createSizeObject(CONFIG.FFD20.tokenSizes[originalData.size])\n      )\n    );\n  }\n};\n\nconst tokens = canvas.tokens.controlled;\n\nif (tokens.length !== 1) {\n  ui.notifications.warn(\"Select a token.\");\n} else {\n  const token = tokens[0];\n  const actor = token.actor;\n  const caster = actor;\n\n  if (!Object.keys(caster.flags.ffd20?.wildshape ?? {}).includes(\"originalData\")) {\n    const originalData = {\n      image: caster.prototypeToken.texture.src,\n      size: caster.system.traits.size,\n    };\n    await caster.update({ \"flags.ffd20.wildshape.originalData\": originalData });\n  }\n\n  const buttons = Object.keys(transformationOptions).map((optionName) => ({\n    label: optionName,\n    callback: () => transform(actor, token, optionName),\n  }));\n  buttons[\"Revert\"] = {\n    label: \"Revert\",\n    icon: '<i class=\"fas fa-user\"></i>',\n    callback: () => revertForm(actor, token),\n  };\n\n  new Dialog({\n    title: \"Wild Shape\",\n    content: \"Choose creature.\",\n    buttons: buttons,\n  }).render(true);\n}","author":"ZuWclcb9BUy2aZSN","img":"systems/ffd20/icons/skills/green_27.jpg","_id":"GyuHEoeLTtLZCvhS","sort":0}
{"name":"Show Actor Information","type":"script","flags":{},"scope":"global","command":"// CONFIGURATION\n// Leave the actorNames array empty to guess the players\n// Example actorNames: `actorNames: [\"Bob\", \"John\"],`\nconst c = {\n  actorNames: [],\n};\n// END CONFIGURATION\n\nconst tokens = canvas.tokens.controlled;\nlet actors = tokens.map(o => o.actor);\nif (!actors.length && c.actorNames.length) actors = game.actors.entities.filter(o => c.actorNames.includes(o.name));\nif (!actors.length) actors = game.actors.entities.filter(o => o.isPC && o.testUserPermission(game.user, \"OWNER\"));\nactors = actors.filter(o => o.testUserPermission(game.user, \"OWNER\"));\n\nif (!actors.length) ui.notifications.warn(\"No applicable actor(s) found\");\nelse {\n  const msg = `Choose the information you want to show for the following actor(s): <strong>${actors.map(o => o.name).join(\"</strong>, <strong>\")}</strong>`;\n  \n  new Dialog({\n    title: \"Show Actor Information\",\n    content: `<p>${msg}</p>`,\n    buttons: {\n      fort: {\n        label: \"Social Defenses\",\n        callback: () => {\n          let c = \"\";\n          // Add demoralize DC\n          c += `<table><thead><tr><td colspan=\"2\">Demoralize (Intimidate)</td><tr><td>Character</td><td>DC</td></thead><tbody>`;\n          for (let a of actors) {\n            const rollData = a.getRollData({ forceRefresh: false });\n            const dc = 10 + rollData.attributes.hd.total + rollData.abilities.wis.mod;\n            c += `<tr><td>${a.name}</td><td>${dc}</td></tr>`;\n          }\n          c += \"</tbody></table>\";\n          // Add diplomacy DCs\n          c += `<table><thead><tr><td colspan=\"3\">Diplomacy</td></tr><tr><td>Character</td><td>Starting Attitude</td><td>DC</td><thead><tbody>`;\n          for (let a of actors) {\n            c += `<tr><td rowspan=\"5\">${a.name}</td>`;\n            const rollData = a.getRollData({ forceRefresh: false });\n            const dipArr = [{ label: \"Hostile\", base: 25 }, { label: \"Unfriendly\", base: 20 }, { label: \"Indifferent\", base: 15 }, { label: \"Friendly\", base: 10 }, { label: \"Helpful\", base: 0 }];\n            for (let b = 0; b < dipArr.length; b++) {\n              const o = dipArr[b];\n              if (b > 0) c += \"<tr>\";\n              c += `<td>${o.label}</td><td>${o.base + rollData.abilities.cha.mod}</td></tr>`;\n            }\n          }\n          c += \"</tbody></table>\";\n          // Render chat message\n          let messageData = {\n            content: c,\n            user: game.user._id,\n            speaker: ChatMessage.getSpeaker({ user: game.user }),\n            type: CONST.CHAT_MESSAGE_TYPES.OTHER,\n          };\n          messageData = ChatMessage.applyRollMode(messageData, game.settings.get(\"core\", \"rollMode\"));\n          ChatMessage.create(messageData);\n        },\n      },\n    },\n  }).render(true);\n}","author":"61klraqiWb97OOLa","img":"systems/ffd20/icons/skills/red_25.jpg","actorIds":[],"_id":"NozVDiFkfZcBg4Hg"}
{"_id":"ON7b8yS1lcBxkMuo","name":"Roll Saving Throw","type":"script","flags":{},"scope":"global","command":"// CONFIGURATION\n// Leave the actorNames array empty to guess the players\n// Example actorNames: `actorNames: [\"Bob\", \"John\"],`\nconst c = {\n  actorNames: [],\n};\n// END CONFIGURATION\n\nconst tokens = canvas.tokens.controlled;\nlet actors = tokens.map(o => o.actor);\nif (!actors.length && c.actorNames.length) actors = game.actors.filter(o => c.actorNames.includes(o.name));\nif (!actors.length) actors = game.actors.filter(o => o.isPC && o.testUserPermission(game.user, \"OWNER\"));\nactors = actors.filter(o => o.testUserPermission(game.user, \"OWNER\"));\n\nif (!actors.length) ui.notifications.warn(\"No applicable actor(s) found\");\nelse {\n  const _roll = async function(type) {\n    for (let a = 0; a < actors.length; a++) {\n      const o = actors[a];\n      await o.rollSavingThrow(type, { event: new MouseEvent({}), noSound: a > 0, });\n    }\n  };\n\n  const msg = `Choose a saving throw to roll for the following actor(s): <strong>${actors.map(o => o.name).join(\"</strong>, <strong>\")}</strong>`;\n\n  new Dialog({\n    title: \"Roll saving throw\",\n    content: `<p>${msg}</p>`,\n    buttons: {\n      fort: {\n        label: \"Fortitude\",\n        callback: () => _roll(\"fort\"),\n      },\n      ref: {\n        label: \"Reflex\",\n        callback: () => _roll(\"ref\"),\n      },\n      will: {\n        label: \"Will\",\n        callback: () => _roll(\"will\"),\n      },\n    },\n  }).render(true);\n}","author":"T9i9xVjdkHeFZC72","img":"systems/ffd20/icons/feats/diehard.jpg","actorIds":[]}
{"_id":"ccZmfabwQrONq2kg","name":"Toggle Buff","type":"script","flags":{},"scope":"global","command":"// CONFIGURATION\n// If one or more tokens are selected, those will be used instead of the listed actors\n// Leave the actorNames array empty to guess the players\n// Example actorNames: `actorNames: [\"Bob\", \"John\"],`\nconst c = {\n  actorNames: [],\n  buffName: \"Mage Armor\"\n};\n// END CONFIGURATION\n\nconst tokens = canvas.tokens.controlled;\nlet actors = tokens.map(o => o.actor);\nif (!actors.length && c.actorNames.length) actors = game.actors.filter(o => c.actorNames.includes(o.name));\nif (!actors.length) actors = game.actors.filter(o => o.isPC);\nactors = actors.filter(o => o.testUserPermission(game.user, \"OWNER\"));\n\nif (!actors.length) ui.notifications.warn(\"No applicable actor(s) found\");\nelse {\n  for (const actor of actors) {\n    const buff = actor.items.find(o => o.name === c.buffName && o.type === \"buff\");\n    if (buff != null) {\n      let active = getProperty(buff, \"system.active\");\n      if (active == null) active = false;\n      buff.update({ \"system.active\": !active });\n    }\n  }\n}","author":"T9i9xVjdkHeFZC72","img":"systems/ffd20/icons/spells/protect-blue-1.jpg","sort":0}
{"_id":"mL9k7wUzzFbj1NmY","name":"Roll Skill","type":"script","flags":{},"scope":"global","command":"// CONFIGURATION\n// If one or more tokens are selected, those will be used instead of the listed actors\n// Leave the actorNames array empty to guess the players\n// Example actorNames: `actorNames: [\"Bob\", \"John\"],`\nconst c = {\n  actorNames: [],\n  skills: [\"per\", \"sen\", \"ste\", \"sur\"],\n};\n// END CONFIGURATION\n\nconst tokens = canvas.tokens.controlled;\nlet actors = tokens.map(o => o.actor);\nif (!actors.length && c.actorNames.length) actors = game.actors.filter(o => c.actorNames.includes(o.name));\nif (!actors.length) actors = game.actors.filter(o => o.isPC && o.testUserPermission(game.user, \"OWNER\"));\nactors = actors.filter(o => o.testUserPermission(game.user, \"OWNER\"));\n\nif (!actors.length) ui.notifications.warn(\"No applicable actor(s) found\");\nelse {\n  const _roll = async function(type) {\n    let madeSound = false;\n    for (let a = 0;a < actors.length; a++) {\n      const o = actors[a];\n      const info = o.getSkillInfo(type);\n      if (!info) continue;\n      await o.rollSkill(type, { event: new MouseEvent({}), skipDialog: true, noSound: madeSound, });\n      madeSound = true;\n    }\n  };\n\n  const buttons = c.skills.reduce((cur, s) => {\n    let info;\n    for (const o of actors) {\n      info = o.getSkillInfo(s);\n      if (info) break;\n    }\n    if (!info) return cur;\n    const label = info.name;\n    cur[s] = {\n      label: label,\n      callback: () => _roll(s),\n    };\n    return cur;\n  }, {});\n\n  const msg = `Choose a skill to roll for the following actor(s): <strong>${actors.map(o => o.name).join(\"</strong>, <strong>\")}</strong>`;\n\n  new Dialog({\n    title: \"Roll saving throw\",\n    content: `<p>${msg}</p>`,\n    buttons: buttons,\n  }).render(true);\n}","author":"T9i9xVjdkHeFZC72","img":"systems/ffd20/icons/feats/skill-focus.jpg","actorIds":[]}
{"_id":"yEPv1InFUHWnh1kt","name":"Create Loot Sheets","type":"script","img":"systems/ffd20/icons/items/inventory/chest-light.jpg","scope":"global","command":"// CONFIGURATION\n/**\n * @param {string} folder - A string of folder names, separated by '/' (slashes)\n * @param {number} defaultPermission - A constant number, to be gathered from the global object CONST.DOCUMENT_PERMISSION_LEVELS (for quick reference, you can replace 'OBSERVER' with one of the following: 'NONE', 'LIMITED' or 'OWNER'\n * @param {string} sheetType - Change this if you have a module installed for a different loot sheet type.\n */\nconst c = {\n  folder: \"Misc/Loot\",\n  defaultPermission: CONST.DOCUMENT_PERMISSION_LEVELS.OBSERVER,\n  sheetType: \"ffd20.ActorSheetFFD20NPCLoot\",\n};\n\n// END CONFIGURATION\n\nasync function createFromTokens(tokens) {\n  let lastFolder = null;\n\n  async function createFolders() {\n    let lastIndex = 0;\n    const folders = game.folders.filter(f => f.type === \"Actor\");\n    const folderNames = c.folder.split(\"/\");\n    for (let a = 0; a < folderNames.length; a++) {\n      const curName = folderNames[a];\n      const prevName = a > 0 ? folderNames[a - 1] : null;\n\n      const f = folders.find(o => o.name === curName && (o.parent ? o.parent.name === prevName : true));\n      if (f) {\n        lastFolder = f;\n        lastIndex = a + 1;\n      }\n    }\n\n    for (let a = lastIndex; a < folderNames.length; a++) {\n      const newFolder = await Folder.create({\n        name: folderNames[a],\n        parent: lastFolder?.id ?? null,\n        type: \"Actor\",\n      });\n      lastFolder = newFolder;\n    }\n  }\n\n  // Create folder(s)\n  if (c.folder) await createFolders();\n\n  // Gather currency\n  const currency = { pgil: 0, gil: 0, sgil: 0, cgil: 0 };\n  tokens.forEach(t => {\n    for (const cc of Object.keys(currency))\n      currency[cc] += t.actor.system.currency[cc];\n  });\n\n  // Create loot NPC for selected tokens\n  const name = \"(Loot) \" + tokens.map(t => t.name).join(\", \");\n\n  const lootNPC = await Actor.create({\n    name,\n    type: \"npc\",\n    img: tokens[0].actor.img,\n    folder: lastFolder?.id ?? null,\n    permission: {\n      default: c.defaultPermission,\n    },\n    flags: {\n      core: { sheetClass: c.sheetType },\n    },\n    system: { currency },\n  });\n\n  const scrubItem = (i) => {\n    delete i.system.links; // Scrap links\n    delete i._id; // scrap ID\n    delete i.system.tag; // scrap tag\n    return i;\n  }\n\n  // Gather item data\n  const itemData = tokens.reduce((cur, o) => {\n    for (const i of o.actor.items) {\n      const itemData = i.toObject();\n      if (!i.isPhysical || i.system.quantity <= 0) continue;\n      scrubItem(itemData);\n      // Check for identical data\n      const oldItem = cur.find(i2 => i2.name === i.name && i2.type === i.type);\n      let sameItem = false;\n      if (oldItem) {\n        // Ensure the objects are similar enough (quantity is the only thing allowed to differ)\n        const oldKeys = Object.keys(flattenObject(diffObject(itemData, oldItem)));\n        sameItem = (oldKeys.length == 1 && oldKeys.includes(\"quantity\")) || oldKeys.length == 0;\n      }\n\n      if (oldItem && sameItem) oldItem.system.quantity += i.system.quantity;\n      else cur.push(itemData);\n    }\n    return cur;\n  }, []);\n\n  // Add items\n  await lootNPC.createEmbeddedDocuments(\"Item\", itemData);\n}\n\n// Get selected tokens\nconst tokens = canvas.tokens.controlled;\nif (tokens.length) createFromTokens(tokens);\nelse ui.notifications?.warn(\"No tokens selected to convert into loot.\");","sort":0,"author":"61klraqiWb97OOLa","flags":{}}
