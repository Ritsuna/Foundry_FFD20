{"_id":"13AHAyh9DklWxvWP","name":"Show Defenses","permission":{"default":0},"type":"script","sort":100001,"flags":{},"scope":"global","command":"game.ffd20.rollDefenses();","author":"T9i9xVjdkHeFZC72","img":"systems/ffd20/icons/items/armor/shield-light-metal.png","actorIds":[]}
{"name":"Award XP","permission":{"default":0,"T9i9xVjdkHeFZC72":3},"type":"script","flags":{},"scope":"global","command":"// CONFIGURATION\r\n// If one or more tokens are selected, those will be used instead of the listed actors\r\n// Leave the actorNames array empty to guess the players\r\n// Example actorNames: `actorNames: [\"Bob\", \"John\"],`\r\nconst c = {\r\n  actorNames: [],\r\n};\r\n// END CONFIGURATION\r\n\r\nconst tokens = canvas.tokens.controlled;\r\nlet actors = tokens.map(o => o.actor);\r\nif (!actors.length && c.actorNames.length) actors = game.actors.entities.filter(o => c.actorNames.includes(o.name));\r\nif (!actors.length) actors = game.actors.entities.filter(o => o.isPC);\r\nactors = actors.filter(o => o.hasPerm(game.user, \"OWNER\"));\r\n\r\nif (!actors.length) ui.notifications.warn(\"No applicable actor(s) found\");\r\nelse {\r\n  const _action = function(xp) {\r\n    if (!isNaN(xp)) {\r\n      actors.forEach(o => {\r\n        let curXP = getProperty(o.data, \"data.details.xp.value\") || 0;\r\n        if (typeof curXP === \"string\") curXP = parseInt(curXP);\r\n        o.update({ \"data.details.xp.value\": curXP + xp });\r\n      });\r\n    }\r\n  };\r\n\r\n  const msg = `Award XP to the following actors: <strong>${actors.map(o => o.name).join(\"</strong>, <strong>\")}</strong>`;\r\n  const field = `<input type=\"text\" name=\"xp\" value=\"0\" placeholder=\"XP amount\" style=\"margin-bottom: 8px;\" />`;\r\n\r\n  new Dialog({\r\n    title: \"Roll saving throw\",\r\n    content: `<p>${msg}</p>${field}`,\r\n    buttons: {\r\n      ok: {\r\n        label: \"Give All\",\r\n        callback: html => {\r\n          let xp = parseInt(html.find('input[name=\"xp\"]').val());\r\n          _action(xp);\r\n        },\r\n      },\r\n      distribute: {\r\n        label: \"Distribute\",\r\n        callback: html => {\r\n          let xp = parseInt(html.find('input[name=\"xp\"]').val());\r\n          xp = Math.floor(xp / actors.length);\r\n          _action(xp);\r\n        }\r\n      }\r\n    },\r\n  }).render(true);\r\n}","author":"T9i9xVjdkHeFZC72","img":"icons/svg/book.svg","actorIds":[],"_id":"8VcUUx7d4TX4WTkt"}
{"name":"Wild Shape","permission":{"default":0,"ZuWclcb9BUy2aZSN":3},"type":"script","flags":{},"scope":"global","command":"// Author: @Adam\r\n\r\n// SETUP NEEDED: for each transformation option you want, please enter it as below\r\n// you also need to set imageFolder to the location of where you store your tokens.\r\n// token art is selected by name & as a png, so for example the image for Bat is located at 'worlds/golarion/tokens/Bestiary/Bat.png'\r\n\r\n// support for elemental body is not complete yet - only air elemental is hardcoded\r\n\r\nconst imageFolder = \"worlds/golarion/tokens/Bestiary\";\r\n\r\nconst transformationOptions = {\r\n  Bat: {\r\n    size: \"diminutive\",\r\n    spellSource: \"beast shape\",\r\n  },\r\n  \"Giant Squid\": {\r\n    size: \"huge\",\r\n    spellSource: \"beast shape\",\r\n  },\r\n  Tendriculos: {\r\n    size: \"huge\",\r\n    spellSource: \"plant shape\",\r\n  },\r\n  \"Air Elemental\": {\r\n    size: \"huge\",\r\n    spellSource: \"elemental body\",\r\n  },\r\n};\r\n\r\nconst sizes = [\"diminutive\", \"tiny\", \"small\", \"medium\", \"large\", \"huge\", \"gargantuan\", \"colossal\"];\r\n\r\nconst sizeTranslation = {\r\n  fine: \"fine\",\r\n  diminutive: \"dim\",\r\n  tiny: \"tiny\",\r\n  small: \"sm\",\r\n  medium: \"med\",\r\n  large: \"lg\",\r\n  huge: \"huge\",\r\n  gargantuan: \"grg\",\r\n  colossal: \"col\",\r\n};\r\n\r\nconst createSizeObject = ({ w, h, scale }) => {\r\n  return {\r\n    width: w,\r\n    height: h,\r\n    scale,\r\n  };\r\n};\r\n\r\nconst mediumOrBigger = (size) => {\r\n  return sizes.indexOf(size) >= sizes.indexOf(\"medium\");\r\n};\r\n\r\nconst createAbilityChange = (formula, subTarget) => {\r\n  formula = \"\" + formula;\r\n  return {\r\n    formula,\r\n    priority: 1,\r\n    target: \"ability\",\r\n    subTarget,\r\n    modifier: \"size\",\r\n  };\r\n};\r\n\r\nconst createNACChange = (formula) => {\r\n  formula = \"\" + formula;\r\n  return {\r\n    formula,\r\n    priority: 1,\r\n    target: \"ac\",\r\n    subTarget: \"nac\",\r\n    modifier: \"size\",\r\n  };\r\n};\r\n\r\nconst createSpeedChange = (formula, subTarget) => {\r\n  formula = \"\" + formula;\r\n  return {\r\n    formula,\r\n    priority: 1,\r\n    target: \"speed\",\r\n    subTarget,\r\n    modifier: \"size\",\r\n  };\r\n};\r\n\r\nconst createBuffChanges = (name) => {\r\n  const creature = transformationOptions[name];\r\n  const bulking = mediumOrBigger(creature.size);\r\n  let buffLevel = null;\r\n\r\n  const changes = [];\r\n\r\n  if (bulking) {\r\n    buffLevel = sizes.indexOf(creature.size) - sizes.indexOf(\"medium\") + 1;\r\n  } else {\r\n    buffLevel = sizes.indexOf(\"medium\") - sizes.indexOf(creature.size);\r\n  }\r\n\r\n  switch (creature.spellSource.toLowerCase()) {\r\n    case \"beast shape\": {\r\n      const mainBonus = buffLevel * 2;\r\n      const nacBonus = buffLevel * 2;\r\n      const penalty = buffLevel > 1 ? -(buffLevel * 2 - 2) : 0;\r\n      const mainBonusAbility = bulking ? \"str\" : \"dex\";\r\n      const penaltyAbility = bulking ? \"dex\" : \"str\";\r\n\r\n      changes.push(createAbilityChange(mainBonus, mainBonusAbility));\r\n      changes.push(createAbilityChange(penalty, penaltyAbility));\r\n      changes.push(createNACChange(nacBonus));\r\n      break;\r\n    }\r\n    case \"plant shape\": {\r\n      const nacBonus = buffLevel * 2;\r\n      if (bulking) {\r\n        const strBonus = Math.pow(2, buffLevel);\r\n        const conBonus = Math.max(2, buffLevel / 2);\r\n        const penalty = -(buffLevel > 2 ? 2 : 0);\r\n\r\n        changes.push(createAbilityChange(strBonus, \"str\"));\r\n        changes.push(createAbilityChange(conBonus, \"con\"));\r\n        changes.push(createAbilityChange(penalty, \"dex\"));\r\n      } else {\r\n        const conBonus = buffLevel * 2;\r\n        changes.push(createAbilityChange(conBonus, \"con\"));\r\n      }\r\n      changes.push(createNACChange(nacBonus));\r\n      break;\r\n    }\r\n    case \"elemental body\": {\r\n      if (name === \"Air Elemental\") {\r\n        changes.push(createAbilityChange(4, \"str\"));\r\n        changes.push(createAbilityChange(6, \"dex\"));\r\n        changes.push(createNACChange(4));\r\n        changes.push(createSpeedChange(120, \"flySpeed\"));\r\n      }\r\n      break;\r\n    }\r\n    default: {\r\n      ui.notifications.error(\r\n        `Cannot find spellSource (${creature.spellSource.toLowerCase()}) in programmed list. Ensure there are no typos.`\r\n      );\r\n    }\r\n  }\r\n\r\n  return changes;\r\n};\r\n\r\nconst createWSBuff = async (caster) => {\r\n  const itemData = { type: \"buff\", name: \"Wild Shape (Auto)\", data: { buffType: \"temp\", level: 1 } };\r\n  // Get templates\r\n  await caster.createOwnedItem(itemData);\r\n  return getWSBuff(caster);\r\n};\r\n\r\nconst getWSBuff = (caster) => {\r\n  return caster.items.find(\r\n    (i) =>\r\n    i.type === \"buff\" &&\r\n    i.name === \"Wild Shape (Auto)\"\r\n  );\r\n};\r\n\r\nconst transform = async (caster, token, name) => {\r\n  const creature = transformationOptions[name];\r\n  const changes = createBuffChanges(name);\r\n\r\n  let buff = getWSBuff(caster);\r\n  if (!buff) buff = await createWSBuff(caster);\r\n  buff.update({ \"data.changes\": changes });\r\n  buff.update({ \"data.active\": true });\r\n\r\n  token.update({ img: `${imageFolder}/${name}.png` });\r\n  token.update(\r\n    createSizeObject(CONFIG.FFD20.tokenSizes[sizeTranslation[creature.size]])\r\n  );\r\n  caster.data.data.traits.size = sizeTranslation[creature.size];\r\n};\r\n\r\nconst revertForm = (caster, token) => {\r\n  getWSBuff(caster).update({ \"data.active\": false });\r\n  token.update({ img: caster.data.flags.originalData.image });\r\n  caster.data.data.traits.size = caster.data.flags.originalData.size;\r\n  token.update(\r\n    createSizeObject(CONFIG.FFD20.tokenSizes[caster.data.flags.originalData.size])\r\n  );\r\n};\r\n\r\nconst tokens = canvas.tokens.controlled;\r\n\r\nif (tokens.length !== 1) {\r\n  ui.notifications.warn(\"Select a token.\");\r\n} else {\r\n  const token = tokens[0];\r\n  const actor = token.actor;\r\n  const caster = actor.data;\r\n\r\n  if (!Object.keys(caster.flags).includes(\"originalData\")) {\r\n    const originalData = {\r\n      image: caster.token.img,\r\n      size: caster.data.traits.size,\r\n    };\r\n    caster.flags.originalData = originalData;\r\n  }\r\n\r\n  const buttons = Object.keys(transformationOptions).map((optionName) => ({\r\n    label: optionName,\r\n    callback: () => transform(actor, token, optionName),\r\n  }));\r\n  buttons[\"Revert\"] = {\r\n    label: \"Revert\",\r\n    icon: '<i class=\"fas fa-user\"></i>',\r\n    callback: () => revertForm(actor, token),\r\n  };\r\n\r\n  new Dialog({\r\n    title: \"Wild Shape\",\r\n    content: \"Choose creature.\",\r\n    buttons: buttons,\r\n  }).render(true);\r\n}","author":"ZuWclcb9BUy2aZSN","img":"systems/ffd20/icons/skills/green_27.jpg","actorIds":[],"_id":"GyuHEoeLTtLZCvhS"}
{"name":"Show Actor Information","permission":{"default":0,"61klraqiWb97OOLa":3},"type":"script","flags":{"core":{"sourceId":"Macro.BVaEjWSEQwis4byi"}},"scope":"global","command":"// CONFIGURATION\n// Leave the actorNames array empty to guess the players\n// Example actorNames: `actorNames: [\"Bob\", \"John\"],`\nconst c = {\n  actorNames: [],\n};\n// END CONFIGURATION\n\nconst tokens = canvas.tokens.controlled;\nlet actors = tokens.map(o => o.actor);\nif (!actors.length && c.actorNames.length) actors = game.actors.entities.filter(o => c.actorNames.includes(o.name));\nif (!actors.length) actors = game.actors.entities.filter(o => o.isPC && o.hasPerm(game.user, \"OWNER\"));\nactors = actors.filter(o => o.hasPerm(game.user, \"OWNER\"));\n\nif (!actors.length) ui.notifications.warn(\"No applicable actor(s) found\");\nelse {\n  const msg = `Choose the information you want to show for the following actor(s): <strong>${actors.map(o => o.name).join(\"</strong>, <strong>\")}</strong>`;\n  \n  new Dialog({\n    title: \"Show Actor Information\",\n    content: `<p>${msg}</p>`,\n    buttons: {\n      fort: {\n        label: \"Social Defenses\",\n        callback: () => {\n          let c = \"\";\n          // Add demoralize DC\n          c += `<table><thead><tr><td colspan=\"2\">Demoralize (Intimidate)</td><tr><td>Character</td><td>DC</td></thead><tbody>`;\n          for (let a of actors) {\n            const rollData = a.getRollData({ forceRefresh: false });\n            const dc = 10 + rollData.attributes.hd.total + rollData.abilities.wis.mod;\n            c += `<tr><td>${a.name}</td><td>${dc}</td></tr>`;\n          }\n          c += \"</tbody></table>\";\n          // Add diplomacy DCs\n          c += `<table><thead><tr><td colspan=\"3\">Diplomacy</td></tr><tr><td>Character</td><td>Starting Attitude</td><td>DC</td><thead><tbody>`;\n          for (let a of actors) {\n            c += `<tr><td rowspan=\"5\">${a.name}</td>`;\n            const rollData = a.getRollData({ forceRefresh: false });\n            const dipArr = [{ label: \"Hostile\", base: 25 }, { label: \"Unfriendly\", base: 20 }, { label: \"Indifferent\", base: 15 }, { label: \"Friendly\", base: 10 }, { label: \"Helpful\", base: 0 }];\n            for (let b = 0; b < dipArr.length; b++) {\n              const o = dipArr[b];\n              if (b > 0) c += \"<tr>\";\n              c += `<td>${o.label}</td><td>${o.base + rollData.abilities.cha.mod}</td></tr>`;\n            }\n          }\n          c += \"</tbody></table>\";\n          // Render chat message\n          let messageData = {\n            content: c,\n            user: game.user._id,\n            speaker: ChatMessage.getSpeaker({ user: game.user }),\n            type: CONST.CHAT_MESSAGE_TYPES.OTHER,\n          };\n          messageData = ChatMessage.applyRollMode(messageData, game.settings.get(\"core\", \"rollMode\"));\n          ChatMessage.create(messageData);\n        },\n      },\n    },\n  }).render(true);\n}","author":"61klraqiWb97OOLa","img":"systems/ffd20/icons/skills/red_25.jpg","actorIds":[],"_id":"NozVDiFkfZcBg4Hg"}
{"_id":"ON7b8yS1lcBxkMuo","name":"Roll Saving Throw","permission":{"default":0,"T9i9xVjdkHeFZC72":3},"type":"script","flags":{},"scope":"global","command":"// CONFIGURATION\n// Leave the actorNames array empty to guess the players\n// Example actorNames: `actorNames: [\"Bob\", \"John\"],`\nconst c = {\n  actorNames: [],\n};\n// END CONFIGURATION\n\nconst tokens = canvas.tokens.controlled;\nlet actors = tokens.map(o => o.actor);\nif (!actors.length && c.actorNames.length) actors = game.actors.entities.filter(o => c.actorNames.includes(o.name));\nif (!actors.length) actors = game.actors.entities.filter(o => o.isPC && o.hasPerm(game.user, \"OWNER\"));\nactors = actors.filter(o => o.hasPerm(game.user, \"OWNER\"));\n\nif (!actors.length) ui.notifications.warn(\"No applicable actor(s) found\");\nelse {\n  const _roll = async function(type) {\n    for (let a = 0; a < actors.length; a++) {\n      let o = actors[a];\n      await o.rollSavingThrow(type, { event: new MouseEvent({}), noSound: a > 0, });\n    }\n  };\n\n  const msg = `Choose a saving throw to roll for the following actor(s): <strong>${actors.map(o => o.name).join(\"</strong>, <strong>\")}</strong>`;\n\n  new Dialog({\n    title: \"Roll saving throw\",\n    content: `<p>${msg}</p>`,\n    buttons: {\n      fort: {\n        label: \"Fortitude\",\n        callback: () => _roll(\"fort\"),\n      },\n      ref: {\n        label: \"Reflex\",\n        callback: () => _roll(\"ref\"),\n      },\n      will: {\n        label: \"Will\",\n        callback: () => _roll(\"will\"),\n      },\n    },\n  }).render(true);\n}","author":"T9i9xVjdkHeFZC72","img":"systems/ffd20/icons/feats/diehard.jpg","actorIds":[]}
{"_id":"ccZmfabwQrONq2kg","name":"Toggle Buff","permission":{"default":0,"T9i9xVjdkHeFZC72":3},"type":"script","flags":{},"scope":"global","command":"// CONFIGURATION\r\n// If one or more tokens are selected, those will be used instead of the listed actors\r\n// Leave the actorNames array empty to guess the players\r\n// Example actorNames: `actorNames: [\"Bob\", \"John\"],`\r\nconst c = {\r\n  actorNames: [],\r\n  buffName: \"Mage Armor\"\r\n};\r\n// END CONFIGURATION\r\n\r\nconst tokens = canvas.tokens.controlled;\r\nlet actors = tokens.map(o => o.actor);\r\nif (!actors.length && c.actorNames.length) actors = game.actors.entities.filter(o => c.actorNames.includes(o.name));\r\nif (!actors.length) actors = game.actors.entities.filter(o => o.isPC);\r\nactors = actors.filter(o => o.hasPerm(game.user, \"OWNER\"));\r\n\r\nif (!actors.length) ui.notifications.warn(\"No applicable actor(s) found\");\r\nelse {\r\n  for (let actor of actors) {\r\n    const buff = actor.items.find(o => o.name === c.buffName && o.type === \"buff\");\r\n    if (buff != null) {\r\n      let active = getProperty(buff.data, \"data.active\");\r\n      if (active == null) active = false;\r\n      buff.update({ \"data.active\": !active });\r\n    }\r\n  }\r\n}\r\n","author":"T9i9xVjdkHeFZC72","img":"systems/ffd20/icons/spells/protect-blue-1.jpg","actorIds":[]}
{"_id":"mL9k7wUzzFbj1NmY","name":"Roll Skill","permission":{"default":0,"T9i9xVjdkHeFZC72":3},"type":"script","flags":{},"scope":"global","command":"// CONFIGURATION\n// If one or more tokens are selected, those will be used instead of the listed actors\n// Leave the actorNames array empty to guess the players\n// Example actorNames: `actorNames: [\"Bob\", \"John\"],`\nconst c = {\n  actorNames: [],\n  skills: [\"per\", \"sen\", \"ste\", \"sur\"],\n};\n// END CONFIGURATION\n\nconst tokens = canvas.tokens.controlled;\nlet actors = tokens.map(o => o.actor);\nif (!actors.length && c.actorNames.length) actors = game.actors.entities.filter(o => c.actorNames.includes(o.name));\nif (!actors.length) actors = game.actors.entities.filter(o => o.isPC && o.hasPerm(game.user, \"OWNER\"));\nactors = actors.filter(o => o.hasPerm(game.user, \"OWNER\"));\n\nif (!actors.length) ui.notifications.warn(\"No applicable actor(s) found\");\nelse {\n  const _roll = async function(type) {\n    let madeSound = false;\n    for (let a = 0;a < actors.length; a++) {\n      let o = actors[a];\n      let info = o.getSkillInfo(type);\n      if (!info) continue;\n      await o.rollSkill(type, { event: new MouseEvent({}), skipDialog: true, noSound: madeSound, });\n      madeSound = true;\n    }\n  };\n\n  const buttons = c.skills.reduce((cur, s) => {\n    let info;\n    for (let o of actors) {\n      info = o.getSkillInfo(s);\n      if (info) break;\n    }\n    if (!info) return cur;\n    let label = info.name;\n    cur[s] = {\n      label: label,\n      callback: () => _roll(s),\n    };\n    return cur;\n  }, {});\n\n  const msg = `Choose a skill to roll for the following actor(s): <strong>${actors.map(o => o.name).join(\"</strong>, <strong>\")}</strong>`;\n\n  new Dialog({\n    title: \"Roll saving throw\",\n    content: `<p>${msg}</p>`,\n    buttons: buttons,\n  }).render(true);\n}","author":"T9i9xVjdkHeFZC72","img":"systems/ffd20/icons/feats/skill-focus.jpg","actorIds":[]}
{"_id":"yEPv1InFUHWnh1kt","name":"Create Loot Sheets","permission":{"default":0,"ZuWclcb9BUy2aZSN":3},"type":"script","flags":{"core":{"sourceId":"Macro.vkoTSdnbRRWCBWrR"}},"scope":"global","command":"// CONFIGURATION\n/**\n * @param {string} folder - A string of folder names, separated by '/' (slashes)\n * @param {number} defaultPermission - A constant number, to be gathered from the global object CONST.ENTITY_PERMISSIONS (for quick reference, you can replace 'OBSERVER' with one of the following: 'NONE', 'LIMITED' or 'OWNER'\n * @param {string} sheetType - Change this if you have a module installed for a different loot sheet type.\n */\n\nconst c = {\n    folder: \"Misc/Loot\",\n    defaultPermission: CONST.ENTITY_PERMISSIONS.OBSERVER,\n    sheetType: \"FFD20.ActorSheetPFNPCLoot\",\n};\n\n// END CONFIGURATION\n\n(async () => {\n\n    // Get selected tokens\n    let tokens = canvas.tokens.controlled;\n    if (!tokens.length) return;\n\n    // Create folder(s)\n    let lastFolder = null;\n    let lastIndex = 0;\n    if (c.folder) {\n        const folders = game.folders.filter(f => f.type === \"Actor\");\n        const folderNames = c.folder.split(\"/\");\n        for (let a = 0; a < folderNames.length; a++) {\n            let curName = folderNames[a];\n            let prevName = a > 0 ? folderNames[a-1] : null;\n            \n            const f = folders.find(o => o.name === curName && (o.parent ? o.parent.name === prevName : true));\n            if (f) {\n                lastFolder = f;\n                lastIndex = a+1;\n            }\n        }\n\n        for (let a = lastIndex; a < folderNames.length; a++) {\n            const newFolder = await Folder.create({\n                name: folderNames[a],\n                parent: lastFolder ? lastFolder._id : null,\n                type: \"Actor\",\n            });\n            lastFolder = newFolder;\n        }\n    }\n\n    // Gather currency\n    let [pp, gp, sp, cp] = tokens.reduce((cur, t) => {\n        cur[0] += t.actor.data.data.currency.pp;\n        cur[1] += t.actor.data.data.currency.gp;\n        cur[2] += t.actor.data.data.currency.sp;\n        cur[3] += t.actor.data.data.currency.cp;\n        return cur;\n    }, [0, 0, 0, 0]);\n\n    // Create loot NPC for selected tokens\n    const lootName = \"(Loot) \" + tokens.reduce((cur, o) => {\n        cur.push(o.name);\n        return cur;\n    }, []).join(\", \");\n    const lootNPC = await Actor.create({\n        name: lootName,\n        type: \"npc\",\n        img: tokens[0].actor.img,\n        folder: lastFolder ? lastFolder._id : null,\n        permission: {\n            default: c.defaultPermission,\n        },\n        flags: {\n            core: {\n                sheetClass: c.sheetType,\n            },\n        },\n        data: {\n            currency: {\n                pp: pp,\n                gp: gp,\n                sp: sp,\n                cp: cp,\n            },\n        },\n    });\n\n    // Gather item data\n    const itemData = tokens.reduce((cur, o) => {\n        for (let i of o.actor.items) {\n            if (game.ffd20.ItemPF.isInventoryItem(i.type) && i.data.data.quantity > 0) {\n                // Check for identical data\n                let addRaw = true;\n                let firstItem;\n                for (let i2 of cur) {\n                    if (i2.name === i.name) {\n                        firstItem = i2;\n                        addRaw = false;\n                        const diffData = flattenObject(diffObject(i.data.data, i2.data));\n                        for (let k of Object.keys(diffData)) {\n                            if (![\"quantity\"].includes(k)) addRaw = true;\n                        }\n                    }\n                }\n                if (addRaw) {\n                    cur.push(duplicate(i.data));\n                }\n                else {\n                    firstItem.data.quantity += i.data.data.quantity;\n                }\n            }\n        }\n        return cur;\n    }, []);\n    \n    // Add items\n    await lootNPC.createOwnedItem(itemData);\n\n})();","author":"ZuWclcb9BUy2aZSN","img":"systems/ffd20/icons/items/inventory/chest-light.jpg","actorIds":[]}
