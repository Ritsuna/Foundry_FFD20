{"name":"Award XP","permission":{"default":0},"type":"script","flags":{},"scope":"global","command":"// CONFIGURATION\r\n// If one or more tokens are selected, those will be used instead of the listed actors\r\n// Leave the actorNames array empty to guess the players\r\n// Example actorNames: `actorNames: [\"Bob\", \"John\"],`\r\nconst c = {\r\n  actorNames: [],\r\n};\r\n// END CONFIGURATION\r\n\r\nconst tokens = canvas.tokens.controlled;\r\nlet actors = tokens.map(o => o.actor);\r\nif (!actors.length && c.actorNames.length) actors = game.actors.entities.filter(o => c.actorNames.includes(o.name));\r\nif (!actors.length) actors = game.actors.entities.filter(o => o.isPC);\r\nactors = actors.filter(o => o.testUserPermission(game.user, \"OWNER\"));\r\n\r\nif (!actors.length) ui.notifications.warn(\"No applicable actor(s) found\");\r\nelse {\r\n  const _action = function(xp) {\r\n    if (!isNaN(xp)) {\r\n      actors.forEach(o => {\r\n        let curXP = getProperty(o.data, \"data.details.xp.value\") || 0;\r\n        if (typeof curXP === \"string\") curXP = parseInt(curXP);\r\n        o.update({ \"data.details.xp.value\": curXP + xp });\r\n      });\r\n    }\r\n  };\r\n\r\n  const msg = `Award XP to the following actors: <strong>${actors.map(o => o.name).join(\"</strong>, <strong>\")}</strong>`;\r\n  const field = `<input type=\"text\" name=\"xp\" value=\"0\" placeholder=\"XP amount\" style=\"margin-bottom: 8px;\" />`;\r\n\r\n  new Dialog({\r\n    title: \"Roll saving throw\",\r\n    content: `<p>${msg}</p>${field}`,\r\n    buttons: {\r\n      ok: {\r\n        label: \"Give All\",\r\n        callback: html => {\r\n          let xp = parseInt(html.find('input[name=\"xp\"]').val());\r\n          _action(xp);\r\n        },\r\n      },\r\n      distribute: {\r\n        label: \"Distribute\",\r\n        callback: html => {\r\n          let xp = parseInt(html.find('input[name=\"xp\"]').val());\r\n          xp = Math.floor(xp / actors.length);\r\n          _action(xp);\r\n        }\r\n      }\r\n    },\r\n  }).render(true);\r\n}","author":"T9i9xVjdkHeFZC72","img":"icons/svg/book.svg","actorIds":[],"_id":"8VcUUx7d4TX4WTkt"}
{"name":"Calculate Spellbook Price","permission":{"default":0},"type":"script","flags":{},"scope":"global","command":"const CONFIG = {\n  basePrice: 15,\n  spellValue: {\n    \"0\": {\n      gp: 5,\n      pages: 1,\n    },\n    \"1\": {\n      gp: 10,\n      pages: 1,\n    },\n    \"2\": {\n      gp: 40,\n      pages: 2,\n    },\n    \"3\": {\n      gp: 90,\n      pages: 3,\n    },\n    \"4\": {\n      gp: 160,\n      pages: 4,\n    },\n    \"5\": {\n      gp: 250,\n      pages: 5,\n    },\n    \"6\": {\n      gp: 360,\n      pages: 6,\n    },\n    \"7\": {\n      gp: 490,\n      pages: 7,\n    },\n    \"8\": {\n      gp: 640,\n      pages: 8,\n    },\n    \"9\": {\n      gp: 810,\n      pages: 9,\n    },\n  },\n};\n\nlet html = `\n<table>\n  <thead>\n    <tr>\n      <th>Spell level</th>\n      <th>Amount of spells</th>\n    </tr>\n  </thead>\n  <tbody>\n`;\nfor (let [k, v] of Object.entries(CONFIG.spellValue)) {\n  html += `\n    <tr>\n      <td>${k}</td>\n      <td>\n        <input class=\"spell-input\" type=\"text\" name=\"level-${k}\" value=\"0\" data-price=\"${v.gp}\" data-pages=\"${v.pages}\" />\n      </td>\n    </tr>\n  `;\n}\nhtml += `\n  </tbody>\n  <thead>\n    <tr>\n      <th>Spellbook price</th>\n      <th>Pages required</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td><input class=\"spellbook-price\" type=\"text\" disabled name=\"spellbook-price\" value=\"${CONFIG.basePrice}\" /></td>\n      <td><input class=\"spellbook-pages\" type=\"text\" disabled name=\"page-value\" value=\"0\" /></td>\n    </tr>\n  </tbody>\n</table>\n\n<div class=\"help-text\">\n  Typical spellbooks can only hold 100 pages.\n</div>\n`;\n\n// -------------------------\n// Functions\n// -------------------------\n\nconst _onChange = function(event) {\n  event.preventDefault();\n  const html = $(this.element);\n\n  let pages = 0;\n  let price = CONFIG.basePrice;\n  html.find(\".spell-input\").each((idx, elem) => {\n    const amount = Number(elem.value);\n    if (Number.isNaN(amount)) return;\n\n    price += Number(elem.dataset.price) * amount;\n    pages += Number(elem.dataset.pages) * amount;\n  });\n\n  html.find(\".spellbook-price\").attr(\"value\", price);\n  html.find(\".spellbook-pages\").attr(\"value\", pages);\n};\n\n// -------------------------\n// Dialog\n// -------------------------\n\nconst d = new Dialog({\n  title: \"Calculate spellbook value\",\n  content: html,\n  buttons: {},\n});\n\nd.activateListeners = function(html) {\n  Dialog.prototype.activateListeners.call(this, html);\n  \n  html.find(\"input.spell-input\").change(_onChange.bind(this));\n};\n\nd.render(true);","author":"61klraqiWb97OOLa","img":"icons/sundries/books/book-embossed-jewel-gold-purple.webp","actorIds":[],"_id":"1l7Iw6xRgx8OMnJH"}
{"_id":"yEPv1InFUHWnh1kt","name":"Create Loot Sheets","type":"script","img":"systems/ffd20/icons/items/inventory/chest-light.jpg","scope":"global","command":"// CONFIGURATION\n/**\n * @param {string} folder - A string of folder names, separated by '/' (slashes)\n * @param {number} defaultPermission - A constant number, to be gathered from the global object CONST.ENTITY_PERMISSIONS (for quick reference, you can replace 'OBSERVER' with one of the following: 'NONE', 'LIMITED' or 'OWNER'\n * @param {string} sheetType - Change this if you have a module installed for a different loot sheet type.\n */\n\nconst c = {\n\tfolder: \"Misc/Loot\",\n\tdefaultPermission: CONST.ENTITY_PERMISSIONS.OBSERVER,\n\tsheetType: \"FFD20.ActorSheetFFD20NPCLoot\",\n};\n\n// END CONFIGURATION\n\nasync function createFromTokens(tokens) {\n\tlet lastFolder = null;\n\n\tasync function createFolders() {\n\t\tlet lastIndex = 0;\n\t\tconst folders = game.folders.filter(f => f.type === \"Actor\");\n\t\tconst folderNames = c.folder.split(\"/\");\n\t\tfor (let a = 0; a < folderNames.length; a++) {\n\t\t\tlet curName = folderNames[a];\n\t\t\tlet prevName = a > 0 ? folderNames[a - 1] : null;\n\n\t\t\tconst f = folders.find(o => o.name === curName && (o.parent ? o.parent.name === prevName : true));\n\t\t\tif (f) {\n\t\t\t\tlastFolder = f;\n\t\t\t\tlastIndex = a + 1;\n\t\t\t}\n\t\t}\n\n\t\tfor (let a = lastIndex; a < folderNames.length; a++) {\n\t\t\tconst newFolder = await Folder.create({\n\t\t\t\tname: folderNames[a],\n\t\t\t\tparent: lastFolder?.id ?? null,\n\t\t\t\ttype: \"Actor\",\n\t\t\t});\n\t\t\tlastFolder = newFolder;\n\t\t}\n\t}\n\n\t// Create folder(s)\n\tif (c.folder) await createFolders();\n\n\t// Gather currency\n\tconst currency = { pgil: 0, gil: 0, sgil: 0, cgil: 0 };\n\ttokens.forEach(t => {\n\t\tfor (let cc of Object.keys(currency))\n\t\t\tcurrency[cc] += t.actor.data.data.currency[cc];\n\t});\n\n\t// Create loot NPC for selected tokens\n\tconst name = \"(Loot) \" + tokens.map(t => t.name).join(\", \");\n\n\tconst lootNPC = await Actor.create({\n\t\tname,\n\t\ttype: \"npc\",\n\t\timg: tokens[0].actor.img,\n\t\tfolder: lastFolder?.id ?? null,\n\t\tpermission: {\n\t\t\tdefault: c.defaultPermission,\n\t\t},\n\t\tflags: {\n\t\t\tcore: { sheetClass: c.sheetType },\n\t\t},\n\t\tdata: { currency },\n\t});\n\n\tconst scrubItem = (i) => {\n\t\tdelete i.data.links; // Scrap links\n\t\tdelete i._id; // scrap ID\n\t\tdelete i.data.tag; // scrap tag\n\t\treturn i;\n\t}\n\n\t// Gather item data\n\tconst itemData = tokens.reduce((cur, o) => {\n\t\tfor (let i of o.actor.items) {\n\t\t\tif (!game.ffd20.documents.ItemFFD20.isInventoryItem(i.type) || i.data.data.quantity <= 0) continue;\n\t\t\tscrubItem(i.data);\n\t\t\t// Check for identical data\n\t\t\tconst oldItem = cur.find(i2 => i2.name === i.name && i.type === i2.type);\n\t\t\tlet sameItem = false;\n\t\t\tif (oldItem) {\n\t\t\t\t// Ensure the objects are similar enough (quantity is the only thing allowed to differ)\n\t\t\t\tconst oldKeys = Object.keys(flattenObject(diffObject(i.data.data, oldItem.data)));\n\t\t\t\tsameItem = (oldKeys.length == 1 && oldKeys.includes(\"quantity\")) || oldKeys.length == 0;\n\t\t\t}\n\n\t\t\tif (oldItem && sameItem) oldItem.data.quantity += i.data.data.quantity;\n\t\t\telse cur.push(scrubItem(deepClone(i.data).toObject()));\n\t\t}\n\t\treturn cur;\n\t}, []);\n\n\t// Add items\n\tawait lootNPC.createEmbeddedDocuments(\"Item\", itemData);\n}\n\n// Get selected tokens\nconst tokens = canvas.tokens.controlled;\nif (tokens.length) createFromTokens(tokens);\nelse ui.notifications?.warn(\"No tokens selected to convert into loot.\");","sort":0,"permission":{"default":0},"flags":{}}
{"_id":"ON7b8yS1lcBxkMuo","name":"Roll Saving Throw","permission":{"default":0},"type":"script","flags":{},"scope":"global","command":"// CONFIGURATION\n// Leave the actorNames array empty to guess the players\n// Example actorNames: `actorNames: [\"Bob\", \"John\"],`\nconst c = {\n  actorNames: [],\n};\n// END CONFIGURATION\n\nconst tokens = canvas.tokens.controlled;\nlet actors = tokens.map(o => o.actor);\nif (!actors.length && c.actorNames.length) actors = game.actors.entities.filter(o => c.actorNames.includes(o.name));\nif (!actors.length) actors = game.actors.entities.filter(o => o.isPC && o.testUserPermission(game.user, \"OWNER\"));\nactors = actors.filter(o => o.testUserPermission(game.user, \"OWNER\"));\n\nif (!actors.length) ui.notifications.warn(\"No applicable actor(s) found\");\nelse {\n  const _roll = async function(type) {\n    for (let a = 0; a < actors.length; a++) {\n      let o = actors[a];\n      await o.rollSavingThrow(type, { event: new MouseEvent({}), noSound: a > 0, });\n    }\n  };\n\n  const msg = `Choose a saving throw to roll for the following actor(s): <strong>${actors.map(o => o.name).join(\"</strong>, <strong>\")}</strong>`;\n\n  new Dialog({\n    title: \"Roll saving throw\",\n    content: `<p>${msg}</p>`,\n    buttons: {\n      fort: {\n        label: \"Fortitude\",\n        callback: () => _roll(\"fort\"),\n      },\n      ref: {\n        label: \"Reflex\",\n        callback: () => _roll(\"ref\"),\n      },\n      will: {\n        label: \"Will\",\n        callback: () => _roll(\"will\"),\n      },\n    },\n  }).render(true);\n}","author":"T9i9xVjdkHeFZC72","img":"systems/ffd20/icons/feats/diehard.jpg","actorIds":[]}
{"_id":"mL9k7wUzzFbj1NmY","name":"Roll Skill","permission":{"default":0},"type":"script","flags":{},"scope":"global","command":"// CONFIGURATION\n// If one or more tokens are selected, those will be used instead of the listed actors\n// Leave the actorNames array empty to guess the players\n// Example actorNames: `actorNames: [\"Bob\", \"John\"],`\nconst c = {\n  actorNames: [],\n  skills: [\"per\", \"sen\", \"ste\", \"sur\"],\n};\n// END CONFIGURATION\n\nconst tokens = canvas.tokens.controlled;\nlet actors = tokens.map(o => o.actor);\nif (!actors.length && c.actorNames.length) actors = game.actors.entities.filter(o => c.actorNames.includes(o.name));\nif (!actors.length) actors = game.actors.entities.filter(o => o.isPC && o.testUserPermission(game.user, \"OWNER\"));\nactors = actors.filter(o => o.testUserPermission(game.user, \"OWNER\"));\n\nif (!actors.length) ui.notifications.warn(\"No applicable actor(s) found\");\nelse {\n  const _roll = async function(type) {\n    let madeSound = false;\n    for (let a = 0;a < actors.length; a++) {\n      let o = actors[a];\n      let info = o.getSkillInfo(type);\n      if (!info) continue;\n      await o.rollSkill(type, { event: new MouseEvent({}), skipDialog: true, noSound: madeSound, });\n      madeSound = true;\n    }\n  };\n\n  const buttons = c.skills.reduce((cur, s) => {\n    let info;\n    for (let o of actors) {\n      info = o.getSkillInfo(s);\n      if (info) break;\n    }\n    if (!info) return cur;\n    let label = info.name;\n    cur[s] = {\n      label: label,\n      callback: () => _roll(s),\n    };\n    return cur;\n  }, {});\n\n  const msg = `Choose a skill to roll for the following actor(s): <strong>${actors.map(o => o.name).join(\"</strong>, <strong>\")}</strong>`;\n\n  new Dialog({\n    title: \"Roll saving throw\",\n    content: `<p>${msg}</p>`,\n    buttons: buttons,\n  }).render(true);\n}","author":"T9i9xVjdkHeFZC72","img":"systems/ffd20/icons/feats/skill-focus.jpg","actorIds":[]}
{"name":"Show Actor Information","permission":{"default":0},"type":"script","flags":{},"scope":"global","command":"// CONFIGURATION\n// Leave the actorNames array empty to guess the players\n// Example actorNames: `actorNames: [\"Bob\", \"John\"],`\nconst c = {\n  actorNames: [],\n};\n// END CONFIGURATION\n\nconst tokens = canvas.tokens.controlled;\nlet actors = tokens.map(o => o.actor);\nif (!actors.length && c.actorNames.length) actors = game.actors.entities.filter(o => c.actorNames.includes(o.name));\nif (!actors.length) actors = game.actors.entities.filter(o => o.isPC && o.testUserPermission(game.user, \"OWNER\"));\nactors = actors.filter(o => o.testUserPermission(game.user, \"OWNER\"));\n\nif (!actors.length) ui.notifications.warn(\"No applicable actor(s) found\");\nelse {\n  const msg = `Choose the information you want to show for the following actor(s): <strong>${actors.map(o => o.name).join(\"</strong>, <strong>\")}</strong>`;\n  \n  new Dialog({\n    title: \"Show Actor Information\",\n    content: `<p>${msg}</p>`,\n    buttons: {\n      fort: {\n        label: \"Social Defenses\",\n        callback: () => {\n          let c = \"\";\n          // Add demoralize DC\n          c += `<table><thead><tr><td colspan=\"2\">Demoralize (Intimidate)</td><tr><td>Character</td><td>DC</td></thead><tbody>`;\n          for (let a of actors) {\n            const rollData = a.getRollData({ forceRefresh: false });\n            const dc = 10 + rollData.attributes.hd.total + rollData.abilities.wis.mod;\n            c += `<tr><td>${a.name}</td><td>${dc}</td></tr>`;\n          }\n          c += \"</tbody></table>\";\n          // Add diplomacy DCs\n          c += `<table><thead><tr><td colspan=\"3\">Diplomacy</td></tr><tr><td>Character</td><td>Starting Attitude</td><td>DC</td><thead><tbody>`;\n          for (let a of actors) {\n            c += `<tr><td rowspan=\"5\">${a.name}</td>`;\n            const rollData = a.getRollData({ forceRefresh: false });\n            const dipArr = [{ label: \"Hostile\", base: 25 }, { label: \"Unfriendly\", base: 20 }, { label: \"Indifferent\", base: 15 }, { label: \"Friendly\", base: 10 }, { label: \"Helpful\", base: 0 }];\n            for (let b = 0; b < dipArr.length; b++) {\n              const o = dipArr[b];\n              if (b > 0) c += \"<tr>\";\n              c += `<td>${o.label}</td><td>${o.base + rollData.abilities.cha.mod}</td></tr>`;\n            }\n          }\n          c += \"</tbody></table>\";\n          // Render chat message\n          let messageData = {\n            content: c,\n            user: game.user._id,\n            speaker: ChatMessage.getSpeaker({ user: game.user }),\n            type: CONST.CHAT_MESSAGE_TYPES.OTHER,\n          };\n          messageData = ChatMessage.applyRollMode(messageData, game.settings.get(\"core\", \"rollMode\"));\n          ChatMessage.create(messageData);\n        },\n      },\n    },\n  }).render(true);\n}","author":"61klraqiWb97OOLa","img":"systems/ffd20/icons/skills/red_25.jpg","actorIds":[],"_id":"NozVDiFkfZcBg4Hg"}
{"_id":"13AHAyh9DklWxvWP","name":"Show Defenses","permission":{"default":0},"type":"script","sort":100001,"flags":{},"scope":"global","command":"game.ffd20.rollDefenses();","author":"T9i9xVjdkHeFZC72","img":"systems/ffd20/icons/items/armor/shield-light-metal.png","actorIds":[]}
{"_id":"ccZmfabwQrONq2kg","name":"Toggle Buff","permission":{"default":0},"type":"script","flags":{},"scope":"global","command":"// CONFIGURATION\r\n// If one or more tokens are selected, those will be used instead of the listed actors\r\n// Leave the actorNames array empty to guess the players\r\n// Example actorNames: `actorNames: [\"Bob\", \"John\"],`\r\nconst c = {\r\n  actorNames: [],\r\n  buffName: \"Mage Armor\"\r\n};\r\n// END CONFIGURATION\r\n\r\nconst tokens = canvas.tokens.controlled;\r\nlet actors = tokens.map(o => o.actor);\r\nif (!actors.length && c.actorNames.length) actors = game.actors.entities.filter(o => c.actorNames.includes(o.name));\r\nif (!actors.length) actors = game.actors.entities.filter(o => o.isPC);\r\nactors = actors.filter(o => o.testUserPermission(game.user, \"OWNER\"));\r\n\r\nif (!actors.length) ui.notifications.warn(\"No applicable actor(s) found\");\r\nelse {\r\n  for (let actor of actors) {\r\n    const buff = actor.items.find(o => o.name === c.buffName && o.type === \"buff\");\r\n    if (buff != null) {\r\n      let active = getProperty(buff.data, \"data.active\");\r\n      if (active == null) active = false;\r\n      buff.update({ \"data.active\": !active });\r\n    }\r\n  }\r\n}\r\n","author":"T9i9xVjdkHeFZC72","img":"systems/ffd20/icons/spells/protect-blue-1.jpg","actorIds":[]}
{"name":"Wild Shape","permission":{"default":0},"type":"script","flags":{},"scope":"global","command":"// Author: @Adam\r\n\r\n// SETUP NEEDED: for each transformation option you want, please enter it as below\r\n// you also need to set imageFolder to the location of where you store your tokens.\r\n// token art is selected by name & as a png, so for example the image for Bat is located at 'worlds/golarion/tokens/Bestiary/Bat.png'\r\n\r\n// support for elemental body is not complete yet - only air elemental is hardcoded\r\n\r\nconst imageFolder = \"worlds/golarion/tokens/Bestiary\";\r\n\r\nconst transformationOptions = {\r\n  Bat: {\r\n    size: \"diminutive\",\r\n    spellSource: \"beast shape\",\r\n  },\r\n  \"Giant Squid\": {\r\n    size: \"huge\",\r\n    spellSource: \"beast shape\",\r\n  },\r\n  Tendriculos: {\r\n    size: \"huge\",\r\n    spellSource: \"plant shape\",\r\n  },\r\n  \"Air Elemental\": {\r\n    size: \"huge\",\r\n    spellSource: \"elemental body\",\r\n  },\r\n};\r\n\r\nconst sizes = [\"diminutive\", \"tiny\", \"small\", \"medium\", \"large\", \"huge\", \"gargantuan\", \"colossal\"];\r\n\r\nconst sizeTranslation = {\r\n  fine: \"fine\",\r\n  diminutive: \"dim\",\r\n  tiny: \"tiny\",\r\n  small: \"sm\",\r\n  medium: \"med\",\r\n  large: \"lg\",\r\n  huge: \"huge\",\r\n  gargantuan: \"grg\",\r\n  colossal: \"col\",\r\n};\r\n\r\nconst createSizeObject = ({ w, h, scale }) => {\r\n  return {\r\n    width: w,\r\n    height: h,\r\n    scale,\r\n  };\r\n};\r\n\r\nconst mediumOrBigger = (size) => {\r\n  return sizes.indexOf(size) >= sizes.indexOf(\"medium\");\r\n};\r\n\r\nconst createAbilityChange = (formula, subTarget) => {\r\n  formula = \"\" + formula;\r\n  return {\r\n    formula,\r\n    priority: 1,\r\n    target: \"ability\",\r\n    subTarget,\r\n    modifier: \"size\",\r\n  };\r\n};\r\n\r\nconst createNACChange = (formula) => {\r\n  formula = \"\" + formula;\r\n  return {\r\n    formula,\r\n    priority: 1,\r\n    target: \"ac\",\r\n    subTarget: \"nac\",\r\n    modifier: \"size\",\r\n  };\r\n};\r\n\r\nconst createSpeedChange = (formula, subTarget) => {\r\n  formula = \"\" + formula;\r\n  return {\r\n    formula,\r\n    priority: 1,\r\n    target: \"speed\",\r\n    subTarget,\r\n    modifier: \"size\",\r\n  };\r\n};\r\n\r\nconst createBuffChanges = (name) => {\r\n  const creature = transformationOptions[name];\r\n  const bulking = mediumOrBigger(creature.size);\r\n  let buffLevel = null;\r\n\r\n  const changes = [];\r\n\r\n  if (bulking) {\r\n    buffLevel = sizes.indexOf(creature.size) - sizes.indexOf(\"medium\") + 1;\r\n  } else {\r\n    buffLevel = sizes.indexOf(\"medium\") - sizes.indexOf(creature.size);\r\n  }\r\n\r\n  switch (creature.spellSource.toLowerCase()) {\r\n    case \"beast shape\": {\r\n      const mainBonus = buffLevel * 2;\r\n      const nacBonus = buffLevel * 2;\r\n      const penalty = buffLevel > 1 ? -(buffLevel * 2 - 2) : 0;\r\n      const mainBonusAbility = bulking ? \"str\" : \"dex\";\r\n      const penaltyAbility = bulking ? \"dex\" : \"str\";\r\n\r\n      changes.push(createAbilityChange(mainBonus, mainBonusAbility));\r\n      changes.push(createAbilityChange(penalty, penaltyAbility));\r\n      changes.push(createNACChange(nacBonus));\r\n      break;\r\n    }\r\n    case \"plant shape\": {\r\n      const nacBonus = buffLevel * 2;\r\n      if (bulking) {\r\n        const strBonus = Math.pow(2, buffLevel);\r\n        const conBonus = Math.max(2, buffLevel / 2);\r\n        const penalty = -(buffLevel > 2 ? 2 : 0);\r\n\r\n        changes.push(createAbilityChange(strBonus, \"str\"));\r\n        changes.push(createAbilityChange(conBonus, \"con\"));\r\n        changes.push(createAbilityChange(penalty, \"dex\"));\r\n      } else {\r\n        const conBonus = buffLevel * 2;\r\n        changes.push(createAbilityChange(conBonus, \"con\"));\r\n      }\r\n      changes.push(createNACChange(nacBonus));\r\n      break;\r\n    }\r\n    case \"elemental body\": {\r\n      if (name === \"Air Elemental\") {\r\n        changes.push(createAbilityChange(4, \"str\"));\r\n        changes.push(createAbilityChange(6, \"dex\"));\r\n        changes.push(createNACChange(4));\r\n        changes.push(createSpeedChange(120, \"flySpeed\"));\r\n      }\r\n      break;\r\n    }\r\n    default: {\r\n      ui.notifications.error(\r\n        `Cannot find spellSource (${creature.spellSource.toLowerCase()}) in programmed list. Ensure there are no typos.`\r\n      );\r\n    }\r\n  }\r\n\r\n  return changes;\r\n};\r\n\r\nconst createWSBuff = async (caster) => {\r\n  const itemData = { type: \"buff\", name: \"Wild Shape (Auto)\", data: { buffType: \"temp\", level: 1 } };\r\n  // Get templates\r\n  await caster.createOwnedItem(itemData);\r\n  return getWSBuff(caster);\r\n};\r\n\r\nconst getWSBuff = (caster) => {\r\n  return caster.items.find(\r\n    (i) =>\r\n    i.type === \"buff\" &&\r\n    i.name === \"Wild Shape (Auto)\"\r\n  );\r\n};\r\n\r\nconst transform = async (caster, token, name) => {\r\n  const creature = transformationOptions[name];\r\n  const changes = createBuffChanges(name);\r\n\r\n  let buff = getWSBuff(caster);\r\n  if (!buff) buff = await createWSBuff(caster);\r\n  buff.update({ \"data.changes\": changes });\r\n  buff.update({ \"data.active\": true });\r\n\r\n  token.update({ img: `${imageFolder}/${name}.png` });\r\n  token.update(\r\n    createSizeObject(CONFIG.FFD20.tokenSizes[sizeTranslation[creature.size]])\r\n  );\r\n  caster.data.data.traits.size = sizeTranslation[creature.size];\r\n};\r\n\r\nconst revertForm = (caster, token) => {\r\n  getWSBuff(caster).update({ \"data.active\": false });\r\n  token.update({ img: caster.data.flags.originalData.image });\r\n  caster.data.data.traits.size = caster.data.flags.originalData.size;\r\n  token.update(\r\n    createSizeObject(CONFIG.FFD20.tokenSizes[caster.data.flags.originalData.size])\r\n  );\r\n};\r\n\r\nconst tokens = canvas.tokens.controlled;\r\n\r\nif (tokens.length !== 1) {\r\n  ui.notifications.warn(\"Select a token.\");\r\n} else {\r\n  const token = tokens[0];\r\n  const actor = token.actor;\r\n  const caster = actor.data;\r\n\r\n  if (!Object.keys(caster.flags).includes(\"originalData\")) {\r\n    const originalData = {\r\n      image: caster.token.img,\r\n      size: caster.data.traits.size,\r\n    };\r\n    caster.flags.originalData = originalData;\r\n  }\r\n\r\n  const buttons = Object.keys(transformationOptions).map((optionName) => ({\r\n    label: optionName,\r\n    callback: () => transform(actor, token, optionName),\r\n  }));\r\n  buttons[\"Revert\"] = {\r\n    label: \"Revert\",\r\n    icon: '<i class=\"fas fa-user\"></i>',\r\n    callback: () => revertForm(actor, token),\r\n  };\r\n\r\n  new Dialog({\r\n    title: \"Wild Shape\",\r\n    content: \"Choose creature.\",\r\n    buttons: buttons,\r\n  }).render(true);\r\n}","author":"ZuWclcb9BUy2aZSN","img":"systems/ffd20/icons/skills/green_27.jpg","actorIds":[],"_id":"GyuHEoeLTtLZCvhS"}
